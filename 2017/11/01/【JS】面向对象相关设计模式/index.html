<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="【JS】面向对象相关设计模式"><meta name="keywords" content="oop,设计模式"><meta name="author" content="Fridolph,undefined"><meta name="copyright" content="Fridolph"><title>【JS】面向对象相关设计模式 | 霪霖笙箫的博客</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css?version=1.5.3"><meta http-equiv="Cache-Control" content="no-cache,no-store,must-revalidate"><meta http-equiv="Pragma" content="no-cache"><meta http-equiv="Expires" content="0"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?https://hm.baidu.com/hm.js?08804673a5fe37365758820497cd9fb1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  localSearch: {"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"},"path":"search.xml"}
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#继承和组合"><span class="toc-number">1.</span> <span class="toc-text">继承和组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象编程原则和设计模式"><span class="toc-number">2.</span> <span class="toc-text">面向对象编程原则和设计模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number"></span> <span class="toc-text">总结</span></a></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/config/avatar.jpg"></div><div class="author-info__name text-center">Fridolph</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">58</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">69</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">14</span></a></div></div><div class="unit"><div class="heart"><div class="heart-piece-0"></div><div class="heart-piece-1"></div><div class="heart-piece-2"></div><div class="heart-piece-3"></div><div class="heart-piece-4"></div><div class="heart-piece-5"></div><div class="heart-piece-6"></div><div class="heart-piece-7"></div><div class="heart-piece-8"></div></div><p class="anime-title"><a href="https://github.com/fridolph" target="_blank">感谢访问本站，若喜欢请star ^_^</a></p></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/config/top-img.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">霪霖笙箫的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">个人主页</a><a class="site-page" href="/archives">文章总览</a><a class="site-page" href="/books">图书推荐</a><a class="site-page" href="/demo">项目实战</a><a class="site-page" href="/gallery">时光轨迹</a></span></div><div id="post-info"><div id="post-title">【JS】面向对象相关设计模式</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-11-01</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JavaScript/">JavaScript</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2017/11/01/【JS】面向对象相关设计模式/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2017/11/01/【JS】面向对象相关设计模式/"></span></a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">2,683</span><span class="post-meta__separator">|</span><span>阅读时长: 11 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><blockquote>
<p>面向对象应该是一种思想，而不是代码的组织形式。</p>
</blockquote>
<p>面向对象的特点：</p>
<ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
<p>子类继承了父类的函数，同时覆盖实现了父类的某些行为。上面的setProgress函数即体现了多态又体现了继承</p>
<a id="more"></a>
<h3 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h3><p>集成商为了实现复用，组合其实也是为了实现复用。继承是is-a的关系，而组合是has-a的关系。</p>
<p>可以把上面的ProgressBar改成组合的方式。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProgressBar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>($container) &#123;</span><br><span class="line">    <span class="keyword">this</span>.fullWidth = $container.width()</span><br><span class="line">    <span class="keyword">this</span>.$bar = <span class="literal">null</span></span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">// 设置宽度</span></span><br><span class="line">  setProgress(percentage) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$bar.animate(&#123;</span><br><span class="line">      width: <span class="keyword">this</span>.fullWidth * percentage + <span class="string">'px'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 完成</span></span><br><span class="line">  finished() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$bar.hide()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 失败</span></span><br><span class="line">  failed() &#123;</span><br><span class="line">    <span class="keyword">this</span>.addFailedText()</span><br><span class="line">  &#125;</span><br><span class="line">  addFailedText() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProgressBarWithNumber</span> <span class="keyword">extends</span> <span class="title">ProgressBar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>($container) &#123;</span><br><span class="line">    <span class="keyword">super</span>($container)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 多态</span></span><br><span class="line">  setProgress(percentage) &#123;</span><br><span class="line">    <span class="comment">// 先借助继承父类的函数</span></span><br><span class="line">    <span class="keyword">super</span>.setProgress(percentage)</span><br><span class="line">    <span class="keyword">this</span>.showPercentageText(percentage)</span><br><span class="line">  &#125;</span><br><span class="line">  showPercentageText(percentage) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造函数里面组合了一个progressBar的实例，然后在setProgress函数里面利用这个实例去设置进度条的百分比。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProgressBarWithNumber</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>($container) &#123;</span><br><span class="line">    <span class="keyword">this</span>.progressBar = <span class="keyword">new</span> ProgressBar($container)</span><br><span class="line">  &#125;</span><br><span class="line">  setProgress(percentage) &#123;</span><br><span class="line">    <span class="keyword">this</span>.progressBar.setProgress(percentage)</span><br><span class="line">    <span class="keyword">this</span>.showPercentageText(percentage)</span><br><span class="line">  &#125;</span><br><span class="line">  showPercentageText(percentage) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>偏向于使用组合而非继承</strong></p>
<p>因为继承的耦合性要大于组合，组合更加灵活。继承是编译阶段就决定了关系，而组合是运行阶段才决定关系。</p>
<h3 id="面向对象编程原则和设计模式"><a href="#面向对象编程原则和设计模式" class="headerlink" title="面向对象编程原则和设计模式"></a>面向对象编程原则和设计模式</h3><ol>
<li>单例模式</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> taskWorker = &#123;</span><br><span class="line">  tasks: [],</span><br><span class="line">  draw() &#123;&#125;,</span><br><span class="line">  addTask(task) &#123;</span><br><span class="line">    Task.tasks.push(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> mapTask = &#123;</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span>(<span class="params">task</span>) </span>&#123;</span><br><span class="line">    taskWorker.addTask(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次get的时候先判断mapTask有没有Task的新实例，如果没有则为第一次。先去实例化一个，并做些初始化工作，如果有则直接返回。然后执行mapTask.get()的时候就能够保证获取到的是一个单例。</p>
<ul>
<li><p>破坏单例</p>
<pre><code>mapTask.aTask = null
</code></pre></li>
</ul>
<ol>
<li>策略模式</li>
</ol>
<p>场景：注册弹框，不同的弹框文字。把文案当做一个个的策略，使用时根据不同类型，映射到不同的策略。<br>这样比写if-else或者switch的好处在于：如果以后要增加或删除某种类型，只需要增删一个type就可以了，而不用去改动if-else逻辑。这就叫做开放封闭原则——对修改是封闭的，而对扩展是开放的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> popType = &#123;</span><br><span class="line">  userReg: &#123;</span><br><span class="line">    title: <span class="string">'Create your account'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  favHouse: &#123;</span><br><span class="line">    title: <span class="string">'Add home to favorite'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  saveSearch: &#123;</span><br><span class="line">    title: <span class="string">'Save this search'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tpl = <span class="string">`&lt;section&gt;&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;/section&gt;`</span></span><br><span class="line"></span><br><span class="line">Mustache.render(tpl, popType[<span class="string">'userReg'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把回调操作封装成一个策略</span></span><br><span class="line"><span class="keyword">var</span> popCallback = &#123;</span><br><span class="line">  userReg: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  favHouse: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  saveSearch: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">util.ajax(<span class="string">'/register'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> popType = <span class="string">'favHouse'</span> <span class="comment">// 获取popType</span></span><br><span class="line">  popCallback[popType]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol>
<li>观察者模式</li>
</ol>
<p>观察者向消息的接受者订阅消息，一旦接受者收到消息后就把消息下发给它的观察者们。在一个回执搜索的应用里面，单击最后一个点关闭路径，要触发搜索。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(inputDom) &#123;</span><br><span class="line">    <span class="keyword">this</span>.inputDom = inputDom</span><br><span class="line">    <span class="keyword">this</span>.visitors = &#123;</span><br><span class="line">      click: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加访问者</span></span><br><span class="line">  on(eventType, visitor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.visitors.push(visitor)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 收到消息，把消息分发给访问者</span></span><br><span class="line">  trigger(type, event) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.visitors[type]) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.visitors[type]; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.visitors[type]()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>适配器模式</li>
</ol>
<p>在一个响应式的页面里，假设小屏和大屏显示的分页样式不同，它们初始化和更新状态的函数都不同，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小屏</span></span><br><span class="line"><span class="keyword">var</span> pagination = <span class="keyword">new</span> jqPagination(&#123;</span><br><span class="line">&#125;)</span><br><span class="line">pagination.showPage = <span class="function"><span class="keyword">function</span>(<span class="params">curPage, totalPage</span>) </span>&#123;</span><br><span class="line">  pagination.setPage(curPage, totalPage)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 大屏</span></span><br><span class="line"><span class="keyword">var</span> pagination = <span class="keyword">new</span> Pagination(&#123;</span><br><span class="line">&#125;)</span><br><span class="line">pagination.showPage = <span class="function"><span class="keyword">function</span>(<span class="params">curPage, totalPage</span>) </span>&#123;</span><br><span class="line">  pagination.showItem(curPage, totalPage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果每次调用都得判断一下不同的屏幕大小然后调用不同函数就很麻烦，所以用一个适配器，对外提供统一的接口：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> screen = $(<span class="built_in">window</span>).width() &lt; <span class="number">800</span> ? <span class="string">'small'</span> : <span class="string">'large'</span></span><br><span class="line"><span class="keyword">var</span> paginationAdapter = &#123;</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.pagination = screen === <span class="string">'small'</span> ? <span class="keyword">new</span> jqPagination() : <span class="keyword">new</span> Pagination()</span><br><span class="line">    <span class="keyword">if</span> (screen === <span class="string">'large'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.pagination.showItem = <span class="keyword">this</span>.pagination.setPage</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  showPage: <span class="function"><span class="keyword">function</span>(<span class="params">curPage, totalPage</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.pagination.showItem(curPage, totalPage)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用者只要调用 <code>paginationAdapter.showPage</code> 就可以更新分页状态，它不需要去关心当前是大屏还是小屏，由适配器去处理这些细节</p>
<ol>
<li>工厂模式</li>
</ol>
<p>工厂模式是把创建交给一个工厂，使用者无需要关心创建细节，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> taskCreator = &#123;</span><br><span class="line">  createTask: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'map'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MapTask()</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'search'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SearchTask()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> mapTask = taskCreator.createTask(<span class="string">'map'</span>)</span><br></pre></td></tr></table></figure>
<p>需要哪种类型的Task时就传一个类型或者name给以个工厂，工厂根据名字去生产相应的产品，不用关心它是怎么创建的，要不要单例之类。</p>
<ol>
<li>外观/门面模式</li>
</ol>
<p>在一个搜索逻辑里，为了显示搜索结果需要执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hideNoResult() <span class="comment">// 隐藏没有结果的显示</span></span><br><span class="line">removeOldResult() <span class="comment">// 删除老的结果</span></span><br><span class="line">showNewResult() <span class="comment">// 显示新结果</span></span><br><span class="line">showPageItem() <span class="comment">// 更新分页</span></span><br><span class="line">resizePhoto() <span class="comment">// 结果图片大小重置</span></span><br></pre></td></tr></table></figure>
<p>于是考虑用一个模块把它包起来</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showResult</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  hideNoResult() <span class="comment">// 隐藏没有结果的显示</span></span><br><span class="line">  removeOldResult() <span class="comment">// 删除老的结果</span></span><br><span class="line">  showNewResult() <span class="comment">// 显示新结果</span></span><br><span class="line">  showPageItem() <span class="comment">// 更新分页</span></span><br><span class="line">  resizePhoto() <span class="comment">// 结果图片大小重置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 需要时调用 showResult()</span></span><br></pre></td></tr></table></figure>
<p>把多个操作封装成一个模块，对外只提供一个门面叫showResult，使用者只要调一下该函数即可</p>
<ol>
<li>状态模式</li>
</ol>
<p>实现一个类似微博的消息框，要求是当数字为0或者超过140时，发推按钮可单击，且剩余数字会跟着变</p>
<p>可用一个state来保存当前的状态，然后当用户输入时，这个state的数据会跟着变，同时更新按钮状态</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tweetBox = &#123;</span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="comment">// 初始化一个state</span></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;&#125;</span><br><span class="line">    tweetBox.bindEvent()</span><br><span class="line">  &#125;,</span><br><span class="line">  setState(key, val) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state[key] = val</span><br><span class="line">  &#125;,</span><br><span class="line">  changeSubmit() &#123;</span><br><span class="line">    <span class="comment">// 通过获取当前的state</span></span><br><span class="line">    $(<span class="string">'#submit'</span>)[<span class="number">0</span>].disabled = tweeetBox.state.text.length === <span class="number">0</span></span><br><span class="line">      || tweetBox.state.text.length &gt; <span class="number">140</span></span><br><span class="line">  &#125;,</span><br><span class="line">  showLeftTextCount() &#123;</span><br><span class="line">    $(<span class="string">'#text-count'</span>).text(<span class="number">140</span> - <span class="keyword">this</span>.state.text.length)</span><br><span class="line">  &#125;,</span><br><span class="line">  bindEvent() &#123;</span><br><span class="line">    $(<span class="string">'.tweet-textarea'</span>).on(<span class="string">'input'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 改变当前的state</span></span><br><span class="line">      tweetBox.setState(<span class="string">'text'</span>, <span class="keyword">this</span>.value)</span><br><span class="line">      tweetBox.changeSubmit()</span><br><span class="line">      tweetBox.showLeftTextCount()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用一个state保存当前状态，通过获取当前state进行下一步操作。</p>
<p>当然，上面的还有优化空间，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tweetBox = &#123;</span><br><span class="line">  setState(key, val) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state[key] = val</span><br><span class="line">    renderDom($(<span class="string">'.tweet'</span>))</span><br><span class="line">  &#125;,</span><br><span class="line">  renderDom($currentDom) &#123;</span><br><span class="line">    diffAndChange($currentDom, renderVirtualDom(tweetBox.state))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// `&lt;input type="submit" disabled=&#123;&#123;this.state.text.length === 0 || this.state.text.length &gt; 140&#125;&#125; /&gt;`</span></span><br></pre></td></tr></table></figure>
<p>这其实就是React的原型，不同的状态有不同的表现行为，所以可以认为是一个状态模式，并且通过状态去驱动DOM更改</p>
<ol>
<li>代理模式</li>
</ol>
<p>其实React不直接操作DOM，而是把数据给state，然后委托给state和虚拟DOM去操作真实DOM，所以它是一个代理模式</p>
<p>eventHandler -&gt; state -&gt; renderDom()</p>
<ol>
<li>状态模式的另一个例子</li>
</ol>
<p>改变一个房源的状态：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newState === <span class="string">'sold'</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (currentState === <span class="string">'building'</span> || currentState === <span class="string">'dold'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'error'</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentState === <span class="string">'ready'</span>) &#123;</span><br><span class="line">    currentState = <span class="string">'sold'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'ok'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (newState === <span class="string">'ready'</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (currentState === <span class="string">'building'</span>) &#123;</span><br><span class="line">    currentState = <span class="string">'toBeSold'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'ok'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更改一个房源的状态之前先要判断一下当前的状态，如果当前状态不支持那么不允许修改。对上面的代码我们可以用代理模式重构一下，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stateChange = &#123;</span><br><span class="line">  ready: &#123;</span><br><span class="line">    building: <span class="string">'error'</span>,</span><br><span class="line">    ready: <span class="string">'error'</span>,</span><br><span class="line">    sold: <span class="string">'ok'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  building: &#123;</span><br><span class="line">    building: <span class="string">'error'</span>,</span><br><span class="line">    ready: <span class="string">'ok'</span>,</span><br><span class="line">    sold: <span class="string">'error'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (stateChange[currentState][newState] !== <span class="string">'error'</span>) &#123;</span><br><span class="line">  currentState = newState</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> stateChange[currentState][newState]</span><br></pre></td></tr></table></figure>
<p>你会发现状态模式和策略模式是孪生兄弟，它们形式相同，只是目的不同。</p>
<p>策略模式封装成策略，状态模式封装成状态。这样的代码就比写很多个if-else强多了，特别是当切换关系比较复杂的时候</p>
<ol>
<li>装饰者模式</li>
</ol>
<p>要实现一个贷款的计算器，点计算按钮后，除了要计算结果，还要把结果发给后端做一个埋点。所以写了一个calculateResult函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateResult</span>(<span class="params">form</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = $(form).serializeForm()</span><br><span class="line">  <span class="keyword">var</span> l = data.rate / <span class="number">1200</span></span><br><span class="line">  <span class="keyword">var</span> o = <span class="built_in">Math</span>.pow(<span class="number">1</span> + l, data.term * <span class="number">12</span>)</span><br><span class="line">  <span class="keyword">var</span> e = data.price * (<span class="number">1</span> - data.payment / <span class="number">100</span>)</span><br><span class="line">  <span class="keyword">var</span> result = (e * l * o / (o - <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">var</span> formatResult = util.formatMoney(result).toFixed(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> $calResult = $(<span class="string">'.loan-cal .cal-result-con'</span>)</span><br><span class="line">  $calResult.find(<span class="string">'.pi-result'</span>).text(formatResult)</span><br><span class="line">  <span class="comment">// 这个函数包含了两个功能，一个计算结果，一个改变DOM</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算按钮click回调</span></span><br><span class="line"><span class="keyword">var</span> result = calculateResult(form)</span><br><span class="line"><span class="comment">// 发送一个埋点请求</span></span><br><span class="line">util.ajax(<span class="string">'/cal-load'</span>, &#123;result&#125;)</span><br></pre></td></tr></table></figure>
<p>因为要把结果返回出来，所以这个函数有两个功能，一个是计算结果，第二个是改变DOM，这样写在一起感觉不太好。<br>于是我们把函数拆了，首先有一个LoanCalculator的类专门负责计算小数结果： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算结果</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoanCalculator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(form) &#123;</span><br><span class="line">    <span class="keyword">this</span>.form = form</span><br><span class="line">  &#125;</span><br><span class="line">  calResult() &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="string">'xxx'</span></span><br><span class="line">    <span class="keyword">this</span>.result = result</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  getResult() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.result) <span class="keyword">this</span>.result = <span class="keyword">this</span>.calResult()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它还提供了一个getResult的函数，如果结果没算过那先算一下保存起来，如果已经计算过了那就直接用算好的结果。<br>然后再写一个<code>NumberFormater</code>，它负责把小数结果格式化成带逗号的形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberFormater</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(calculator) &#123;</span><br><span class="line">    <span class="keyword">this</span>.calculator = calculator</span><br><span class="line">  &#125;</span><br><span class="line">  calResult() &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">this</span>.calculator.calResult()</span><br><span class="line">    <span class="keyword">this</span>.result = result</span><br><span class="line">    <span class="keyword">return</span> util.formatMoney(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在它的构造函数里传一个calculator给它，这个calculator可以是上面的LoanCalculator，获取到它的计算结果然后格式化。<br>接着写一个DOMRenderer的类，它负责把结果下显示出来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示结果</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DOMRenderer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(calculator) &#123;</span><br><span class="line">    <span class="keyword">this</span>.calculator = calculator</span><br><span class="line">  &#125;</span><br><span class="line">  calResult() &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">this</span>.calculator.calResult()</span><br><span class="line">    $(<span class="string">'.pi-result'</span>).text(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后代码调用如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> loadCalculator = <span class="keyword">new</span> LoanCalculator(form)</span><br><span class="line"><span class="keyword">let</span> numberFormator = <span class="keyword">new</span> NumberFormator(loadCalculator)</span><br><span class="line"><span class="keyword">let</span> domRenderer = <span class="keyword">new</span> DOMRenderer(numberFormator)</span><br><span class="line">domRenderer.calResult()</span><br><span class="line">util.ajax(<span class="string">'/cal-loan'</span>, &#123;<span class="attr">result</span>: loadCalculator.getResult()&#125;)</span><br></pre></td></tr></table></figure>
<p>可以看到它就是一个装饰的过程，一层一层地装饰：</p>
<p>DOMRenderer -&gt; NumberFormator -&gt; LoanCalculator</p>
<p>下一个装饰者调用上一个calResult函数，对它的结果进一步地装饰。如果这些装饰者的返回结果类型比较平行时，可以一层层地装饰下去。</p>
<p>使用装饰者模式，逻辑是清晰了，但是系统的复杂性增加了，有时候能用简单方式实现还是用简单方式。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下上文提到的面向对象的编程原则：</p>
<ol>
<li>把共性和特性或者会变和不变的部分分离出来</li>
<li>少用继承，多用组合</li>
<li>低耦合高聚合</li>
<li>开放封闭原则（对修改封闭，对扩展开放）</li>
<li>单一职责原则</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Fridolph</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.fridolph.top/2017/11/01/【JS】面向对象相关设计模式/">http://blog.fridolph.top/2017/11/01/【JS】面向对象相关设计模式/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.fridolph.top" target="_blank">霪霖笙箫的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/oop/">oop</a><a class="post-meta__tags" href="/tags/设计模式/">设计模式</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2017/12/13/【设计模式】初识IOC/"><i class="fa fa-chevron-left">  </i><span>【JS】【设计模式】初识IOC</span></a></div><div class="next-post pull-right"><a href="/2017/10/14/【Vue】iview按需引入相关配置/"><span>【Vue】iview按需引入相关配置</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'http://blog.fridolph.top/2017/11/01/【JS】面向对象相关设计模式/';
  this.page.identifier = '2017/11/01/【JS】面向对象相关设计模式/';
  this.page.title = '【JS】面向对象相关设计模式';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'fridolph' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-src" src="https://fridolph.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2016 - 2024 By Fridolph</div><div class="framework-info"><span>driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.3"></script><script src="/js/fancybox.js?version=1.5.3"></script><script src="/js/sidebar.js?version=1.5.3"></script><script src="/js/copy.js?version=1.5.3"></script><script src="/js/fireworks.js?version=1.5.3"></script><script src="/js/transition.js?version=1.5.3"></script><script src="/js/scroll.js?version=1.5.3"></script><script src="/js/head.js?version=1.5.3"></script></body></html>