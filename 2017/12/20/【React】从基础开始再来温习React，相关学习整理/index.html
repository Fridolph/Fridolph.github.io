<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="【React】从基础开始再来温习React，相关学习整理"><meta name="keywords" content="React"><meta name="author" content="Fridolph,undefined"><meta name="copyright" content="Fridolph"><title>【React】从基础开始再来温习React，相关学习整理 | 霪霖笙箫的博客</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css?version=1.5.3"><meta http-equiv="Cache-Control" content="no-cache,no-store,must-revalidate"><meta http-equiv="Pragma" content="no-cache"><meta http-equiv="Expires" content="0"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?https://hm.baidu.com/hm.js?08804673a5fe37365758820497cd9fb1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  localSearch: {"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"},"path":"search.xml"}
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#React"><span class="toc-number">1.</span> <span class="toc-text">React</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#React新特性相关"><span class="toc-number">1.1.</span> <span class="toc-text">React新特性相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#render新的返回类型"><span class="toc-number">1.1.1.</span> <span class="toc-text">render新的返回类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#错误处理"><span class="toc-number">1.1.2.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Portals"><span class="toc-number">1.1.3.</span> <span class="toc-text">Portals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义DOM属性"><span class="toc-number">1.1.4.</span> <span class="toc-text">自定义DOM属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#生命周期"><span class="toc-number">1.2.</span> <span class="toc-text">生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#挂载阶段"><span class="toc-number">1.2.1.</span> <span class="toc-text">挂载阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更新阶段"><span class="toc-number">1.2.2.</span> <span class="toc-text">更新阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#卸载阶段"><span class="toc-number">1.2.3.</span> <span class="toc-text">卸载阶段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ref相关"><span class="toc-number">1.3.</span> <span class="toc-text">ref相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在DOM上使用ref"><span class="toc-number">1.4.</span> <span class="toc-text">在DOM上使用ref</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#在组件上使用ref"><span class="toc-number">1.4.1.</span> <span class="toc-text">在组件上使用ref</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#父组件访问子组件的DOM节点"><span class="toc-number">1.4.2.</span> <span class="toc-text">父组件访问子组件的DOM节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事件处理"><span class="toc-number">1.5.</span> <span class="toc-text">事件处理</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/config/avatar.jpg"></div><div class="author-info__name text-center">Fridolph</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">58</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">69</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">14</span></a></div></div><div class="unit"><div class="heart"><div class="heart-piece-0"></div><div class="heart-piece-1"></div><div class="heart-piece-2"></div><div class="heart-piece-3"></div><div class="heart-piece-4"></div><div class="heart-piece-5"></div><div class="heart-piece-6"></div><div class="heart-piece-7"></div><div class="heart-piece-8"></div></div><p class="anime-title"><a href="https://github.com/fridolph" target="_blank">感谢访问本站，若喜欢请star ^_^</a></p></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/config/top-img.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">霪霖笙箫的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">个人主页</a><a class="site-page" href="/archives">文章总览</a><a class="site-page" href="/books">图书推荐</a><a class="site-page" href="/demo">项目实战</a><a class="site-page" href="/gallery">时光轨迹</a></span></div><div id="post-info"><div id="post-title">【React】从基础开始再来温习React，相关学习整理</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-12-20</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/React/">React</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2017/12/20/【React】从基础开始再来温习React，相关学习整理/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2017/12/20/【React】从基础开始再来温习React，相关学习整理/"></span></a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">3,147</span><span class="post-meta__separator">|</span><span>阅读时长: 12 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><blockquote>
<p>React虽然从14版就在学习使用了，- - 换公司之后一直在用Vue，以前用Redux，服务端渲染总是觉得很坑，虽然跟着前辈写似懂非懂的，业务逻辑也能做，但Redux那块始终用得不好。也算是曲线救国，Vue、Vuex的使用让我慢慢理解了React的核心和优美之处。正好现在新版发布了，再来重学一次吧</p>
</blockquote>
<a id="more"></a>
<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><p>前端UI本质问题是： 如何将来源于服务器的动态数据和用户的交互行为高效地反映复杂的用户界面上。React通过引入虚拟DOM、状态、单向数据流等设计理念，形成以组件为核心，用组件搭建UI的开发模式，完美地将数据、组件状态和UI映射到一起，极大提高了开发大型Web应用的效率。</p>
<p>React的特点：</p>
<ol>
<li>声明式的视图层</li>
</ol>
<p>使用React不用担心数据、状态和视图交错。</p>
<ol>
<li>简单的更新流程</li>
</ol>
<p>定义UI状态，React框架会复杂把它渲染成最终的UI。当状态数据发生变化时，React也会根据最新的状态渲染出最新的UI</p>
<ol>
<li>灵活地渲染实现</li>
</ol>
<p>先渲染成虚拟DOM，简单的JS对象然后渲染成对应UI</p>
<ol>
<li>高效的DOM操作</li>
</ol>
<p>操作JS对象比起操作真实DOM在效率上有了巨大提升。基于Diff算法，React可以尽量减少虚拟DOM到真实DOM的渲染次数</p>
<p>尽管如此，React并不是MVC框架，从分层上看，React属于V层，关注如何根据状态创建可复用UI组件。当应用复杂时，需结合Redux等才能最大发挥</p>
<h2 id="React新特性相关"><a href="#React新特性相关" class="headerlink" title="React新特性相关"></a>React新特性相关</h2><p>这里介绍了16的新特性，包括render方法新支持的返回类型、新的错误处理机制和Error Boundary组件，可以将组件挂载到任意DOM树的Portals特性以及自定义DOM属性的支持。</p>
<p>基于新的fiber架构。还有如 setState传入null不触发组件更新，更加高效的服务端渲染等方式等。</p>
<h3 id="render新的返回类型"><a href="#render新的返回类型" class="headerlink" title="render新的返回类型"></a>render新的返回类型</h3><p>返回数组</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      &lt;li key=<span class="string">"a"</span>&gt;a&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      &lt;li key="b"&gt;b&lt;/</span>li&gt;</span><br><span class="line">      &lt;li key=<span class="string">"c"</span>&gt;c&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    ]</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>返回字符串</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Just a strings</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>App 组件的render方法渲染 ListComponent 和 StringComponent</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &lt;ListComponent /&gt;</span><br><span class="line">      &lt;<span class="regexp">/ul&gt;,</span></span><br><span class="line"><span class="regexp">      &lt;StringComponent /</span>&gt;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>16版本前，组件运行期间执行错误会阻塞应用渲染。16引入新的错误处理机制，组件抛错时，会就爱你个组件从组件树中卸载，从而避免整个应用的崩溃。</p>
<p>16还提供了一种更友好的错误处理方式——错误边界。错误边界是能够捕获子组件的错误并对其优雅处理的组件，输出错误日志、显示出错提示等这比卸载组件更友好</p>
<p>定义了 componentDidCatch(error, info) 方法的组件将成为一个错误边界，现在我们创建一个组件ErrorBoundary</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">hasError</span>: <span class="literal">false</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidCatch(error, info) &#123;</span><br><span class="line">    <span class="comment">// 显示错误UI</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    <span class="comment">// 同时输出错误日志</span></span><br><span class="line">    <span class="built_in">console</span>.log(error, info)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.hasError) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Oopts, something went wrong.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在App中使用ErrorBoundary</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      user: &#123; <span class="attr">name</span>: <span class="string">'react'</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将user置为null，模拟异常</span></span><br><span class="line">  onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">user</span>: <span class="literal">null</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ErrorBoundary&gt;</span><br><span class="line">          &lt;Profile user=&#123;<span class="keyword">this</span>.state.user&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/ErrorBoundary&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.onClick&#125;&gt;更新&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const Profile = (&#123;user&#125;) =&gt; &lt;div&gt;name: &#123;user.name&#125;&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>
<p>点击更新按钮后，Profile接受的属性user为null，程序会抛错TypeError，这个错误被ErrorBoundary捕获，并在界面上显示出错提示</p>
<h3 id="Portals"><a href="#Portals" class="headerlink" title="Portals"></a>Portals</h3><p>Portals特性让我们可以把组件渲染到当前组件树以外的DOM节点上。该特性的典型应用场景是，渲染应用的全局弹框，使用Portals后，任意组件都可以将弹框组件渲染到根节点上，以方便弹框的显示。Portals的实现依赖于ReactDOM的一个新API</p>
<pre><code>ReactDOM.createPortal(child, container)
</code></pre><p>第一个参数child是可以被渲染的React节点，例如React元素、由React元素组成的数组、字符串等。<br>container是一个DOM元素，child将被挂载到这个DOM节点</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modal</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="comment">// 根节点下创建一个div节点</span></span><br><span class="line">    <span class="keyword">this</span>.container = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(<span class="keyword">this</span>.container)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> ReactDOM.createPortal(</span><br><span class="line">      &lt;div className=<span class="string">"modal"</span>&gt;</span><br><span class="line">        &lt;span className=<span class="string">"close"</span> onClick=&#123;<span class="keyword">this</span>.props.onClose&#125;&gt;&amp;times;<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">        &lt;div className=<span class="string">"content"</span>&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;,</span><br><span class="line">      <span class="keyword">this</span>.container</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(<span class="keyword">this</span>.container)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在App中使用Modal</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">showModal</span>: <span class="literal">true</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  closeModal = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">showModal</span>: <span class="literal">false</span>&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;Dashboard&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">        &#123;this.state.showModal &amp;&amp; (</span></span><br><span class="line"><span class="regexp">          &lt;Modal onClose=&#123;this.closeModal&#125;&gt;Modal Dialog&lt;/</span>Modal&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="自定义DOM属性"><a href="#自定义DOM属性" class="headerlink" title="自定义DOM属性"></a>自定义DOM属性</h3><p>16版 React会把不识别的属性传递给DOM元素。例如， 在16前，下面的React元素</p>
<pre><code>&lt;div custom-attribute=&quot;something&quot; /&gt;
</code></pre><p>在浏览器中渲染出的DOM节点为：</p>
<pre><code>&lt;div /&gt;
</code></pre><p>而React16版渲染出的DOM节点为：</p>
<pre><code>&lt;div custom-attribute=&quot;something&quot; /&gt;
</code></pre><hr>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>组件从创建到被销毁的过程称为组件的生命周期。通常，有以下三个阶段：</p>
<h3 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h3><ul>
<li><p>constructor</p>
</li>
<li><p>componentWillMount 用得较少，因为此阶段的都可移到constructor里，该方法调用this.setState不会引起重渲</p>
</li>
<li><p>render 根据组件的props和state返回一个React元素。需注意，render并不负责组件的实际渲染，它只是返回一个UI描述，真正渲染DOM由React本身负责，该阶段不能执行有副作用的操作</p>
</li>
<li><p>componentDidMount 组件被挂载后只调用一次，依赖DOM节点操作可放该阶段中，还有服务端请求等操作，this.setState会引起重渲</p>
</li>
</ul>
<h3 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h3><ul>
<li>componentWillReceiveProps(nextProps) 引起组件更新过程调用。state引起组件更新不会触发该方法的执行。nextProps是父组件传递给当前组件的新props. 因此往往需比较nextProps和this.props来决定是否执行props发生变化后的逻辑</li>
</ul>
<blockquote>
<p>(1)在componentWillReceiveProps中调用setState，只有在组件render及其之后的方法中，this.setState指向的才是更新后的state。在render之前的方法shouldComponentUpdate、componentWillUpdate中，this.setState依然指向的是更新前的state</p>
</blockquote>
<blockquote>
<p>(2)通过调用setState更新组件状态并不会触发componentWillReceiveProps的调用，否则会进入一个死循环 componentWillReceiveProps -&gt; this.setState -&gt; componentWillReceiveProps …</p>
</blockquote>
<ul>
<li><p>shouldComponentUpdate(nextProps, nextState) 该方法决定组件是否继续执行更新过程。当方法返回true时(默认)，组件会继续更新过程。当返回false，组件的更新过程停止，后续的componentWillUpdate、render、componentDidUpdate也不会被调用，这是优化性能的一个重要钩子</p>
</li>
<li><p>componentWillUpdate(nextProps, nextState) 在组件render前调用，可作为组件更新前执行某些工作的地方</p>
</li>
</ul>
<blockquote>
<p>shouldComponentUpdate和componentWillUpdate中都不能调用setState，否则会引起循环调用问题</p>
</blockquote>
<ul>
<li><p>render 同上，省略了</p>
</li>
<li><p>componentDidUpdate(prevProps, prevState) 组件更新后被调用，可作为更新后操作DOM的地方，其参数prevProps, prevState代表组件更新前的props和state</p>
</li>
</ul>
<h3 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h3><p>组件从DOM中被卸载的过程，只有一个声明周期方法</p>
<ul>
<li>componentWillUnmount 在组件卸载前调用，可在这里执行一些清理工作。如定时器或手动创建的DOM元素等，以避免内存泄漏</li>
</ul>
<blockquote>
<p>只有类才具有生命周期方法，函数组件是没有生命周期钩子的。</p>
</blockquote>
<h2 id="ref相关"><a href="#ref相关" class="headerlink" title="ref相关"></a>ref相关</h2><p>绝大部分场景应避免使用ref，因为它破坏了React中以props为数据传递介质的典型数据流。</p>
<p>下面介绍下ref的常用使用场景</p>
<h2 id="在DOM上使用ref"><a href="#在DOM上使用ref" class="headerlink" title="在DOM上使用ref"></a>在DOM上使用ref</h2><p>ref接受一个回调函数作为值，在组件被挂载或卸载时，回调函数会被调用，在组件被挂载时，回调函数会接受当前DOM元素作为参数；组件被卸载时回调函数会接受null作为参数</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoFocusTextInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> ref=&#123;input =&gt; <span class="keyword">this</span>.textInput = input&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  componentDidMount() &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 通过ref让input自动获取焦点</span></span><br><span class="line"><span class="regexp">    this.textInput.focus()</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>AutoFocusTextInput中为input定义ref，在组件挂载后，通过ref获取input元素，让其自动获取焦点，否则就很难实现该功能</p>
<h3 id="在组件上使用ref"><a href="#在组件上使用ref" class="headerlink" title="在组件上使用ref"></a>在组件上使用ref</h3><p>例，在使用AutoFocusTextInput组件的外部组件Containter中控制：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoFocusTextInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  blur = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.textInput.blur()</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> ref=&#123;input =&gt; <span class="keyword">this</span>.textInput = input&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ AutoFocusTextInputContainer.jsx</span></span><br><span class="line"><span class="regexp">class AutoFocusTextInputContainer extends Component &#123;</span></span><br><span class="line"><span class="regexp">  handleClick = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 通过ref调用 组件的方法</span></span><br><span class="line"><span class="regexp">    this.inputInstance.blur()</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;AutoFocusTextInput ref=&#123;this.inputInstance = input&#125; /</span>&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;失去焦点&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过ref获取到了AutoFocusTextInput组件的实例对象，并把它赋值给Container的inputInstance属性，这样就可以通过inputInstance调用AutoFocusTextInput中的blur方法，让已经处于获取焦点状态的input失去焦点。</p>
<h3 id="父组件访问子组件的DOM节点"><a href="#父组件访问子组件的DOM节点" class="headerlink" title="父组件访问子组件的DOM节点"></a>父组件访问子组件的DOM节点</h3><p>某些场景可能会需要。例如父组件需知道这个DOM元素的尺寸或位置信息，直接使用ref是无法实现的。</p>
<p>这时，可在子组件的DOM元素上定义ref，ref的值是父组件传递给子组件的一个回调函数，回调函数可以通过一个自定义的属性传递，例如inputRef, 这样父组件的回调函数中就能获取到这个DOM元素</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Children</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 子组件使用父组件传递的inputRef, 为input的ref赋值</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input ref=&#123;props.inputRef&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Parent extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 自定义一个属性inputRef，值是一个函数</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;Children inputRef=&#123;el =&gt; this.inputElement = el&#125; /</span>&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从该例中还可发现，即时子组件是函数组件，这种方式同样有效。</p>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><ul>
<li>React的事件命名采用驼峰命名</li>
<li>处理事件的响应函数要以对象形式赋值给事件属性</li>
</ul>
<hr>
<p>React事件是合成事件，并不是原生DOM事件。在React事件中必须显式调用事件对象的preventDefault方法来阻止事件的默认行为。</p>
<p>在 React组件中处理事件最容易出错的是事件处理函数中this指向问题，因为ES6 Class不会为方法自动绑定到当前对象。</p>
<ol>
<li>使用箭头函数</li>
</ol>
<p>箭头函数的this指向的是函数定义时的对象，可保证this总是指向当前组件的实例对象。<br>直接在render方法为元素事件定义事件处理函数，最大问题是每次render调用时都会重新创建一个新的事件处理函数，带来额外的性能开销，组件所处层级越低，开销就越大</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;e =&gt; <span class="keyword">this</span>.handleClick(e)&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>使用组件方法</li>
</ol>
<p>直接将组件的方法赋值给元素的事件属性，同时在类的构造函数中，将这个方法的this绑定当当前对象</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick(e)&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>好处是每次render不会重新创建一个回调函数，没有额外的性能损失。但模版较为繁琐，还有下一种改良：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>)&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>使用bind会创建一个新函数，因此该写法毅然存在每次render都会创建一个新函数问题</p>
<p><strong>3. 属性初始化语法</strong> property initializer syntax</p>
<p>使用ES7的property initializers会自动为class中定义的方法绑定this：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ES7的属性初始化方法，实际上也是使用了箭头函数</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> num = ++<span class="keyword">this</span>.state.num</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      num</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;<span class="keyword">this</span>.state.num&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.handleClick&#125;&gt;click&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这种方式既不需要在构造函数中手动绑定this，也不需要担心组件重复渲染导致的函数重复创建问题。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Fridolph</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.fridolph.top/2017/12/20/【React】从基础开始再来温习React，相关学习整理/">http://blog.fridolph.top/2017/12/20/【React】从基础开始再来温习React，相关学习整理/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.fridolph.top" target="_blank">霪霖笙箫的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/React/">React</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2017/12/28/【React】进阶React的重要知识点/"><i class="fa fa-chevron-left">  </i><span>【React】进阶React的重要知识点</span></a></div><div class="next-post pull-right"><a href="/2017/12/13/【设计模式】初识IOC/"><span>【JS】【设计模式】初识IOC</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'http://blog.fridolph.top/2017/12/20/【React】从基础开始再来温习React，相关学习整理/';
  this.page.identifier = '2017/12/20/【React】从基础开始再来温习React，相关学习整理/';
  this.page.title = '【React】从基础开始再来温习React，相关学习整理';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'fridolph' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-src" src="https://fridolph.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2016 - 2024 By Fridolph</div><div class="framework-info"><span>driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.3"></script><script src="/js/fancybox.js?version=1.5.3"></script><script src="/js/sidebar.js?version=1.5.3"></script><script src="/js/copy.js?version=1.5.3"></script><script src="/js/fireworks.js?version=1.5.3"></script><script src="/js/transition.js?version=1.5.3"></script><script src="/js/scroll.js?version=1.5.3"></script><script src="/js/head.js?version=1.5.3"></script></body></html>