<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>霪霖笙箫的博客</title>
  
  <subtitle>国服大前端, 请多指教 ^_^ 喜爱羽毛球、棒球，动漫控，摄影迷</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.fridolph.top/"/>
  <updated>2024-01-01T07:09:42.270Z</updated>
  <id>http://blog.fridolph.top/</id>
  
  <author>
    <name>Fridolph</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【总结】2023年底面临的危机及反思</title>
    <link href="http://blog.fridolph.top/2023/12/28/%E3%80%90%E6%80%BB%E7%BB%93%E3%80%912023%E5%B9%B4%E5%BA%95%E9%9D%A2%E4%B8%B4%E7%9A%84%E5%8D%B1%E6%9C%BA%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%8F%8D%E6%80%9D/"/>
    <id>http://blog.fridolph.top/2023/12/28/【总结】2023年底面临的危机及一些反思/</id>
    <published>2023-12-28T14:41:03.000Z</published>
    <updated>2024-01-01T07:09:42.270Z</updated>
    
    <content type="html"><![CDATA[<h3 id="吐槽（为什么又开始写博客了）"><a href="#吐槽（为什么又开始写博客了）" class="headerlink" title="吐槽（为什么又开始写博客了）"></a>吐槽（为什么又开始写博客了）</h3><blockquote><p>16年毕业，趁着互联网的风口，选择了前端岗位。那时技术更新日新月异可谓百鸟争鸣，从jQuery面向对象的开发模式，逐渐过渡到以现代构建工具，利用React、Vue等框架，高效率的开发模式，需要持续学习来应对接连的挑战。    随着工作稳定，慢慢将重心转移到生活和家庭中，这无可厚非。本以为段子里的程序猿中年危机离我还很遥远，但它还是来了，随之而来的还有无尽的焦虑及大数据伴生的各种烦恼、负能量推送。对此我很抗拒、迷茫，在短期的自我调整中，我偶然翻起了之前看了一半的《学习产品思维》，受益良多。  遂决定写下这篇博客，以此吹响“反击”的号角。</p></blockquote><a id="more"></a><p>运用产品思维的一个好处就是可以跳脱当前，站在一个客观的角度俯瞰全局，在此就预设一个命题来进行思考——如何看待当下的失业危机，该怎样调整和应对？</p><h2 id="明确目的"><a href="#明确目的" class="headerlink" title="明确目的"></a>明确目的</h2><h3 id="解决焦虑，设定目标"><a href="#解决焦虑，设定目标" class="headerlink" title="解决焦虑，设定目标"></a>解决焦虑，设定目标</h3><p>焦虑无非是不知道做什么，对自己能力的不自信，从而产生的一种大众跟随情绪。但自从学完了产品思维后，不良情绪逐渐消散。正因设定了许许多多可完成的目标，哪还能再此停留不前呢？</p><h3 id="接受现实，坦然面对"><a href="#接受现实，坦然面对" class="headerlink" title="接受现实，坦然面对"></a>接受现实，坦然面对</h3><p>首先是年底前（元旦后可能还会有部分）工作对接处理。需要注意的：19年、21年某几个项目的开发环境readme添加，环境搭建node版本不同的几个坑；当前维护的两个项目代码提交及注释，写完交接文档。</p><p>对于公司欠薪很遗憾，好聚好散，生活还得继续，接下来走劳动仲裁途径维护自己权益，积累了一波仲裁经验，希望以后用不到吧：</p><h3 id="XXX公司工作相关思考"><a href="#XXX公司工作相关思考" class="headerlink" title="XXX公司工作相关思考"></a>XXX公司工作相关思考</h3><p>这里就不写太多了，作为一个引子，会把相关内容移到简历中，这里写个大纲：</p><ul><li>完成的项目<ul><li>时间</li><li>收益</li><li>技术架构</li><li>难点</li><li>启发</li></ul></li><li>经验<ul><li>团队管理</li><li>项目管理</li><li>项目维护</li></ul></li><li>个人<ul><li>贡献</li><li>优势</li><li>不足</li></ul></li></ul><h2 id="如何调整"><a href="#如何调整" class="headerlink" title="如何调整"></a>如何调整</h2><p>其实写到这里，那种压力和负担感已缓解了不少。本地启了下之前的博客备份，被几个同事看到，还被尴夸了一波（害羞），说：没看出来你以前弄的东西这么牛逼。（某：合着现在菜狗是吧 … 但好像无力反驳）学习下周董的心态呗，哥20年前的歌现在依旧牛逼，那我几年前的产出现在也勉强能打没问题吧？</p><p>心理上没了负担，只需把目标转化为行动，并坚持下去 ^_^<br>不断获得反馈，及时校正和处理。</p><h2 id="如何应对"><a href="#如何应对" class="headerlink" title="如何应对"></a>如何应对</h2><p>结合着个人情况设立了以下目标，并会根据实际情况做出反馈及时更新该篇博客。</p><ol><li>设定阶段计划 与 每天学习计划<ul><li>保持学习状态，按计划执行</li><li>若因家事等不能执行，也要留出1h进行阅读</li><li>每天至少有一次梳理提交到github、gitee中</li></ul></li><li>个人网站重新搭建<ul><li>[&#x2714;]购买服务器、恢复域名</li><li>[&#x2716;]2024年1月中旬左右完成备案</li><li>[&#x2716;]备案搞定后技术博客更新，部署上线</li></ul></li><li>23年底做完资料大整理<ul><li>[&#x2714;] 学习云盘，个人移动盘资料内容同步更新、整理</li><li>[&#x2714;] github、gitee垃圾项目，fork等清理</li><li>[&#x2714;] [fridolph]学习项目，按新的目录重新分类、整理</li><li>[&#x2714;] 制定1-2月的学习计划，并开始执行</li></ul></li><li>技术学习提高 与 博客上新计划<ul><li>[&#x2716;] 元旦前写一篇《学习产品思维》 的学习总结</li><li>[&#x2716;] 一周内看完 《TypeScript晋级》并写一篇技术博客</li><li>[&#x2716;] 一周内看完 《web安全实战宝典》并写一篇技术博客</li><li>[&#x2716;] 一周内看完 《vue3+ts二次封装组件》并写一篇技术博客</li></ul></li><li>恢复驾驶资格（悲催，忙着忘换驾照超过一年）<ul><li>[&#x2716;] 计划1月15日考过科目一（下载驾考宝典，每天至少刷一遍）</li><li>[&#x2716;] 计划1月8日 去指定医院 进行C1的体检</li><li>[&#x2716;] 计划1月8日 拍一寸免冠白底照，app上预约考科目一</li><li>[&#x2716;] 通过科目一，成功换驾照</li></ul></li><li>羽毛球技术提升计划<ul><li>每周保持 2-3 次的打球频率</li><li>坚持、节制</li><li>提高反手吊球稳定性</li><li>针对性刻意练习杀球</li></ul></li></ol><h2 id="温故知新，迎接挑战"><a href="#温故知新，迎接挑战" class="headerlink" title="温故知新，迎接挑战"></a>温故知新，迎接挑战</h2><p>相信自己，回想一下毕业时找工作的情形吧。需要把知识形成体系，多借助思维脑图，把掌握的东西表达出来即可。</p><h3 id="准备面试"><a href="#准备面试" class="headerlink" title="准备面试"></a>准备面试</h3><ul><li>[&#x2716;] 刷完 《【前端面试】全家桶》 - 学习笔记提交到github（1个月）</li><li>[&#x2716;] 更新个人简历pdf，并同步到BOSS直聘、拉钩（可趁着春节前后）</li><li>[&#x2716;] 用vue3+ts重构<code>myresume</code>项目部署上线</li></ul><blockquote><p>ps <code>myresume</code>是之前自己写着玩的项目，正好趁此机会升级一波，看看能不能加点新东西，保持活力。有那么点想法了，看有否有时间去完善吧</p></blockquote><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>作为一名理科生，写作真的是过不去的坎 …… ORZ，但带有目的性 的写作会相对让码字变得容易些。设立目的尽量遵循SMART原则，给予一定的反馈和奖励，让自己能坚持下去。</p><p>每个人都身处于当下的环境中，相信自己，你能做到的，加油！！！<br>愿自己能找到一份不996，少加班有双休的工作，希望自己与家人朋友都健康平安！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;吐槽（为什么又开始写博客了）&quot;&gt;&lt;a href=&quot;#吐槽（为什么又开始写博客了）&quot; class=&quot;headerlink&quot; title=&quot;吐槽（为什么又开始写博客了）&quot;&gt;&lt;/a&gt;吐槽（为什么又开始写博客了）&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;16年毕业，趁着互联网的风口，选择了前端岗位。那时技术更新日新月异可谓百鸟争鸣，从jQuery面向对象的开发模式，逐渐过渡到以现代构建工具，利用React、Vue等框架，高效率的开发模式，需要持续学习来应对接连的挑战。    随着工作稳定，慢慢将重心转移到生活和家庭中，这无可厚非。本以为段子里的程序猿中年危机离我还很遥远，但它还是来了，随之而来的还有无尽的焦虑及大数据伴生的各种烦恼、负能量推送。对此我很抗拒、迷茫，在短期的自我调整中，我偶然翻起了之前看了一半的《学习产品思维》，受益良多。  遂决定写下这篇博客，以此吹响“反击”的号角。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="总结" scheme="http://blog.fridolph.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://blog.fridolph.top/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="思考" scheme="http://blog.fridolph.top/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>【性能】（七）浏览器缓存优化</title>
    <link href="http://blog.fridolph.top/2019/02/03/%E3%80%90%E6%80%A7%E8%83%BD%E3%80%917%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    <id>http://blog.fridolph.top/2019/02/03/【性能】7浏览器缓存优化/</id>
    <published>2019-02-03T13:45:42.000Z</published>
    <updated>2024-01-01T06:59:05.736Z</updated>
    
    <content type="html"><![CDATA[<section><br>    <h2>七、浏览器缓存优化</h2><br>    <h3>核心点</h3><br>    <ul><br>        <li>了解缓存策略相关设置</li><br>    <li>缓存优化实践</li><br>    </ul><br></section><section><br>  <h2>设置 HTTP Header</h2><br>  <ul><br>    <li>Cache-Control</li><br>    <li>Expires</li><br>    <li>Last-Modified / If-Modified-Since</li><br>    <li>Etag / If-None-Match</li><br>  </ul><br></section><section><br>  <h3>Cache-Control</h3><br>  <p>可出现在request header和response header中，其作用是 让浏览器和客户端相互知道各自的缓存策略情况</p><br>  <ul><br>    <li>max-age</li><br>    <li>private</li><br>    <li>public</li><br>    <li>no-cache</li><br>    <li>no-store</li><br>  </ul><br></section><section><br>  <h3>Cache-Control</h3><br>  <ul><br>    <li class="fragment">max-age 缓存的最大有效时间，浏览器再次请求该资源时不会向服务端发起请求 </li><br>    <li class="fragment">s-maxage 同上，但只能指定public缓存</li><br>    <li class="fragment">public</li><br>    <li class="fragment">no-cache 发请求到服务端判断浏览器缓存是否过期</li><br>    <li class="fragment">no-store 完全不使用缓存策略</li><br>  </ul><br></section><section><br>  <h3>Last-Modified / If-Modified-Since</h3><br>  <h4>基于客户端和服务端协商的缓存机制</h4><br>  <ul><br>    <li class="fragment">Last-Modified - response header</li><br>    <li class="fragment">If-Modified-Since - request header</li><br>    <li class="fragment">需要与cache-control一起使用</li><br>  </ul><br>  <h4>缺点</h4><br>  <ul><br>    <li class="fragment">某些服务端不能获取精确的修改时间</li><br>    <li class="fragment">文件修改时间改了，但文件内容没有变</li><br>  </ul><br></section><section><br>  <h3>Etag / If-None-Match</h3><br>  <ul><br>    <li class="fragment">文件内容的hash值</li><br>    <li class="fragment">Etag - response header</li><br>    <li class="fragment">If-none-match - request header</li><br>    <li class="fragment">需要与cache-control 共同使用</li><br>  </ul><br></section><section><br>  <h2>分级缓存策略<br></h2></section><section><br>  <h3>200 HTTP Code</h3><br>  <p>当浏览器本地没有缓存或者下一层失效时，可通过ctrl+f5 浏览器去服务器下载最新数据</p><br></section><section><br>  <h3>304 HTTP Code</h3><br>  <p>这一层由 last-modified / Etag 控制，当下一层失效时或用户点击refresh f5，浏览器发送请求给服务器，若服务端没变化则返回304给浏览器</p><br></section><section><br>  <h3>200 HTTP Code (from cache)</h3><br>  <p>这一层由 expires/cache-control 控制</p><br><br>  <ul><br>    <li class="fragment">expires (http 1.0) 是绝对时间</li><br>    <li class="fragment">cache-control (http 1.1) 相对时间，两者都存在，cache-control覆盖expire，只要没失效，浏览器只访问自己的缓存</li><br>  </ul><br></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;section&gt;&lt;br&gt;    &lt;h2&gt;七、浏览器缓存优化&lt;/h2&gt;&lt;br&gt;    &lt;h3&gt;核心点&lt;/h3&gt;&lt;br&gt;    &lt;ul&gt;&lt;br&gt;        &lt;li&gt;了解缓存策略相关设置&lt;/li&gt;&lt;br&gt;    &lt;li&gt;缓存优化实践&lt;/li&gt;&lt;br&gt;    &lt;/ul&gt;&lt;br&gt;&lt;/
      
    
    </summary>
    
      <category term="性能" scheme="http://blog.fridolph.top/categories/%E6%80%A7%E8%83%BD/"/>
    
    
      <category term="缓存" scheme="http://blog.fridolph.top/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>【性能】（六）浏览器存储</title>
    <link href="http://blog.fridolph.top/2019/02/02/%E3%80%90%E6%80%A7%E8%83%BD%E3%80%916%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8/"/>
    <id>http://blog.fridolph.top/2019/02/02/【性能】6浏览器存储/</id>
    <published>2019-02-02T13:17:32.000Z</published>
    <updated>2024-01-01T06:58:54.427Z</updated>
    
    <content type="html"><![CDATA[<section><br>    <h2>六、浏览器存储</h2><br>    <h3>核心点</h3><br>    <ul><br>        <li>理解localStorage、cookie、sessionStorage、indexDB的概念和使用</li><br>        <li>学习理解PWA和Service Worker的应用</li><br>    <li>多种浏览器存储方式并存</li><br>    </ul><br></section><section><br>  <h3>什么是Cookie</h3><br>  <p>Cookie 是在 HTTP 协议下，服务器或脚本可以维护客户工作站上信息的一种方式，也可叫作浏览器缓存</p><br>  <h4>Cookie 生成方式</h4><br>  <ul><br>    <li>http response header 中的 set-cookie</li><br>  </ul><br></section><section><br>  <h4>Cookie 用途</h4><br>  <ul><br>    <li class="fragment">用于浏览器端和服务器端的交互</li><br>    <li class="fragment">客户端自身数据的存储</li><br>  </ul><br>  <h4 class="fragment">过期时间 expire</h4><br>  <p class="fragment">因为HTTP请求无状态，所以需要Cookie去维持客户端状态</p><br></section><section><br>  <h3>Cookie存储限制</h3><br>  <ul><br>    <li class="fragment">浏览器存储 大小4KB左右</li><br>    <li class="fragment">需要设置过期时间 expire</li><br>    <li class="fragment">cookie属性有 httponly 是不支持js读写</li><br>    <li class="fragment">CDN的流量损耗(故CDN域名不要携带cookie)</li><br>    <li class="fragment">CDN的域名和主站的域名要分开</li><br>  </ul><br></section><section><br>  <h3>LocalStorage</h3><br>  <ul><br>    <li class="fragment">HTML5设计出来专门用于浏览器存储的</li><br>    <li class="fragment">本地存储大小为5M左右</li><br>    <li class="fragment">仅在客户端使用，不和服务端进行通信</li><br>    <li class="fragment">接口封装较好</li><br>    <li class="fragment">浏览器本地缓存方案</li><br>  </ul><br></section><section><br>  <h3>SessionStorage</h3><br>  <ul><br>    <li class="fragment">会话级别的浏览器存储</li><br>    <li class="fragment">大小为5M左右</li><br>    <li class="fragment">仅在客户端使用，不和服务端进行通信</li><br>    <li class="fragment">接口封装较好</li><br>    <li class="fragment">对于表单信息的维护</li><br>  </ul><br></section><section><br>  <h3>IndexDB</h3><br>  <p class="fragment">IndexDB是一种低级API，用于客户端存储大量数据化数据。该API使用索引来实现对该数据的高性能搜索。</p><br>  <p class="fragment">虽然Web Storage对于存储较少量数据很有用，但对于存储更大量结构化数据来说，这种方法不太有用，IndexDB提供了一个解决方案为应用创建离线版本</p><br></section><section><br>  <h3>Service Workers</h3><br>  <p class="fragment">Service Worker 是一个脚本，浏览器独立于当前网页，将其在后台运行，为实现一些不依赖页面或者用户交互的特性打开了一扇大门。</p><br>  <p class="fragment">在未来这些特性将包括推送消息，背景后台同步，geofencing(地理围栏定位)，但它将推送的第一个首要特性就是拦截和处理网络请求的能力，包括以编程方式来管理被缓存的响应。</p><br></section><section><br>  <h3>PWA (Progressive Web App)</h3><br>  <p class="fragment">是一种Web APP新模型，并不是具体指某一种前沿技术或者某一个单一的知识点。这是一系列新的Web特性，配合优秀的UI交互设计，逐步地增强Web APP的用户体验</p><br>  <ul><br>    <li class="fragment">可靠：在没有网络的环境也能提供基本的页面访问，而不会出现未连接到互联网的页面</li><br>    <li class="fragment">快速：针对网页渲染及网络数据访问有较好地优化</li><br>    <li class="fragment">融入：应用可以被增加到手机桌面，并且和普通应用一样有全屏、推送等特性</li><br>  </ul><br></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;section&gt;&lt;br&gt;    &lt;h2&gt;六、浏览器存储&lt;/h2&gt;&lt;br&gt;    &lt;h3&gt;核心点&lt;/h3&gt;&lt;br&gt;    &lt;ul&gt;&lt;br&gt;        &lt;li&gt;理解localStorage、cookie、sessionStorage、indexDB的概念和使用&lt;/li&gt;&lt;br&gt;
      
    
    </summary>
    
      <category term="性能" scheme="http://blog.fridolph.top/categories/%E6%80%A7%E8%83%BD/"/>
    
    
      <category term="localstorage" scheme="http://blog.fridolph.top/tags/localstorage/"/>
    
      <category term="sessionstorage" scheme="http://blog.fridolph.top/tags/sessionstorage/"/>
    
  </entry>
  
  <entry>
    <title>【性能】（五）回流与重绘</title>
    <link href="http://blog.fridolph.top/2019/01/31/%E3%80%90%E6%80%A7%E8%83%BD%E3%80%915%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98/"/>
    <id>http://blog.fridolph.top/2019/01/31/【性能】5回流与重绘/</id>
    <published>2019-01-31T03:57:52.000Z</published>
    <updated>2024-01-01T06:58:48.576Z</updated>
    
    <content type="html"><![CDATA[<section><br>    <h2>五、回流与重绘</h2><br>    <h3>核心点</h3><br>    <ul><br>        <li>理解浏览器重绘与回流的机制</li><br>        <li>对于一些经典案例进行分析</li><br>    <li>重绘与回流的案例相关解读</li><br>    </ul><br></section><section><br>  <h3>CSS性能让JavaScript变慢？</h3><br>  <p class="fragment">因为CSS放在head中，加载CSS也会阻塞浏览器资源加载</p><br>  <ul><br>    <li class="fragment">一个线程 =&gt; UI渲染</li><br>    <li class="fragment">一个线程 =&gt; JS引擎</li><br>  </ul><br>  <p class="fragment">频繁触发重绘与回流，会导致UI频繁渲染，从而阻塞JS执行，最终导致JS变慢</p><br></section><section><br>  <h3>回流 Reflow</h3><br>  <p class="fragment">当render tree中的一部分或全部因为元素的规模尺寸、布局、隐藏等改变而需要重新构建。这就称为回流，Reflow</p><br>  <p class="fragment">当页面布局和几何属性改变时就需要Reflow。Reflow涉及到页面布局、大小变化等</p><br></section><section><br>  <h3>重绘 Repaint</h3><br>  <p class="fragment">当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不影响布局的，比如backgrond-color 则就称为重绘 Repaint</p><br>  <p class="fragment">页面发生（任何）变化，都会发生重绘</p><br>  <p class="fragment"><b>回流必将引起重绘，而重绘不一定引起回流</b></p><br></section><section><br>  <h3>触发Repaint的属性 - 盒模型相关</h3><br>  <ul><br>    <li>display</li><br>    <li>padding margin</li><br>    <li>border-width border</li><br>    <li>width height min-height</li><br>  </ul><br></section><section><br>  <h3>触发Repaint的属性 - 定位、浮动</h3><br>  <ul><br>    <li>clear</li><br>    <li>float</li><br>    <li>position</li><br>    <li>top bottom left right</li><br>  </ul><br></section><section><br>  <h3>触发Repaint的属性 - 改变文字结构</h3><br>  <ul><br>    <li>overflow overflow-y</li><br>    <li>vertical-align</li><br>    <li>line-height</li><br>    <li>font-size font-family font-weight</li><br>    <li>text-align</li><br>    <li>white-space</li><br>  </ul><br></section><section><br>  <h3>只触发Reflow的属性</h3><br>  <ul><br>    <li>visibility</li><br>    <li>color box-shadow</li><br>    <li>border-style border-radius</li><br>    <li>text-decoration</li><br>    <li>background background-image background-position background-repeat background-size</li><br>    <li>outline outline-color outline-style outline-width</li><br>  </ul><br></section><section><br>  <h3>Reflow、Repaint优化</h3><br>  <ul><br>    <li class="fragment">避免使用触发回流、重绘的CSS属性</li><br>    <li class="fragment">将回流、重绘的影响范围限制在单独的图层之内</li><br>    <li class="fragment">将频繁重绘回流的DOM元素单独作为一个独立图层，那么这个DOM元素的重绘和回流影响只会在这个图层中</li><br>  </ul><br></section><section><br>  <h3>新建DOM的过程</h3><br>  <ol><br>    <li>获取DOM后分隔为多个图层</li><br>    <li>对每个图层的节点计算样式结果 Recalculate style</li><br>    <li>为每个节点生成图形和位置 Layout</li><br>    <li>将每个节点绘制填充到图层位图中</li><br>    <li>图层作为纹理上传至GPU</li><br>    <li>符合多个图层到页面上生成最终屏幕图像</li><br>  </ol><br></section><section><br>  <h3>Chrome 创建图层的条件</h3><br>  <ol><br>    <li>3D或透视变换的CSS属性 perspective transform</li><br>    <li>使用加速视频解码 video节点</li><br>    <li>拥有3D (WebGL) 上下文或加速的2D上下文的canvas节点</li><br>    <li>混合插件 如Flash</li><br>    <li>对自己的opacity 做CSS动画或使用一个动画webkit变换的元素</li><br>    <li>拥有加速CSS过滤器的元素</li><br>    <li>元素有一个包含复合层的后代节点</li><br>    <li>元素有一个 z-index 较低且包含一个复合层的兄弟元素</li><br>  </ol><br></section><section><br>  <h3>实战优化点 1</h3><br>  <ol><br>    <li>用 translate 替代 top 改变</li><br>    <li>用opacity 替代 visibility</li><br>    <li>不直接修改DOM样式，而是预先定义好class</li><br>    <li>把DOM离线后修改（先隐藏计算后再显示）</li><br>    <li>不要把DOM结点的属性值放在循环里当成循环里的变量</li><br>  </ol><br></section><section><br>  <h3>实战优化点 2</h3><br>  <ol><br>    <li>不要使用table布局</li><br>    <li>动画实现的速度的选择</li><br>    <li>对于动画新建图层</li><br>    <li>合理启用GPU硬件加速</li><br>  </ol><br></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;section&gt;&lt;br&gt;    &lt;h2&gt;五、回流与重绘&lt;/h2&gt;&lt;br&gt;    &lt;h3&gt;核心点&lt;/h3&gt;&lt;br&gt;    &lt;ul&gt;&lt;br&gt;        &lt;li&gt;理解浏览器重绘与回流的机制&lt;/li&gt;&lt;br&gt;        &lt;li&gt;对于一些经典案例进行分析&lt;/li&gt;&lt;br&gt;    
      
    
    </summary>
    
      <category term="性能" scheme="http://blog.fridolph.top/categories/%E6%80%A7%E8%83%BD/"/>
    
    
      <category term="渲染" scheme="http://blog.fridolph.top/tags/%E6%B8%B2%E6%9F%93/"/>
    
      <category term="回流" scheme="http://blog.fridolph.top/tags/%E5%9B%9E%E6%B5%81/"/>
    
      <category term="重绘" scheme="http://blog.fridolph.top/tags/%E9%87%8D%E7%BB%98/"/>
    
  </entry>
  
  <entry>
    <title>【性能】（四）懒加载与预加载</title>
    <link href="http://blog.fridolph.top/2019/01/30/%E3%80%90%E6%80%A7%E8%83%BD%E3%80%914%E6%87%92%E5%8A%A0%E8%BD%BD%E4%B8%8E%E9%A2%84%E5%8A%A0%E8%BD%BD/"/>
    <id>http://blog.fridolph.top/2019/01/30/【性能】4懒加载与预加载/</id>
    <published>2019-01-30T14:11:24.000Z</published>
    <updated>2024-01-01T06:58:31.277Z</updated>
    
    <content type="html"><![CDATA[<section><br>    <h2>四、懒加载和预加载</h2><br>    <h3>核心点（这里只以图片举例）</h3><br>    <ul><br>        <li>理解懒加载和预加载的原理</li><br>        <li>懒加载与预加载案例</li><br>    <li>懒加载与预加载实战</li><br>    </ul><br></section><section><br>  <h3>什么是懒加载</h3><br>  <ul><br>    <li class="fragment">图片进入可视区之后请求图片资源</li><br>    <li class="fragment">对于电商等图片很多、页面很长的业务场景适用</li><br>    <li class="fragment">减少无效资源的加载</li><br>    <li class="fragment">并发加载的资源过多会阻塞js的加载，影响网站的正常使用</li><br>  </ul><br></section><section><br>  <h3>图片懒加载</h3><br>  <ul><br>    <li class="fragment">需要监听scroll事件，在scroll事件的回调中</li><br>    <li class="fragment">去判断设置的懒加载图片是否进入可视区域</li><br>    <li class="fragment">到可视区通过data-src，将src赋给图片从而发出请求</li><br>  </ul><br></section><section><br>  <h3>什么是预加载</h3><br>  <ul><br>    <li class="fragment">图片等静态资源在使用之前提前请求</li><br>    <li class="fragment">资源使用到时能从缓存中加载，提升用户体验</li><br>    <li class="fragment">页面展示的依赖关系维护</li><br>  </ul><br></section><section><br>  <h3>预加载的几种实践方案</h3><br>  <ul><br>    <li class="fragment">通过设置样式，默认是通过DOM加载的，但不显示</li><br>    <li class="fragment">使用Image对象，并设置src，这样脚本运行便会加载，动态添加到需要的DOM中即可</li><br>    <li class="fragment">通过XHR加载（可能会有跨域问题）</li><br>  </ul><br></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;section&gt;&lt;br&gt;    &lt;h2&gt;四、懒加载和预加载&lt;/h2&gt;&lt;br&gt;    &lt;h3&gt;核心点（这里只以图片举例）&lt;/h3&gt;&lt;br&gt;    &lt;ul&gt;&lt;br&gt;        &lt;li&gt;理解懒加载和预加载的原理&lt;/li&gt;&lt;br&gt;        &lt;li&gt;懒加载与预加载案例&lt;/li&gt;
      
    
    </summary>
    
      <category term="性能" scheme="http://blog.fridolph.top/categories/%E6%80%A7%E8%83%BD/"/>
    
    
      <category term="懒加载" scheme="http://blog.fridolph.top/tags/%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="预加载" scheme="http://blog.fridolph.top/tags/%E9%A2%84%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>【性能】（三）JS加载与执行</title>
    <link href="http://blog.fridolph.top/2019/01/27/%E3%80%90%E6%80%A7%E8%83%BD%E3%80%913JS%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C/"/>
    <id>http://blog.fridolph.top/2019/01/27/【性能】3JS加载与执行/</id>
    <published>2019-01-27T13:17:52.000Z</published>
    <updated>2024-01-01T07:00:03.121Z</updated>
    
    <content type="html"><![CDATA[<section><br>    <h2>三、JS脚本加载与执行</h2><br>    <h3>核心点</h3><br>    <ul><br>        <li>理解浏览器端html、css、js的加载过程</li><br>        <li>css、js加载过程中的优化点</li><br>    <li>深入理解和学习JS相关优化点</li><br>    </ul><br></section><section><br>    <h3>网站在浏览器端是如何进行渲染的？</h3><br>    <ul><br>    <li class="fragment">1. 通过HTTP请求拿回的html文件，读取html</li><br>    <li class="fragment">2. 字节流(服务器端) -&gt; 字符流(浏览器端) -&gt; 语法分析 拿到相应 token 添加到DOM树</li><br>    <li class="fragment">3. （html -&gt; DOM树）link方式 并发 同时css -&gt; CSSOM树)</li><br>    <li class="fragment">4. V8引擎解析JavaScript(阻塞)</li><br>    <li class="fragment">5. Render Tree (DOM CSSOM都准备好才做这步)</li><br>    <li class="fragment">6. 回流 reflow 重绘 repaint</li><br>  </ul><br></section><section><br>  <h3>HTML渲染过程的一些特点</h3><br>  <ul><br>    <li class="fragment">顺序执行、并发加载</li><br>    <li class="fragment">是否阻塞</li><br>    <li class="fragment">依赖关系</li><br>    <li class="fragment">引入方式</li><br>  </ul><br></section><section><br>  <h4>顺序执行、并发加载</h4><br>  <ul><br>    <li class="fragment">词法分析 - token分析从上到下，从而html是从上到下解析</li><br>    <li class="fragment">并发加载 - html中引入的外部资源是并发加载的</li><br>    <li class="fragment">并发上限 - 根据浏览器不同 一般来说HTTP1.1下是6个</li><br>  </ul><br></section><section><br>  <h4>CSS阻塞</h4><br>  <ul><br>    <li class="fragment">css加载会阻塞页面的渲染  -&gt; css文件在head标签中通过link引入</li><br>    <li class="fragment">css阻塞js的执行 -&gt;  在加载css时后续js的执行是会被阻塞的</li><br>    <li class="fragment">css不阻塞外部脚本的加载 （阻塞执行js而不阻塞加载js）</li><br>  </ul><br></section><section><br>  <h4>js阻塞</h4><br>  <ul><br>    <li class="fragment">直接引入的js阻塞页面的渲染</li><br>    <li class="fragment">js的执行不阻塞资源的加载</li><br>    <li class="fragment">js顺序执行，阻塞后续js逻辑的执行</li><br>  </ul><br></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;section&gt;&lt;br&gt;    &lt;h2&gt;三、JS脚本加载与执行&lt;/h2&gt;&lt;br&gt;    &lt;h3&gt;核心点&lt;/h3&gt;&lt;br&gt;    &lt;ul&gt;&lt;br&gt;        &lt;li&gt;理解浏览器端html、css、js的加载过程&lt;/li&gt;&lt;br&gt;        &lt;li&gt;css、js加载过程中的
      
    
    </summary>
    
      <category term="性能" scheme="http://blog.fridolph.top/categories/%E6%80%A7%E8%83%BD/"/>
    
    
      <category term="js" scheme="http://blog.fridolph.top/tags/js/"/>
    
      <category term="渲染" scheme="http://blog.fridolph.top/tags/%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>【性能】（二）图片优化相关</title>
    <link href="http://blog.fridolph.top/2019/01/22/%E3%80%90%E6%80%A7%E8%83%BD%E3%80%912%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/"/>
    <id>http://blog.fridolph.top/2019/01/22/【性能】2图片优化相关/</id>
    <published>2019-01-22T11:17:52.000Z</published>
    <updated>2024-01-01T06:57:56.087Z</updated>
    
    <content type="html"><![CDATA[<section><br>    <h2>二、图片相关知识与优化</h2><br>    <h3>核心点</h3><br>    <ul><br>        <li>超过一半的流量和时间都用来下载图片</li><br>        <li>图片优化效果明显将大大提高网站性能</li><br>    </ul><br></section><section><br>    <h3>有损压缩，一张JPG图片的解析过程</h3><br>    <p class="fragment">Raw Image Data -&gt; Color Transform -&gt; Down sampling -&gt; Forward DCT -&gt; Quantization -&gt; Encoding</p><br>    <hr><br>    <p class="fragment">源数据 -&gt; 颜色转换 -&gt; 颜色采样（区分高频低频颜色变化） -&gt; 对高频颜色进行压缩DCT -&gt; 质量控制 -&gt; 编码</p><br></section><section><br>    <h3>不同格式图片常用的业务场景</h3><br>    <ul><br>        <li class="fragment">1. jpg有损压缩，压缩率高，不支持透明。用于大部分不需要透明图片的业务场景</li><br>        <li class="fragment">2. png支持透明，浏览器兼容性好。用于大部分需要透明图片的业务场景</li><br>        <li class="fragment">3. webp压缩程度更好，在ios webview有兼容性问题。适用所有高版安卓</li><br>        <li class="fragment">4. svg矢量图，代码内嵌，相对较小，图片样式相对简单的场景</li><br>    </ul><br></section><section><br>    <h3>图片压缩</h3><br>    <ul><br>        <li class="fragment">1. CSS雪碧图 减少HTTP请求数（至少1次）整张图较大时也会存在加载慢的现象</li><br>        <li class="fragment">2. Image inline base64 （将图片的内容内嵌到html中 -&gt; 减少网站的HTTP请求数(0)）</li><br>        <li class="fragment">3. 在安卓下使用webp</li><br>        <li class="fragment">webp 优势在于更好的图像压缩压缩算法带来的更小图片体积。同时具备有损和无损压缩模式、alpha透明及动画特性，在jpg和png上转化效果都很优秀、统一和稳定</li><br>    </ul><br></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;section&gt;&lt;br&gt;    &lt;h2&gt;二、图片相关知识与优化&lt;/h2&gt;&lt;br&gt;    &lt;h3&gt;核心点&lt;/h3&gt;&lt;br&gt;    &lt;ul&gt;&lt;br&gt;        &lt;li&gt;超过一半的流量和时间都用来下载图片&lt;/li&gt;&lt;br&gt;        &lt;li&gt;图片优化效果明显将大大提高网站性能
      
    
    </summary>
    
      <category term="性能" scheme="http://blog.fridolph.top/categories/%E6%80%A7%E8%83%BD/"/>
    
    
      <category term="图片" scheme="http://blog.fridolph.top/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>【性能】（一）资源压缩与合并</title>
    <link href="http://blog.fridolph.top/2019/01/20/%E3%80%90%E6%80%A7%E8%83%BD%E3%80%911%E8%B5%84%E6%BA%90%E5%8E%8B%E7%BC%A9%E4%B8%8E%E5%90%88%E5%B9%B6/"/>
    <id>http://blog.fridolph.top/2019/01/20/【性能】1资源压缩与合并/</id>
    <published>2019-01-20T05:17:52.000Z</published>
    <updated>2024-01-01T06:58:02.678Z</updated>
    
    <content type="html"><![CDATA[<section><br>    <h2>一、资源的合并与压缩</h2><br>    <h3>核心点</h3><br>    <ul><br>        <li>减少HTTP数量请求</li><br>        <li>减少请求资源大小</li><br>    </ul><br></section><section><br>    <h3>浏览器的一个请求从发送到返回经历了什么</h3><br>    <p class="fragment">1. 浏览器输入url -&gt; 回车</p><br>    <p class="fragment">2. 解析 domain -&gt; DNS服务器 -&gt; 返回ip</p><br>    <p class="fragment">3. IP地址打在协议中 -&gt; 发送到网络 (经过局域网 -&gt; 交换机 -&gt; 路由器 -&gt; 主干网络 -&gt; 服务端)</p><br>    <p class="fragment">4. 服务端返回资源（GET请求）浏览器进行渲染</p><br>    <p class="fragment">5. render -&gt; DOM -&gt; CSSOM -&gt; 下载并加载css、js、img等资源 -&gt; reflow &amp; repaint</p><br></section><section><br>    <h3>针对以上，可作的优化工作</h3><br>    <p class="fragment">1. DNS 资源缓存 -&gt; 减少初次请求数及时间</p><br>    <p class="fragment">2. 网络请求 CDN -&gt; 解决网络高并发和缓存（不带主站cookie）</p><br>    <p class="fragment">3. 接口优化 -&gt; 浏览器的缓存策略 (相同资源、接口在浏览器读取缓存)</p><br></section><section><br>    <h3>减少HTTP请求大小和HTTP请求次数</h3><br>    <p><b>浏览器端渲染</b> vue、react 走框架代码渲染数据，而不是直出HTML（该过程对首屏有损耗，不利于性能）</p><br>    <p class="fragment">服务端渲染 SSR，整个HTML直出到浏览器端</p><br></section><section><br>    <h3>请求过程中一些潜在的性能优化点</h3><br>    <ul><br>        <li class="fragment">DNS是否可以通过缓存减少DNS查询时间？</li><br>        <li class="fragment">网络请求的过程中走最近的网络环境？</li><br>        <li class="fragment">相同的静态资源是否可以缓存？</li><br>        <li class="fragment">能否减少请求HTTP请求大小</li><br>        <li class="fragment">减少HTTP请求数</li><br>        <li class="fragment">服务端渲染</li><br>    </ul><br>    <hr><br>    <h3 class="fragment">深入理解 HTTP请求过程 是前端性能优化的核心</h3><br></section><section><br>    <h3>通过案例学习，理解以下优化点</h3><br>    <hr><br>    <ul><br>        <li>HTML文件压缩</li><br>        <li>CSS压缩</li><br>        <li>JS的压缩和混乱</li><br>        <li>文件合并</li><br>        <li>图片压缩并使用CDN</li><br>        <li>开启Gzip</li><br>    </ul><br></section><section><br>    <h3>HTML压缩</h3><br>    <p style="text-align: left">HTML代码压缩就是压缩这些在文本文件中有意义，但是在HTML中不显示的字符，包括<code>空格、制表符、换行符</code>等，还有一些其他意义的字符，如<code>HTML注释</code>也可以被压缩</p><br>    <hr><br>    <h3>如何进行HTML压缩</h3><br>    <ul><br>        <li>使用在线网站进行压缩</li><br>        <li>Node.js提供了<code>html-minifier</code>工具(Node.js的压缩方案： 1构建阶段 2服务端)</li><br>        <li>后端模版引擎渲染压缩</li><br>    </ul><br></section><section><br>    <h3>CSS压缩</h3><br>    <ul><br>        <li>无效代码删除</li><br>        <li>css语义合并</li><br>    </ul><br>    <hr><br>    <h3>如何进行css压缩</h3><br>    <ul><br>        <li>使用在线网站进行压缩</li><br>        <li>使用<code>html-minifier</code>对html中的css进行压缩</li><br>        <li>配置postcss等进行压缩</li><br>    </ul><br></section><section><br>    <h3>JS压缩与混乱</h3><br>    <ul><br>        <li>无效字符的删除</li><br>        <li>剔除注释</li><br>        <li>代码语义的缩减和优化</li><br>        <li>代码保护</li><br>    </ul><br>    <hr><br>    <h3>如何进行JS压缩</h3><br>    <ul><br>        <li>使用在线网站进行压缩</li><br>        <li>使用 uglifyjs2 对js代码进行压缩</li><br>        <li>在webpack、gulp中配置js压缩</li><br>    </ul><br></section><section><br>    <h3>文件合并</h3><br>    <p>不合并带来的弊端：</p><br>    <ul><br>        <li>文件与文件之间有插入的上行请求，增加了 N-1 个网络延迟</li><br>        <li>受丢包问题影响更严重</li><br>        <li>经过代理服务器时可能会被断开</li><br>    </ul><br>    <p>合并所带来的问题思考：1.首屏渲染问题  2.缓存失效问题</p><br></section><section><br>    <h3>如何进行文件合并</h3><br>    <ul><br>        <li>使用在线网站进行文件合并</li><br>        <li>使用Node.js实现文件合并(webpack、gulp)</li><br>    </ul><br></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;section&gt;&lt;br&gt;    &lt;h2&gt;一、资源的合并与压缩&lt;/h2&gt;&lt;br&gt;    &lt;h3&gt;核心点&lt;/h3&gt;&lt;br&gt;    &lt;ul&gt;&lt;br&gt;        &lt;li&gt;减少HTTP数量请求&lt;/li&gt;&lt;br&gt;        &lt;li&gt;减少请求资源大小&lt;/li&gt;&lt;br&gt;    &lt;/ul
      
    
    </summary>
    
      <category term="性能" scheme="http://blog.fridolph.top/categories/%E6%80%A7%E8%83%BD/"/>
    
    
      <category term="http" scheme="http://blog.fridolph.top/tags/http/"/>
    
      <category term="压缩" scheme="http://blog.fridolph.top/tags/%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>【Node】学习stream模块</title>
    <link href="http://blog.fridolph.top/2018/11/15/%E3%80%90Node%E3%80%91%E5%AD%A6%E4%B9%A0stream%E6%A8%A1%E5%9D%97/"/>
    <id>http://blog.fridolph.top/2018/11/15/【Node】学习stream模块/</id>
    <published>2018-11-15T14:17:52.000Z</published>
    <updated>2024-01-01T03:34:15.604Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>正好读到了相关的文章推送，正巧也把之前看到的和弄了一小半的资料整理一下。- - node的学习又再此开启</p></blockquote><h1 id="stream的基本概念和常用API概述"><a href="#stream的基本概念和常用API概述" class="headerlink" title="stream的基本概念和常用API概述"></a>stream的基本概念和常用API概述</h1><p>让数据流动起来。数据从原来的source流向dest，要像水一样，慢慢的一点一点通过一个管道流过去。stream并不是node.js独有的概念，而是一个操作系统最基本的操作方式，只不过node.js有API支持这种操作方式。linux命令的<code>|</code>就是stream，因此所有server端语言都应该实现stream的API。</p><a id="more"></a><h2 id="为何要使用stream"><a href="#为何要使用stream" class="headerlink" title="为何要使用stream"></a>为何要使用stream</h2><p>例子，在线播放视频。一点一点从服务端将视频流动到本地播放器，一边流动一边播放，直到播放完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>)</span><br><span class="line">  fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    res.end(data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">8000</span>)</span><br></pre></td></tr></table></figure><p>这段node.js代码跑起来会读取文件，语法上没问题，但如果data.txt文件非常大，在响应大量用户的并发请求时，程序可能会消耗大量的内存，这样很可能会造成用户连接缓慢的问题。而且，如果并发请求过大，服务器内存开销也很大。</p><p>要解决该问题很简单，用stream改造一下。即不是把全部文件读取了再返回，而是一边读取一边返回，一点点地把数据流动到客户端。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>)</span><br><span class="line">  <span class="keyword">var</span> stream = fs.createReadStream(fileName)</span><br><span class="line">  stream.pipe(res)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">8000</span>)</span><br></pre></td></tr></table></figure><p>小结一下，之所以用stream，是因为一次性读取、操作大文件，内存和网络是吃不消的，因此要让数据流动起来，一点一点地进行操作。这符合分而治之的思想。</p><h2 id="stream流转的过程"><a href="#stream流转的过程" class="headerlink" title="stream流转的过程"></a>stream流转的过程</h2><p>从管道换水的例子可看出，stream包括source, dest还有中间的管道，下面将通过这三方面介绍stream的过程。其中比较关键的api有：</p><ul><li>data事件，用来监听stream数据的输入</li><li>end事件，用来监听stream数据输入完成</li><li>fs.createReadStream方法，返回一个文件读取的stream对象</li><li>fs.createWriteStream方法， 返回一个文件读取的stream对象</li><li>pipe方法，用来做数据流转</li></ul><h3 id="source-——-从哪里来"><a href="#source-——-从哪里来" class="headerlink" title="source —— 从哪里来"></a>source —— 从哪里来</h3><p>stream常见的来源主要有三种：</p><ul><li>从控制台输入</li><li>http请求中的request</li><li>读取文件</li></ul><p>运行如下代码，然后从控制台输入任何内容，都会被data事件监听到，process.stdin就是一个stream对象。<code>注意data就是stream用来监听数据传入的一个自定义函数</code>，后续会大量用到该方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.stdin.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'stream by stdin'</span>, chunk.toString())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>http请求中的request输入可以参考如下代码片段。即客户端发起http请求，服务端可以通过这种方式（用到了data事件监听）。这种http请求一般是一个post请求，上传数据。注意，end用来监听stream数据传输完毕，一般和data共用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 一点一点 接受内容</span></span><br><span class="line">  data += chunk.toString()</span><br><span class="line">&#125;)</span><br><span class="line">res.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// end表示数据接受完成</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>读取文件用 fs.createReadStream(…) 可以返回一个读取文件的stream对象，该对象可以监听data和end事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> readStream = fs.createReadStream(<span class="string">'./file1.txt'</span>)</span><br><span class="line"><span class="keyword">var</span> length = <span class="number">0</span></span><br><span class="line">readStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">  length += chunk.toString().length</span><br><span class="line">&#125;)</span><br><span class="line">readStream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(length)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>以上source三种代码示例有一个共同特点，就是对stream对象可以监听data和end事件。nodejs监听自定义事件要使用.on方法，例如 process.stdin.on(‘data’, …) ，能很直观地监听到stream数据的传入和结束。</p><h3 id="dest-——-到哪里去"><a href="#dest-——-到哪里去" class="headerlink" title="dest —— 到哪里去"></a>dest —— 到哪里去</h3><p>stream常见的输出方式主要有三种：</p><ul><li>输出到控制台</li><li>http请求中的response</li><li>写入文件</li></ul><p>如果让控制台输入这个source直接通过管道连接到控制台输入，即让数据从输入直接流向输出，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.stdin.pipe(process.stdout)</span><br></pre></td></tr></table></figure><p>nodejs处理http请求时会用到req和res，其实这两者都是stream对象。其中，req是source，res是dest。所以stream方式读取文件然后直接返回http请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stream = fs.createReadStream(fileName)</span><br><span class="line">stream.pipe(res)</span><br></pre></td></tr></table></figure><p>读取文件可以用stream，写入文件也可以用stream，其中 fs.createWriteStream(…) 会返回一个写入文件的stream对象，即dest。这段代码，就是将一个文件中的内容，一点一点地流动到另外的文件中，完成复制功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> readStream = fs.createReadStream(<span class="string">'./file1.txt'</span>)</span><br><span class="line"><span class="keyword">var</span> writeStrea = fs.createWriteStream(<span class="string">'./file2.txt'</span>)</span><br><span class="line">readStream.pipe(writeStream)</span><br></pre></td></tr></table></figure><h3 id="stream常见使用场景"><a href="#stream常见使用场景" class="headerlink" title="stream常见使用场景"></a>stream常见使用场景</h3><p>stream常见的使用场景是http请求和文件操作。 总结来看，http请求和文件操作都属于IO，即stream主要的应用场景是处理IO，这又回到了stream的本质——由于一次性IO操作过大，硬件开销太多，影响软件运行效率，因此将IO分批分段操作，让数据一点一点地流动起来，直到操作完成。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本章主要介绍了stream的基本概念和常用API</p><ul><li>stream的基本概念，即 source -&gt; 管道 -&gt; dest</li><li>为何要用stream —— 一次性操作IO，内存和网络开销过大</li><li>source pipe dest各部分常用API</li><li>stream的常见应用场景——IO操作</li></ul><hr><h2 id="node-js实现http请求"><a href="#node-js实现http请求" class="headerlink" title="node.js实现http请求"></a>node.js实现http请求</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>)</span><br><span class="line">  fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    res.end(data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">8000</span>)</span><br></pre></td></tr></table></figure><h2 id="get请求和response"><a href="#get请求和response" class="headerlink" title="get请求和response"></a>get请求和response</h2><p>通过req.method可获取请求方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> method = req.method</span><br><span class="line">  <span class="keyword">if</span> (method === <span class="string">'GET'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>)</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      res.end(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">8000</span>)</span><br></pre></td></tr></table></figure><h3 id="response和stream"><a href="#response和stream" class="headerlink" title="response和stream"></a>response和stream</h3><p>response常用的API有send、end等，如上面代码中的<code>res.end(data)</code>，但是response也是一个stream对象。大家再次回顾一开始的管道换水的图，以及source.pipe(dest)模型，response就是一个dest</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> method = req.method</span><br><span class="line">  <span class="keyword">if</span> (method === <span class="string">'GET'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>)</span><br><span class="line">    <span class="keyword">var</span> stream = fs.createReadStream(fileName)</span><br><span class="line">    stream.pipe(res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8000</span>)</span><br></pre></td></tr></table></figure><h3 id="使用stream对性能的提升"><a href="#使用stream对性能的提升" class="headerlink" title="使用stream对性能的提升"></a>使用stream对性能的提升</h3><p>略</p><p>###　实际应用</p><p>对response使用stream特性能提高性能。因此，在nodejs中如果要返回的数据是经过IO操作得来的，例如上面例子中读取文件内容，可以直接使用stream.pipe(res)这种方式，而不再使用res.end(data)了。</p><p>这种应用的实例很多，主要有两种场景：</p><ul><li>使用node.js作为服务代理，即客户端通过node.js服务作为跳板去请求其他服务，返回请求的内容</li><li>使用node.js作为静态文件服务器，直接返回静态文件</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本节主要讲解了node.js如何处理http的get请求，以及如何对response使用stream特性，并做了压力测试证明可以提高性能。</p><h2 id="在http-post请求中使用stream"><a href="#在http-post请求中使用stream" class="headerlink" title="在http post请求中使用stream"></a>在http post请求中使用stream</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> method = req.method</span><br><span class="line">  <span class="keyword">if</span> (method === <span class="string">'POST'</span>) &#123;</span><br><span class="line">    req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 接受到部分数据</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'chunk'</span>, chunk.toString().length)</span><br><span class="line">    &#125;)</span><br><span class="line">    req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">      res.end(<span class="string">'ok'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">8000</span>)</span><br></pre></td></tr></table></figure><p>post请求发送数据量若很大， res.on(‘data’, …) 要分多次才能把数据接受完毕</p><p>小结一下，request和response一样，本身也是一个stream对象，可以用stream的特性，那肯定也能提高性能。两者的区别在于，request是source类型，是stream的源头，而response是dest类型，是stream的目的地。</p><p>再举个例子，如果要把request请求的数据直接response，那么最快的方式就是res.pipe(res)</p><h3 id="使用stream对性能的提升-1"><a href="#使用stream对性能的提升-1" class="headerlink" title="使用stream对性能的提升"></a>使用stream对性能的提升</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> method = req.method</span><br><span class="line">  <span class="keyword">if</span> (method === <span class="string">'POST'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> dataStr = <span class="string">''</span></span><br><span class="line">    req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> chunkStr = chunk.toString()</span><br><span class="line">      dataStr += chunkStr</span><br><span class="line">    &#125;)</span><br><span class="line">    res.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>)</span><br><span class="line">      fs.writeFile(fileName, dataStr)</span><br><span class="line">      res.end(<span class="string">'ok'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8000</span>)</span><br></pre></td></tr></table></figure><p>用stream改良后如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> method = req.method</span><br><span class="line">  <span class="keyword">if</span> (method === <span class="string">'POST'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> dataStr = <span class="string">''</span></span><br><span class="line">    req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> chunkStr = chunk.toString()</span><br><span class="line">      dataStr += chunkStr</span><br><span class="line">    &#125;)</span><br><span class="line">    res.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>)</span><br><span class="line">      <span class="keyword">var</span> writeStream = fs.createWriteStream(fileName)</span><br><span class="line">      res.pipe(writeStream)</span><br><span class="line">      req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        res.end(<span class="string">'ok'</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>和get请求使用stream场景类似，post请求使用stream的场景，主要是用于将接受的数据直接进行IO操作，例如：</p><ul><li>将接收的数据直接存储为文件</li><li>将接收的数据直接post给其他的web server</li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>介绍了stream在http请求中的应用和性能提升，IO操作不仅仅包括网络IO，还包括文件IO，下一节讲解stream在文件操作中的使用，以及性能提升。</p><hr><h2 id="node-js读写文件"><a href="#node-js读写文件" class="headerlink" title="node.js读写文件"></a>node.js读写文件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>)</span><br><span class="line"><span class="comment">// 读文件</span></span><br><span class="line">fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span></span><br><span class="line">  <span class="built_in">console</span>.log(data.toString())</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 写文件</span></span><br><span class="line">fs.writeFile(fileName, <span class="string">'xxx'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'写入成功'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>根据以上读写操作，可以做一个简单的文件拷贝程序，将data.txt中的内容拷贝到data-bak.txt 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读文件</span></span><br><span class="line"><span class="keyword">var</span> fileName1 = path.resolve(__dirname, <span class="string">'data.txt'</span>)</span><br><span class="line">fs.readFile(fileName1, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">var</span> dataStr = data.toString()</span><br><span class="line">  <span class="comment">// 写入文件</span></span><br><span class="line">  <span class="keyword">var</span> fileName2 = path.resolve(__dirname, <span class="string">'data-bak.txt'</span>)</span><br><span class="line">  fs.writeFile(fileName2, dataStr, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'拷贝文件成功'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="使用stream读写文件"><a href="#使用stream读写文件" class="headerlink" title="使用stream读写文件"></a>使用stream读写文件</h3><ul><li>使用 fs.cretaeReadStream(filename) 来创建读取文件的stream对象</li><li>使用 fs.createWriteStream(filename) 来创建写入文件的stream对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> filename1 = path.resolve(__dirname, <span class="string">'data.txt'</span>)</span><br><span class="line"><span class="keyword">var</span> filename2 = path.resolve(__dirname, <span class="string">'data-bak.txt'</span>)</span><br><span class="line"><span class="keyword">var</span> readStream = fs.createReadStream(filename1)</span><br><span class="line"><span class="keyword">var</span> writeStream = fs.createWriteStream(filename2)</span><br><span class="line">readStream.pipe(writeStream)</span><br><span class="line">readStream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'拷贝完成'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="使用stream带来的性能提升"><a href="#使用stream带来的性能提升" class="headerlink" title="使用stream带来的性能提升"></a>使用stream带来的性能提升</h3><p>略</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>所有执行文件操作的场景，都应该尝试使用stream，例如文件的读写、拷贝、解压缩、格式转换等。除非是体积小且读写次数少，性能上可忽略。</p><hr><p>原生的stream对“行”无能为力，它只是把文件当作一个数据流，简单粗暴地流动。很多文件格式都是分行的，例如csv文件、日志文件等</p><p>node.js提供了按行读取API——readline，它本质上也是stream，只不过是以“行”作为数据流动的单位</p><h2 id="readline的使用"><a href="#readline的使用" class="headerlink" title="readline的使用"></a>readline的使用</h2><p>相比于stream的data和end自定义事件，readline需要监听line和close两个自定义事件。readline的基本使用示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> path = requrie(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> readline = <span class="built_in">require</span>(<span class="string">'readline'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'readline-data.txt'</span>)</span><br><span class="line"><span class="comment">// 创建读取文件的stream对象</span></span><br><span class="line"><span class="keyword">var</span> readStream = fs.createReadStream(fileName)</span><br><span class="line"><span class="comment">// 创建readline对象</span></span><br><span class="line"><span class="keyword">var</span> rl = readline.createInterface(&#123;</span><br><span class="line">  <span class="comment">// 输入，依赖于stream对象</span></span><br><span class="line">  input: readStream</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 监听逐行读取的内容</span></span><br><span class="line">rl.on(<span class="string">'line'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">lineData</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'lineData: '</span>, lineData)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 监听读取完成</span></span><br><span class="line">rl.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'readline end'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上代码，需要先根据文件名，创建读取文件的stream对象，然后传入并生成一个readline对象，然后通过line事件监听逐行读取，通过close事件监听读取完成。</p><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>对于处理按行为单位的文件，如日志文件，使用readline是最佳选择。下面是一个实际例子，用来记录访问数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line"><span class="comment">// 监听逐行读取的内容</span></span><br><span class="line">rl.on(<span class="string">'line'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">lineData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lineData.indexOf(<span class="string">'2018-10-30 14:00'</span>) &gt;= <span class="number">0</span> &amp;&amp; lineData.indexOf(<span class="string">'user.html'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    num++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 监听读取完成</span></span><br><span class="line">rl.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'num: '</span>, num)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>最后，将这个示例所用的代码贴到下面，供学习参考：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> memeye = <span class="built_in">require</span>(<span class="string">'memeye'</span>)</span><br><span class="line"><span class="keyword">var</span> readline = <span class="built_in">require</span>(<span class="string">'readline'</span>)</span><br><span class="line"></span><br><span class="line">memeye()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doReadLine</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'readline-data.txt'</span>)</span><br><span class="line">  <span class="keyword">var</span> readStream = fs.createReadStream(fileName)</span><br><span class="line">  <span class="keyword">var</span> rl = readline.createInterface(&#123;</span><br><span class="line">    input: readStream</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line">  rl.on(<span class="string">'line'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">lineData</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lineData.indexOf(<span class="string">'2018-10-30 14:00'</span>) &gt;= <span class="number">0</span> &amp;&amp; lineData.indexOf(<span class="string">'user.html'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      num++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 监听读取完成</span></span><br><span class="line">  rl.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'num: '</span>, num)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(doReadLine, <span class="number">5000</span>)</span><br></pre></td></tr></table></figure><hr><p>stream就是数据一点一点地流动起来，那么每次流动的数据是什么呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readStream = fs.createReadStream(<span class="string">'./file.txt'</span>)</span><br><span class="line">readStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>冯诺依曼结构，其核心内容之一就是：计算机使用二进制形式存储计算。</p><p>计算机内存由若干个存储单元组成，每个存储单元只能存储0或1（因为内存是硬件，计算机硬件本质上就是一个一个的电子元件，只能识别充电和放电的状态，充电代表1，放电代表0），即二进制单元（bit）。但是这一个单元所能存储的信息太少，因此约定将8个二进制单元为一个基本存储单元，叫做字节（byte）。一个字节所能存储的最大整数就是(2^8 = 256)，也正好是16^2，因此也常常使用两位的16进制数代表一个字节。例如css常见的颜色值就是6位16进制数字，它占用3个字节的空间。</p><p>二进制是计算机最底层的数据格式，也是一种通用格式。计算机中的任何数据格式，字符串、数字、视频、音频、程序、网络包等，在最底层都是用二进制来进行存储的。这些高级格式和二进制之间，都可通过固定的编码格式进行相互转换。例如，C语言中int32类型的十进制数，就占用32bit即4byte。总之，计算机底层存储的数据都是二进制格式，各种高级类型都有对应的编码规则，和二进制进行相互转化。</p><h2 id="nodejs表示二进制"><a href="#nodejs表示二进制" class="headerlink" title="nodejs表示二进制"></a>nodejs表示二进制</h2><p>Buffer就是nodejs中二进制的表述形式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'学习nodejs stream'</span></span><br><span class="line"><span class="keyword">var</span> buf = Buffer.from(str, <span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure><p>以上代码，先通过 Buffer.from 将一段字符串转化为二进制形式，其中utf-8是一个编码规则。二进制打印出来之后是一个类数组的对象，每个元素都是两位的16进制数字，即代表一个byte，打印出来的buf一共有20byte。即根据utf-8的编码规则，这段字符串需要20byte进行存储，最后再通过utf-8规则将二进制转换为字符串并打印出来</p><h3 id="流动的数据是二进制格式"><a href="#流动的数据是二进制格式" class="headerlink" title="流动的数据是二进制格式"></a>流动的数据是二进制格式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readStrem = fs.createReadStream(<span class="string">'./file.txt'</span>)</span><br><span class="line">readStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(chunk <span class="keyword">instanceof</span> Buffer)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'chunk: '</span>, chunk)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看到stream中流动的数据就是Buffer类型。因此，在使用stream chunk时，需要将这些二进制数据转换为相应的格式。例如之前讲解post请求是，从request中接收数据就是这样。再回归一下之前的代码，就能明白了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataStr = <span class="string">''</span></span><br><span class="line">req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将二进制数据先转化为字符串</span></span><br><span class="line">  <span class="keyword">var</span> chunkStr = chunk.toString()</span><br><span class="line">  dataStr += chunkStr</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>stream中为何要“流动”二进制格式的数据呢？</p><p>为了优化IO操作。无论是文件IO还是网络IO，其中包含的数据格式是未知的，如字符串、音频、视频、网络包等。即便这些字符串，其编码规则也是未知的，如ASC编码、utf-8编码。再这么多未可知的情况下，只能是以不变应万变，直接用最通过的二进制格式，谁都能认识，且二进制格式进行流动和传输，效率是最高的。</p><h3 id="Buffer带来的性能提升"><a href="#Buffer带来的性能提升" class="headerlink" title="Buffer带来的性能提升"></a>Buffer带来的性能提升</h3><p>略</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li>二进制和字节的基本认识</li><li>node.js中Buffer表示二进制</li><li>stream中的chunk是二进制格式，以及和字符串格式的转换</li><li>二进制格式在http请求中的性能提升</li></ul><hr><h2 id="stream常用类型总结"><a href="#stream常用类型总结" class="headerlink" title="stream常用类型总结"></a>stream常用类型总结</h2><p>再次回顾这张图 source通过一个管道流向了dest，如下图：</p><p>这里的source可能是http请求中的request，也可能是读取文件的stream对象，也可能是process.stdin；这里的dest可能是请求中的response，也可能是写入文件的stream对象，也可能是process.stdout；这里的管道就是pipe函数。</p><p>先不管pipe函数。source和dest完全就是两个不同的类型，一个是读取数据的，叫做readable stream，一个是写入数据的，叫作Writeable stream。除了这两种类型之外，还有一种类型叫作duplex stream（双工流），即有读取又有写入能力。示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>)</span><br><span class="line"><span class="keyword">var</span> readStream = fs.createReadStream(<span class="string">'./file.txt'</span>)</span><br><span class="line"><span class="keyword">var</span> writeStream = fs.createWriteStream(<span class="string">'./file.txt'</span>)</span><br><span class="line">readStream.pipe(zlib.createGzip()).pipe(writeStream)</span><br></pre></td></tr></table></figure><h3 id="readable-stream"><a href="#readable-stream" class="headerlink" title="readable stream"></a>readable stream</h3><p>http请求中的request和读取文件的stream对象都是readable stream。它有两种常用操作方式，第一种是直接将数据pipe到一个Writeable stream</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>)</span><br><span class="line"><span class="keyword">var</span> stream = fs.createReadStream(fileName)</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">stream.pipe(res)</span><br></pre></td></tr></table></figure><p>第二种是通过监听on end自定义事件来获取数据再手动处理，例如之前讲解post请求时的代码示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataStr = <span class="string">''</span></span><br><span class="line">req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 接收到数据先存储起来</span></span><br><span class="line">  <span class="keyword">var</span> chunkStr = chunk.toString()</span><br><span class="line">  dataStr += chunkStr</span><br><span class="line">&#125;)</span><br><span class="line">req.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 接收完数据将数据写入文件</span></span><br><span class="line">  <span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'post.txt'</span>)</span><br><span class="line">  fs.writeFile(fileName, dataStr)</span><br><span class="line">  res.end(<span class="string">'OK'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上说的两个例子，都是已经分装好的readable stream，那么它本来的面目是怎样的？如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Readable = <span class="built_in">require</span>(<span class="string">'stream'</span>).Readable</span><br><span class="line"><span class="comment">// 构造一个readable stream并往里添数据</span></span><br><span class="line"><span class="keyword">var</span> rs = <span class="keyword">new</span> Readable</span><br><span class="line">rs.push(<span class="string">'learn'</span>)</span><br><span class="line">rs.push(<span class="string">'nodejs'</span>)</span><br><span class="line">rs.push(<span class="string">'stream'</span>)</span><br><span class="line">rs.push(<span class="literal">null</span>)</span><br><span class="line"><span class="comment">// pipe到一个Writeable stream</span></span><br><span class="line">rs.pipe(process.stdout)</span><br></pre></td></tr></table></figure><p>从上代码可看出，nodejs提供了readable stream的构造函数，可以new出一个新的readable stream对象。然后通过push函数往里灌入完成，即可输入了。最后pipe到了一个Writeable stream</p><h3 id="Writeable-stream"><a href="#Writeable-stream" class="headerlink" title="Writeable stream"></a>Writeable stream</h3><p>根据之前的分析，http请求中的response和写入文件的stream对象都是Writeable stream，它可以作为参数传入pipe函数，以读取上游的数据。例如之前讲解文件操作时拷贝文件的代码示例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'post.txt'</span>)</span><br><span class="line"><span class="keyword">var</span> writeStream = fs.createWriteStream(fileName)</span><br><span class="line">res.pipe(writeStream)</span><br></pre></td></tr></table></figure><p>以上代码中 writeStream 是已经封装好了的 Writeable stream ，下面再来看看它的真实面目。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Writeable = <span class="built_in">require</span>(<span class="string">'stream'</span>).Writeable</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ws = Writeable()</span><br><span class="line">ws._write = <span class="function"><span class="keyword">function</span>(<span class="params">chunk, enc, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 输出流动的数据</span></span><br><span class="line">  <span class="built_in">console</span>.log(chunk.toString())</span><br><span class="line">  <span class="comment">// 继续监听下一次输出</span></span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 作为参数传递到pipe函数中</span></span><br><span class="line">process.stdin.pipe(ws)</span><br></pre></td></tr></table></figure><p>根据以上代码得知，nodejs提供了Writeable构造函数可以new一个新的Writeable stream。通过实现它的_write方法即可监听到每次流动的数据，运行next()可继续监听.</p><h3 id="再谈pipe"><a href="#再谈pipe" class="headerlink" title="再谈pipe"></a>再谈pipe</h3><p>之前一直是用<code>source.pipe(dest)</code>这种模式来用pipe的，其实pipe可以链式调用。例如上文演示的duplex stream示例代码<code>readStream.pipe(zlib.createGzip()).pipe(writeStream)</code>，还有之前讲解文件操作最后列举的gulp配置文件~</p><p>之前讲解<code>source.pipe(dest)</code>模式是为了方便理解和使用，现在我们更新一个更严谨的pipe用法：</p><ul><li>调用pipe的对象必须是readable stream或者duplex stream，即具有读取数据的功能，如req.pipe(…)</li><li>传入pipe的参数必须是writeable stream或者duplex stream, 即具有写入数据的功能，如req.pipe(res)</li><li>pipe支持链式调用</li></ul><p>更新了pipe的最新规则，再来看就不会有困惑了。</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>这里主要讲解了stream的常用类型和pipe函数的规则：</p><ul><li>stream的常见类型：readable stream和writeable stream</li><li>readable stream的本质和用法</li><li>writeable stream的本质和用法</li><li>pipe的新规则</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;正好读到了相关的文章推送，正巧也把之前看到的和弄了一小半的资料整理一下。- - node的学习又再此开启&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;stream的基本概念和常用API概述&quot;&gt;&lt;a href=&quot;#stream的基本概念和常用API概述&quot; class=&quot;headerlink&quot; title=&quot;stream的基本概念和常用API概述&quot;&gt;&lt;/a&gt;stream的基本概念和常用API概述&lt;/h1&gt;&lt;p&gt;让数据流动起来。数据从原来的source流向dest，要像水一样，慢慢的一点一点通过一个管道流过去。stream并不是node.js独有的概念，而是一个操作系统最基本的操作方式，只不过node.js有API支持这种操作方式。linux命令的&lt;code&gt;|&lt;/code&gt;就是stream，因此所有server端语言都应该实现stream的API。&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://blog.fridolph.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="node" scheme="http://blog.fridolph.top/tags/node/"/>
    
      <category term="stream" scheme="http://blog.fridolph.top/tags/stream/"/>
    
  </entry>
  
  <entry>
    <title>【学习】cookie、session和token</title>
    <link href="http://blog.fridolph.top/2018/07/28/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91cookie%E3%80%81session%E5%92%8Ctoken/"/>
    <id>http://blog.fridolph.top/2018/07/28/【学习】cookie、session和token/</id>
    <published>2018-07-28T04:18:12.000Z</published>
    <updated>2024-01-01T03:36:46.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cookie定义"><a href="#Cookie定义" class="headerlink" title="Cookie定义"></a>Cookie定义</h2><p>Cookie 是一小段文本信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递。Cookie 包含每次用户访问站点时 Web 应用程序都可以读取的信息。</p><a id="more"></a><p>例如，如果在用户请求站点中的页面时应用程序发送给该用户的不仅仅是一个页面，还有一个包含日期和时间的 Cookie，用户的浏览器在获得页面的同时还获得了该 Cookie，并将它存储在用户硬盘上的某个文件夹中。</p><p>以后，如果该用户再次请求您站点中的页面，当该用户输入 URL 时，浏览器便会在本地硬盘上查找与该 URL 关联的 Cookie。如果该 Cookie 存在，浏览器便将该 Cookie 与页请求一起发送到您的站点。然后，应用程序便可以确定该用户上次访问站点的日期和时间。您可以使用这些信息向用户显示一条消息，也可以检查到期日期。</p><p>Cookie 与网站关联，而不是与特定的页面关联。因此，无论用户请求站点中的哪一个页面，浏览器和服务器都将交换 Cookie 信息。用户访问不同站点时，各个站点都可能会向用户的浏览器发送一个 Cookie；浏览器会分别存储所有 Cookie。</p><p>Cookie 帮助网站存储有关访问者的信息。一般来说，Cookie 是一种保持 Web 应用程序连续性（即执行状态管理）的方法。除短暂的实际交换信息的时间外，浏览器和 Web 服务器间都是断开连接的。对于用户向 Web 服务器发出的每个请求，Web 服务器都会单独处理。但是在很多情况下，Web 服务器在用户请求页时识别出用户会十分有用。例如，购物站点上的 Web 服务器跟踪每位购物者，这样站点就可以管理购物车和其他的用户特定信息。因此，Cookie 可以作为一种名片，提供相关的标识信息帮助应用程序确定如何继续执行。</p><p>使用 Cookie 能够达到多种目的，所有这些目的都是为了帮助网站记住用户。例如，一个实施民意测验的站点可以简单地将 Cookie 作为一个 Boolean 值，用它来指示用户的浏览器是否已参与了投票，这样用户便无法进行第二次投票。要求用户登录的站点则可以通过 Cookie 来记录用户已经登录，这样用户就不必每次都输入凭据。</p><p>分类：一般分为两种形式的Cookie：1.会话型的，2.持久性的。会话型的是浏览器的处理过程中保留的，是暂时性的，当浏览器关闭时则消除了！而持久性的是保存在客户端的硬盘上的，就像论坛的Cookie一样。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：极高的扩展性和可用性</p><p>通过良好的编程，控制保存在cookie中的session对象的大小。<br>通过加密和安全传输技术（SSL），减少cookie被破解的可能性。<br>只在cookie中存放不敏感数据，即使被盗也不会有重大损失。<br>控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。</p><p>缺点：</p><p>Cookie数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。<br>安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。<br>有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。</p><h2 id="Session定义"><a href="#Session定义" class="headerlink" title="Session定义"></a>Session定义</h2><p>在Web开发中，服务器可以为每个用户浏览器创建一个会话对象(session对象)。注意：一个浏览器独占一个session对象（默认）。因此，在需要保存用户数据时，服务器可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问时，可以从用户的session中取出该用户的数据。</p><p>注：新开浏览器窗口会生成新的Session，子标签页除外。子标签页公用父窗口的Session</p><h3 id="Session用途"><a href="#Session用途" class="headerlink" title="Session用途"></a>Session用途</h3><ol><li>记录用户登录与行为数据. 考虑到这些数据用户修改随意性大，没必要直接存到数据库</li><li>用户执行刷新时，可直接根据session打开上次访问网页的状态，优化体验</li><li>通过session把用户行为联系起来，构建出完整模型，进行数据挖掘</li></ol><blockquote><p>session其实就是会话变量的保存地，只要是能使用变量的地方，都能使用session变量。一般地session就是像一个临时容器，来存放临时东西。</p></blockquote><h3 id="Session和Cookie的区别和联系"><a href="#Session和Cookie的区别和联系" class="headerlink" title="Session和Cookie的区别和联系"></a>Session和Cookie的区别和联系</h3><blockquote><p>具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务端保存状态的方案。两者存储的都是用户相关行为信息</p></blockquote><ul><li><p>cookie是把用户的数据写在本地浏览器上，其他网站也可以扫描使用该cookie，容易泄漏自己网站的用户隐私，且一般浏览器对单个网站站点有cookie数量与大小限制</p></li><li><p>session是把用户数据写在用户独占的session上，存储在服务端，一般只将session的id存储在cookie中。但将数据存储在服务器，成本相对高些</p></li><li><p>session是由服务端创建，开发人员可以在服务器上通过request对象拿到</p></li><li><p>一般情况，登录信息等重要信息存储在session中，其他信息存储在cookie中</p></li></ul><p>由于HTTP协议是无状态协议，所以服务端需要记录用户状态时，就需要用某种机制（Session）来识别具体用户。服务端为特定用户创建特定 Session 用于标识这个用户。Session是保存在服务端的，有一个唯一标识。</p><p>在服务端保存Session方法很多，内存、数据库、文件都有，集群时也要考虑Session的转移，使用一些缓存服务如Memcached之类来存放。</p><p>那么服务端如何识别特定用户？ Cookie，每次HTTP请求时，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用Cookie来实现Session跟踪。第一次创建Session时，服务端会在HTTP协议中告诉客户端，需要在Cookie里记录一个Session ID，以后每次请求都把这个会话ID发送到服务器，这样服务端就能识别客户端了。</p><ul><li>Session是在服务端保存的一个数据结构，用来跟踪用户的状态，该数据可以保存在集群、数据库、文件中</li><li>Cookie是在客户端保存用户信息的一种机制，用来记录用户信息，也是Session的一种实现方式</li></ul><h3 id="Session的实现原理"><a href="#Session的实现原理" class="headerlink" title="Session的实现原理"></a>Session的实现原理</h3><p>服务器会为每一个访问服务器的用户创建一个session对象，且把session对象的id保存在本地cookie上，只要用户再次访问服务器时，带着session id，服务器就会匹配用户在服务器上的session。根据session中的数据，还原用户上次的浏览状态或提供其他人性化服务。</p><h3 id="浏览器禁用Cookie后如何实现Session"><a href="#浏览器禁用Cookie后如何实现Session" class="headerlink" title="浏览器禁用Cookie后如何实现Session"></a>浏览器禁用Cookie后如何实现Session</h3><p><strong>URL地址重写</strong></p><p>原理是将用户session的id信息重写到url地址中。服务器能够解析重写后的url以获取sessionId。这样即时客户端不支持Cookie，也可以使用Session来记录用户状态。</p><h3 id="Session和Cookie有效时长"><a href="#Session和Cookie有效时长" class="headerlink" title="Session和Cookie有效时长"></a>Session和Cookie有效时长</h3><ul><li>session</li></ul><p>服务器会把长时间没有活动的session从服务器内存中清除，此时session便失效。具体根据服务端设置</p><ul><li>cookie</li></ul><p>主要内容包括：Key、value、过期时间、路径和域。路径与域一起构成cookie的作用范围，通过过期时间expires设置cookie的有效时长</p><blockquote><p>若不设置过期时间，表示这个cookie的生命周期为浏览器的会话期间，关闭访问服务器的浏览器窗口，cookie就消失，一般称为会话cookie。若保存在内存中设置了过期时间，则cookie会存储在硬盘上直到超过有效时间</p></blockquote><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>前端 http 里所说的 Token  是指 <code>访问资源的凭据</code>。</p><p>例如当调用 google api 需要带上有效的token来表明请求的合法性。 这个token是google给的，代表了有权访问api背后的资源。</p><ul><li>access token 调用api时携带的token</li></ul><ol><li>首先需要向google api注册应用程序，注册完毕后拿到认证信息（credentials）包括id和secret</li><li>接下来向google请求access token。如果想访问用户资源，这里会提醒用户授权</li><li>授权完毕，google会返回access token，或者授权代码（authorization code）, 再通过代码取得access token</li><li>token获取到后，就能带上token访问api了</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/7/3/1646088e5837a9a2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="access token流程"></p><p>在第3步通过code兑换access token的过程中，google不仅会返回access token，还会返回额外信息，这其中和之后更新相关的就是refresh token</p><p>一旦access token过期，就可以通过refresh token再次请求access token。当然这要根据请求方式和访问的资源类型而定，这又会引起两个问题：</p><ol><li>如果refresh token也过期了怎么办？需要用户重新登录授权</li><li>为什么要区分refresh token和access token？如果合并成一个token然后把过期时间调整更长，且每次失效后用户重新登录授权就好？</li></ol><h2 id="OAuth"><a href="#OAuth" class="headerlink" title="OAuth"></a>OAuth</h2><p>从获取token到使用token访问接口。这其实是标准的OAuth2.0机制下访问api的流程。</p><h3 id="SSO-Single-Sign-On"><a href="#SSO-Single-Sign-On" class="headerlink" title="SSO Single Sign-On"></a>SSO Single Sign-On</h3><p>单点登录（公司内部，一个用户登录，可访问所有系统）</p><p>SSO是一类解决方案的统称，而在具体实施，我们有两种策略可供选择：</p><ol><li>SAML 2.0</li><li>OAuth 2.0</li></ol><p><strong>Authentication VS Authorisation</strong></p><ul><li>Authentication 身份鉴别 认证</li><li>Authorisation 授权</li></ul><p>认证的作用在于认可你有权限访问系统，用于鉴别访问者是否是合法用户；而授权用于决定你有访问哪些资源的权限。作为系统设计者来说，这两者的差别是不同的工作职责。</p><p>Authorization Server/Identity Provider(IdP) VS Service Provider(SP)/Resource Server<br>把负责认证的服务称为 Authorization Server 或者 Identity Provider，以下简称 IdP；而负责提供资源（API调用）的服务称为  Resource Server 或者 Service Provider，以下简称 SP</p><h3 id="SMAL-2-0"><a href="#SMAL-2-0" class="headerlink" title="SMAL 2.0"></a>SMAL 2.0</h3><p><img src="https://user-gold-cdn.xitu.io/2018/7/3/16460893ef7a34a4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="SMAL2.0流程图"></p><ul><li>还未登录的用户打开浏览器访问网站（SP）网站提供服务但是不负责用户认证</li><li>SP向IdP发送一个SAML认证请求，同时SP向用户浏览器重定向到IdP</li><li>IdP在验证完来自SAML的请求无误后，在浏览器中呈现登录表单让用户进行填写用户名和密码进行登录</li><li>一旦用户登录成功，IdP会生成一个包含用户信息（用户名和密码）的SAML token（SAML token 又称为 SAML Assertion，本质上是 XML 节点）IdP向SP返回token，并且将用户重定向到SP（token的返回是在重定向步骤中实现的）</li><li>SP对拿到的token进行验证，并且解析用户信息。此时就能够根据这些信息允许用户访问我们网站的内容了</li></ul><p>当用户在IdP登录成功后，IdP需要将用户再次重定向至SP站点，这一步有两个方法：</p><ul><li>HTTP重定向（不推荐，因无法携带更长的信息）</li><li>HTTP POST请求，当用户登录后渲染表单，点击向SP提交POST</li></ul><p>如果是应用是基于web，无问题。但若是Android和IOS问题就来了：</p><ul><li>用户在iphone上打开应用，需要通过IdP认证</li><li>应用跳转safari登录认证完毕后，需要通过http post形式将token返回至手机应用</li></ul><p>虽然post的url可以拉起应用，但无法解析post内容，也就无法获取SAML token</p><hr><h3 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h3><p><img src="https://user-gold-cdn.xitu.io/2018/7/3/164608b5c33898d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="OAutho2.0流程图"></p><ul><li>用户通过客户端（也可以是浏览器或手机应用）想要访问SP上的资源，但是SP告诉用户需要认证，将用户重定向至IdP</li><li>IdP向用户询问SP是否可以访问用户信息，若用户同意，IdP向客户端返回access code</li><li>客户端拿code向IdP换access token，并拿着access token向SP请求资源</li><li>SP接受请求后拿着附带token向IdP验证用户身份</li></ul><p>OAuth本意是一个应用允许另一个应用在用户授权的情况下访问自己的数据，OAuth设计本意更倾向于授权而非认证（当然授权用户信息就间接实现了认证）</p><h3 id="OpenID"><a href="#OpenID" class="headerlink" title="OpenID"></a>OpenID</h3><ul><li>OpenID只用于身份验证，允许你以同一个账户在多个网站登录。它仅仅是为你的合法身份背书，当你以xx帐号登录某个站点后，该站点无权访问你在xxb上的数据</li><li>OAuth用户授权，允许被授权方访问授权方的用户数据</li></ul><h3 id="Refresh-Token"><a href="#Refresh-Token" class="headerlink" title="Refresh Token"></a>Refresh Token</h3><p>为什么需要？</p><p>这样处理是为了职责分离：refresh token负责身份验证， access token负责资源请求。虽然两者都由IdP发出，但access token还要和SP进行数据交换，如果公用会有身份泄漏可能。</p><hr><p>token其实是为OAuth服务的，它是访问数据的一把钥匙。</p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JWT 也是token，它是访问资源的凭证。甚至你可以不需要向 Google 索要 access token，而是携带 JWT 作为 HTTP header 里的 bearer token 直接访问 API 也是可以的。</p><p>顾名思义，它是json结构的token，由三部分组成：</p><ul><li>header</li></ul><p>用于描述元信息，例如产生signature的算法</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span>,</span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>payload</li></ul><p>用于携带你希望向服务端传递的信息。即可以往里面添加字段，也可以塞入自定义字段</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"userId"</span>: <span class="string">"b08f86af-35da-48f2-8fab-cef3904660bd"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>signature</li></ul><p>创建签名需要分以下几个步骤</p><ol><li>需要从接口服务端拿到密钥 假设为 <code>secret</code></li><li>将header进行base64编码，假设为 <code>headerStr</code></li><li>将payload进行base64编码，假设为 <code>payloadStr</code></li><li>将headerStr和payloadStr用 <code>.</code> 字符串拼接，成为字符 <code>data</code></li><li>以data和secret作为参数，使用哈希算法计算出签名</li></ol><p>下面是伪代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// signature algorithm</span></span><br><span class="line">data = base64URLEncoded(header) + <span class="string">'.'</span> + base64URLEncoded(payload)</span><br><span class="line">signature = Hash(data, secret)</span><br></pre></td></tr></table></figure><p>假设我们的原始 JSON 结构是这样的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Header</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span>,</span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span></span><br><span class="line">&#125;</span><br><span class="line">// Payload:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"userId"</span>: <span class="string">"b08f86af-35da-48f2-8fab-cef3904660bd"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果密钥是字符串secret的话，那么最终 JWT 的结果就是这样的</p><pre><code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM</code></pre><p>你可以在 <a href="https://jwt.io/" target="_blank" rel="noopener">jwt.io</a> 上验证这个结果</p><hr><p>JWT的目的不是为了隐藏或者保密数据，而是为了确保数据确实来自被授权的人创建的（不被篡改）</p><p>用于接口调用</p><h2 id="有状态的会话"><a href="#有状态的会话" class="headerlink" title="有状态的会话"></a>有状态的会话</h2><p>因为HTTP是无状态的，所以客户端和服务端需要解决如何让之间的对话变得有状态。例如只有登录状态的用户才有权限去调用某些接口，那么在用户登录后，需要记住该用户是已经登录的状态。常见的方法是使用session机制。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/3/164608d56ba8fc6e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="常见的session模型"></p><ul><li>用户在浏览器登录后，服务端为用户生成唯一的session id，存储在服务端的存储服务（mysql redis）</li><li>该session id也返回给浏览器以SESSION_ID为key存储在cookie中</li><li>如果用户再次访问该站，cookie里的SESSION_ID会随着请求一同发往服务端</li><li>服务端通过判断SESSION_ID是否在redis判断用户是否处于登录状态</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Cookie定义&quot;&gt;&lt;a href=&quot;#Cookie定义&quot; class=&quot;headerlink&quot; title=&quot;Cookie定义&quot;&gt;&lt;/a&gt;Cookie定义&lt;/h2&gt;&lt;p&gt;Cookie 是一小段文本信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递。Cookie 包含每次用户访问站点时 Web 应用程序都可以读取的信息。&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://blog.fridolph.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="cookie" scheme="http://blog.fridolph.top/tags/cookie/"/>
    
      <category term="session" scheme="http://blog.fridolph.top/tags/session/"/>
    
      <category term="token" scheme="http://blog.fridolph.top/tags/token/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】栈、队列、链表及其区别</title>
    <link href="http://blog.fridolph.top/2018/07/20/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E3%80%81%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%8C%BA%E5%88%AB/"/>
    <id>http://blog.fridolph.top/2018/07/20/【数据结构】栈、队列、链表及其区别/</id>
    <published>2018-07-20T14:49:03.000Z</published>
    <updated>2024-01-01T03:25:59.654Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写这篇是因为之前在群里看到小伙伴在讨论算法相关知识，对于前端来说，这块也是很重要嘛，正好把之前没看完的那本电子书，《学习JavaScript数据结构与算法》复习下~</p></blockquote><a id="more"></a><h2 id="栈数据结构"><a href="#栈数据结构" class="headerlink" title="栈数据结构"></a>栈数据结构</h2><p>栈是一种遵从后进先出(LIFO, Last in First out)原则的有序集合。新添加的或待删除的元素都保存在栈的同一端，称作栈顶，另一端叫作栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。</p><hr><p>我们只是用ES6的简化语法把Stack函数转换成类。但变量items却是公共的，ES6的类是基于原型的，虽然基于原型的类比基于函数的类更节省内存，也更适合创建多个实例，却不能够声明私有属性或方法，而且，在这种情况下，我们希望Stack类的用户只能访问暴露给类的方法，否则就有可能从栈的中间移除元素（因为我们用数组来存储其值）</p><p>以下是ES6方法，创建私有属性的方式：</p><ul><li>用ES6的限定作用域Symbol实现类</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _items = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>[_items] = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// stack方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法创建了一个假的私有属性，因为 Object.getOwnPropertySymbols能够取到类里面声明的所有Symbols属性</p><p>下面是一个破坏Stack类的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stack = <span class="keyword">new</span> Stack();</span><br><span class="line">stack.push(<span class="number">5</span>);</span><br><span class="line">stack.push(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">let</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(stack);</span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols.length); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols); <span class="comment">// [Symbol()]</span></span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols[<span class="number">0</span>]); <span class="comment">// Symbol()</span></span><br><span class="line">stack[objectSymbols[<span class="number">0</span>]].push(<span class="number">1</span>);</span><br><span class="line">stack.print(); <span class="comment">// 5, 8, 1</span></span><br></pre></td></tr></table></figure><p>访问stack[objectSymbols[0]]是可以得到_items的，并且_items属性是一个数组，可以进行任意的数组操作，于是还有下面的方案：</p><p>用ES6的WeakMap实现类</p><p>有一种数据类型可以确保属性是私有的，这就是WeakMap，现在只需要知道WeakMap可以存储键值对，其中键是对象，值可以是任意数据类型。</p><p>如果用WeakMap类存储items变量，Stack类就是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    items.set(<span class="keyword">this</span>, [])</span><br><span class="line">  &#125;</span><br><span class="line">  push(element) &#123;</span><br><span class="line">    <span class="keyword">let</span> s = items.get(<span class="keyword">this</span>);</span><br><span class="line">    s.push(element);</span><br><span class="line">  &#125;</span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = items.get(<span class="keyword">this</span>);</span><br><span class="line">    r = s.pop();</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们知道items在Stack类里是真正的私有属性了，但还有一件事要做。items现在仍然是在Stack类以外声明的，因此谁都可以改动它。我们要用一个闭包（外层函数）把Stack类包起来，这样就只能在这个函数里访问WeakMap：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Stack = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">      items.set(<span class="keyword">this</span>, []);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Stack;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>完整代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.items = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向栈添加元素</span></span><br><span class="line">  push(element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.items.push(element);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从栈移除元素</span></span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 查看栈顶元素</span></span><br><span class="line">  peek() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.items.length - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 检查栈是否为空</span></span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`当前栈是否为空：<span class="subst">$&#123;<span class="keyword">this</span>.items.length === <span class="number">0</span>&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清空栈元素</span></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.items = [];</span><br><span class="line">  &#125;</span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`当前栈的元素有<span class="subst">$&#123;<span class="keyword">this</span>.items.length&#125;</span>个`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 打印栈元素</span></span><br><span class="line">  print() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.items.toString())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> stack = <span class="keyword">new</span> Stack();</span><br><span class="line"><span class="comment">// console.log(stack.isEmpty())</span></span><br><span class="line">stack.push(<span class="number">5</span>)</span><br><span class="line">stack.push(<span class="number">8</span>)</span><br><span class="line"><span class="built_in">console</span>.log(stack.peek())</span><br><span class="line">stack.push(<span class="number">11</span>)</span><br><span class="line">stack.size()</span><br><span class="line">stack.isEmpty()</span><br><span class="line">stack.pop();</span><br><span class="line">stack.pop();</span><br><span class="line">stack.size()</span><br></pre></td></tr></table></figure><h2 id="队列数据结构"><a href="#队列数据结构" class="headerlink" title="队列数据结构"></a>队列数据结构</h2><p>队列是遵循FIFO(First In First Out，先进先出)原则的一组有序的项。<br>队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。</p><h3 id="JS任务队列"><a href="#JS任务队列" class="headerlink" title="JS任务队列"></a>JS任务队列</h3><p>当我们在浏览器中打开新标签时，就会创建一个任务队列。这是因为每个标签都是单线程处理所有的任务，它被称为事件循环。<br>浏览器要负责多个任务，如渲染HTML，执行JS代码，处理用户交互（输入、点击等），执行和处理异步请求。</p><p>代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建队列</span></span><br><span class="line"><span class="keyword">let</span> Queue = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">      items.set(<span class="keyword">this</span>, []);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向队列添加元素</span></span><br><span class="line">    enqueue(elem) &#123;</span><br><span class="line">      items.push(elem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向队列移除元素</span></span><br><span class="line">    dequeue() &#123;</span><br><span class="line">      <span class="keyword">return</span> items.shift();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看队列头元素</span></span><br><span class="line">    front() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(items[<span class="number">0</span>])</span><br><span class="line">      <span class="keyword">return</span> items[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查队列是否为空</span></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`是否为空：<span class="subst">$&#123;items.length === <span class="number">0</span>&#125;</span>`</span>)</span><br><span class="line">      <span class="keyword">return</span> items.length === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`队列长度为：<span class="subst">$&#123;items.length&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">return</span> items.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印队列元素</span></span><br><span class="line">    print() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(items.valueOf());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 使用Queue类</span></span><br><span class="line"><span class="keyword">let</span> queue = <span class="keyword">new</span> Queue();</span><br><span class="line">queue.isEmpty();</span><br><span class="line">queue.enqueue(<span class="string">'John'</span>);</span><br><span class="line">queue.enqueue(<span class="string">'Jack'</span>);</span><br><span class="line">queue.enqueue(<span class="string">'Camila'</span>);</span><br><span class="line">queue.print();</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表是种动态的数据结构，这意味着我们可以从中任意添加或移除项，它会按需进行扩充。</p><p>要存储多个元素，数组（或列表）可能是最常用的数据结构。每种语言都实现了数组，它提供了一个便利的[]语法来访问其元素。然而这种数据结构有一种缺点，其数组大小是固定的。<br>从数组的起点或中间插入或移除项的成本很高，因为它需要移动元素（尽管我们知道JS的Array类可以帮我们做这类事，但情况还是相同）<br>链表存储有序的元素集合，但不同于数组，链表的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称为指针或链接）组成。<br>相对于传统的数组，链表的好处在于，添加或移除元素时不需要移动其他元素。然而，链表需要使用指针，因此实现链表时需要额外注意。数组的另一个细节是可以直接访问任何位置的任何元素。而想要访问链表中间的一个元素，需要从起点（表头）开始迭代列表直到找到所需元素。</p><p>完整代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> Node = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> length = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> head = <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 向列表尾部添加一个新的项</span></span><br><span class="line">  <span class="keyword">this</span>.append = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element)</span><br><span class="line">    <span class="keyword">let</span> current</span><br><span class="line">    <span class="comment">// 列表中第一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (head === <span class="literal">null</span>) &#123;</span><br><span class="line">      head = node</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      current = node</span><br><span class="line">      <span class="comment">// 循环列表，直到找到最后一项</span></span><br><span class="line">      <span class="keyword">while</span> (current.next) &#123;</span><br><span class="line">        current = current.next</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 找到最后一项，将其next赋为node，建立连接</span></span><br><span class="line">      current.next = node</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新列表长度</span></span><br><span class="line">    length++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向列表的特定位置插入一个新的项</span></span><br><span class="line">  <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span>(<span class="params">position, element</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 检查越界值</span></span><br><span class="line">    <span class="keyword">if</span> (position &gt;= <span class="number">0</span> &amp;&amp; position &lt;= length) &#123;</span><br><span class="line">      <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element)</span><br><span class="line">      <span class="keyword">let</span> current = head</span><br><span class="line">      <span class="keyword">let</span> previous</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">      <span class="comment">// 在第一个位置添加</span></span><br><span class="line">      <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">        node.next = current</span><br><span class="line">        head = node</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (index++ <span class="xml"><span class="tag">&lt; <span class="attr">position</span>) &#123;</span></span></span><br><span class="line"><span class="xml">          previous = current</span></span><br><span class="line"><span class="xml">          current = current.next</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">        node.next = current</span></span><br><span class="line"><span class="xml">        previous.next = node</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">      // 更新列表长度</span></span><br><span class="line"><span class="xml">      length++</span></span><br><span class="line"><span class="xml">      return true</span></span><br><span class="line"><span class="xml">    &#125; else &#123;</span></span><br><span class="line"><span class="xml">      return false</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  // 从列表的特定位置移除一项</span></span><br><span class="line"><span class="xml">  this.removeAt = function(position) &#123;</span></span><br><span class="line"><span class="xml">    // 检查越界值</span></span><br><span class="line"><span class="xml">    if (position &gt; -1 &amp;&amp; position <span class="tag">&lt; <span class="attr">length</span>) &#123;</span></span></span><br><span class="line"><span class="xml">      let current = head</span></span><br><span class="line"><span class="xml">      let previous</span></span><br><span class="line"><span class="xml">      let index = 0</span></span><br><span class="line"><span class="xml">      // 移除第一项</span></span><br><span class="line"><span class="xml">      if (position === 0) &#123;</span></span><br><span class="line"><span class="xml">        head = current.next</span></span><br><span class="line"><span class="xml">      &#125; else &#123;</span></span><br><span class="line"><span class="xml">        while (index++ <span class="tag">&lt; <span class="attr">position</span>) &#123;</span></span></span><br><span class="line"><span class="xml">          previous = current</span></span><br><span class="line"><span class="xml">          current = current.next</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">        // 将previous与current的下一项连接起来；跳过current，从而移除它</span></span><br><span class="line"><span class="xml">        previous.next = current.next</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">      length--</span></span><br><span class="line"><span class="xml">      return current.element</span></span><br><span class="line"><span class="xml">    &#125; else &#123;</span></span><br><span class="line"><span class="xml">      return null</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  // 从列表中移除一项</span></span><br><span class="line"><span class="xml">  this.remove = function(element) &#123;</span></span><br><span class="line"><span class="xml">    let index = this.indexOf(element)</span></span><br><span class="line"><span class="xml">    return this.removeAt(index)</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  // 返回元素在列表中的索引，若列表中没有该元素则返回-1</span></span><br><span class="line"><span class="xml">  this.indexOf = function(element) &#123;</span></span><br><span class="line"><span class="xml">    let current = head</span></span><br><span class="line"><span class="xml">    let index = -1</span></span><br><span class="line"><span class="xml">    while (current) &#123;</span></span><br><span class="line"><span class="xml">      if (element === current.element) &#123;</span></span><br><span class="line"><span class="xml">        return index</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">      index++</span></span><br><span class="line"><span class="xml">      current = current.next</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    return -1</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  this.isEmpty = function() &#123;</span></span><br><span class="line"><span class="xml">    return length === 0</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  // 返回链表包含的元素个数，与数组的length属性类似</span></span><br><span class="line"><span class="xml">  this.size = function() &#123;</span></span><br><span class="line"><span class="xml">    return length</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  this.getHead = function() &#123;</span></span><br><span class="line"><span class="xml">    return head</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  // 由于列表项使用了Node类，就需要重写继承自JS默认的toString方法，让其只输出元素值</span></span><br><span class="line"><span class="xml">  this.toString = function() &#123;</span></span><br><span class="line"><span class="xml">    // 首先要访问列表中的所有元素，就需要有一个起点，也就是head。我们会把current变量当作索引，控制循环访问列表</span></span><br><span class="line"><span class="xml">    // 我们还需要初始化用于拼接元素值的变量，接下来就是循环访问列表中的每个元素</span></span><br><span class="line"><span class="xml">    // 我们要用current来检查元素是否存在，然后得到元素内容进行拼接</span></span><br><span class="line"><span class="xml">    // 最后迭代下一个元素，最终返回列表内容的字符串</span></span><br><span class="line"><span class="xml">    let current = head</span></span><br><span class="line"><span class="xml">    let string = ''</span></span><br><span class="line"><span class="xml">    while (current) &#123;</span></span><br><span class="line"><span class="xml">      string += current.element + (current.next ? 'n' : '')</span></span><br><span class="line"><span class="xml">      current = current.next</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    return string</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  this.print = function() &#123;&#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">var md1 = `</span></span><br><span class="line"><span class="xml">  LinkedList数据结构还需要一个Node辅助类。Node类表示要加入列表的项，它包含一个element属性，即要添加到列表的值，以及一个next属性，即指向列表中下一个节点项的指针。</span></span><br><span class="line"><span class="xml">  LinkedList类也有存储列表项的数组的length属性（是一个私有变量）</span></span><br><span class="line"><span class="xml">  另一个重要点是，我们还需要存储第一个节点的引用。为此，可以把这个引用存储在称为head的变量中</span></span><br><span class="line"><span class="xml">  然后就是LinkedList类的方法</span></span><br><span class="line"><span class="xml">`</span></span><br></pre></td></tr></table></figure><h3 id="链表优点"><a href="#链表优点" class="headerlink" title="链表优点"></a>链表优点</h3><ol><li><p>使用链表数据结构可以克服数组链表需要预先知道数据大小的缺点，链表数据结构可以充分内存空间，实现灵活的内存动态管理</p></li><li><p>数据的存取往往要在不同的排列顺序中转换，而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的指针。链表允许插入和移除链表上任意位置上的节点，但是不允许随机存取</p></li></ol><h3 id="链表缺点"><a href="#链表缺点" class="headerlink" title="链表缺点"></a>链表缺点</h3><p>链表失去了数组随机读取的优点，同时链表由于增加了节点的指针域，空间开销比较大</p><hr><p>先到这里，后面再补充吧~~</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写这篇是因为之前在群里看到小伙伴在讨论算法相关知识，对于前端来说，这块也是很重要嘛，正好把之前没看完的那本电子书，《学习JavaScript数据结构与算法》复习下~&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习" scheme="http://blog.fridolph.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="js" scheme="http://blog.fridolph.top/tags/js/"/>
    
      <category term="数据结构" scheme="http://blog.fridolph.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【JS】脚本错误及错误捕获</title>
    <link href="http://blog.fridolph.top/2018/07/14/%E3%80%90JS%E3%80%91%E8%84%9A%E6%9C%AC%E9%94%99%E8%AF%AF%E5%8F%8A%E9%94%99%E8%AF%AF%E6%8D%95%E8%8E%B7/"/>
    <id>http://blog.fridolph.top/2018/07/14/【JS】脚本错误及错误捕获/</id>
    <published>2018-07-14T12:52:15.000Z</published>
    <updated>2024-01-01T03:29:09.745Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>从脚本错误开始，了解脚本为什么会报错以及抛出错误，最后介绍了用window.onerror、try catch捕获错误。</p></blockquote><a id="more"></a><h2 id="什么是脚本错误"><a href="#什么是脚本错误" class="headerlink" title="什么是脚本错误"></a>什么是脚本错误</h2><p>如果您以前使用过JavaScript onerror事件做过任何工作，您可能会遇到以下情况：</p><p>“Script error.”</p><p>“脚本错误”是当错误源自从不同来源（不同域，端口或协议）提供的JavaScript文件时，浏览器发送到onerror回调的内容。这很痛苦，因为即使出现错误，您也不知道错误是什么，也不知道它来自哪个代码。这就是window.onerror的全部目的 - 深入了解应用程序中未捕获的错误。</p><h2 id="产生原因：跨源脚本"><a href="#产生原因：跨源脚本" class="headerlink" title="产生原因：跨源脚本"></a>产生原因：跨源脚本</h2><p>为了更好地了解正在发生的事情，请考虑以下示例HTML文档，假设从<a href="http://example.com/test提供：" target="_blank" rel="noopener">http://example.com/test提供：</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>example.com/test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://another-domain.com/app.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">message, url, line, column, error</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(message, url, line, column, error);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    foo(); <span class="comment">// call function declared in app.js</span></span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是<a href="http://another-domain.com/app.js的内容。它声明了一个函数foo，其调用将始终抛出ReferenceError。" target="_blank" rel="noopener">http://another-domain.com/app.js的内容。它声明了一个函数foo，其调用将始终抛出ReferenceError。</a></p><p>在浏览器中加载此文档并执行JavaScript时，会将以下内容输出到控制台（通过window.onerror回调记录）：</p><p>“Script error.”, “”, 0, 0, undefined</p><p>这不是JavaScript错误 - 出于安全原因，浏览器故意隐藏源自不同来源的脚本文件的错误。这是为了避免脚本无意中将潜在敏感信息泄露给它无法控制的onerror回调。出于这个原因，浏览器只允许window.onerror洞察来自同一域的错误。我们所知道的是发生了一个错误 - 没有别的！</p><h2 id="但这并不坏"><a href="#但这并不坏" class="headerlink" title="但这并不坏"></a>但这并不坏</h2><p>尽管浏览器有良好的意图，但是有一些很好的理由可以让您深入了解从不同来源提供的脚本引发的错误：</p><ol><li>您的应用程序JavaScript文件是从不同的主机名提供的，例如static.sentry.io/app.js</li><li>您正在使用社区CDN提供的库，例如cdnjs或Google的托管库</li><li>您正在使用商业第三方JavaScript库，该库仅由外部服务器提供</li></ol><p>但不要担心 - 深入了解这些文件所提供的JavaScript错误只需要进行一些简单的调整。</p><h2 id="修复：CORS-attributes-amp-headers"><a href="#修复：CORS-attributes-amp-headers" class="headerlink" title="修复：CORS attributes &amp; headers"></a>修复：CORS attributes &amp; headers</h2><p>为了了解源自不同来源的脚本引发的JavaScript异常，您必须做两件事:</p><ol><li>添加 crossorigin=”anonymous” 脚本属性</li></ol><p><code>&lt;script src=&quot;http://another-domain.com/app.js&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;</code></p><p>这告诉浏览器应该“anonymous”(匿名)获取目标文件。这意味着在请求此文件时，浏览器不会将任何潜在的用户识别信息（如cookie或HTTP凭据）传输到服务器。</p><ol><li>添加Cross Origin HTTP header</li></ol><p><code>Access-Control-Allow-Origin: *</code></p><p>CORS是“跨源资源共享”的缩写，它是一组API（主要是HTTP标头），它们规定了文件应该如何从源头下载和提供。</p><p>通过设置Access-Control-Allow-Origin：*，服务器向浏览器指示任何源可以获取此文件。或者，您可以将其限制为您控制的已知来源，例如</p><p><code>Access-Control-Allow-Origin: https://www.example.com</code></p><p>注意：大多数社区CDN正确设置了Access-Control-Allow-Origin标头。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl --head https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.js | \</span><br><span class="line">  grep -i <span class="string">"access-control-allow-origin"</span></span><br><span class="line"></span><br><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure><p>完成这两个步骤后，此脚本触发的任何错误都将向window.onerror报告，就像任何常规的同域脚本一样。因此，代替“脚本错误”，从一开始的onerror示例将产生：</p><p><code>&quot;ReferenceError: bar is not defined&quot;, &quot;http://another-domain.com/app.js&quot;, 2, 1, [Object Error]</code></p><h2 id="另一种解决方案：try-catch"><a href="#另一种解决方案：try-catch" class="headerlink" title="另一种解决方案：try / catch"></a>另一种解决方案：try / catch</h2><p>有时，我们并不总是能够调整Web应用程序正在使用的脚本的HTTP头。在这些情况下，有一种替代方法：使用try / catch。</p><p>再次考虑原始示例，这次使用try / catch：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- <span class="doctag">note:</span> crossorigin="anonymous" intentionally absent --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://another-domain.com/app.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">message, url, line, column, error</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(message, url, line, column, error);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">    foo(); <span class="comment">// call function declared in app.js</span></span></span><br><span class="line"><span class="javascript">  &#125; <span class="keyword">catch</span> (e) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(e);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">throw</span> e; <span class="comment">// intentionally re-throw (caught by window.onerror)</span></span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于后代，some-domain.com/app.js再次看起来像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// another-domain.com/app.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  bar(); <span class="comment">// ReferenceError: bar is not a function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行示例HTML将向控制台输出以下2个条目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">=&gt; ReferenceError: bar is not defined</span><br><span class="line">    at foo (http://another-domain.com/b.js:2:3)</span><br><span class="line">    at http://example.com/<span class="built_in">test</span>/:15:3</span><br><span class="line"></span><br><span class="line">=&gt; <span class="string">"Script error."</span>, <span class="string">""</span>, 0, 0, undefined</span><br></pre></td></tr></table></figure><p>第一个控制台语句 - 来自try / catch - 设法获取一个错误对象，包括类型，消息和堆栈跟踪，包括文件名和行号。来自window.onerror的第二个控制台语句再一次只能输出“脚本错误”。</p><p>现在，这是否意味着您需要尝试/捕获所有代码？可能不是 - 如果您可以轻松更改HTML并在CDN上指定CORS标题，则最好这样做并坚持使用window.onerror。但是，如果您不控制这些资源，使用try / catch包装第三方代码是一种可靠的（虽然是乏味的）方式，可以深入了解跨源脚本引发的错误。</p><p>注意：默认情况下，Raven.js - Sentry的JavaScript SDK - 仔细设备内置方法，尝试自动将代码包装在try / catch块中。它这样做是为了尝试捕获所有脚本中的错误消息和堆栈跟踪，无论它们来自哪个来源。如果可能，仍建议设置CORS属性和标头。</p><h2 id="window-onerror"><a href="#window-onerror" class="headerlink" title="window.onerror"></a>window.onerror</h2><p>onerror是一个特殊的浏览器事件，只要抛出未捕获的JavaScript错误就会触发该事件。这是记录客户端错误并将其报告给服务器的最简单方法之一。它也是Sentry的客户端JavaScript集成（raven-js）工作的主要机制之一。</p><p>你通过向window.onerror分配一个函数来监听onerror事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">msg, url, lineNo, columnNo, error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... handle error ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抛出错误时，以下参数将传递给函数：</p><ul><li>msg - 与错误相关的消息，例如“未捕获的ReferenceError：foo未定义”</li><li>url - 与错误关联的脚本或文档的URL，例如“/dist/app.js”</li><li>lineNo - 行号（如果有）</li><li>columnNo - 列号（如果可用）</li><li>error - 与此错误关联的Error对象（如果可用）</li></ul><p>前四个参数告诉你错误发生在哪个脚本，行和列中。最后一个参数Error对象可能是最有价值的。让我们来了解原因。</p><h3 id="Error对象和error-stack"><a href="#Error对象和error-stack" class="headerlink" title="Error对象和error.stack"></a>Error对象和error.stack</h3><p>乍一看，Error对象不是很特别。它包含3个标准化属性：message，fileName和lineNumber。已通过window.onerror提供给你的冗余值。</p><p>有价值的部分是非标准属性：Error.prototype.stack。此堆栈属性告诉你错误发生时程序的每个帧的源位置。错误堆栈跟踪可能是调试的关键部分。尽管不标准，但每个现代浏览器都提供此属性。</p><p>以下是Chrome 46中Error对象的堆栈属性的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Error: foobar\n    at new bar (&lt;anonymous&gt;:241:11)\n    at foo (&lt;anonymous&gt;:245:5)\n    at &lt;anonymous&gt;:250:5\n    at &lt;anonymous&gt;:251:3\n    at &lt;anonymous&gt;:267:4\n    at callFunction (&lt;anonymous&gt;:229:33)\n    at &lt;anonymous&gt;:239:23\n    at &lt;anonymous&gt;:240:3\n    at Object.InjectedScript._evaluateOn (&lt;anonymous&gt;:875:140)\n    at Object.InjectedScript._evaluateAndWrap (&lt;anonymous&gt;:808:34)"</span></span><br></pre></td></tr></table></figure><p>难以阅读，对吗？stack属性实际上只是一个未格式化的字符串。这是格式化的样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Error: foobar</span></span><br><span class="line"><span class="string">    at new bar (&lt;anonymous&gt;:241:11)</span></span><br><span class="line"><span class="string">    at foo (&lt;anonymous&gt;:245:5)</span></span><br><span class="line"><span class="string">    at &lt;anonymous&gt;:250:5</span></span><br><span class="line"><span class="string">    at &lt;anonymous&gt;:251:3</span></span><br><span class="line"><span class="string">    at &lt;anonymous&gt;:267:4</span></span><br><span class="line"><span class="string">    at callFunction (&lt;anonymous&gt;:229:33)</span></span><br><span class="line"><span class="string">    at &lt;anonymous&gt;:239:23</span></span><br><span class="line"><span class="string">    at &lt;anonymous&gt;:240:3</span></span><br><span class="line"><span class="string">    at Object.InjectedScript._evaluateOn (&lt;anonymous&gt;:875:140)</span></span><br><span class="line"><span class="string">    at Object.InjectedScript._evaluateAndWrap (&lt;anonymous&gt;:808:34)"</span></span><br></pre></td></tr></table></figure><p>一旦格式化，就很容易看出堆栈属性如何在帮助调试错误时起到关键作用。只有一个障碍：堆栈属性是非标准的，它的实现在浏览器之间有所不同。例如，这是来自Internet Explorer 11的相同堆栈跟踪：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Error</span>: foobar</span><br><span class="line">   at bar (Unknown script code:<span class="number">2</span>:<span class="number">5</span>)</span><br><span class="line">   at foo (Unknown script code:<span class="number">6</span>:<span class="number">5</span>)</span><br><span class="line">   at Anonymous <span class="function"><span class="keyword">function</span> (<span class="params">Unknown script code:<span class="number">11</span>:<span class="number">5</span></span>)</span></span><br><span class="line"><span class="function">   <span class="title">at</span> <span class="title">Anonymous</span> <span class="title">function</span> (<span class="params">Unknown script code:<span class="number">10</span>:<span class="number">2</span></span>)</span></span><br><span class="line"><span class="function">   <span class="title">at</span> <span class="title">Anonymous</span> <span class="title">function</span> (<span class="params">Unknown script code:<span class="number">1</span>:<span class="number">73</span></span>)</span></span><br></pre></td></tr></table></figure><p>不仅每个帧的格式不同，帧也具有较少的细节。例如，Chrome会识别出已使用新关键字，并且对eval调用有更深入的了解。这只是IE 11与Chrome的比较 - 其他类似的浏览器具有不同的格式和细节。</p><p>幸运的是，有一些工具可以规范化堆栈属性，使其在浏览器中保持一致。例如，raven-js使用TraceKit来规范化错误字符串。还有stacktrace.js和其他一些项目。</p><h3 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h3><p>window.onerror已经在浏览器中出现了一段时间 - 你会在浏览器中找到它与IE6和Firefox 2一样古老的版本。</p><p>问题是每个浏览器都以不同的方式实现window.onerror。特别是，将多少个参数发送给onerror侦听器，以及这些参数的结构。</p><p>这是一个在大多数浏览器中将参数传递给onerror的表：</p><table><thead><tr><th style="text-align:center">Browser</th><th style="text-align:center">Message</th><th style="text-align:center">URL</th><th style="text-align:center">lineNo</th><th style="text-align:center">colNo</th><th style="text-align:center">errorObj</th></tr></thead><tbody><tr><td style="text-align:center">Firefox</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center">Chrome</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center">Edge</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center">IE 11</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center">IE 10</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center">IE 9, 8</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center">Safari 10 and up</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center">Safari 9</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center">Android Browser 4.4</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr></tbody></table><p>Internet Explorer 8,9和10对onerror的支持有限，这可能不足为奇。但是你可能会惊讶于Safari只在Safari 10中添加了对错误对象的支持（2016年发布）。此外，仍旧使用现有Android浏览器（现已替换为Chrome Mobile）的旧手机版仍然在那里，并且不会传递错误对象。</p><p>没有错误对象，就没有堆栈跟踪属性。这意味着这些浏览器无法从错误捕获的错误中检索有价值的堆栈信息。</p><h3 id="使用try-catch-兼容-window-onerror"><a href="#使用try-catch-兼容-window-onerror" class="headerlink" title="使用try / catch 兼容 window.onerror"></a>使用try / catch 兼容 window.onerror</h3><p>但是有一种解决方法 - 你可以将应用程序中的代码包装在try / catch中并自己捕获错误。这个错误对象将在每个现代浏览器中包含我们令人垂涎的堆栈属性。</p><p>考虑以下帮助器方法invoke，它使用参数数组调用对象上的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invoke</span>(<span class="params">obj, method, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[method].apply(<span class="keyword">this</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">invoke(<span class="built_in">Math</span>, <span class="string">'max'</span>, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// returns 2</span></span><br></pre></td></tr></table></figure><p>这里再次调用，这次包装在try / catch中，以捕获任何抛出的错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invoke</span>(<span class="params">obj, method, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj[method].apply(<span class="keyword">this</span>, args);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    captureError(e); <span class="comment">// report the error</span></span><br><span class="line">    <span class="keyword">throw</span> e; <span class="comment">// re-throw the error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">invoke(<span class="built_in">Math</span>, <span class="string">'highest'</span>, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// throws error, no method Math.highest</span></span><br></pre></td></tr></table></figure><p>当然，在任何地方手动执行此操作非常麻烦。你可以通过创建通用包装器实用程序函数来使其更容易：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapErrors</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// don't wrap function more than once</span></span><br><span class="line">  <span class="keyword">if</span> (!fn.__wrapped__) &#123;</span><br><span class="line">    fn.__wrapped__ = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        captureError(e); <span class="comment">// report the error</span></span><br><span class="line">        <span class="keyword">throw</span> e; <span class="comment">// re-throw the error</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fn.__wrapped__;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> invoke = wrapErrors(<span class="function"><span class="keyword">function</span>(<span class="params">obj, method, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[method].apply(<span class="keyword">this</span>, args);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">invoke(<span class="built_in">Math</span>, <span class="string">'highest'</span>, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// no method Math.highest</span></span><br></pre></td></tr></table></figure><p>因为JavaScript是单线程的，所以你不需要在任何地方使用wrap  - 只是在每个新堆栈的开头。</p><p>这意味着你需要包装函数声明：</p><ul><li>在你的应用程序开始时（例如，如果你使用jQuery，请在$（document）.ready中）</li><li>在事件处理程序中，例如addEventListener或$ .fn.click</li><li>基于计时器的回调，例如setTimeout或requestAnimationFrame</li></ul><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$(wrapErrors(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// application start</span></span><br><span class="line">  doSynchronousStuff1(); <span class="comment">// doesn't need to be wrapped</span></span><br><span class="line"></span><br><span class="line">  setTimeout(wrapErrors(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    doSynchronousStuff2(); <span class="comment">// doesn't need to be wrapped</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  $(<span class="string">'.foo'</span>).click(wrapErrors(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    doSynchronousStuff3(); <span class="comment">// doesn't need to be wrapped</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>如果这看起来像是很多工作，请不要担心！大多数错误报告库都具有增强内置函数（如addEventListener和setTimeout）的机制，因此你不必每次都调用包装实用程序。是的，raven-js也这样做。</p><h3 id="将错误传输到你的服务器"><a href="#将错误传输到你的服务器" class="headerlink" title="将错误传输到你的服务器"></a>将错误传输到你的服务器</h3><p>好的，所以你已经完成了你的工作 - 你已经插入window.onerror，并且你还在try / catch中包装函数，以便捕获尽可能多的错误信息。</p><p>最后一步是：将错误信息传输到你的服务器。为了实现这一点，你需要设置某种报告Web服务，该服务将通过HTTP接受你的错误数据，将其记录到文件和/或将其存储在数据库中。</p><p>如果此Web服务与Web应用程序位于同一个域中，则可以使用XMLHttpRequest轻松实现。在下面的示例中，我们使用jQuery的AJAX函数将数据传输到我们的服务器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">captureError</span>(<span class="params">ex</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> errorData = &#123;</span><br><span class="line">    name: ex.name, <span class="comment">// e.g. ReferenceError</span></span><br><span class="line">    message: ex.line, <span class="comment">// e.g. x is undefined</span></span><br><span class="line">    url: <span class="built_in">document</span>.location.href,</span><br><span class="line">    stack: ex.stack <span class="comment">// stacktrace string; remember, different per-browser!</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  $.post(<span class="string">'/logger/js/'</span>, &#123;</span><br><span class="line">    data: errorData</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，如果必须跨源传输错误，则报告端点需要支持CORS（跨源资源共享）。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.sentry.io/2016/05/17/what-is-script-error" target="_blank" rel="noopener">什么是脚本错误</a></li><li><a href="https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror.html" target="_blank" rel="noopener">window.onerror捕获错误</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你已经做到这一点，那么你现在可以拥有所需的所有工具来推送自己的基本错误报告库并将其与你的应用程序集成：</p><ul><li>window.onerror的工作原理以及它支持的浏览器</li><li>如何使用try / catch来捕获缺少window.onerror的堆栈跟踪</li><li>将错误数据传输到你的服务器</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;从脚本错误开始，了解脚本为什么会报错以及抛出错误，最后介绍了用window.onerror、try catch捕获错误。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.fridolph.top/categories/JavaScript/"/>
    
    
      <category term="JS" scheme="http://blog.fridolph.top/tags/JS/"/>
    
      <category term="Error" scheme="http://blog.fridolph.top/tags/Error/"/>
    
  </entry>
  
  <entry>
    <title>【JS】理解跨域及相关解决方案</title>
    <link href="http://blog.fridolph.top/2018/07/07/%E3%80%90%E8%B7%A8%E5%9F%9F%E3%80%91%E7%90%86%E8%A7%A3%E8%B7%A8%E5%9F%9F%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://blog.fridolph.top/2018/07/07/【跨域】理解跨域及相关解决方案/</id>
    <published>2018-07-07T04:49:03.000Z</published>
    <updated>2024-01-01T03:31:03.835Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写这篇一是为复习，二来是有个良好的总结。对于知识点的理解总是一知半解，不深入，这篇希望在此基础上不断深化加深印象和理解。</p></blockquote><a id="more"></a><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><blockquote><p>A cross-domain solution (CDS) is a means of information assurance that provides the ability to manually or automatically access or transfer between two or more differing security domains.</p></blockquote><p>解决两个安全域之间的信息传递，这个就叫做CDS——跨域解决方案。跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。</p><h3 id="为什么需要跨域"><a href="#为什么需要跨域" class="headerlink" title="为什么需要跨域"></a>为什么需要跨域</h3><p>浏览器有同源策略限制。</p><p>同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p><p>这是一个用于隔离潜在恶意文件的重要安全机制。同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。</p><p>我们要知道协议、域名和端口一致就是同源的就好。这里有点不直观，举例来看好了，以下列出了常见的跨域场景：</p><table><thead><tr><th style="text-align:center">URL</th><th style="text-align:center">说明</th><th style="text-align:center">是否允许通信</th></tr></thead><tbody><tr><td style="text-align:center"><a href="http://www.domain.com/a.js" target="_blank" rel="noopener">http://www.domain.com/a.js</a><br><a href="http://www.domain.com/b.js" target="_blank" rel="noopener">http://www.domain.com/b.js</a><br><a href="http://www.domain.com/lab/c.js" target="_blank" rel="noopener">http://www.domain.com/lab/c.js</a></td><td style="text-align:center">同一域名，不同文件或路径</td><td style="text-align:center">允许</td></tr><tr><td style="text-align:center"><a href="http://www.domain.com:8000/a.js" target="_blank" rel="noopener">http://www.domain.com:8000/a.js</a><br><a href="http://www.domain.com/b.js" target="_blank" rel="noopener">http://www.domain.com/b.js</a></td><td style="text-align:center">同一域名，不同端口</td><td style="text-align:center">不允许</td></tr><tr><td style="text-align:center"><a href="http://www.domain.com/a.js" target="_blank" rel="noopener">http://www.domain.com/a.js</a><br><a href="https://www.domain.com/b.js" target="_blank" rel="noopener">https://www.domain.com/b.js</a></td><td style="text-align:center">同一域名，不同协议</td><td style="text-align:center">不允许</td></tr><tr><td style="text-align:center"><a href="http://www.domain.com/a.js" target="_blank" rel="noopener">http://www.domain.com/a.js</a><br><a href="http://192.168.4.12/b.js" target="_blank" rel="noopener">http://192.168.4.12/b.js</a></td><td style="text-align:center">域名和域名对应相同ip</td><td style="text-align:center">不允许</td></tr><tr><td style="text-align:center"><a href="http://www.domain.com/a.js" target="_blank" rel="noopener">http://www.domain.com/a.js</a><br><a href="http://192.168.4.12/b.js" target="_blank" rel="noopener">http://192.168.4.12/b.js</a></td><td style="text-align:center">域名和域名对应相同ip</td><td style="text-align:center">不允许</td></tr><tr><td style="text-align:center"><a href="http://www.domain.com/a.js" target="_blank" rel="noopener">http://www.domain.com/a.js</a><br><a href="http://x.domain.com/b.js" target="_blank" rel="noopener">http://x.domain.com/b.js</a><br><a href="http://domain.com/c.js" target="_blank" rel="noopener">http://domain.com/c.js</a></td><td style="text-align:center">主域相同，子域不同</td><td style="text-align:center">不允许</td></tr><tr><td style="text-align:center"><a href="http://www.domain1.com/a.js" target="_blank" rel="noopener">http://www.domain1.com/a.js</a><br><a href="http://www.domain2.com/b.js" target="_blank" rel="noopener">http://www.domain2.com/b.js</a></td><td style="text-align:center">不同域名</td><td style="text-align:center">不允许</td></tr></tbody></table><p>data：URLs获得一个新的，空的安全上下文。</p><p>在页面中用 about:blank 或 javascript: URL 执行的脚本会继承打开该 URL 的文档的源，因为这些类型的 URLs 没有明确包含有关原始服务器的信息。</p><h2 id="避免同源限制"><a href="#避免同源限制" class="headerlink" title="避免同源限制"></a>避免同源限制</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>同源网页的Cookie才能共享，但是两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享cookie</p><blockquote><p>该方法只适用于Cookie和iframe窗口。 localStorage和IndexDB无法通过这种方法规避，而要使用PostMessage API</p></blockquote><p>另外，服务器也可以在设置cookie时，指定cookie所属域名为一级域名</p><pre><code>Set-Cookie: key=value; domain=.example.com; path=/</code></pre><p>这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie</p><h3 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h3><p>如果两个网页不同源，就无法拿到对方的DOM，典型例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。</p><p>如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的document.domain属性，就可以规避同源政策，拿到DOM。</p><p>对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。</p><ul><li>片段识别符 fragment identifier</li><li>window.name</li><li>跨文档通信API Cross-document messaging</li></ul><ol><li>片段识别符</li></ol><p>片段识别符指的是 url的#号后面部分，如果只是改变片段标识符，页面不会重新刷新。父窗口可以把信息，写入子窗口的片段标识符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> src = originURL + <span class="string">'#'</span> + data</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'myIframe'</span>).src = src</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子窗口通过监听hashchange事件得到通知</span></span><br><span class="line"><span class="built_in">window</span>.onhashchange = checkMessage</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkMessage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> message = <span class="built_in">window</span>.location.hash</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样子窗口也可以改变父窗口的片段标识符</p><pre><code>parent.location.href = target + &apos;#&apos; + hash</code></pre><ol><li>window.name</li></ol><p>浏览器窗口有window.name属性。这个属性最大特点是，无论是否同源，只要是在同一个窗口里，前一个网页设置里这个属性，后一个网页可以读取它。</p><p>父窗口先打开一个子窗口，载入一个不同源的页面，该页面将信息写入window.name属性</p><pre><code>window.name = data</code></pre><p>接着，子窗口跳回一个与主窗口同域的网址</p><pre><code>location = &apos;http://parent.url.com/xxx.html&apos;</code></pre><p>然后，主窗口就可以读取子窗口的window.name了</p><pre><code>var data = document.getElementById(&apos;myFrame&apos;).contentWindow.name</code></pre><p>该方法的优点是，window.name容量很大，可以放置很长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能。</p><p><strong>document.domain</strong></p><p>通过修改document的domain属性，我们可以在域和子域或者不同的子域之间通信。同域策略认为域和子域隶属于不同的域，比如<a href="http://www.a.com和sub.a.com是不同的域，这时，我们无法在www.a.com下的页面中调用sub.a.com中定义的JavaScript方法。但是当我们把它们document的domain属性都修改为a.com，浏览器就会认为它们处于同一个域下，那么我们就可以互相调用对方的method来通信了。" target="_blank" rel="noopener">www.a.com和sub.a.com是不同的域，这时，我们无法在www.a.com下的页面中调用sub.a.com中定义的JavaScript方法。但是当我们把它们document的domain属性都修改为a.com，浏览器就会认为它们处于同一个域下，那么我们就可以互相调用对方的method来通信了。</a></p><ol><li>window.postMessage</li></ol><p>上两种都属于抖机灵操作，HTML为解决该问题，引入了一个全新的API，跨文档通信API Cross-document messaging</p><p>该API为window对象新增了一个<code>window.postMessage</code>方法，允许跨窗口通信，无论这两个窗口是否同源</p><p>举例来说，父窗口<a href="http://aaa.com向子窗口http://bbb.com发消息，调用postMessage方法就可以了。" target="_blank" rel="noopener">http://aaa.com向子窗口http://bbb.com发消息，调用postMessage方法就可以了。</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> popup = <span class="built_in">window</span>.open(<span class="string">'http://bbb.com'</span>, title)</span><br><span class="line">popup.postMessage(<span class="string">'hello world'</span>, <span class="string">'http://bbb.com'</span>)</span><br></pre></td></tr></table></figure><p>postMessage方法的第一个参数是具体的信息内容，第二个参数是接受消息的窗口的源origin，即协议+域名+端口。也可以设为*，表示不限制域名，向所有窗口发送。</p><p>子窗口向父窗口发送消息的写法类似：</p><pre><code>widnow.opener.postMessage(&apos;Nice to see you&apos;, &apos;http://aaa.com&apos;)</code></pre><p>父窗口和子窗口都可以通过message事件，监听对方的消息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h3 id="server-proxy"><a href="#server-proxy" class="headerlink" title="server proxy"></a>server proxy</h3><p>在数据提供方没有提供对JSONP协议或者window.name协议的支持，也没有对其它域开放访问权限时，我们可以通过server proxy的方式来抓取数据。</p><p>例如当<a href="http://www.a.com域下的页面需要请求www.b.com下的资源文件asset.txt时，直接发送一个指向www.b.com/asset.txt的Ajax请求肯定是会被浏览器阻止。这时，我们在www.a.com下配一个代理，然后把Ajax请求绑定到这个代理路径下，例如www.a.com/proxy/" target="_blank" rel="noopener">www.a.com域下的页面需要请求www.b.com下的资源文件asset.txt时，直接发送一个指向www.b.com/asset.txt的Ajax请求肯定是会被浏览器阻止。这时，我们在www.a.com下配一个代理，然后把Ajax请求绑定到这个代理路径下，例如www.a.com/proxy/</a>, 然后这个代理发送HTTP请求访问<a href="http://www.b.com下的asset.txt，跨域的HTTP请求是在服务器端进行的，客户端并没有产生跨域的Ajax请求。这个跨域方式不需要和目标资源签订协议，带有侵略性，另外需要注意的是实践中应该对这个代理实施一定程度的保护，比如限制他人使用或者使用频率。" target="_blank" rel="noopener">www.b.com下的asset.txt，跨域的HTTP请求是在服务器端进行的，客户端并没有产生跨域的Ajax请求。这个跨域方式不需要和目标资源签订协议，带有侵略性，另外需要注意的是实践中应该对这个代理实施一定程度的保护，比如限制他人使用或者使用频率。</a></p><h2 id="Ajax跨域"><a href="#Ajax跨域" class="headerlink" title="Ajax跨域"></a>Ajax跨域</h2><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老实浏览器全部支持，服务器改造小。</p><p>它的基本思想是，网页通过添加一个<code>script</code>标签，向服务器请求json数据，这种做法不受同源策略限制；服务器接受请求后，将数据放在一个指定名字的回调里传回来</p><p>首先，网页动态插入<code>script</code>元素，由它向跨源网址发出请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addScriptTag</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElmement(<span class="string">'script'</span>)</span><br><span class="line">  script.src = src</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  addScriptTag(<span class="string">'http://example.com/ip=0.0.0.0?callback=foo'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'your public IP address is: '</span> + data.ip)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>script</code>元素请求的脚本， 直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为js对象，而不是字符串，因此避免了使用JSON.parse的步骤</p><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p><code>WebSocket</code>是一种通信协议，使用ws:// (非加密) 和 wss:// (加密) 作为协议前缀。该协议不实行同源限制，只要服务器支持，就可以使用它进行跨源通信。</p><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。</p><p>我们来看下例子，下面是前端部分代码：(原生WebSocket API使用起来不太方便，我们使用Socket.io)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>user: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"text"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./socket.io.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> socket = io(<span class="string">'http://www.domain2.com:8080'</span>)</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 连接成功处理</span></span></span><br><span class="line"><span class="javascript">  socket.on(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 监听服务端消息</span></span></span><br><span class="line"><span class="javascript">    socket.on(<span class="string">'message'</span>, msg =&gt; &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'data from server: '</span> + msg)</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>).onblur = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    socket.send(<span class="keyword">this</span>.value)</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>node.js socket 部分实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> socket = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)</span><br><span class="line"><span class="comment">// 启http服务</span></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'text/html'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  res.end()</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">8080</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'server is running at port 8080'</span>)</span><br><span class="line"><span class="comment">// 监听socket连接</span></span><br><span class="line">socket.listen(server).on(<span class="string">'connection'</span>, client =&gt; &#123;</span><br><span class="line">  <span class="comment">// 接受消息</span></span><br><span class="line">  client.on(<span class="string">'message'</span>, msg =&gt; &#123;</span><br><span class="line">    client.send(<span class="string">'hello: '</span> + msg)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'data from client: '</span> + msg)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 断开处理</span></span><br><span class="line">  client.on(<span class="string">'disconnect'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'client socket has closed.'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>下例是浏览器发出的WebSocket请求的头信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP /1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http://example.com</span><br></pre></td></tr></table></figure><p>上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。</p><p>正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS是一个W3C标准，全称是”跨域资源共享” Cross Origin Resource Share，它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</p><blockquote><p>实现CORS通信的关键是服务端，只要服务端实现了CORS接口，就可以跨源通信</p></blockquote><p>具体看软一峰老师这篇就好<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></p><p>CORS目前是跨域的主流解决方案，相比JSONP更为强大。JSONP只支持GET请求，而CORS支持所有类型的HTTP请求。但是JSONP有优势在于兼容性，所以还是需要根据场景来决定是否使用该方案。</p><h3 id="nginx代理跨域"><a href="#nginx代理跨域" class="headerlink" title="nginx代理跨域"></a>nginx代理跨域</h3><p><strong>nginx配置解决iconfont跨域</strong></p><p>浏览器跨域访问JS、CSS、img等常规静态资源被同源策略许可，但iconfont字体文件例外，此时可在nginx的静态资源服务器中加入以下配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  add_header Access-Control-Allow-Origin: *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>nginx反向代理跨域接口</strong></p><p>跨域原理：同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略也就不存在跨域问题了。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做桥接，反向代理访问domain2接口，并且可顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。下面是具体配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># proxy服务器</span></span><br><span class="line">server &#123;</span><br><span class="line">  listen 81;</span><br><span class="line">  server_name www.domain1.com;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://www.domain2.com:8080; <span class="comment"># 反向代理</span></span><br><span class="line">    proxy_cookie_domain www.domain2.com www.domain1.com; <span class="comment"># 修改cookie里域名</span></span><br><span class="line">    index index.html index.htm;</span><br><span class="line">    <span class="comment"># 当用webpack-dev-server等中间件代理接口访问nginx时，此时无浏览器参与</span></span><br><span class="line">    <span class="comment"># 所以没有同源限制，下面的跨域配置可不启用</span></span><br><span class="line">    add_header Access-Control-Allow-Origin http://www.domain1.com; <span class="comment"># 当前端只跨域不带cookie时，可为 *</span></span><br><span class="line">    add_header Access-Control-Allow-Credentails <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="comment">// 前端开关，浏览器是否读写cookie</span></span><br><span class="line">xhr.withCredentails = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 访问nginx中的代理服务器</span></span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'http://www.domain1.com:81/?user=admin'</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure><p>node.js后台示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> server = http.createServer()</span><br><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>)</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> params = qs.parse(req.url.substring(<span class="number">2</span>))</span><br><span class="line">  <span class="comment">// 向前台写cookie</span></span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">'Set-Cookie'</span>: <span class="string">'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'</span></span><br><span class="line">    <span class="comment">// 设置HttpOnly 前端无法通过document.cookie读取</span></span><br><span class="line">  &#125;)</span><br><span class="line">  res.write(<span class="built_in">JSON</span>.stringify(params))</span><br><span class="line">  res.end()</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">8080</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'server is running at port 8080'</span>)</span><br></pre></td></tr></table></figure><h2 id="常见安全问题及思考"><a href="#常见安全问题及思考" class="headerlink" title="常见安全问题及思考"></a>常见安全问题及思考</h2><h3 id="JSONP导致的安全问题"><a href="#JSONP导致的安全问题" class="headerlink" title="JSONP导致的安全问题"></a>JSONP导致的安全问题</h3><p>我们知道，一切用户输入都是“有害”的。传入callback值会在结果里面直接返回。因此，如果该参数过滤不严格，会导致XSS</p><ol><li>Callback可自定义导致的安全问题</li></ol><p>当输出 JSON 时，没有严格定义好 Content-Type（ Content-Type: application/json ）然后加上 callback 这个输出点没有进行过滤直接导致了一个典型的 XSS 漏洞。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">v</span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">  alert(v.name);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://0.0.0.0/1.php?callback=test"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$callback = $_GET[<span class="string">'callback'</span>]</span><br><span class="line"><span class="keyword">print</span> $callback.<span class="string">'(&#123; "id": "1", "name": "vincent" &#125;);'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>对于这种漏洞，主要修复手段：</p><ul><li>严格定义 <code>Content-Type: application/json</code></li><li>过滤callback以及JSON数据输出(针对输出结果进行转码处理)</li></ul><ol><li>json劫持</li></ol><p>json劫持属于CSRF的范畴。攻击者可以在自己的站点中写入一条访问JSON的JS，在用户cookie未过期的情况下，JSON中会返回敏感的用户信息，然后攻击者可以获取到数据，并发送到自己的站点</p><p>敏感数据获取程序如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// alert(v.name)</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> url = <span class="string">'http://0.0.0.0/'</span> + <span class="built_in">JSON</span>.stringify(data)</span></span><br><span class="line"><span class="javascript">  xhr.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>)</span></span><br><span class="line"><span class="undefined">  xhr.send()</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://x.x.x.x/1.php?callback=test"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是<code>Content-Type</code>和<code>X-Content-Type-Options</code>头，如果在API请求的响应标头中，<code>X-Content-Type-Options</code>设置为<code>nosniff</code>，则必须将<code>Content-Type</code>设置为 JS(text/javascript、application/javascript, text/ecmascript)来在所有浏览器上生效。这是因为通过在响应中包含回调，响应不再是JSON，而是JavaScript</p><p>若配置</p><pre><code>header(&apos;Content-type: application/json; chartset=utf-8&apos;)header(&apos;X-Content-Type-Options: nosniff&apos;)</code></pre><p>console输入如下：</p><pre><code>Refused to execute script from &apos;http://10.59.0.248/1.php?callback=test&apos; because its MIME type (&apos;application/json&apos;) is not executable, and strict MIME type checking is enabled.</code></pre><p>常见的修复方案：</p><ol><li>Referer正则匹配</li></ol><p>常见的有Referer匹配正则编写错误导致正则绕过。（一般情况下浏览器直接访问某URL是不带Referer的，所以很多防御部署是允许空Referer的）</p><ol><li>添加Token</li><li>放弃使用jsonp跨域获取数据，使用CORS或PostMessage</li></ol><h3 id="CORS的安全性问题"><a href="#CORS的安全性问题" class="headerlink" title="CORS的安全性问题"></a>CORS的安全性问题</h3><p>重点参考这篇</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#" target="_blank" rel="noopener">MDN HTTP访问控制（CORS）</a></p><p><a href="https://dailc.github.io/2018/01/04/security_ajaxissafeornot.html" target="_blank" rel="noopener">AJAX请求真的不安全么？谈谈Web安全与AJAX的关系</a></p><p>Access-Control-Allow-Origin就是一个允许请求的域白名单，只有是这个域里有的，服务器才会统一跨域请求，如果合理的设置白名单，反而可以避免CSRF攻击。</p><p>设置成*的一般是公共的API，为了避免被频繁请求或DDOS，一般会多出密钥验证的步骤，并且限制请求频率和次数。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">浏览器同源政策及其规避方法</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></li><li><a href="http://www.cnblogs.com/hustskyking/archive/2013/03/31/CDS-introduce.html" target="_blank" rel="noopener">JavaScript跨域（1）：什么是跨域，如何跨域</a></li><li><a href="http://www.cnblogs.com/hustskyking/articles/ten-methods-cross-domain.html" target="_blank" rel="noopener">跨域资源共享的10种方式</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#" target="_blank" rel="noopener">MDN HTTP访问控制（CORS）</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/domain#helloworld" target="_blank" rel="noopener">MDN - Document.domain</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">MDN - 浏览器的同源策略</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#" target="_blank" rel="noopener">MDN HTTP访问控制（CORS）</a></li><li><a href="https://dailc.github.io/2018/01/04/security_ajaxissafeornot.html" target="_blank" rel="noopener">AJAX请求真的不安全么？谈谈Web安全与AJAX的关系</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写这篇一是为复习，二来是有个良好的总结。对于知识点的理解总是一知半解，不深入，这篇希望在此基础上不断深化加深印象和理解。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.fridolph.top/categories/JavaScript/"/>
    
    
      <category term="跨域" scheme="http://blog.fridolph.top/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="面试" scheme="http://blog.fridolph.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【JS】学习正则表达式</title>
    <link href="http://blog.fridolph.top/2018/06/29/%E3%80%90JS%E3%80%91%E5%AD%A6%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://blog.fridolph.top/2018/06/29/【JS】学习正则表达式（一）/</id>
    <published>2018-06-29T09:49:03.000Z</published>
    <updated>2024-01-01T07:23:48.507Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近因工作用到了，顺便查看了一些关于正则的博客，确实非常使用。学好正则看来是以后的一个必选项，趁着最近时间挺充裕的，于是系统的入门了一下，也算是能手写几个简单的正则来匹配规则了。</p></blockquote><a id="more"></a><h3 id="子字符串匹配和替换"><a href="#子字符串匹配和替换" class="headerlink" title="子字符串匹配和替换"></a>子字符串匹配和替换</h3><p>如果只想知道某个字符串是否包含在一个更大的字符串中，下面的 String.prototype 方法就可以实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="string">'As I was going to Saint Ives'</span></span><br><span class="line">input.startsWith(<span class="string">'As'</span>) <span class="comment">// true</span></span><br><span class="line">input.endsWith(<span class="string">'Ives'</span>) <span class="comment">// true</span></span><br><span class="line">input.startsWith(<span class="string">'going'</span>, <span class="number">9</span>) <span class="comment">// true - 从下标9开始数</span></span><br><span class="line">input.endsWith(<span class="string">'going'</span>, <span class="number">14</span>) <span class="comment">// true - 将下标14当作字符串结尾</span></span><br><span class="line">input.includes(<span class="string">'going'</span>) <span class="comment">// true</span></span><br><span class="line">input.includes(<span class="string">'going'</span>, <span class="number">10</span>) <span class="comment">// false - 从下标10开始</span></span><br><span class="line">input.indexOf(<span class="string">'going'</span>) <span class="comment">// 9</span></span><br><span class="line">input.indexOf(<span class="string">'going'</span>, <span class="number">10</span>) <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 若想进一步操作，如替换掉刚才匹配的字符串，可以使用String.prototype.replace</span></span><br><span class="line"><span class="keyword">const</span> output = input.replace(<span class="string">'going'</span>, <span class="string">'walking'</span>)</span><br></pre></td></tr></table></figure><h3 id="构造正则表达式"><a href="#构造正则表达式" class="headerlink" title="构造正则表达式"></a>构造正则表达式</h3><p>在 JS 中，正则可以通过 RegExp 类来表示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re1 = <span class="regexp">/going/</span> <span class="comment">// 可以搜索 'going'的正则表达式</span></span><br><span class="line"><span class="keyword">const</span> re2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'going'</span>) <span class="comment">// 使用对象构造器的等价形式</span></span><br></pre></td></tr></table></figure><h3 id="使用正则进行搜索"><a href="#使用正则进行搜索" class="headerlink" title="使用正则进行搜索"></a>使用正则进行搜索</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="string">'As I was going to Saint Ives'</span></span><br><span class="line"><span class="keyword">const</span> re = <span class="regexp">/\w&#123;3,&#125;/gi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串(input)开始</span></span><br><span class="line">input.match(re) <span class="comment">// ['was', 'going', 'Saint', 'Ives']</span></span><br><span class="line">input.search(re) <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从正则表达式开始(re)</span></span><br><span class="line">re.test(input) <span class="comment">// true - input至少包含一个三个字母的单词</span></span><br><span class="line">re.exec(input) <span class="comment">// ['was'] (第一个匹配)</span></span><br><span class="line">re.exec(input) <span class="comment">// ['going'] (exec会记住它所在的位置)</span></span><br><span class="line">re.exec(input) <span class="comment">// ['Saint']</span></span><br><span class="line">re.exec(input) <span class="comment">// ['Ives']</span></span><br><span class="line">re.exec(input) <span class="comment">// null - 匹配完毕</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，所有这些方法都可以直接使用字面量语法</span></span><br><span class="line">input.match(<span class="regexp">/\w&#123;3,&#125;/gi</span>)</span><br><span class="line">input.search(<span class="regexp">/\w&#123;3,&#125;/gi</span>)</span><br><span class="line">;<span class="regexp">/\w&#123;3,&#125;/gi</span>.test(input)</span><br><span class="line">;<span class="regexp">/\w&#123;3,&#125;/gi</span>.exec(input)</span><br></pre></td></tr></table></figure><h3 id="使用正则表达式进行替换"><a href="#使用正则表达式进行替换" class="headerlink" title="使用正则表达式进行替换"></a>使用正则表达式进行替换</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="string">'As I was going to Saint Ives'</span></span><br><span class="line"><span class="keyword">const</span> output = input.replace(<span class="regexp">/\w&#123;3,&#125;/gi</span>, <span class="string">'****'</span>)</span><br></pre></td></tr></table></figure><h3 id="匹配-HTML"><a href="#匹配-HTML" class="headerlink" title="匹配 HTML"></a>匹配 HTML</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> html1 = <span class="string">`</span></span><br><span class="line"><span class="string">  HTML width &lt;a href="/one"&gt;one link&lt;/a&gt;, and some JavaScript.</span></span><br><span class="line"><span class="string">  &lt;script src="strff.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> matches = html.match(<span class="regexp">/&lt;area|&lt;a|&lt;link|&lt;script|&lt;source/gi</span>)</span><br></pre></td></tr></table></figure><p>要了解的是，现在来说正则表达式不能解析 HTML。为解决这个问题，需引入一个解析器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> html2 = <span class="string">'&lt;br&gt; [!CDATA[&lt;br&gt;]]'</span></span><br><span class="line"><span class="keyword">const</span> matches = html.match(<span class="regexp">/&lt;br&gt;/gi</span>) <span class="comment">// ['&lt;br&gt;', '&lt;br&gt;']</span></span><br></pre></td></tr></table></figure><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>字符集提供了一种简洁的方式，来表达单个字符的分支。如果想在一个字符串中查找所有的数字，可以使用分支：</p><p><strong>具名字符集</strong></p><p>\d [0-9]<br>\D [^0-9]<br>\s [\t\v\n \r] 包含制表符、空格和垂直制表符<br>\S [^\t\v\n \r]<br>\w [a-zA-Z_] 破折号和句号没有被包含进来，所以它不能用于域名和 CSS 类<br>\W [^a-za-z_]</p><h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><p><strong>重复修饰符</strong></p><p><code>{n}</code> 精确 n 次<br>/\d{5}/ 匹配 5 位数字</p><p><code>{n,}</code> 至少 n 次<br>/\d{5,}/ 匹配 5 位或 5 位以上数字</p><p><code>{n, m}</code> 最少 n 次，最多 m 次<br>/\d{2,5}/ 匹配 2 到 5 位数字</p><p><code>?</code> 0 或 1 次，等价于{0,1}<br>/[a-z]\d?/i 匹配跟随了 0 个或 1 个数字的字符</p><p><code>*</code> 0 次或多次<br>/[a-z]\d*/i 匹配跟随了 0 个或多个数字的字母</p><p><code>+</code> 1 次或多次<br>/[a-z]\d+/i 匹配了至少跟随了 1 个数字的字母</p><h3 id="句点元字符和转义"><a href="#句点元字符和转义" class="headerlink" title="句点元字符和转义"></a>句点元字符和转义</h3><p>在正则中，句点是一个特殊的字符，表示“匹配任何内容”（除了新的一行）。通常，这个匹配一切的元字符用来消费哪些输入中并不关心的内容。</p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>到目前为止，所构造的正则能够识别单个字符（重复允许多次匹配，但这依旧是一个单字符匹配）。而分组则允许构造子表达式，它可以被当作一个独立单元来使用。</p><p>除了创建子表达式，分组还可以帮助“捕获”分组结果，以便后续使用。<br>“捕获”结果是默认功能，不过也有办法创建“非捕获组”，这也是接下来要学习的内容。</p><p>分组是使用圆括号来指定的，非捕获组看起来像 <code>(?:&lt;subexpression&gt;)</code>，其中<subexpression>是需要匹配的内容</subexpression></p><p>看组例子，假设现在要匹配的后缀为.com .org .edu 的域名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">'Visit oreilly.com today!'</span></span><br><span class="line"><span class="keyword">const</span> match = text.match(<span class="regexp">/[a-z]+(?:\.com|\.org|\.edu)/i</span>)</span><br></pre></td></tr></table></figure><p>分组的另一个好处是可以在分组时使用重复。一般情况下，重复仅被用在重复元字符前面的单个字符上。分组则允许将其用在一整个字符串上。有一个常见的例子是，如果想匹配 URL,以及那些以http://或https://（独立于协议的URL）开始的URL，可以在分组上使用代表匹配0个或1个<code>?</code>的重复元字符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;link rel="stylesheet" href="http://insecure.com/stuff.css"&gt;</span></span><br><span class="line"><span class="string">  &lt;link rel="stylesheet" href="https://secure.com/securestuff.css"&gt;</span></span><br><span class="line"><span class="string">  &lt;link rel="stylehseet" href="//anything.comflexible.css"&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> matches = html.match(<span class="regexp">/(?:https?)?\/\/[a-z][a-z0-9-]+[a-z0-9]+/gi</span>)</span><br></pre></td></tr></table></figure><p>以一个非捕获组开始 (?:https?)? ，注意这里有两个匹配 0 或 1 个的重复元字符</p><p>第一个表示 https 的 s 是可选的（一般情况下重复元字符只作用于它左边最近的字符）第二个指向它左边的整个组（整体来看，它会匹配空字符串：没有 https、http 或者 https）</p><p>继续执行，匹配了两个斜杠 \/\/ (必须对斜杠进行转义)<br>然后得到了一个复杂的字符类。</p><blockquote><p>需要记住一点，使用正则时并不需要一次做完所有事情。事实上，每当浏览网站时，可以先找出所有 URL 或疑似 URL 的东西，然后做二次分析，筛选出那些非法或不完整的 URL 等。 但，为防止注入攻击而检查用户输入等情况就要让正则滴水不漏</p></blockquote><hr><h3 id="懒惰匹配、贪婪匹配"><a href="#懒惰匹配、贪婪匹配" class="headerlink" title="懒惰匹配、贪婪匹配"></a>懒惰匹配、贪婪匹配</h3><p>例：html 文本，想将其中的<code>&lt;i&gt;</code>标签替换成<code>&lt;source&gt;</code>标签，下面是第一次尝试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = <span class="string">`</span></span><br><span class="line"><span class="string">  Regex pros know the difference between</span></span><br><span class="line"><span class="string">  &lt;i&gt;greedy&lt;/i&gt; and &lt;i&gt;lazy&lt;/i&gt; matching.</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">input.replace(<span class="regexp">/&lt;i&gt;(.*)&lt;\/i&gt;/gi</span>, <span class="string">'&lt;strong&gt;$1&lt;/strong&gt;'</span>)</span><br><span class="line"><span class="comment">// Regex pros know the difference between</span></span><br><span class="line"><span class="comment">// &lt;strong&gt;greedy&lt;/i&gt; and &lt;i&gt;lazy&lt;/strong&gt; matching.</span></span><br></pre></td></tr></table></figure><p>我们认识一下正则表达式引擎的工作方式，它只有在找到符合要求的匹配后，才会消费输入并且继续运行。默认情况下，它是通过贪婪模式来实现的，它会找到第一个<code>&lt;i&gt;</code>，然后，在找到<code>&lt;/i&gt;</code>并且确定在这个<code>&lt;/i&gt;</code>之后不存在同样的<code>&lt;/i&gt;</code>，查找都不会停止。因为这里有两个<code>&lt;/i&gt;</code>，所以正则会匹配到第二个<code>&lt;/i&gt;</code>，而非第一个。</p><p>这里可以使用重复元字符 * 将其转换成懒惰匹配来解决，在后面添加一个问号即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = <span class="string">`</span></span><br><span class="line"><span class="string">  Regex pros know the difference between</span></span><br><span class="line"><span class="string">  &lt;i&gt;greedy&lt;/i&gt; and &lt;i&gt;lazy&lt;/i&gt; matching.</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">input.replace(<span class="regexp">/&lt;i&gt;(.*?)&lt;\/i&gt;/gi</span>, <span class="string">'&lt;strong&gt;$1&lt;/strong&gt;'</span>)</span><br></pre></td></tr></table></figure><p>与之前相比，该正则除了在*后面加了一个问号，其他完全一样。</p><p>所有的重复元字符： _ + ？ {n} {n, } {n, m}都可以在后面跟随一个问号将它变成懒惰的（虽然在实践中，通常只把它和_ + 一起使用过）</p><h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>先由简单例子入手，假设想匹配符合 XYXY 格式的乐队名字，所以当希望匹配（PJJP、GOOG、ANNA）这些乐队名时，反向引用就可以登场了。正则表达式中的每个组（包括子组）都被分配了一个数字，从左到右依次是 1，2，3…可以通过在反斜杠后加一个数字的方式来引用特定的组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promo = <span class="string">'Opening for XAAX is the dynamic GOOG! At the box office now !'</span></span><br><span class="line"><span class="keyword">const</span> bands = promo.match(<span class="regexp">/(?:[A-Z])(?:[A-Z])/g</span>)</span><br><span class="line"><span class="comment">// 使用重音符，是因为我们将单引号和双引号都用过了</span></span><br><span class="line"><span class="keyword">const</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;img alt="A 'simple' example."&gt;</span></span><br><span class="line"><span class="string">  &lt;img alt="Don't abuse it!"&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> matches = html.match(<span class="regexp">/&lt;img alt=(?:['"]).*?/g</span>)</span><br></pre></td></tr></table></figure><h3 id="替换组"><a href="#替换组" class="headerlink" title="替换组"></a>替换组</h3><p>分组带来的好处是，可以利用它做一些更加复杂的替换，继续看 HTML 的例子，加入想要去掉一个<code>&lt;a&gt;</code>标签中除了 href 以外的内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> html = <span class="string">`&lt;a class="nope" href="/yep"&gt;Yep&lt;/a&gt;`</span></span><br><span class="line"><span class="keyword">let</span> str = html.replace(<span class="regexp">/&lt;a .*?(href=".*?").*?/</span>, <span class="string">'&lt;a $1&gt;'</span>)</span><br><span class="line"><span class="comment">// str -&gt; "&lt;a href="/yep"&gt;&gt;Yep&lt;/a&gt;"</span></span><br></pre></td></tr></table></figure><p>所有的组都被分配了一个从 1 开始的数字，这个正则表达式中，通过\1 来引用第一个组；而在替换字符串上，用的是$1。注意，在这个表达式中使用懒惰量词是为了防止它在匹配时跨域多个<code>&lt;a&gt;</code>标签。不过，如果<code>&lt;a&gt;</code>标签的 href 属性使用的是单引号而非双号，也会匹配失败。</p><p>下面来扩展这个例子，希望保持 class 和 href，依旧删除其他元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> html = <span class="string">`&lt;a class="yep" href="/yep" id="nope"&gt;Yep&lt;/a&gt;`</span></span><br><span class="line"><span class="keyword">let</span> str = html.replace(<span class="regexp">/&lt;a .*?(class=".*?").*?(href=".*?").*?&gt;/</span>, <span class="string">'&lt;a $2 $1&gt;'</span>)</span><br></pre></td></tr></table></figure><p>注意在这个表达式中，将 class 和 href 的顺序颠倒了，使得 href 始终先出现，这个表达啊是的问题在于 class 和 href 始终要保持相同的顺序，并且，一旦<code>&lt;a&gt;</code>标签中的属性使用了单引号，就会匹配失败</p><p>除了$1,$2,$3…这些组引用，还有$` 匹配项之前的所有内容， $&amp; 匹配目标本身， $’匹配项之后的所有内容，如果想使用一个美元符号，可以使用$$:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="string">'One two three'</span></span><br><span class="line">input.replace(<span class="regexp">/two/</span>, <span class="string">'($`)'</span>) <span class="comment">// "One (One ) three"</span></span><br><span class="line">input.replace(<span class="regexp">/\w+/g</span>, <span class="string">'($&amp;)'</span>) <span class="comment">// "(One) (two) (three)"</span></span><br><span class="line">input.replace(<span class="regexp">/two/</span>, <span class="string">"($')"</span>) <span class="comment">// "One ( three) three"</span></span><br><span class="line">input.replace(<span class="regexp">/two/</span>, <span class="string">'($$)'</span>) <span class="comment">// "One ($) three"</span></span><br></pre></td></tr></table></figure><h3 id="函数替换"><a href="#函数替换" class="headerlink" title="函数替换"></a>函数替换</h3><p>这是正则最棒的一个特性之一，因为它允许将一个非常复杂的正则表达式拆分成一些简单的表达式。</p><p>再来看一个实际修改 HTML 的例子：希望保留 class, id, href 属性并删除其他内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;a class="foo" href="/foo" id="foo"&gt;Foo&lt;/a&gt;</span></span><br><span class="line"><span class="string">  &lt;A href='/foo' Class="foo"&gt;Foo&lt;/a&gt;</span></span><br><span class="line"><span class="string">  &lt;a href="/foo"&gt;Foo&lt;/a&gt;</span></span><br><span class="line"><span class="string">  &lt;a onclick="javascript:alert('foo!')" href="/foo"&gt;Foo&lt;/a&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>用正则来实现感觉很麻烦，因为变化太多！确实，不过之前说过，并不一定要一次到位。可以通过将表达式拆分成两个，从而大大减少变化的数量：一个用于识别<code>&lt;a&gt;</code>标签，而另一个用于将<code>&lt;a&gt;</code>替换成期望的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sanitizeATag</span>(<span class="params">aTag</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取标签</span></span><br><span class="line">  <span class="keyword">const</span> parts = aTag.match(<span class="regexp">/&lt;a\s+(.*?)&gt;(.*?)&lt;\/a&gt;/i</span>)</span><br><span class="line">  <span class="comment">// parts[1]是&lt;a&gt;标签中间的属性</span></span><br><span class="line">  <span class="comment">// parts[2]是&lt;a&gt;和&lt;/a&gt;中间的内容</span></span><br><span class="line">  <span class="keyword">const</span> attributes = parts[<span class="number">1</span>]</span><br><span class="line">    <span class="comment">// 接下来将其分割成独立的属性</span></span><br><span class="line">    .split(<span class="regexp">/\s+/</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&lt;a <span class="subst">$&#123;attributes</span></span></span><br><span class="line"><span class="string"><span class="subst">    .filter(attr =&gt; <span class="regexp">/^(?:class|id|href)[\s=]/i</span>.test(attr))</span></span></span><br><span class="line"><span class="string"><span class="subst">    .join(<span class="string">' '</span>)&#125;</span>&gt;</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;parts[<span class="number">2</span>]&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/a&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数比想象中要长，不过为了更加清晰，可以将它分成不同的部分。注意即使在这个函数中，依旧使用了多个正则表达式：一个用来匹配<code>&lt;a&gt;</code>，一个用来切割（使用一个正则表达十来识别一个或多个空格字符）字符串，还有一个用来过滤期望的属性。如果只用一个正则表达式来完成这些工作将会非常复杂。</p><p>接下来：在一个包含很多<code>&lt;a&gt;</code>的 HTML 块中使用 sanitizeATag 函数，编写一个只匹配<code>&lt;a&gt;</code>的正则表达式就很简单了：</p><pre><code>html.match(/&lt;a .*?&gt;(.*?)&lt;\/a&gt;/ig);</code></pre><p>在匹配时，可以将函数当作一个替换参数传给 String.prototype.replace。目前为止，只 ongoing 过字符串作为替换参数。而使用函数则允许对每一个替换执行一个特定的操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">html.replace(<span class="regexp">/&lt;a .*?&gt;(.*?)&lt;\/a&gt;/gi</span>, <span class="function"><span class="keyword">function</span>(<span class="params">m, g1, offset</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`&lt;a&gt; tag found at <span class="subst">$&#123;offset&#125;</span>. contents: <span class="subst">$&#123;g1&#125;</span>&lt;/a&gt;`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*undefined</span></span><br><span class="line"><span class="comment">  undefined</span></span><br><span class="line"><span class="comment">  undefined</span></span><br><span class="line"><span class="comment">  undefined</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// &lt;a&gt; tag found at 3. contents: Foo&lt;/a&gt;</span></span><br><span class="line"><span class="comment">// &lt;a&gt; tag found at 49. contents: Foo&lt;/a&gt;</span></span><br><span class="line"><span class="comment">// &lt;a&gt; tag found at 86. contents: Foo&lt;/a&gt;</span></span><br><span class="line"><span class="comment">// &lt;a&gt; tag found at 111. contents: Foo&lt;/a&gt;</span></span><br></pre></td></tr></table></figure><p>传给 String.prototype.replace 的函数会按顺序接收以下参数：</p><ul><li>整个匹配的字符串(等价于$&amp;)</li><li>匹配上的组(如果存在)，有多少个组，这种参数就会有多少个</li><li>原始字符串中的匹配偏移量(一个数字)</li><li>原始字符串(很少使用到)</li></ul><p>该函数的返回值就是用来替换正则表达式的字符串。在上例中，没有指定返回值，所以默认返回 undefined。它会被转换成字符串后当作替换字符串使用。上例的重点就是强调这种工作机制，而非真实的转换，所以这里并没有返回最终结果。现在来回顾一下这个例子，有了能够清理单个<code>&lt;a&gt;</code>标签的函数，以及在 HTML 中查找<code>&lt;a&gt;</code>标签的方法，所以可以将它们结合起来使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html.replace(<span class="regexp">/&lt;a .*?&lt;\/a&gt;/gi</span>, sanitizeATag)</span><br></pre></td></tr></table></figure><p>当需要从一个大字符串中匹配小字符串，并且还要对小字符串做额外处理时，都可以通过向<code>String.prototype.replace</code>中传入函数来解决这个问题！</p><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>通常，我们会关心一个字符串的开始和结束，或者整个字符串（而不只是一部分），这时<code>锚点</code>就派上用场了。有两种锚点：分别是用于匹配行开始的<code>^</code>，以及用于匹配行结束的<code>$</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="string">'It was the best of times, it was the worst of times'</span></span><br><span class="line"><span class="keyword">const</span> begin = input.match(<span class="regexp">/^\w+/g</span>) <span class="comment">// "It"</span></span><br><span class="line"><span class="keyword">const</span> end = input.match(<span class="regexp">/\w+$/g</span>) <span class="comment">// "times"</span></span><br><span class="line"><span class="keyword">const</span> everything = input.match(<span class="regexp">/^.*$/g</span>)</span><br><span class="line"><span class="comment">// "It was the best of times, it was the worst of times"</span></span><br><span class="line"><span class="keyword">const</span> nomatch1 = input.match(<span class="regexp">/^best/gi</span>)</span><br><span class="line"><span class="keyword">const</span> nomatch2 = input.match(<span class="regexp">/worst$/gi</span>)</span><br></pre></td></tr></table></figure><p>关于锚点，一般情况下，它匹配的是整个 字符串的开始和末尾，即使字符串中有换行。如果想把某个字符串当作多行字符串（以换行符分隔）来处理，就需要用到 m(多行选项)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="string">'One line\nTwo lines\nThree lines\nFour'</span></span><br><span class="line"><span class="keyword">const</span> begin = input.match(<span class="regexp">/^\w+/gm</span>)</span><br><span class="line"><span class="keyword">const</span> end = input.match(<span class="regexp">/\w+$/gm</span>)</span><br></pre></td></tr></table></figure><h3 id="单词边界匹配"><a href="#单词边界匹配" class="headerlink" title="单词边界匹配"></a>单词边界匹配</h3><p>正则中一个经常被忽视，但却非常有用的特性。类似开始锚点和行末锚点，单词边界匹配的是\b，取反是\B，它不消费输入内容。单词边界界定为一个\w 匹配之前或之后紧挨着一个\W（非单词字符），或字符串的开始或结尾。来看个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inputs = [</span><br><span class="line">  <span class="string">'yinlinshengxiao@gmail.com'</span>,</span><br><span class="line">  <span class="string">'yinlinshengxiao@gmail.com is my email'</span>,</span><br><span class="line">  <span class="string">'my email is yinlinshengxiao@gmail.com'</span>,</span><br><span class="line">  <span class="string">'use yinlinshengxiao@gmail.com, my email'</span>,</span><br><span class="line">  <span class="string">'my email: yinlinshengxiao@gmail.com.'</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">  虽然有多种不同情况，这些邮箱有一个共同点：它们都处在单词边界。</span></span><br><span class="line"><span class="string">  单词边界标记的另一个好处是，因为它们不消费输入，所以不用担心“将它们放回”到替换字符串中：</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> emailMatcher = <span class="regexp">/\b[a-z][a-z0-9._-]*@[a-z][a-z0-9_-]+\.[a-z]+(?:\.[a-z]+)?\b/gi</span></span><br><span class="line">inputs.map(<span class="function"><span class="params">s</span> =&gt;</span> s.replace(emailMatcher, <span class="string">'&lt;a href="mailto:$&amp;"&gt;$&amp;&lt;/a&gt;'</span>))</span><br></pre></td></tr></table></figure><p>当需要搜索以外的单词开始、结束或包含其他单词的文本时，使用单词边界也非常方便。例如：/\bcount/ 会找到 count countdown， 但不会找到 discount recount 等。而 /\bcount\B/只能找到 countdown，/\Bcount\b/会找到 discount 和 recount，而 /\Bcount\B/只能找到 accountable</p><h3 id="向前查找"><a href="#向前查找" class="headerlink" title="向前查找"></a>向前查找</h3><p>与锚点和单词边界元字符一样，它不消费输入。然而，不同于锚点和单词边界的是，它们是通用的，可以匹配任何子表达式却不消费它。事实上，正如单词边界元字符，向前查找的这种不消费的特性，解决了有时候不得不进行“原封不动”的替换问题。只要有内容重复，向前查找就是必须的，而且他们可以简化某些特定类型的匹配。</p><p>例子：验证密码是否符合预设规则</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validPassword</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    /[A-Z]/.test(p) &amp;&amp;</span><br><span class="line">    /[<span class="number">0</span><span class="number">-9</span>]/.test(p) &amp;&amp;</span><br><span class="line">    /[a-z]/.test(p) &amp;&amp;</span><br><span class="line">    !<span class="regexp">/[^a-zA-Z0-9]/</span>.test(p)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 假设想将它们组合成一个正则表达式：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validPassword</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/[A-Z].*[0-9][a-z]/</span>.test(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该表达式对顺序有要求，不仅要求大写字母出现在数字之前，数字出现在两个小写字母前，而且没有对非法字符做任何校验。实际上也没有有个好办法可以实现它，因为字符在正则表达式运行时就被消费了。</p><p><code>向前查找</code>通过不消费输入来解决这个问题，本质上每个向前查找都是一个不消费输入的独立正则表达式，在 JS 中，向前查找是这样的 <code>(?=&lt;subexpression&gt;)</code>, 还有一个“否定向前查找” <code>:(?!&lt;subexpression&gt;)</code> 只会匹配不存在于子表达式中的内容。下面继续来重写上面的验证密码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validPassword</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/(?=.*[A-Z])(?=.*[0-9])(?=.*[a-z])(?!.*[^a-zA-Z0-9])/</span>.test(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该例子展示了向前检查（以及否定向前检查）的一个重要场景。</p><h3 id="动态构造正则表达式"><a href="#动态构造正则表达式" class="headerlink" title="动态构造正则表达式"></a>动态构造正则表达式</h3><p>这里提倡优先使用正则表达式字面语法而非构造器，因为不用对反斜杠进行转义。需要使用构造器的地方是动态构造。例如，想在一个字符串中匹配一个包含多个用户名的数组，但却没有办法将这些用户名整合在一个正则表达式字面量中。此时正则构造器就有用了，它可以通过字符串来构造正则表达式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = [<span class="string">'mary'</span>, <span class="string">'nick'</span>, <span class="string">'arthur'</span>, <span class="string">'sam'</span>, <span class="string">'yevtte'</span>]</span><br><span class="line"><span class="keyword">const</span> text =</span><br><span class="line">  <span class="string">'User @arthur started the backup and 15:15, '</span> +</span><br><span class="line">  <span class="string">'and @nick and @yvette restored it at 18:35.'</span></span><br><span class="line"><span class="keyword">const</span> userRegexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`@(?:<span class="subst">$&#123;users.join(<span class="string">'|'</span>)&#125;</span>)\\b`</span>, <span class="string">'g'</span>)</span><br><span class="line">text.match(userRegexp)</span><br></pre></td></tr></table></figure><p>与该例正则等价的字面量是： <code>/@(?:mary|nick|arthur|sam|yevtte)\b/g</code><br>需要注意的是：必须在 b 单词边界元字符之前使用双反斜杠</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一篇已经涉及了正则表达式中的主要知识点，但对于正则中包含的技术、例子和其固有的复杂性，也只是浅尝辄止。想要深入学习正则表达式，需要更多的练习与理解，那么以后在工作与学习中多多运用进去吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近因工作用到了，顺便查看了一些关于正则的博客，确实非常使用。学好正则看来是以后的一个必选项，趁着最近时间挺充裕的，于是系统的入门了一下，也算是能手写几个简单的正则来匹配规则了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.fridolph.top/categories/JavaScript/"/>
    
    
      <category term="js" scheme="http://blog.fridolph.top/tags/js/"/>
    
      <category term="正则表达式" scheme="http://blog.fridolph.top/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【JS】变量声明与赋值，引用、值传递与对象拷贝</title>
    <link href="http://blog.fridolph.top/2018/06/23/%E3%80%90JS%E3%80%91%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%8E%E8%B5%8B%E5%80%BC%EF%BC%8C%E5%BC%95%E7%94%A8%E3%80%81%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/"/>
    <id>http://blog.fridolph.top/2018/06/23/【JS】变量声明与赋值，引用、值传递与对象拷贝/</id>
    <published>2018-06-23T12:41:02.000Z</published>
    <updated>2024-01-01T07:23:19.899Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>夯实基础系列。虽然想整理之前测试相关的东西，不过最近看书有讲到这个，遂将之前收藏的博客、文章结合书里的讲解做了一些整理和例子来加深这块的印象。（今天也才把测试的看了没来得及整理）</p></blockquote><a id="more"></a><p>ES6 为我们引入了 <code>let</code> 与 <code>const</code> 两种新的变量声明关键字，同时也引入了块作用域；本文首先介绍 ES6 中常用的三种变量声明方式，然后讨论了 JavaScript 按值传递的特性以及多种的赋值方式，最后介绍了复合类型拷贝的技巧</p><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>在 JavaScript 中，基本的变量声明可以用 var 方式；JavaScript 允许省略 var，直接对未声明的变量赋值。也就是说，var a = 1 与 a = 1，这两条语句的效果相同。但是由于这样的做法很容易不知不觉地创建全局变量（尤其是在函数内部），所以建议总是使用 var 命令声明变量。在 ES6 中，对于变量声明的方式进行了扩展，引入了 let 与 const。var 与 let 两个关键字创建变量的区别在于， var 声明的变量作用域是最近的函数块；而 let 声明的变量作用域是最近的闭合块，往往会小于函数块。另一方面，以 let 关键字创建的变量虽然同样被提升到作用域头部，但是并不能在实际声明前使用；如果强行使用则会抛出 ReferenceError 异常。</p><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><p>var 是 JavaScript 中基础的变量声明方式之一，其基本语法为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="comment">// Declaration and initialization</span></span><br><span class="line">x = <span class="string">'Hello World'</span> <span class="comment">// Assignment</span></span><br><span class="line"><span class="comment">// Or all in one</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="string">'Hello World'</span></span><br></pre></td></tr></table></figure><p>ECMAScript 6 以前我们在 JavaScript 中并没有其他的变量声明方式，以 var 声明的变量作用于函数作用域中，如果没有相应的闭合函数作用域，那么该变量会被当做默认的全局变量进行处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> hello = <span class="string">'Hello World'</span></span><br><span class="line">  <span class="keyword">return</span> hello</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(hello)</span><br></pre></td></tr></table></figure><p>像如上这种调用方式会抛出异常: ReferenceError: hello is not defined，因为 hello 变量只能作用于 sayHello 函数中，不过如果按照如下先声明全局变量方式再使用时，其就能够正常调用:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="string">'Hello World'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> hello</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(hello)</span><br></pre></td></tr></table></figure><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>在 ECMAScript 6 中我们可以使用 let 关键字进行变量声明:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x <span class="comment">// Declaration and initialization</span></span><br><span class="line">x = <span class="string">'Hello World'</span> <span class="comment">// Assignment</span></span><br><span class="line"><span class="comment">// Or all in one</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="string">'Hello World'</span></span><br></pre></td></tr></table></figure><p>let 关键字声明的变量是属于块作用域，也就是包含在 {} 之内的作用于。使用 let 关键字的优势在于能够降低偶然的错误的概率，因为其保证了每个变量只能在最小的作用域内进行访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Peter'</span></span><br><span class="line"><span class="keyword">if</span> (name === <span class="string">'Peter'</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> hello = <span class="string">'Hello Peter'</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> hello = <span class="string">'Hi'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(hello)</span><br></pre></td></tr></table></figure><p>上述代码同样会抛出 ReferenceError: hello is not defined 异常，因为 hello 只能够在闭合的块作用域中进行访问，我们可以进行如下修改:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Peter'</span></span><br><span class="line"><span class="keyword">if</span> (name === <span class="string">'Peter'</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> hello = <span class="string">'Hello Peter'</span></span><br><span class="line">  <span class="built_in">console</span>.log(hello)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> hello = <span class="string">'Hi'</span></span><br><span class="line">  <span class="built_in">console</span>.log(hello)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以利用这种块级作用域的特性来避免闭包中因为变量保留而导致的问题，譬如如下两种异步代码，使用 var 时每次循环中使用的都是相同变量；而使用 let 声明的 i 则会在每次循环时进行不同的绑定，即每次循环中闭包捕获的都是不同的 i 实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`i:<span class="subst">$&#123;i&#125;</span>`</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`j:<span class="subst">$&#123;j&#125;</span>`</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> k = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`k:<span class="subst">$&#123;k&#125;</span>`</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">i: <span class="number">0</span></span><br><span class="line">i: <span class="number">1</span></span><br><span class="line">j: <span class="number">2</span></span><br><span class="line">j: <span class="number">2</span></span><br><span class="line">k: <span class="number">2</span></span><br><span class="line">k: <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const 关键字一般用于常量声明，用 const 关键字声明的常量需要在声明时进行初始化并且不可以再进行修改，并且 const 关键字声明的常量被限制于块级作用域中进行访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> x;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// okay, block scoped name</span></span><br><span class="line">      <span class="keyword">const</span> x = <span class="string">"sneaky"</span>;</span><br><span class="line">      <span class="comment">// error, const</span></span><br><span class="line">      x = <span class="string">"foo"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// error, already declared in block</span></span><br><span class="line">    <span class="keyword">let</span> x = <span class="string">"inner"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaScript 中 const 限制的并非值不可变性；而是创建了不可变的绑定，即对于某个值的只读引用，并且禁止了对于该引用的重赋值，即如下的代码会触发错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line">numbers = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>] <span class="comment">// error: assignment to constant variable</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers[<span class="number">4</span>])</span><br></pre></td></tr></table></figure><p>我们可以参考如下图片理解这种机制，每个变量标识符都会关联某个存放变量实际值的物理地址；所谓只读的变量即是该变量标识符不可以被重新赋值，而该变量指向的值还是可变的。</p><p>JavaScript 中存在着所谓的原始类型与复合类型，使用 const 声明的原始类型是值不可变的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Example 1</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">10</span></span><br><span class="line">a = a + <span class="number">1</span> <span class="comment">// error: assignment to constant variable</span></span><br><span class="line"># Example 2</span><br><span class="line"><span class="keyword">const</span> isTrue = <span class="literal">true</span></span><br><span class="line">isTrue = <span class="literal">false</span> <span class="comment">// error: assignment to constant variable</span></span><br><span class="line"># Example 3</span><br><span class="line"><span class="keyword">const</span> sLower = <span class="string">'hello world'</span></span><br><span class="line"><span class="keyword">const</span> sUpper = sLower.toUpperCase() <span class="comment">// create a new string</span></span><br><span class="line"><span class="built_in">console</span>.log(sLower) <span class="comment">// print hello world</span></span><br><span class="line"><span class="built_in">console</span>.log(sUpper) <span class="comment">// print HELLO WORLD</span></span><br></pre></td></tr></table></figure><p>而如果我们希望将某个对象同样变成不可变类型，则需要使用 Object.freeze()；不过该方法仅对于键值对的 Object 起作用，而无法作用于 Date、Map 与 Set 等类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Example 4</span><br><span class="line"><span class="keyword">const</span> me = <span class="built_in">Object</span>.freeze(&#123;<span class="attr">name</span>: “Jacopo”&#125;)</span><br><span class="line">me.age = <span class="number">28</span></span><br><span class="line"><span class="built_in">console</span>.log(me.age) <span class="comment">// print undefined</span></span><br><span class="line"># Example 5</span><br><span class="line"><span class="keyword">const</span> arr = <span class="built_in">Object</span>.freeze([<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>]) <span class="comment">// print -1</span></span><br><span class="line"># Example 6</span><br><span class="line"><span class="keyword">const</span> me = <span class="built_in">Object</span>.freeze(&#123;</span><br><span class="line">  name: <span class="string">'Jacopo'</span>,</span><br><span class="line">  pet: &#123;</span><br><span class="line">    type: <span class="string">'dog'</span>,</span><br><span class="line">    name: <span class="string">'Spock'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">me.pet.name = <span class="string">'Rocky'</span></span><br><span class="line">me.pet.breed = <span class="string">'German Shepherd'</span></span><br><span class="line"><span class="built_in">console</span>.log(me.pet.name) <span class="comment">// print Rocky</span></span><br><span class="line"><span class="built_in">console</span>.log(me.pet.breed) <span class="comment">// print German Shepherd</span></span><br></pre></td></tr></table></figure><p>即使是 Object.freeze() 也只能防止顶层属性被修改，而无法限制对于嵌套属性的修改，这一点我们会在下文的浅拷贝与深拷贝部分继续讨论。</p><h2 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h2><h3 id="按值传递"><a href="#按值传递" class="headerlink" title="按值传递"></a>按值传递</h3><p>JavaScript 中永远是按值传递（pass-by-value），只不过当我们传递的是某个对象的引用时，这里的值指的是对象的引用。按值传递中函数的形参是被调用时所传实参的副本。修改形参的值并不会影响实参。而按引用传递（pass-by-reference）时，函数的形参接收实参的隐式引用，而不再是副本。这意味着函数形参的值如果被修改，实参也会被修改。同时两者指向相同的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeStuff</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  a = a * <span class="number">10</span>;</span><br><span class="line">  b.item = <span class="string">"changed"</span>;</span><br><span class="line">  c = &#123;<span class="attr">item</span>: <span class="string">"changed"</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">item</span>: <span class="string">"unchanged"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">item</span>: <span class="string">"unchanged"</span>&#125;;</span><br><span class="line">changeStuff(num, obj1, obj2);</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.item); <span class="comment">// changed</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.item); <span class="comment">// unchanged</span></span><br></pre></td></tr></table></figure><p>JavaScript 按值传递就表现于在内部修改了 c 的值但是并不会影响到外部的 obj2 变量。如果我们更深入地来理解这个问题，JavaScript 对于对象的传递则是按共享传递的（pass-by-sharing，也叫按对象传递、按对象共享传递）。最早由Barbara Liskov. 在1974年的GLU语言中提出；该求值策略被用于Python、Java、Ruby、JS等多种语言。该策略的重点是：调用函数传参时，函数接受对象实参引用的副本(既不是按值传递的对象副本，也不是按引用传递的隐式引用)。 它和按引用传递的不同在于：在共享传递中对函数形参的赋值，不会影响实参的值。按共享传递的直接表现就是上述代码中的 obj1，当我们在函数内修改了 b 指向的对象的属性值时，我们使用 obj1 来访问相同的变量时同样会得到变化后的值。</p><h3 id="连续赋值"><a href="#连续赋值" class="headerlink" title="连续赋值"></a>连续赋值</h3><p>JavaScript 中是支持变量的连续赋值，即譬如：</p><pre><code>var a=b=1;</code></pre><p>为了解释上述问题，我们引入一个新的变量:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">n</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a; <span class="comment">// 持有a，以回查</span></span><br><span class="line">a.x = a = &#123;<span class="attr">n</span>:<span class="number">2</span>&#125;;</span><br><span class="line">alert(a.x);<span class="comment">// --&gt; undefined</span></span><br><span class="line">alert(b.x);<span class="comment">// --&gt; [object Object]</span></span><br></pre></td></tr></table></figure><p>实际上在连续赋值中，值是直接赋予给变量指向的内存地址：</p><pre><code>a.x  =  a  = {n:2}        │      │{n:1}&lt;──┘      └─&gt;{n:2}</code></pre><h3 id="Deconstruction-解构赋值"><a href="#Deconstruction-解构赋值" class="headerlink" title="Deconstruction: 解构赋值"></a>Deconstruction: 解构赋值</h3><p>解构赋值允许你使用类似数组或对象字面量的语法将数组和对象的属性赋给各种变量。这种赋值语法极度简洁，同时还比传统的属性访问方法更为清晰。传统的访问数组前三个元素的方式为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> first = someArray[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> second = someArray[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> third = someArray[<span class="number">2</span>];</span><br><span class="line"><span class="comment">// 结构赋值</span></span><br><span class="line"><span class="keyword">var</span> [first, second, third] = someArray;</span><br><span class="line"><span class="comment">// === Arrays</span></span><br><span class="line"><span class="keyword">var</span> [a, b] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b);<span class="comment">//=&gt; 1 2</span></span><br><span class="line"><span class="comment">// Use from functions, only select from pattern</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> [a, b] = foo();</span><br><span class="line"><span class="built_in">console</span>.log(a, b);<span class="comment">// =&gt; 1 2</span></span><br><span class="line"><span class="comment">// Omit certain values</span></span><br><span class="line"><span class="keyword">var</span> [a, , b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b);<span class="comment">// =&gt; 1 3</span></span><br><span class="line"><span class="comment">// Combine with spread/rest operator (accumulates the rest of the values)</span></span><br><span class="line"><span class="keyword">var</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b);<span class="comment">// =&gt; 1 [ 2, 3 ]</span></span><br><span class="line"><span class="comment">// Fail-safe.</span></span><br><span class="line"><span class="keyword">var</span> [, , , a, b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b);<span class="comment">// =&gt; undefined undefined</span></span><br><span class="line"><span class="comment">// Swap variables easily without temp</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">[b, a] = [a, b];</span><br><span class="line"><span class="built_in">console</span>.log(a, b);<span class="comment">// =&gt; 2 1</span></span><br><span class="line"><span class="comment">// Advance deep arrays</span></span><br><span class="line"><span class="keyword">var</span> [a, [b, [c, d]]] = [<span class="number">1</span>, [<span class="number">2</span>, [[[<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>], <span class="number">6</span>]]];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a:"</span>, a, <span class="string">"b:"</span>, b, <span class="string">"c:"</span>, c, <span class="string">"d:"</span>, d);<span class="comment">// =&gt; a: 1 , b: 2,  c: [ [ 3, 4 ], 5 ] , d: 6</span></span><br><span class="line"><span class="comment">// === Objects</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">user</span>: x&#125; = &#123;<span class="attr">user</span>: <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(x);<span class="comment">// =&gt; 5</span></span><br><span class="line"><span class="comment">// Fail-safe</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">user</span>: x&#125; = &#123;<span class="attr">user2</span>: <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(x);<span class="comment">// =&gt; undefined</span></span><br><span class="line"><span class="comment">// More values</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">prop</span>: x, <span class="attr">prop2</span>: y&#125; = &#123;<span class="attr">prop</span>: <span class="number">5</span>, <span class="attr">prop2</span>: <span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(x, y);<span class="comment">// =&gt; 5 10</span></span><br><span class="line"><span class="comment">// Short-hand syntax</span></span><br><span class="line"><span class="keyword">var</span> &#123; prop, prop2&#125; = &#123;<span class="attr">prop</span>: <span class="number">5</span>, <span class="attr">prop2</span>: <span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(prop, prop2);<span class="comment">// =&gt; 5 10</span></span><br><span class="line"><span class="comment">// Equal to:</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">prop</span>: prop, <span class="attr">prop2</span>: prop2&#125; = &#123;<span class="attr">prop</span>: <span class="number">5</span>, <span class="attr">prop2</span>: <span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(prop, prop2);<span class="comment">// =&gt; 5 10</span></span><br><span class="line"><span class="comment">// Oops: This doesn't work:</span></span><br><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line">&#123; a, b &#125; = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">// But this does work</span></span><br><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line">(&#123; a, b &#125; = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a, b);<span class="comment">// =&gt; 1 2</span></span><br><span class="line"><span class="comment">// This due to the grammar in JS.</span></span><br><span class="line"><span class="comment">// Starting with &#123; implies a block scope, not an object literal.</span></span><br><span class="line"><span class="comment">// () converts to an expression.</span></span><br><span class="line"><span class="comment">// From Harmony Wiki:</span></span><br><span class="line"><span class="comment">// Note that object literals cannot appear in</span></span><br><span class="line"><span class="comment">// statement positions, so a plain object</span></span><br><span class="line"><span class="comment">// destructuring assignment statement</span></span><br><span class="line"><span class="comment">//  &#123; x &#125; = y must be parenthesized either</span></span><br><span class="line"><span class="comment">// as (&#123; x &#125; = y) or (&#123; x &#125;) = y.</span></span><br><span class="line"><span class="comment">// Combine objects and arrays</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">prop</span>: x, <span class="attr">prop2</span>: [, y]&#125; = &#123;<span class="attr">prop</span>: <span class="number">5</span>, <span class="attr">prop2</span>: [<span class="number">10</span>, <span class="number">100</span>]&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(x, y);<span class="comment">// =&gt; 5 100</span></span><br><span class="line"><span class="comment">// Deep objects</span></span><br><span class="line"><span class="keyword">var</span> &#123;</span><br><span class="line">  prop: x,</span><br><span class="line">  prop2: &#123;</span><br><span class="line">    prop2: &#123;</span><br><span class="line">      nested: [ , , b]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; = &#123; <span class="attr">prop</span>: <span class="string">"Hello"</span>, <span class="attr">prop2</span>: &#123; <span class="attr">prop2</span>: &#123; <span class="attr">nested</span>: [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]&#125;&#125;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(x, b);<span class="comment">// =&gt; Hello c</span></span><br><span class="line"><span class="comment">// === Combining all to make fun happen</span></span><br><span class="line"><span class="comment">// All well and good, can we do more? Yes!</span></span><br><span class="line"><span class="comment">// Using as method parameters</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params">&#123;prop: x&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;;</span><br><span class="line">foo(&#123;<span class="attr">invalid</span>: <span class="number">1</span>&#125;);<span class="comment">// =&gt; undefined</span></span><br><span class="line">foo(&#123;<span class="attr">prop</span>: <span class="number">1</span>&#125;);<span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="comment">// Can also use with the advanced example</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  prop: x,</span></span></span><br><span class="line"><span class="function"><span class="params">  prop2: &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    prop2: &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      nested: b</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, ...b);</span><br><span class="line">&#125;;</span><br><span class="line">foo(&#123; <span class="attr">prop</span>: <span class="string">"Hello"</span>, <span class="attr">prop2</span>: &#123; <span class="attr">prop2</span>: &#123; <span class="attr">nested</span>: [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]&#125;&#125;&#125;); <span class="comment">// =&gt; Hello a b c</span></span><br><span class="line"><span class="comment">// In combination with other ES2015 features.</span></span><br><span class="line"><span class="comment">// Computed property names</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'fieldName'</span>;</span><br><span class="line"><span class="keyword">const</span> computedObject = &#123; [name]: name &#125;; <span class="comment">// (where object is &#123; 'fieldName': 'fieldName' &#125;)</span></span><br><span class="line"><span class="keyword">const</span> &#123; [name]: nameValue &#125; = computedObject;</span><br><span class="line"><span class="built_in">console</span>.log(nameValue) <span class="comment">// =&gt; fieldName</span></span><br><span class="line"><span class="comment">// Rest and defaults</span></span><br><span class="line"><span class="keyword">var</span> ajax = <span class="function"><span class="keyword">function</span> (<span class="params">&#123; url = <span class="string">"localhost"</span>, port: p = <span class="number">80</span>&#125;, ...data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Url:"</span>, url, <span class="string">"Port:"</span>, p, <span class="string">"Rest:"</span>, data);</span><br><span class="line">&#125;;</span><br><span class="line">ajax(&#123; <span class="attr">url</span>: <span class="string">"someHost"</span> &#125;, <span class="string">"additional"</span>, <span class="string">"data"</span>, <span class="string">"hello"</span>);<span class="comment">// =&gt; Url: someHost Port: 80 Rest: [ 'additional', 'data', 'hello' ]</span></span><br><span class="line">ajax(&#123; &#125;, <span class="string">"additional"</span>, <span class="string">"data"</span>, <span class="string">"hello"</span>);<span class="comment">// =&gt; Url: localhost Port: 80 Rest: [ 'additional', 'data', 'hello' ]</span></span><br><span class="line"><span class="comment">// Ooops: Doesn't work (in traceur)</span></span><br><span class="line"><span class="keyword">var</span> ajax = <span class="function">(<span class="params">&#123; url = <span class="string">"localhost"</span>, port: p = <span class="number">80</span>&#125;, ...data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Url:"</span>, url, <span class="string">"Port:"</span>, p, <span class="string">"Rest:"</span>, data);</span><br><span class="line">&#125;;</span><br><span class="line">ajax(&#123; &#125;, <span class="string">"additional"</span>, <span class="string">"data"</span>, <span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// probably due to traceur compiler</span></span><br><span class="line">But <span class="keyword">this</span> does:</span><br><span class="line"><span class="keyword">var</span> ajax = <span class="function">(<span class="params">&#123; url: url = <span class="string">"localhost"</span>, port: p = <span class="number">80</span>&#125;, ...data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Url:"</span>, url, <span class="string">"Port:"</span>, p, <span class="string">"Rest:"</span>, data);</span><br><span class="line">&#125;;</span><br><span class="line">ajax(&#123; &#125;, <span class="string">"additional"</span>, <span class="string">"data"</span>, <span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// Like _.pluck</span></span><br><span class="line"><span class="keyword">var</span> users = [</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">"Name1"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">"Name2"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">"Name2"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">"Name3"</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> names = users.map( <span class="function">(<span class="params">&#123; user &#125;</span>) =&gt;</span> user );</span><br><span class="line"><span class="built_in">console</span>.log(names);<span class="comment">// =&gt; [ 'Name1', 'Name2', 'Name2', 'Name3' ]</span></span><br><span class="line"><span class="comment">// Advanced usage with Array Comprehension and default values</span></span><br><span class="line"><span class="keyword">var</span> users = [</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">"Name1"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">"Name2"</span>, <span class="attr">age</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">"Name2"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">"Name3"</span>, <span class="attr">age</span>: <span class="number">4</span> &#125;</span><br><span class="line">];</span><br><span class="line">[<span class="keyword">for</span> (&#123; user, age = <span class="string">"DEFAULT AGE"</span> &#125; <span class="keyword">of</span> users) <span class="built_in">console</span>.log(user, age)];</span><br><span class="line"><span class="comment">// =&gt; Name1 DEFAULT AGE</span></span><br><span class="line"><span class="comment">// =&gt; Name2 2</span></span><br><span class="line"><span class="comment">// =&gt; Name2 DEFAULT AGE</span></span><br><span class="line"><span class="comment">// =&gt; Name3 4</span></span><br></pre></td></tr></table></figure><h3 id="数组与迭代器"><a href="#数组与迭代器" class="headerlink" title="数组与迭代器"></a>数组与迭代器</h3><p>以上是数组解构赋值的一个简单示例，其语法的一般形式为：</p><pre><code>[ variable1, variable2, ..., variableN ] = array;</code></pre><p>事实上，用变量来描述并不恰当，因为你可以对任意深度的嵌套数组进行解构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line"><span class="built_in">console</span>.log(foo);<span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(bar);<span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(baz);<span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>此外，你可以在对应位留空来跳过被解构数组中的某些元素：</p><pre><code>var [,,third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];console.log(third);  // &quot;baz&quot;</code></pre><p>而且你还可以通过“不定参数”模式捕获数组中的所有尾随元素：</p><pre><code>var [head, ...tail] = [1, 2, 3, 4];console.log(tail);// [2, 3, 4]</code></pre><p>当访问空数组或越界访问数组时，对其解构与对其索引的行为一致，最终得到的结果都是：undefined。</p><pre><code>console.log([][0]); // undefinedvar [missing] = [];console.log(missing); // undefined</code></pre><p>请注意，数组解构赋值的模式同样适用于任意迭代器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> [first, second, third, fourth, fifth, sixth] = fibs();</span><br><span class="line"><span class="built_in">console</span>.log(sixth); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>通过解构对象，你可以把它的每个属性与不同的变量绑定，首先指定被绑定的属性，然后紧跟一个要解构的变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> robotA = &#123; <span class="attr">name</span>: <span class="string">"Bender"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> robotB = &#123; <span class="attr">name</span>: <span class="string">"Flexo"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">name</span>: nameA &#125; = robotA;</span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">name</span>: nameB &#125; = robotB;</span><br><span class="line"><span class="built_in">console</span>.log(nameA);<span class="comment">// "Bender"</span></span><br><span class="line"><span class="built_in">console</span>.log(nameB);<span class="comment">// "Flexo"</span></span><br></pre></td></tr></table></figure><p>当属性名与变量名一致时，可以通过一种实用的句法简写：</p><pre><code>var { foo, bar } = { foo: &quot;lorem&quot;, bar: &quot;ipsum&quot; };console.log(foo);    // &quot;lorem&quot;console.log(bar);    // &quot;ipsum&quot;</code></pre><p>与数组解构一样，你可以随意嵌套并进一步组合对象解构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> complicatedObj = &#123;</span><br><span class="line">  arrayProp: [</span><br><span class="line">    <span class="string">"Zapp"</span>,</span><br><span class="line">    &#123; <span class="attr">second</span>: <span class="string">"Brannigan"</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">arrayProp</span>: [first, &#123; second &#125;] &#125; = complicatedObj;</span><br><span class="line"><span class="built_in">console</span>.log(first);<span class="comment">// "Zapp"</span></span><br><span class="line"><span class="built_in">console</span>.log(second);<span class="comment">// "Brannigan"</span></span><br></pre></td></tr></table></figure><p>当你解构一个未定义的属性时，得到的值为undefined：</p><pre><code>var { missing } = {};console.log(missing);    // undefined</code></pre><p>请注意，当你解构对象并赋值给变量时，如果你已经声明或不打算声明这些变量（亦即赋值语句前没有let、const或var关键字），你应该注意这样一个潜在的语法错误：</p><pre><code>{ blowUp } = { blowUp: 10 };    // Syntax error 语法错误</code></pre><p>为什么会出错？这是因为JavaScript语法通知解析引擎将任何以{开始的语句解析为一个块语句（例如，{console}是一个合法块语句）。解决方案是将整个表达式用一对小括号包裹：</p><pre><code>({ safe } = {});    // No errors 没有语法错误</code></pre><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>当你要解构的属性未定义时你可以提供一个默认值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [missing = <span class="literal">true</span>] = [];</span><br><span class="line"><span class="built_in">console</span>.log(missing);<span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">message</span>: msg = <span class="string">"Something went wrong"</span> &#125; = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(msg);<span class="comment">// "Something went wrong"</span></span><br><span class="line"><span class="keyword">var</span> &#123; x = <span class="number">3</span> &#125; = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(x);<span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>由于解构中允许对对象进行解构，并且还支持默认值，那么完全可以将解构应用在函数参数以及参数的默认值中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeBreakpoint</span>(<span class="params">&#123; url, line, column &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们构造一个提供配置的对象，并且需要这个对象的属性携带默认值时，解构特性就派上用场了。举个例子，jQuery的ajax函数使用一个配置对象作为它的第二参数，我们可以这样重写函数定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  async = true,</span></span></span><br><span class="line"><span class="function"><span class="params">  beforeSend = noop,</span></span></span><br><span class="line"><span class="function"><span class="params">  cache = true,</span></span></span><br><span class="line"><span class="function"><span class="params">  complete = noop,</span></span></span><br><span class="line"><span class="function"><span class="params">  crossDomain = false,</span></span></span><br><span class="line"><span class="function"><span class="params">  global = true,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="regexp">//</span> ... 更多配置</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样，解构也可以应用在函数的多重返回值中，可以类似于其他语言中的元组的特性：</p><pre><code>function returnMultipleValues() {  return [1, 2];}var [foo, bar] = returnMultipleValues();</code></pre><h3 id="Three-Dots-…"><a href="#Three-Dots-…" class="headerlink" title="Three Dots …"></a>Three Dots …</h3><p>es6新增的特性</p><h3 id="Rest-Operator"><a href="#Rest-Operator" class="headerlink" title="Rest Operator"></a>Rest Operator</h3><p>在 JavaScript 函数调用时我们往往会使用内置的 arguments 对象来获取函数的调用参数，不过这种方式却存在着很多的不方便性。譬如 arguments 对象是 Array-Like 对象，无法直接运用数组的 .map() 或者 .forEach() 函数；并且因为 arguments 是绑定于当前函数作用域，如果我们希望在嵌套函数里使用外层函数的 arguments 对象，我们还需要创建中间变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// store arguments into a separated variable</span></span><br><span class="line">  <span class="keyword">var</span> argsOuter = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// args is an array-like object</span></span><br><span class="line">    <span class="keyword">var</span> even = <span class="built_in">Array</span>.prototype.map.call(argsOuter, <span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// do something with argsOuter</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6 中为我们提供了 Rest Operator 来以数组形式获取函数的调用参数，Rest Operator 也可以用于在解构赋值中以数组方式获取剩余的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countArguments</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> args.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// get the number of arguments</span></span><br><span class="line">countArguments(<span class="string">'welcome'</span>, <span class="string">'to'</span>, <span class="string">'Earth'</span>); <span class="comment">// =&gt; 3</span></span><br><span class="line"><span class="comment">// destructure an array</span></span><br><span class="line"><span class="keyword">let</span> otherSeasons, autumn;</span><br><span class="line">[autumn, ...otherSeasons] = cold;</span><br><span class="line">otherSeasons  <span class="comment">// =&gt; ['winter']</span></span><br></pre></td></tr></table></figure><p>典型的 Rest Operator 的应用场景譬如进行不定数组的指定类型过滤：</p><pre><code>function filter(type, ...items) {  return items.filter(item =&gt; typeof item === type);}filter(&apos;boolean&apos;, true, 0, false);        // =&gt; [true, false]filter(&apos;number&apos;, false, 4, &apos;Welcome&apos;, 7); // =&gt; [4, 7]</code></pre><p>尽管 Arrow Function 中并没有定义 arguments 对象，但是我们仍然可以使用 Rest Operator 来获取 Arrow Function 的调用参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> outerArguments = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="keyword">const</span> concat = <span class="function">(<span class="params">...items</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span> === outerArguments); <span class="comment">// =&gt; true</span></span><br><span class="line">    <span class="keyword">return</span> items.reduce(<span class="function">(<span class="params">result, item</span>) =&gt;</span> result + item, <span class="string">''</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  concat(<span class="number">1</span>, <span class="number">5</span>, <span class="string">'nine'</span>); <span class="comment">// =&gt; '15nine'</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="Spread-Operator"><a href="#Spread-Operator" class="headerlink" title="Spread Operator"></a>Spread Operator</h3><p>Spread Operator 则与 Rest Opeator 的功能正好相反，其常用于进行数组构建与解构赋值，也可以用于将某个数组转化为函数的参数列表，其基本使用方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cold = [<span class="string">'autumn'</span>, <span class="string">'winter'</span>];</span><br><span class="line"><span class="keyword">let</span> warm = [<span class="string">'spring'</span>, <span class="string">'summer'</span>];</span><br><span class="line"><span class="comment">// construct an array</span></span><br><span class="line">[...cold, ...warm] <span class="comment">// =&gt; ['autumn', 'winter', 'spring', 'summer']</span></span><br><span class="line"><span class="comment">// function arguments from an array</span></span><br><span class="line">cold.push(...warm);</span><br><span class="line">cold <span class="comment">// =&gt; ['autumn', 'winter', 'spring', 'summer']</span></span><br></pre></td></tr></table></figure><p>我们也可以使用 Spread Operator 来简化函数调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, country) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.country = country;</span><br><span class="line">  &#125;</span><br><span class="line">  getDescription() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> leads <span class="subst">$&#123;<span class="keyword">this</span>.country&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> details = [<span class="string">'Alexander the Great'</span>, <span class="string">'Greece'</span>];</span><br><span class="line"><span class="keyword">var</span> Alexander = <span class="keyword">new</span> King(...details);</span><br><span class="line">Alexander.getDescription(); <span class="comment">// =&gt; 'Alexander the Great leads Greece'</span></span><br></pre></td></tr></table></figure><p>还有另外一个好处就是可以用来替换 Object.assign 来方便地从旧有的对象中创建新的对象，并且能够修改部分值；譬如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj_new_1 = <span class="built_in">Object</span>.assign(&#123;&#125;,obj,&#123;<span class="attr">a</span>:<span class="number">3</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> obj_new_2 = &#123;</span><br><span class="line">  ...obj,</span><br><span class="line">  a:<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们还需要讨论下 Spread Operator 与 Iteration Protocols，实际上 Spread Operator 也是使用的 Iteration Protocols 来进行元素遍历与结果搜集；因此我们也可以通过自定义 Iterator 的方式来控制 Spread Operator 的表现。Iterable 协议规定了对象必须包含 Symbol.iterator 方法，该方法返回某个 Iterator 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Iterable &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> Iterator;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该 Iterator 对象从属于 Iterator Protocol，其需要提供 next 成员方法，该方法会返回某个包含 done 与 value 属性的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Iterator &#123;</span><br><span class="line">  next() &#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">        value: <span class="xml"><span class="tag">&lt;<span class="name">value</span>&gt;</span>,</span></span><br><span class="line">        done: &lt;boolean&gt;</span><br><span class="line">     &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>典型的 Iterable 对象就是字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'hi'</span>;</span><br><span class="line"><span class="keyword">var</span> iterator = str[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">iterator.toString(); <span class="comment">// =&gt; '[object String Iterator]'</span></span><br><span class="line">iterator.next();     <span class="comment">// =&gt; &#123; value: 'h', done: false &#125;</span></span><br><span class="line">iterator.next();     <span class="comment">// =&gt; &#123; value: 'i', done: false &#125;</span></span><br><span class="line">iterator.next();     <span class="comment">// =&gt; &#123; value: undefined, done: true &#125;</span></span><br><span class="line">[...str];            <span class="comment">// =&gt; ['h', 'i']</span></span><br></pre></td></tr></table></figure><p>我们可以通过自定义 array-like 对象的 Symbol.iterator 属性来控制其在迭代器上的效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="comment">// Conform to Iterator protocol</span></span><br><span class="line">      done : index &gt;= <span class="keyword">this</span>.length,</span><br><span class="line">      value: <span class="keyword">this</span>[index++]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'Cat'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'Bird'</span>,</span><br><span class="line">  length: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Conform to Iterable Protocol</span></span><br><span class="line">arrayLike[<span class="built_in">Symbol</span>.iterator] = iterator;</span><br><span class="line"><span class="keyword">var</span> array = [...arrayLike];</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// =&gt; ['Cat', 'Bird']</span></span><br></pre></td></tr></table></figure><p>arrayLike[Symbol.iterator] 为该对象创建了值为某个迭代器的属性，从而使该对象符合了 Iterable 协议；而 iterator() 又返回了包含 next 成员方法的对象，使得该对象最终具有和数组相似的行为表现。</p><h2 id="Copy-Composite-Data-Types-复合类型的拷贝"><a href="#Copy-Composite-Data-Types-复合类型的拷贝" class="headerlink" title="Copy Composite Data Types: 复合类型的拷贝"></a>Copy Composite Data Types: 复合类型的拷贝</h2><h3 id="Shallow-Copy-浅拷贝"><a href="#Shallow-Copy-浅拷贝" class="headerlink" title="Shallow Copy 浅拷贝"></a>Shallow Copy 浅拷贝</h3><p>浅拷贝是指复制时，指对第一层键值对进行独立的赋值，一个简单的实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!source || <span class="keyword">typeof</span> source !== <span class="string">'object'</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 这个方法有点问题，target一定要事先定好，不然就不能改变实参了</span></span><br><span class="line">  <span class="comment">// 具体原因解释可看参考资料中 JS是值传递还是引用传递</span></span><br><span class="line">  <span class="keyword">if</span> (!target || <span class="keyword">typeof</span> target !== <span class="string">'object'</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这边最好区别一下对象和数组的复制</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">    <span class="keyword">if</span> (source.hasOwnProperty(key)) &#123;</span><br><span class="line">      target[key] = source[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><p>Object.assign() 方法可以把任意多个源对象所拥有的自身可枚举属性拷贝给目标对象，然后返回目标对象。<br>Object.assign 方法只会拷贝 源对象自身的并且可枚举的属性 到目标对象身上。注意，对于访问器属性，该方法会执行那个访问器属性的 getter 函数，然后把得到的值拷贝给目标对象如果你想拷贝访问器属性本身，请使用 <code>Object.getOwnPropertyDescriptor</code> 和 <code>Object.difineProperties()</code>方法</p><p>注意，字符串类型和 symbol 类型的属性都会被拷贝。</p><p>注意，在属性拷贝过程中可能会产生异常，比如目标对象的某个只读属性和源对象的某个属性同名，这时该方法会抛出一个 TypeError 异常，拷贝过程中断，已经拷贝成功的属性不会受到影响，还未拷贝的属性将不会再被拷贝。</p><p>注意， Object.assign 会跳过那些值为 null 或 undefined 的源对象。</p><pre><code>Object.assign(target, ...sources)</code></pre><p>浅拷贝一个对象</p><pre><code>var obj = {a: 1}var copy = Object.assign({}, obj)console.log(copy) // {a:1}</code></pre><p>合并若干个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">var</span> o3 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(o1, o2, o3)</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o1) <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;, 注意目标对象自身也会改变。</span></span><br></pre></td></tr></table></figure><p>拷贝 symbol 类型的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; [<span class="built_in">Symbol</span>(<span class="string">'foo'</span>)]: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, o1, o2)</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123; a: 1, [Symbol("foo")]: 2 &#125;</span></span><br></pre></td></tr></table></figure><p>继承属性和不可枚举属性是不能拷贝的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(</span><br><span class="line">  &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// foo是个继承属性</span></span><br><span class="line">    bar: &#123; <span class="attr">value</span>: <span class="number">2</span> &#125;, <span class="comment">// bar是个不可枚举属性</span></span><br><span class="line">    baz: &#123;</span><br><span class="line">      value: <span class="number">3</span>,</span><br><span class="line">      enumerable: <span class="literal">true</span> <span class="comment">// baz是个自身可枚举属性</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj)</span><br><span class="line"><span class="built_in">console</span>.log(copy) <span class="comment">// &#123;baz: 3&#125;</span></span><br></pre></td></tr></table></figure><p>原始值会被隐式转换成其包装对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="string">'123'</span></span><br><span class="line"><span class="keyword">var</span> v2 = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> v3 = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> v4 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, v1, <span class="literal">null</span>, v2, <span class="literal">undefined</span>, v3, v4)</span><br><span class="line"><span class="comment">// 源对象如果是原始值，会被自动转换成它们的包装对象，</span></span><br><span class="line"><span class="comment">// 而 null 和 undefined 这两种原始值会被完全忽略。</span></span><br><span class="line"><span class="comment">// 注意，只有字符串的包装对象才有可能有自身可枚举属性。</span></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123; "0": "1", "1": "2", "2": "3" &#125;</span></span><br></pre></td></tr></table></figure><p>例子：拷贝属性过程中发生异常</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'foo'</span>, &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  writeable: <span class="literal">false</span></span><br><span class="line">&#125;) <span class="comment">// target 的 foo 属性是个只读属性。</span></span><br><span class="line"><span class="built_in">Object</span>.assign(target, &#123; <span class="attr">bar</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">foo2</span>: <span class="number">3</span>, <span class="attr">foo</span>: <span class="number">3</span>, <span class="attr">foo3</span>: <span class="number">3</span> &#125;, &#123; <span class="attr">baz</span>: <span class="number">4</span> &#125;)</span><br><span class="line"><span class="comment">// TypeError: "foo" is read-only</span></span><br><span class="line"><span class="comment">// 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。</span></span><br><span class="line"><span class="built_in">console</span>.log(target.bar) <span class="comment">// 2，说明第一个源对象拷贝成功了。</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo2) <span class="comment">// 3，说明第二个源对象的第一个属性也拷贝成功了。</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo) <span class="comment">// 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo3) <span class="comment">// undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。</span></span><br><span class="line"><span class="built_in">console</span>.log(target.baz) <span class="comment">// undefined，第三个源对象更是不会被拷贝到的。</span></span><br></pre></td></tr></table></figure><h3 id="使用-concat-来复制数组"><a href="#使用-concat-来复制数组" class="headerlink" title="使用 [].concat 来复制数组"></a>使用 [].concat 来复制数组</h3><p>同样类似于对于对象的复制，我们建议使用[].concat 来进行数组的深复制:</p><pre><code>ar list = [1, 2, 3];var changedList = [].concat(list);changedList[1] = 2;list === changedList; // false</code></pre><p>同样的，concat 方法也只能保证一层深复制:</p><pre><code>&gt; list = [[1,2,3]][ [ 1, 2, 3 ] ]&gt; new_list = [].concat(list)[ [ 1, 2, 3 ] ]&gt; new_list[0][0] = 44&gt; list[ [ 4, 2, 3 ] ]</code></pre><h3 id="浅拷贝的缺陷"><a href="#浅拷贝的缺陷" class="headerlink" title="浅拷贝的缺陷"></a>浅拷贝的缺陷</h3><p>不过需要注意的是，assign 是浅拷贝，或者说，它是一级深拷贝，举两个例子说明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultOpt = &#123;</span><br><span class="line">  title: &#123;</span><br><span class="line">    text: <span class="string">'hello world'</span>,</span><br><span class="line">    subtext: <span class="string">"It's my world"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> opt = <span class="built_in">Object</span>.assign(&#123;&#125;, defaultOpt, &#123;</span><br><span class="line">  title: &#123;</span><br><span class="line">    subtext: <span class="string">'Yes, your world'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(opt) <span class="comment">// &#123; title: &#123; subtext: 'Yes, your world.' &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>上面这个例子中，对于对象的一级子元素而言，只会替换引用，而不会动态的添加内容。那么，其实 assign 并没有解决对象的引用混乱问题，参考下下面这个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultOpt = &#123;</span><br><span class="line">  title: &#123;</span><br><span class="line">    text: <span class="string">'hello world'</span>,</span><br><span class="line">    subtext: <span class="string">"It's my world."</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> opt1 = <span class="built_in">Object</span>.assign(&#123;&#125;, defaultOpt);</span><br><span class="line"><span class="keyword">const</span> opt2 = <span class="built_in">Object</span>.assign(&#123;&#125;, defaultOpt);</span><br><span class="line">opt2.title.subtext = <span class="string">'Yes, your world.'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(opt1); <span class="comment">// &#123; title: &#123; text: 'hello world', subtext: 'Yes, your world.' &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(opt2); <span class="comment">// &#123; title: &#123; text: 'hello world', subtext: 'Yes, your world.' &#125; &#125;</span></span><br></pre></td></tr></table></figure><h3 id="DeepCopy-深拷贝"><a href="#DeepCopy-深拷贝" class="headerlink" title="DeepCopy: 深拷贝"></a>DeepCopy: 深拷贝</h3><p><strong>递归属性遍历</strong></p><p>一般来说，在JavaScript中考虑复合类型的深层复制的时候，往往就是指对于Date、Object与Array这三个复合类型的处理。我们能想到的最常用的方法就是先创建一个空的新对象，然后递归遍历旧对象，直到发现基础类型的子节点才赋予到新对象对应的位置。不过这种方法会存在一个问题，就是JavaScript中存在着神奇的原型机制，并且这个原型会在遍历的时候出现，然后原型不应该被赋予给新对象。那么在遍历的过程中，我们应该考虑使用hasOenProperty方法来过滤掉那些继承自原型链上的属性:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> copy</span><br><span class="line">  <span class="comment">// 处理基本类型 null undefined</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">null</span> === obj || <span class="string">'object'</span> !== <span class="keyword">typeof</span> obj) <span class="keyword">return</span> obj</span><br><span class="line">  <span class="comment">// 若为 Date 对象时</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">    copy = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    copy.setTime(obj.getTime())</span><br><span class="line">    <span class="keyword">return</span> copy</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理数组</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">    copy = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = obj.length; i &lt; len; i++) &#123;</span><br><span class="line">      copy[i] = clone(obj[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理对象</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">    copy = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj.hasOwnProperty(attr)) &#123;</span><br><span class="line">        copy[attr] = clone(obj[arr])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unable to copy obj! Its type isn\'t supported!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This would be cloneable:</span></span><br><span class="line"><span class="keyword">var</span> tree = &#123;</span><br><span class="line">    <span class="string">"left"</span>  : &#123; <span class="string">"left"</span> : <span class="literal">null</span>, <span class="string">"right"</span> : <span class="literal">null</span>, <span class="string">"data"</span> : <span class="number">3</span> &#125;,</span><br><span class="line">    <span class="string">"right"</span> : <span class="literal">null</span>,</span><br><span class="line">    <span class="string">"data"</span>  : <span class="number">8</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// This would kind-of work, but you would get 2 copies of the</span></span><br><span class="line"><span class="comment">// inner node instead of 2 references to the same copy</span></span><br><span class="line"><span class="keyword">var</span> directedAcylicGraph = &#123;</span><br><span class="line">    <span class="string">"left"</span>  : &#123; <span class="string">"left"</span> : <span class="literal">null</span>, <span class="string">"right"</span> : <span class="literal">null</span>, <span class="string">"data"</span> : <span class="number">3</span> &#125;,</span><br><span class="line">    <span class="string">"data"</span>  : <span class="number">8</span></span><br><span class="line">&#125;;</span><br><span class="line">directedAcyclicGraph[<span class="string">"right"</span>] = directedAcyclicGraph[<span class="string">"left"</span>];</span><br><span class="line"><span class="comment">// Cloning this would cause a stack overflow due to infinite recursion:</span></span><br><span class="line"><span class="keyword">var</span> cylicGraph = &#123;</span><br><span class="line">    <span class="string">"left"</span>  : &#123; <span class="string">"left"</span> : <span class="literal">null</span>, <span class="string">"right"</span> : <span class="literal">null</span>, <span class="string">"data"</span> : <span class="number">3</span> &#125;,</span><br><span class="line">    <span class="string">"data"</span>  : <span class="number">8</span></span><br><span class="line">&#125;;</span><br><span class="line">cylicGraph[<span class="string">"right"</span>] = cylicGraph;</span><br></pre></td></tr></table></figure><h3 id="利用JSON深拷贝"><a href="#利用JSON深拷贝" class="headerlink" title="利用JSON深拷贝"></a>利用JSON深拷贝</h3><pre><code>JSON.parse(JSON.stringify(obj))</code></pre><p>对于一般的需求是可以满足的，但是它有缺点，下例中，可以看到JSON赋值会忽略掉值为undefined以及函数表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="literal">undefined</span>,</span><br><span class="line">  sum: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line"><span class="built_in">console</span>.log(obj2) <span class="comment">// Object &#123;a: 1, b: 2&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zhuanlan.zhihu.com/p/28313321" target="_blank" rel="noopener">基于 JSX 的动态数据绑定</a><br><a href="https://zhuanlan.zhihu.com/p/27844393" target="_blank" rel="noopener">ECMAScript 2017（ES8）特性概述</a><br><a href="https://zhuanlan.zhihu.com/p/27410280" target="_blank" rel="noopener">WebAssembly 初体验：从零开始重构计算模块</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;夯实基础系列。虽然想整理之前测试相关的东西，不过最近看书有讲到这个，遂将之前收藏的博客、文章结合书里的讲解做了一些整理和例子来加深这块的印象。（今天也才把测试的看了没来得及整理）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.fridolph.top/categories/JavaScript/"/>
    
    
      <category term="js" scheme="http://blog.fridolph.top/tags/js/"/>
    
      <category term="es6" scheme="http://blog.fridolph.top/tags/es6/"/>
    
      <category term="引用" scheme="http://blog.fridolph.top/tags/%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>【JS】【设计模式】从订阅发布模式说起</title>
    <link href="http://blog.fridolph.top/2018/06/13/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%8E%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F%E8%AF%B4%E8%B5%B7/"/>
    <id>http://blog.fridolph.top/2018/06/13/【设计模式】从订阅发布模式说起/</id>
    <published>2018-06-13T15:19:03.000Z</published>
    <updated>2024-01-01T06:26:27.303Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>先扯点闲话。一时兴起，遂决定之后采用这个前缀来写这个十多篇的系列总结了。在之前的学习和博客整理中，感觉都挺没方向，很散乱。除了看书的总结外，其他时候都是零碎性地学习，我想，若能系统性地带着目的去散落这些点，再类似依赖收集一样把这些零碎的东西汇总整理出来，那应该也挺不错的~</p></blockquote><!-- ![学习正则表达式](/18-6-14/4361135.jpg) --><p>这周的复习知识点主要是以下几方面：</p><ul><li>设计模式之发布订阅/观察者模式</li><li>事件相关，事件、模型、处理机制</li><li>Ajax</li><li>异步</li></ul><a id="more"></a><p>我将这些点梳理到了脑图中，并作了一些批注，感觉一边整理了知识点，也让自己有了一个整体的脉络和方向感，树越分散也就是所谓的深度，让树更深也就是知识的深度。</p><!-- ![知识点梳理](/18-6-14/52685215.jpg) --><h2 id="从设计原则说起"><a href="#从设计原则说起" class="headerlink" title="从设计原则说起"></a>从设计原则说起</h2><p>一个优秀的程序员通常由其<strong>操作技能</strong>、<strong>知识水平</strong>，<strong>经验层力</strong>和<strong>能力</strong>四个方面组成。这些原则，也就是巨人的肩膀，总结而出流传至今，每一个程序员都应该了解，运用于开发和生活中。</p><p>要我来说的话就是，先去了解，知道有这些东西，也许不能马上运用到实际项目中，但当我们遇到困难时，就可以回顾一下图里的各原则，结合以下经验：</p><ol><li>粗浅地了解这些原则</li><li>在（公司或开源）项目中观察或总结他人或自己的设计</li><li>实践、回顾，再总结</li><li>总结后再回到第1步深入了解以此往复</li></ol><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>比较概念的解释是，目标和观察者是基类，目标提供维护观察者的一系列方法，观察者提供更新接口。具体观察者和具体目标继承各自的基类，然后具体观察者把自己注册到具体目标里，在具体目标发生变化时候，调度观察者的更新方法</p><!-- ![观察者模式](/18-6-14/636423.jpg) --><p>简易版观察者模式实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObserverList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.observerList = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observerList.push(observer)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get(index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="keyword">this</span>.count()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.observerList[index]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeAt(index) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observerList.splice(index, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  count() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.observerList.length</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  indexOf(observer, startIndex = <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = startIndex</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="keyword">this</span>.count()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.observerList[i] === observer) &#123;</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">      &#125;</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers = <span class="keyword">new</span> ObserverList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addObserver(observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.add(observer)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeObserver(observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.removeAt(<span class="keyword">this</span>.observers.indexOf(observer))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify(...args) &#123;</span><br><span class="line">    <span class="keyword">let</span> observerCount = <span class="keyword">this</span>.observers.count()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; observerCount; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>.observers.get(i).update(args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p>比较概念的解释是，订阅者把自己想订阅的事件注册到调度中心，当该事件触发时候，发布者发布该事件到调度中心（顺带上下文），由调度中心统一调度订阅者注册到调度中心的处理代码。</p><!-- ![发布订阅模式](/18-6-14/91374451.jpg) --><p>简易版发布订阅模式实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">PubSub</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subscribers = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  subscribe(type, fn) &#123;</span><br><span class="line">    <span class="keyword">let</span> listeners = <span class="keyword">this</span>.subscribers[type] || []</span><br><span class="line">    listeners.push(fn)</span><br><span class="line">    <span class="keyword">this</span>.subscribers[type] = listeners</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  unsubscribe(type, fn) &#123;</span><br><span class="line">    <span class="keyword">let</span> listeners = <span class="keyword">this</span>.subscribers[type]</span><br><span class="line">    <span class="keyword">if</span> (!listeners) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">this</span>.subscribers[type] = listeners.filter(<span class="function"><span class="params">v</span> =&gt;</span> v !== fn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  publish(type, ...args) &#123;</span><br><span class="line">    <span class="keyword">let</span> listeners = <span class="keyword">this</span>.subscribers[type]</span><br><span class="line">    <span class="keyword">if</span> (!listeners) <span class="keyword">return</span></span><br><span class="line">    listeners.forEach(<span class="function"><span class="params">item</span> =&gt;</span> (item.apply(type, args)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><ul><li>两者最大的区别是调度的地方<br>虽然两种模式都存在订阅者和发布者（具体观察者可认为是订阅者，具体目标可认为是观察者），但是观察者模式是由具体目标调度的，而发布/订阅模式是统一由调度中心调度的。所以观察者模式的订阅者和发布者之间是存在依赖的，而发布/订阅模式则不会</li><li>两种模式都可以用于松散耦合，改进代码管理和潜在的复用</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>观察者和发布/订阅模式鼓励我们认真思考应用程序不同部分之间的关​​系。他们还帮助我们确定包含直接关系的层次，而这些关系可以用主题和观察者集合取而代之。这可以有效地将应用程序分解为更小，更松散的块，以改善代码管理和重用的潜力。</p><p>使用Observer模式的进一步动机是我们需要保持相关对象之间的一致性，而不需要使类紧密耦合。例如，当一个对象需要能够通知其他对象而不做这些对象的假设时。</p><p>使用这两种模式时，观察者和主体之间可能存在动态关系。这提供了很大的灵活性，当我们的应用程序的不同部分紧密耦合时，这可能不容易实现。</p><p>尽管对于每个问题来说，这并不总是最好的解决方案，但这些模式仍然是设计分离系统的最佳工具之一，应该被视为任何JavaScript开发人员的工具带中的重要工具。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>因此，这些模式的一些问题实际上源于其主要益处。在“发布/订阅”中，通过将发布者与订阅者分离，有时可能难以获得我们应用程序的特定部分正常运行的保证。</p><p>例如，发布商可能会假定一个或多个订阅者正在倾听他们。假设我们正在使用这样的假设来记录或输出关于某些应用程序过程的错误。如果执行日志记录的用户崩溃（或出于某种原因无法运行），由于系统的解耦特性，发布者将无法看到这种情况。</p><p>这种模式的另一个缺点是用户对彼此的存在并不知情，并且对转换发布商的成本视而不见。由于用户和发布者之间的动态关系，更新依赖性很难追踪。</p><hr><h3 id="实践应用-实现Vue的双向绑定"><a href="#实践应用-实现Vue的双向绑定" class="headerlink" title="实践应用 - 实现Vue的双向绑定"></a>实践应用 - 实现Vue的双向绑定</h3><p>这么一看的话，其实Vue里的双向绑定的实现也是发布订阅模式吧。为什么不是观察者？ 因为多了一个Watcher，这就是相当于调度中心，通过这一层为中间人进行的更新。</p><p>这类的代码看多少次都不嫌多，这是之前网上一个不错的实现，我拿过来学习了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVue</span> </span>&#123;</span><br><span class="line">  <span class="comment">// new Vue(&#123; ... &#125;) 这个options就是这里的对象啦</span></span><br><span class="line">  <span class="comment">// 初始化 将 options 赋值到实例对象上</span></span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$options = options</span><br><span class="line">    <span class="keyword">this</span>.$el = <span class="built_in">document</span>.querySelector(options.el)</span><br><span class="line">    <span class="keyword">this</span>.$data = options.data</span><br><span class="line">    <span class="keyword">this</span>.$methods = options.methods</span><br><span class="line">    <span class="comment">// data的内容会放到这里来， 这也就说明了 初始化结束后，手动加的值不会被监听到</span></span><br><span class="line">    <span class="keyword">this</span>._binding = &#123;&#125;</span><br><span class="line">    <span class="comment">// 初始化时会监听data上的属性</span></span><br><span class="line">    <span class="keyword">this</span>._observe(<span class="keyword">this</span>.$data)</span><br><span class="line">    <span class="comment">// 初始化时 编译 $el 里的子节点</span></span><br><span class="line">    <span class="keyword">this</span>._compile(<span class="keyword">this</span>.$el)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _observe(obj) &#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">        that._binding[key] = &#123;</span><br><span class="line">          <span class="comment">// 添加依赖收集， 是个数组</span></span><br><span class="line">          _directives: []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(that._binding[key])</span><br><span class="line">        <span class="keyword">let</span> val = obj[key]</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'object'</span>) &#123;</span><br><span class="line">          <span class="comment">// 若是对象就递归</span></span><br><span class="line">          that._observe(val)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> binding = that._binding[key]</span><br><span class="line">        <span class="comment">// 响应式 双向绑定的核心操作</span></span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(that.$data, key, &#123;</span><br><span class="line">          enumerable: <span class="literal">true</span>,</span><br><span class="line">          configurable: <span class="literal">true</span>,</span><br><span class="line">          get() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> 获取 <span class="subst">$&#123;val&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">          &#125;,</span><br><span class="line">          set(newVal) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> 更新 <span class="subst">$&#123;newVal&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">if</span> (val !== newVal) &#123;</span><br><span class="line">              val = newVal</span><br><span class="line">              binding._directives.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">                item.update()</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _compile(root) &#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> nodes = root.children</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nodes.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> node = nodes[i]</span><br><span class="line">      <span class="keyword">if</span> (node.children.length) &#123;</span><br><span class="line">        <span class="keyword">this</span>._compile(node)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (node.hasAttribute(<span class="string">'v-click'</span>)) &#123;</span><br><span class="line">        node.onclick = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">let</span> attrVal = nodes[i].getAttribute(<span class="string">'v-click'</span>)</span><br><span class="line">          <span class="keyword">return</span> that.$methods[attrVal].bind(that.$data)</span><br><span class="line">        &#125;)()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (node.hasAttribute(<span class="string">'v-model'</span>) &amp;&amp; (node.tagName === <span class="string">'INPUT'</span> || node.tagName === <span class="string">'TEXTAREA'</span>)) &#123;</span><br><span class="line">        node.addEventListener(<span class="string">'input'</span>, (<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">let</span> attrVal = node.getAttribute(<span class="string">'v-model'</span>)</span><br><span class="line">          that._binding[attrVal]._directives.push(<span class="keyword">new</span> Wathcer(</span><br><span class="line">            <span class="string">'input'</span>,</span><br><span class="line">            node,</span><br><span class="line">            that,</span><br><span class="line">            attrVal,</span><br><span class="line">            <span class="string">'value'</span></span><br><span class="line">          ))</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            that.$data[attrVal] = nodes[key].value</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)(i))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (node.hasAttribute(<span class="string">'v-bind'</span>)) &#123;</span><br><span class="line">        <span class="keyword">let</span> attrVal = node.getAttribute(<span class="string">'v-bind'</span>)</span><br><span class="line">        that._binding[attrVal]._directives.push(<span class="keyword">new</span> Watcher(</span><br><span class="line">          <span class="string">'text'</span>,</span><br><span class="line">          node,</span><br><span class="line">          that,</span><br><span class="line">          attrVal,</span><br><span class="line">          <span class="string">'innerHTML'</span></span><br><span class="line">        ))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, el, vm, exp, attr) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name    <span class="comment">// 指令名</span></span><br><span class="line">    <span class="keyword">this</span>.el = el        <span class="comment">// 指令对应dom</span></span><br><span class="line">    <span class="keyword">this</span>.vm = vm        <span class="comment">// 指令所属MyVue实例</span></span><br><span class="line">    <span class="keyword">this</span>.exp = exp      <span class="comment">// 指令对应值</span></span><br><span class="line">    <span class="keyword">this</span>.attr = attr    <span class="comment">// 绑定的属性值</span></span><br><span class="line">    <span class="keyword">this</span>.update()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="keyword">this</span>.el[<span class="keyword">this</span>.attr] = <span class="keyword">this</span>.vm.$data[<span class="keyword">this</span>.exp]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>这里说一下，我们通过 new 生成了一个 MyVue实例，而传入的参数（对象）作为配置，在初始化阶段做了这些事情：</p><ol><li>赋值，实例的 $options $el $data $method 都是从options里获取到的</li><li>_observe 为每一个实例上的data属性添加监听 （通过Object.defineProperty）</li><li>_compile 编译节点，指令对应的value对应一个新的Watcher，进行依赖收集从而触发数据响应</li></ol><p>于是到codepen上试试吧</p><iframe height="300" scrolling="no" title="simple Vue ~ MVVM" src="//codepen.io/fridolph/embed/gKxrBO/?height=300&theme-id=dark&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/fridolph/pen/gKxrBO/" target="_blank" rel="noopener">simple Vue ~ MVVM</a> by fridolph (<a href="https://codepen.io/fridolph" target="_blank" rel="noopener">@fridolph</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><hr><h2 id="event-js-的实现"><a href="#event-js-的实现" class="headerlink" title="event.js 的实现"></a>event.js 的实现</h2><p>这是一个典型的发布订阅模式的应用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义R对象 如果支持es6用原生的Reflect，没就相当于提供polyfill</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> R = <span class="keyword">typeof</span> <span class="built_in">Reflect</span> === <span class="string">'object'</span> ? <span class="built_in">Reflect</span> : <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> ReflectApply = R &amp;&amp; <span class="keyword">typeof</span> R.apply === <span class="string">'function'</span></span><br><span class="line">  ? R.apply</span><br><span class="line">  : <span class="function"><span class="keyword">function</span> <span class="title">ReflectApply</span>(<span class="params">target, receiver, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.apply.call(target, receiver, args);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">var</span> ReflectOwnKeys</span><br><span class="line"><span class="keyword">if</span> (R &amp;&amp; <span class="keyword">typeof</span> R.ownKeys === <span class="string">'function'</span>) &#123;</span><br><span class="line">  ReflectOwnKeys = R.ownKeys</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Object</span>.getOwnPropertySymbols) &#123;</span><br><span class="line">  ReflectOwnKeys = <span class="function"><span class="keyword">function</span> <span class="title">ReflectOwnKeys</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.getOwnPropertyNames(target)</span><br><span class="line">      .concat(<span class="built_in">Object</span>.getOwnPropertySymbols(target));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ReflectOwnKeys = <span class="function"><span class="keyword">function</span> <span class="title">ReflectOwnKeys</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.getOwnPropertyNames(target);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.warn的封装</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProcessEmitWarning</span>(<span class="params">warning</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">console</span> &amp;&amp; <span class="built_in">console</span>.warn) <span class="built_in">console</span>.warn(warning);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Number.isNaN 是es6加入的，后面是并联的兼容处理，Number类型 自身与自身不相等的只有NaN了</span></span><br><span class="line"><span class="keyword">var</span> NumberIsNaN = <span class="built_in">Number</span>.isNaN || <span class="function"><span class="keyword">function</span> <span class="title">NumberIsNaN</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value !== value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventEmitter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  EventEmitter.init.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将EventEmitter构造函数作为默认导出</span></span><br><span class="line"><span class="built_in">module</span>.exports = EventEmitter;</span><br><span class="line"><span class="comment">// 向后兼容node 0.10.x 版本 看来这个库相当老了啊，不过也不妨碍我们学习</span></span><br><span class="line"></span><br><span class="line">EventEmitter.EventEmitter = EventEmitter;</span><br><span class="line">EventEmitter.prototype._events = <span class="literal">undefined</span>;</span><br><span class="line">EventEmitter.prototype._eventsCount = <span class="number">0</span>;</span><br><span class="line">EventEmitter.prototype._maxListeners = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认情况下，如果超过10个侦听器，EventEmitters将会输出警告添加到它</span></span><br><span class="line"><span class="comment">// 这是一个有用的默认值，它有助于查找内存泄漏</span></span><br><span class="line"><span class="keyword">var</span> defaultMaxListeners = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(EventEmitter, <span class="string">'defaultMaxListeners'</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> defaultMaxListeners;</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">'number'</span> || arg &lt; <span class="number">0</span> || NumberIsNaN(arg)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '</span> + arg + <span class="string">'.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    defaultMaxListeners = arg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造类的静态方法</span></span><br><span class="line">EventEmitter.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 相当于constructor的构造函数调用 初始化</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._events === <span class="literal">undefined</span> ||</span><br><span class="line">      <span class="keyword">this</span>._events === <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>)._events) &#123;</span><br><span class="line">    <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">this</span>._eventsCount = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._maxListeners = <span class="keyword">this</span>._maxListeners || <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显然不是所有的Emitters侦听器都应该限制为10个。这个功能允许增加</span></span><br><span class="line">EventEmitter.prototype.setMaxListeners = <span class="function"><span class="keyword">function</span> <span class="title">setMaxListeners</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> n !== <span class="string">'number'</span> || n &lt; <span class="number">0</span> || NumberIsNaN(n)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'The value of "n" is out of range. It must be a non-negative number. Received '</span> + n + <span class="string">'.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._maxListeners = n;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给下面的 getMaxListeners方法用  EventEmitter原型方法里的 this指向实例对象</span></span><br><span class="line"><span class="comment">// 所以可从实例中 拿到 属性值 _maxListeners</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$getMaxListeners</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (that._maxListeners === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> EventEmitter.defaultMaxListeners;</span><br><span class="line">  <span class="keyword">return</span> that._maxListeners;</span><br><span class="line">&#125;</span><br><span class="line">EventEmitter.prototype.getMaxListeners = <span class="function"><span class="keyword">function</span> <span class="title">getMaxListeners</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> $getMaxListeners(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span> <span class="title">emit</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="comment">// emit第一个参数一般是方法名，所以 从arguments[1]开始</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">  <span class="comment">// 右边的表达式返回一个布尔值 ，type报错就为true。doError可理解为错误标记的flag</span></span><br><span class="line">  <span class="keyword">var</span> doError = (type === <span class="string">'error'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拿到 实例的 _events 对象</span></span><br><span class="line">  <span class="keyword">var</span> events = <span class="keyword">this</span>._events;</span><br><span class="line">  <span class="keyword">if</span> (events !== <span class="literal">undefined</span>)</span><br><span class="line">    <span class="comment">// 没有错就直接返回 false</span></span><br><span class="line">    doError = (doError &amp;&amp; events.error === <span class="literal">undefined</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!doError)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面是错误处理</span></span><br><span class="line">  <span class="keyword">if</span> (doError) &#123;</span><br><span class="line">    <span class="keyword">var</span> er;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>)</span><br><span class="line">      er = args[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (er <span class="keyword">instanceof</span> <span class="built_in">Error</span>) &#123;</span><br><span class="line">      <span class="comment">// 注意：“throw”这一行的注释是有意的，他们表示 如果这导致未处理的异常，则在Node的输出中输入。</span></span><br><span class="line">      <span class="keyword">throw</span> er;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 错误上下文为er 这里的er就是传进来的type的报错环境上下文</span></span><br><span class="line">    <span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unhandled error.'</span> + (er ? <span class="string">' ('</span> + er.message + <span class="string">')'</span> : <span class="string">''</span>));</span><br><span class="line">    err.context = er;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从events里找type对应的函数 拿到 并赋给handler</span></span><br><span class="line">  <span class="keyword">var</span> handler = events[type];</span><br><span class="line">  <span class="keyword">if</span> (handler === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handler === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// 绑定上下文</span></span><br><span class="line">    ReflectApply(handler, <span class="keyword">this</span>, args);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// handler多次调用  把多个handler 放到数组里来处理</span></span><br><span class="line">    <span class="keyword">var</span> len = handler.length;</span><br><span class="line">    <span class="keyword">var</span> listeners = arrayClone(handler, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">      ReflectApply(listeners[i], <span class="keyword">this</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_addListener</span>(<span class="params">target, type, listener, prepend</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m;</span><br><span class="line">  <span class="keyword">var</span> events;</span><br><span class="line">  <span class="keyword">var</span> existing;</span><br><span class="line">  <span class="comment">// listener类型判断</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The "listener" argument must be of type Function. Received type '</span> + <span class="keyword">typeof</span> listener);</span><br><span class="line">  &#125;</span><br><span class="line">  events = target._events;</span><br><span class="line">  <span class="keyword">if</span> (events === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    events = target._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    target._eventsCount = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 为了避免在 type === "newListener" 这种情况下递归</span></span><br><span class="line">    <span class="comment">// 在将其添加到侦听器之前，首先触发 "newListener"</span></span><br><span class="line">    <span class="keyword">if</span> (events.newListener !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      target.emit(<span class="string">'newListener'</span>, type,</span><br><span class="line">                  listener.listener ? listener.listener : listener);</span><br><span class="line">      <span class="comment">// 重新分配 `events`，因为newListener处理程序可能导致了 this._events被分配给一个新的对象</span></span><br><span class="line">      events = target._events;</span><br><span class="line">    &#125;</span><br><span class="line">    existing = events[type];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (existing === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// 优化一个listener的情况。不需要额外的数组对象</span></span><br><span class="line">    existing = events[type] = listener;</span><br><span class="line">    ++target._eventsCount;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> existing === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// 添加第二个元素，需要更改为数组</span></span><br><span class="line">      existing = events[type] =</span><br><span class="line">        prepend ? [listener, existing] : [existing, listener];</span><br><span class="line">      <span class="comment">//如果我们已经有了一个数组，只需追加</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prepend) &#123;</span><br><span class="line">      existing.unshift(listener);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      existing.push(listener);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查监听器泄漏</span></span><br><span class="line">    m = $getMaxListeners(target);</span><br><span class="line">    <span class="comment">// m &gt; 0 &amp;&amp; (exiting.length &gt; m &amp;&amp; !existing.warned )</span></span><br><span class="line">    <span class="keyword">if</span> (m &gt; <span class="number">0</span> &amp;&amp; existing.length &gt; m &amp;&amp; !existing.warned) &#123;</span><br><span class="line">      existing.warned = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 没有错误代码，因为它是一个warning</span></span><br><span class="line">      <span class="keyword">var</span> w = <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">'Possible EventEmitter memory leak detected. '</span> +</span><br><span class="line">        existing.length + <span class="string">' '</span> + <span class="built_in">String</span>(type) + <span class="string">' listeners '</span> +</span><br><span class="line">        <span class="string">'added. Use emitter.setMaxListeners() to '</span> +</span><br><span class="line">        <span class="string">'increase limit'</span></span><br><span class="line">      )</span><br><span class="line">      w.name = <span class="string">'MaxListenersExceededWarning'</span>;</span><br><span class="line">      w.emitter = target;</span><br><span class="line">      w.type = type;</span><br><span class="line">      w.count = existing.length;</span><br><span class="line">      ProcessEmitWarning(w);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结合上面的函数，这是高阶函数的用法 普通地，我们一般会传 事件名和回调</span></span><br><span class="line"><span class="comment">// 这里返回 _addListner方法 第一个参数是 this 实例对象作为上下文环境</span></span><br><span class="line"><span class="comment">// 然后是 事件名，回调，prepend默认为false</span></span><br><span class="line">EventEmitter.prototype.addListener = <span class="function"><span class="keyword">function</span> <span class="title">addListener</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _addListener(<span class="keyword">this</span>, type, listener, <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 同名方法 addListner 和用 on等效</span></span><br><span class="line">EventEmitter.prototype.on = EventEmitter.prototype.addListener;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和on的区别在于 prepend为true，当前已经是数组了才会这样用（不同我们来，已经封装在内部逻辑里了）</span></span><br><span class="line">EventEmitter.prototype.prependListener = <span class="function"><span class="keyword">function</span> <span class="title">prependListener</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _addListener(<span class="keyword">this</span>, type, listener, <span class="literal">true</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onceWrapper</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 把参数放到 args中。 我们先看下面的 _onceWrap方法</span></span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">  <span class="comment">// 显然，这个if逻辑会走到里</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.fired) &#123;</span><br><span class="line">    <span class="comment">// removeListener会被调用</span></span><br><span class="line">    <span class="keyword">this</span>.target.removeListener(<span class="keyword">this</span>.type, <span class="keyword">this</span>.wrapFn);</span><br><span class="line">    <span class="comment">// 然后再把fired 设回true</span></span><br><span class="line">    <span class="keyword">this</span>.fired = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 这里因为ReflectApply的原因，this上下文回到了 实例对象上</span></span><br><span class="line">    ReflectApply(<span class="keyword">this</span>.listener, <span class="keyword">this</span>.target, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_onceWrap</span>(<span class="params">target, type, listener</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始state</span></span><br><span class="line">  <span class="keyword">var</span> state = &#123; <span class="attr">fired</span>: <span class="literal">false</span>, <span class="attr">wrapFn</span>: <span class="literal">undefined</span>, <span class="attr">target</span>: target, <span class="attr">type</span>: type, <span class="attr">listener</span>: listener &#125;;</span><br><span class="line">  <span class="comment">// 好 有了这个bind后，上面onceWrapper的this就知道了，我们再跳回去</span></span><br><span class="line">  <span class="keyword">var</span> wrapped = onceWrapper.bind(state);</span><br><span class="line">  wrapped.listener = listener;</span><br><span class="line">  state.wrapFn = wrapped;</span><br><span class="line">  <span class="keyword">return</span> wrapped;</span><br><span class="line">  <span class="comment">// 回到wrapped这个上下文中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法可理解为调用一次后 自动把方法注销掉</span></span><br><span class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span> <span class="title">once</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The "listener" argument must be of type Function. Received type '</span> + <span class="keyword">typeof</span> listener);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.on(type, _onceWrap(<span class="keyword">this</span>, type, listener));</span><br><span class="line">  <span class="comment">// 后同，return this 是返回实例对象自身，方便链式调用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.prependOnceListener = <span class="function"><span class="keyword">function</span> <span class="title">prependOnceListener</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The "listener" argument must be of type Function. Received type '</span> + <span class="keyword">typeof</span> listener);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.prependListener(type, _onceWrap(<span class="keyword">this</span>, type, listener));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除监听方法</span></span><br><span class="line">EventEmitter.prototype.removeListener = <span class="function"><span class="keyword">function</span> <span class="title">removeListener</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> list, events, position, i, originalListener;</span><br><span class="line">  <span class="comment">// 错误判断，这里先略过了</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The "listener" argument must be of type Function. Received type '</span> + <span class="keyword">typeof</span> listener);</span><br><span class="line">  &#125;</span><br><span class="line">  events = <span class="keyword">this</span>._events;</span><br><span class="line">  <span class="keyword">if</span> (events === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// list被赋值为evnets[type] 即 一个注册的事件</span></span><br><span class="line">  list = events[type];</span><br><span class="line">  <span class="keyword">if</span> (list === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前list 和所传的注册事件若一致就进入这个逻辑里</span></span><br><span class="line">  <span class="keyword">if</span> (list === listener || list.listener === listener) &#123;</span><br><span class="line">    <span class="comment">// 处理 注册事件 为单个函数 的情况</span></span><br><span class="line">    <span class="keyword">if</span> (--<span class="keyword">this</span>._eventsCount === <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">delete</span> events[type];</span><br><span class="line">      <span class="keyword">if</span> (events.removeListener)</span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">'removeListener'</span>, type, list.listener || listener);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> list !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理 注册事件 为数组的情况</span></span><br><span class="line">    position = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = list.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (list[i] === listener || list[i].listener === listener) &#123;</span><br><span class="line">        originalListener = list[i].listener;</span><br><span class="line">        position = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>)</span><br><span class="line">      list.shift();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      spliceOne(list, position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list.length === <span class="number">1</span>)</span><br><span class="line">      events[type] = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (events.removeListener !== <span class="literal">undefined</span>)</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">'removeListener'</span>, type, originalListener || listener);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同名方法，等同于 removeListener</span></span><br><span class="line">EventEmitter.prototype.off = EventEmitter.prototype.removeListener;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除所有的监听</span></span><br><span class="line">EventEmitter.prototype.removeAllListeners = <span class="function"><span class="keyword">function</span> <span class="title">removeAllListeners</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> listeners, events, i;</span><br><span class="line">  events = <span class="keyword">this</span>._events;</span><br><span class="line">  <span class="keyword">if</span> (events === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不侦听removeListener，不需要触发emit</span></span><br><span class="line">  <span class="keyword">if</span> (events.removeListener === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 通过赋值的方式 让 实例对象的 _events 为空</span></span><br><span class="line">      <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">      <span class="comment">// 事件数清0</span></span><br><span class="line">      <span class="keyword">this</span>._eventsCount = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[type] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (--<span class="keyword">this</span>._eventsCount === <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">delete</span> events[type];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为所有事件上的所有侦听器发出removeListener</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(events);</span><br><span class="line">    <span class="keyword">var</span> key;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; keys.length; ++i) &#123;</span><br><span class="line">      key = keys[i];</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">'removeListener'</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">this</span>.removeAllListeners(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.removeAllListeners(<span class="string">'removeListener'</span>);</span><br><span class="line">    <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">this</span>._eventsCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  listeners = events[type];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> listeners === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.removeListener(type, listeners);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (listeners !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// LIFO order</span></span><br><span class="line">    <span class="keyword">for</span> (i = listeners.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">this</span>.removeListener(type, listeners[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样的，我们先看 原型方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_listeners</span>(<span class="params">target, type, unwrap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> events = target._events;</span><br><span class="line">  <span class="keyword">if</span> (events === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  <span class="comment">// 参数type为事件名</span></span><br><span class="line">  <span class="keyword">var</span> evlistener = events[type];</span><br><span class="line">  <span class="keyword">if</span> (evlistener === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> evlistener === <span class="string">'function'</span>)</span><br><span class="line">    <span class="keyword">return</span> unwrap ? [evlistener.listener || evlistener] : [evlistener];</span><br><span class="line">  <span class="keyword">return</span> unwrap ?</span><br><span class="line">    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.listeners = <span class="function"><span class="keyword">function</span> <span class="title">listeners</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回 _listeners调用的结果，回到 _listener函数</span></span><br><span class="line">  <span class="keyword">return</span> _listeners(<span class="keyword">this</span>, type, <span class="literal">true</span>);</span><br><span class="line">&#125;;</span><br><span class="line">EventEmitter.prototype.rawListeners = <span class="function"><span class="keyword">function</span> <span class="title">rawListeners</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _listeners(<span class="keyword">this</span>, type, <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br><span class="line">EventEmitter.listenerCount = <span class="function"><span class="keyword">function</span>(<span class="params">emitter, type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> emitter.listenerCount === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> emitter.listenerCount(type);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> listenerCount.call(emitter, type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">EventEmitter.prototype.listenerCount = listenerCount;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listenerCount</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> events = <span class="keyword">this</span>._events;</span><br><span class="line">  <span class="keyword">if</span> (events !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> evlistener = events[type];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> evlistener === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (evlistener !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> evlistener.length;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EventEmitter.prototype.eventNames = <span class="function"><span class="keyword">function</span> <span class="title">eventNames</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._eventsCount &gt; <span class="number">0</span> ? ReflectOwnKeys(<span class="keyword">this</span>._events) : [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助方法，浅拷贝数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayClone</span>(<span class="params">arr, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> copy = <span class="keyword">new</span> <span class="built_in">Array</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    copy[i] = arr[i];</span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组中删除某项</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spliceOne</span>(<span class="params">list, index</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; index + <span class="number">1</span> &lt; list.length; index++)</span><br><span class="line">    list[index] = list[index + <span class="number">1</span>];</span><br><span class="line">  list.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// listner的拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unwrapListeners</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = <span class="keyword">new</span> <span class="built_in">Array</span>(arr.length);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ret.length; ++i) &#123;</span><br><span class="line">    ret[i] = arr[i].listener || arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;先扯点闲话。一时兴起，遂决定之后采用这个前缀来写这个十多篇的系列总结了。在之前的学习和博客整理中，感觉都挺没方向，很散乱。除了看书的总结外，其他时候都是零碎性地学习，我想，若能系统性地带着目的去散落这些点，再类似依赖收集一样把这些零碎的东西汇总整理出来，那应该也挺不错的~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- ![学习正则表达式](/18-6-14/4361135.jpg) --&gt;
&lt;p&gt;这周的复习知识点主要是以下几方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设计模式之发布订阅/观察者模式&lt;/li&gt;
&lt;li&gt;事件相关，事件、模型、处理机制&lt;/li&gt;
&lt;li&gt;Ajax&lt;/li&gt;
&lt;li&gt;异步&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.fridolph.top/categories/JavaScript/"/>
    
    
      <category term="设计模式" scheme="http://blog.fridolph.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="观察者" scheme="http://blog.fridolph.top/tags/%E8%A7%82%E5%AF%9F%E8%80%85/"/>
    
      <category term="发布订阅" scheme="http://blog.fridolph.top/tags/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/"/>
    
  </entry>
  
  <entry>
    <title>【年中总结】提升学习效率，良好习惯养成与坚持</title>
    <link href="http://blog.fridolph.top/2018/06/03/%E3%80%90%E5%B9%B4%E6%80%BB%E7%BB%93%E3%80%91%E6%8F%90%E5%8D%87%E5%AD%A6%E4%B9%A0%E6%95%88%E7%8E%87%EF%BC%8C%E8%89%AF%E5%A5%BD%E4%B9%A0%E6%83%AF%E5%85%BB%E6%88%90%E4%B8%8E%E5%9D%9A%E6%8C%81/"/>
    <id>http://blog.fridolph.top/2018/06/03/【年总结】提升学习效率，良好习惯养成与坚持/</id>
    <published>2018-06-03T13:12:03.000Z</published>
    <updated>2024-01-01T06:26:02.002Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/06/03/【年总结】提升学习效率，良好习惯养成与坚持/18-6-6/82300696.jpg" alt=""></p><blockquote><p>2018年已过了一半，自己的目标也在稳步进行着，但这还不够，于是制定了这个年底前的冲刺计划。希望自己能坚持下来，顺利达成今年的最终目标！  于是这篇没什么技术含量，纯抒情~</p></blockquote><a id="more"></a><p>好在春节后工作上压力少了些，周末基本没加班了。在周二或三，周末拿一天出去打打羽毛球或者乒乓球的运动节奏下，颈椎基本没事了。身体才是革命的本钱啊。闹钟定在6点半，提醒自己一定吃了饭后再回公司，以免8点半后除了面没什么吃的了。</p><p>在年中也写好了年中总结和相关计划，对于自己的表现只能说中规中矩吧，克服了几个技术难点：</p><ul><li>v18n国际化</li><li>权限控制分级下的组件模块化</li><li>vuex模块分层及本地api缓存</li></ul><p>感觉完成度不是太高，还有待继续优化和学习。新入坑了好几个技能点（感觉技能点都没点亮的程度）</p><ul><li>Vue SSR服务端渲染 （勉强算是把demo做出来了。。 对于原生ssr还是一知半解）</li><li>Nuxt 入坑了一小半，个人网站的搭建用到了，目前完成66%吧（就差作品整理了希望9月左右能完善上线）</li><li>微信小程序 原生貌似是 view - text -&gt; div - span 的感觉，最近美团开源的mpvue拿来练手，把个人网站的图书模块拿来做demo了</li><li>TypeScript 拿来把vue-where-go项目重构了下，但build失败只能跑dev - - 引better-scroll报错还是没解决，趁deno的热劲，后半年的重点之一就是系统学习TypeScript了</li></ul><p>上面的感觉完成度都在80%左右吧，还有就是网上看到个不错的在线简历，自己拿来改成了响应式，感觉还不错，在下一份工作确定后我就开源出来 -w- 后半年继续了解把demo做了博客写了，以上先告一段落吧。</p><hr><p>之后的目标计划和达成目标：</p><ol><li>前端测试相关</li><li>前端基础、难点、考点梳理</li><li>正则表达式强化学习</li><li>webpack再学习 （还停留在3.11 初步了解4.5 现在貌似4.8了？）</li><li>前端性能相关</li><li>原生Node模块 + express + koa</li><li>再深入框架 Vue React</li></ol><hr><p>2 的话，新入的几个知乎live，掘金的小册可以帮到梳理不少，之前慕课的几个好课程也有很多参考。</p><p>性能的话，受到之前掘金一篇文章影响，（作者是应届生啊，现在的人真是越来越牛了，再不努力以后要失业了）准备后面有时间好好学习下 <a href="https://github.com/pod4g/hiper" target="_blank" rel="noopener">hiper</a> 源码</p><p>Node很纠结啦，说不会，天天用天天写？ 说会，也就writeFile、npm install npm run 什么的… 大前端就在前方，虽然被亲爹抛弃了，还是有很高的学习价值，服务端 express -&gt; koa -&gt; egg 我是按这个流程先过渡啦</p><p><img src="https://img1.doubanio.com/view/subject/l/public/s29715097.jpg" alt=""></p><p><img src="https://img1.doubanio.com/view/subject/l/public/s29735438.jpg" alt=""></p><p>这两本对于上面的总结很有帮助，顺便就安利出来了。打折活动顺便还买了几个Node、Vue、React相关的书，再此期间，每周坚持写博客，希望不会打脸。</p><p>我相信时间是真的可以挤出来的（相信有什么X用，道理懂就是想说啊） … 但问题是世界杯来了 - - 还好喜欢的荷兰今年没入选，作为一名伪球迷小组赛德国阿根廷巴西西班牙可以看看，之后就是1/4和决赛了吧</p><p>还有房租到期了，该搬家了 … 想着就头大。 等等，好像可以去摇号了？ 各种麻烦，还是再租5年房吧，期待以久的7月—— OverLoad、绮玉sense、巨人 …… 真美好，于是，存到10月吧？！</p><hr><p>我还是想说 ~ 恭喜RNG</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1528284389223&amp;di=989cd89eea25cc50b626e0f290f32517&amp;imgtype=0&amp;src=http%3A%2F%2Fnpic7.edushi.com%2Fcn%2Fzixun%2Fzh-chs%2F2018-05%2F21%2F4404599-201805210954256741.jpg" alt=""></p><p>大声告诉自己，此刻的我最想：</p><p><del>补番、打游戏、打球、K歌、狼人杀、旅行</del> 敲代码，好好学习，天天向上。</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1528285008590&amp;di=61ab62cee77c0250c5d4b954d8f8150c&amp;imgtype=0&amp;src=http%3A%2F%2Fcdn.oss.gaokaopai.com%2Fmobile%2Fface%2Fpost%2F2017%2F11%2F06%2Fthumb%2F2017110692731509975374500_and.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/06/03/【年总结】提升学习效率，良好习惯养成与坚持/18-6-6/82300696.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2018年已过了一半，自己的目标也在稳步进行着，但这还不够，于是制定了这个年底前的冲刺计划。希望自己能坚持下来，顺利达成今年的最终目标！  于是这篇没什么技术含量，纯抒情~&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="总结" scheme="http://blog.fridolph.top/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://blog.fridolph.top/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>【小程序】mpvue开发小程序初体验</title>
    <link href="http://blog.fridolph.top/2018/05/07/%E3%80%90%E5%B0%8F%E7%A8%8B%E5%BA%8F%E3%80%91mpvue%E5%BC%80%E5%8F%91%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://blog.fridolph.top/2018/05/07/【小程序】mpvue开发小程序初体验/</id>
    <published>2018-05-07T13:52:15.000Z</published>
    <updated>2024-01-01T07:23:01.484Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>mpvue （github 地址请参见）是一个使用 Vue.js 开发小程序的前端框架。框架基于 Vue.js 核心，mpvue 修改了 Vue.js 的 runtime 和 compiler 实现，使其可以运行在小程序环境中，从而为小程序开发引入了整套 Vue.js 开发体验。</p></blockquote><p>具体可以参考官方文档，之前虽然也尝试过小程序，就觉得是vue + react，半杂着es6和模版代码，由于没有css预处理器写起来样式和组件化感觉都很麻烦，正好趁着火热，把一直想做的小程序继续完成了。</p><a id="more"></a><p>周末做了2天总算是熬出来了 ……实在是不想写博客啊。 好了不发牢骚，开始正文</p><p>小程序的初始化这里就不介绍了，搬网上的文字也没意思， 直接看这里 <a href="http://mpvue.com/mpvue/quickstart/" target="_blank" rel="noopener">http://mpvue.com/mpvue/quickstart/</a></p><p>项目跑起来打包出来的dist就是我们需要的文件了，我们先看下根目录下的配置文件 project.config.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"description"</span>: <span class="string">"项目配置文件。"</span>,</span><br><span class="line"><span class="attr">"setting"</span>: &#123;</span><br><span class="line"><span class="attr">"urlCheck"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">"es6"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"postcss"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">"minified"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">"newFeature"</span>: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"miniprogramRoot"</span>: <span class="string">"./dist/"</span>,</span><br><span class="line"><span class="attr">"client"</span>: <span class="string">"./dist"</span>,</span><br><span class="line"><span class="attr">"svr"</span>: <span class="string">"./server"</span>,</span><br><span class="line"><span class="attr">"qcloudRoot"</span>: <span class="string">"./server"</span>,</span><br><span class="line"><span class="attr">"appid"</span>: <span class="string">"你的小程序id"</span>,</span><br><span class="line"><span class="attr">"projectname"</span>: <span class="string">"my-miniapp"</span>,</span><br><span class="line"><span class="attr">"compileType"</span>: <span class="string">"miniprogram"</span></span><br><span class="line">  // condition 不知道干啥的，这里没贴</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>很有意思的点在于，小程序每个文件都有一个json配置文件，可理解为这是多页的SPA组合而成。如果要引入vuex需在每<code>页</code>的entry中引入。那问题是会不会出现类似于flux多个store导致状态管理混乱的情况？ 这个具体的还没有试过，等有时间把应用做大点，想尝试下。</p></blockquote><p>一看就明白的配置，还是要说说。 setting里是针对打包后的dist目录，这里没有开启es6（毕竟babel本来就是编译为es5的）</p><p>miniprogramRoot 就是小程序开发工具 读的app入口了。client和svr是我根据官方的demo改的，这样，可以上传server到测试环境里，直接mock数据。</p><hr><p>不用写那啥wxss和小程序原生的模版还是挺好，用多了和React、Vue挺混乱的，感觉后期会精分。</p><p>npm run dev 其实会打包出来 dist 而小程序找的是这个dist，其内容被mpvue转成了 微信小程序的原生模版映射。小程序会在开发环境下分配测试域名，我们要mock数据貌似只能通过该方式来（没了解太多，有其他方式请批评指教）</p><p>server/routes/index.js</p><pre><code>router.get(&apos;/books&apos;, ccontrollers.books)</code></pre><p>server端是express，看着还是挺熟悉，这是定义接口，于是我们顺藤摸瓜到 server/controllers 下</p><p><code>index.js</code>文件是作路由映射，<code>module.exports = mapDir(path.join(__dirname))</code> 找到当前文件夹下的文件或文件夹。我们随便打开个文件看看，如 user.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line"><span class="comment">// 通过 Koa 中间件进行登录态校验之后</span></span><br><span class="line"><span class="comment">// 登录信息会被存储到 ctx.state.$wxInfo</span></span><br><span class="line"><span class="comment">// 具体查看：</span></span><br><span class="line"><span class="keyword">if</span> (ctx.state.$wxInfo.loginState === <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// loginState 为 1，登录态校验成功</span></span><br><span class="line">ctx.state.data = ctx.state.$wxInfo.userinfo</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ctx.state.code = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释得很清楚，若访问服务端 <code>/user</code> 就能在<code>ctx.state</code>中拿到我们想到的数据了。</p><p>于是编写一个 books.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">  ctx.state.data = &#123;</span><br><span class="line">    books: [</span><br><span class="line"><span class="comment">// 数据省略</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前台访问</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HOST = <span class="string">'用腾讯云分配的域名即可'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="comment">// 省略</span></span><br><span class="line">methods: &#123;</span><br><span class="line">getCgiBooks() &#123;</span><br><span class="line">      <span class="comment">// util.showBusy('请求中...')</span></span><br><span class="line">      <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">      wx.getStorage(&#123;</span><br><span class="line">        key: <span class="string">'booklist'</span>,</span><br><span class="line">        success(res) &#123;</span><br><span class="line">          <span class="comment">// console.log('从缓存拿booklist', res.data)</span></span><br><span class="line">          that.books = res.data</span><br><span class="line">        &#125;,</span><br><span class="line">        fail(err) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(err)</span><br><span class="line">          wx.request(&#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;HOST&#125;</span>/weapp/books`</span>,</span><br><span class="line">            login: <span class="literal">false</span>,</span><br><span class="line">            success(result) &#123;</span><br><span class="line">              <span class="comment">// util.showSuccess('请求成功完成')</span></span><br><span class="line">              <span class="comment">// console.log('请求服务端拿到booklist', result.data.data.books)</span></span><br><span class="line">              that.books = result.data.data.books</span><br><span class="line">              wx.setStorage(&#123;</span><br><span class="line">                key: <span class="string">'booklist'</span>,</span><br><span class="line">                data: result.data.data.books</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            fail(error) &#123;</span><br><span class="line">              <span class="comment">// util.showModel('请求失败', error)</span></span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">'request fail'</span>, error)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步和回调很多，随着业务场景的复杂度提升感觉后期的回调会很可怕…… 所以可根据场景自行封装Promise，使用async/await的方式</p><h2 id="先挖坑"><a href="#先挖坑" class="headerlink" title="先挖坑"></a>先挖坑</h2><p>小程序还在开发中。直接拿vue来写，上手超快，有其他坑再上来补充好来。。</p><p>主要是小程序还未发布，只能本地玩，之后再把项目踩坑等传上来。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;mpvue （github 地址请参见）是一个使用 Vue.js 开发小程序的前端框架。框架基于 Vue.js 核心，mpvue 修改了 Vue.js 的 runtime 和 compiler 实现，使其可以运行在小程序环境中，从而为小程序开发引入了整套 Vue.js 开发体验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体可以参考官方文档，之前虽然也尝试过小程序，就觉得是vue + react，半杂着es6和模版代码，由于没有css预处理器写起来样式和组件化感觉都很麻烦，正好趁着火热，把一直想做的小程序继续完成了。&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://blog.fridolph.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="mpvue" scheme="http://blog.fridolph.top/tags/mpvue/"/>
    
      <category term="小程序" scheme="http://blog.fridolph.top/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>【TS】使用vuex-class</title>
    <link href="http://blog.fridolph.top/2018/05/01/%E3%80%90TS%E3%80%91%E4%BD%BF%E7%94%A8vuex-class/"/>
    <id>http://blog.fridolph.top/2018/05/01/【TS】使用vuex-class/</id>
    <published>2018-05-01T02:29:03.000Z</published>
    <updated>2024-01-01T07:24:04.675Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>vuex-class</code>是<code>vue-class-component</code>作者写的，质量有保证。且目前这类的库也不多，用法和之前的vue-property-decorator差不多，主要是通过装饰器模式，一来支持ts里的vuex，二来减少冗余的代码量。</p></blockquote><a id="more"></a><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>我们直接来看官方的例子就好，引入相关依赖</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">'vue-class-component'</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  State,</span><br><span class="line">  Getter,</span><br><span class="line">  Action,</span><br><span class="line">  Mutation,</span><br><span class="line">  namespace</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'vuex-class'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> someModule = namespace(<span class="string">'path/to/module'</span>)</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  @State(<span class="string">'foo'</span>) stateFoo</span><br><span class="line">  @State(<span class="function"><span class="params">state</span> =&gt;</span> state.bar) stateBar</span><br><span class="line">  @Getter(<span class="string">'foo'</span>) getterFoo</span><br><span class="line">  @Action(<span class="string">'foo'</span>) actionFoo</span><br><span class="line">  @Mutation(<span class="string">'foo'</span>) mutationFoo</span><br><span class="line">  @someModule.Getter(<span class="string">'foo'</span>) moduleGetterFoo</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 若省略参数，直接使用参数名称</span></span><br><span class="line">  @State foo</span><br><span class="line">  @Getter bar</span><br><span class="line">  @Action baz</span><br><span class="line">  @Mutation qux</span><br><span class="line"></span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="keyword">this</span>.stateFoo <span class="comment">// -&gt; store.state.foo</span></span><br><span class="line">    <span class="keyword">this</span>.stateBar <span class="comment">// -&gt; store.state.bar</span></span><br><span class="line">    <span class="keyword">this</span>.getterFoo <span class="comment">// -&gt; store.getters.foo</span></span><br><span class="line">    <span class="keyword">this</span>.actionFoo(&#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; store.dispatch('foo', &#123; value: true &#125;)</span></span><br><span class="line">    <span class="keyword">this</span>.mutationFoo(&#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; store.commit('foo', &#123; value: true &#125;)</span></span><br><span class="line">    <span class="keyword">this</span>.moduleGetterFoo <span class="comment">// -&gt; store.getters['path/to/module/foo']</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看着非常简单… 好像懂了 大概就是这种感觉？！</p><p>然而 namespace 这个就找不到，需要自己在 <code>*.d.ts</code>文件里定义接口</p><p>和我们之前用的vuex提供的 mapMutations mapGetters 这些一样，只是换了种形式进来了而已。</p><p>源码也更少，增加点信心一探究竟吧~</p><p>vuex-class/src/index.ts</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  State,</span><br><span class="line">  Getter,</span><br><span class="line">  Action,</span><br><span class="line">  Mutation,</span><br><span class="line">  <span class="keyword">namespace</span></span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'./bindings'</span></span><br></pre></td></tr></table></figure><p>vuex-class/src/bindings.ts</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createDecorator&#125; <span class="keyword">from</span> <span class="string">'vue-class-component'</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  mapState,</span><br><span class="line">  mapGetters,</span><br><span class="line">  mapActions,</span><br><span class="line">  mapMutations</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们在使用时，ts有各种烦人的检查，若类型不一致报错是无法运行的</span></span><br><span class="line"><span class="comment">// 把其他的省略了- - 只保留了看得懂和我们关心，使用的那几个</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> BindingHelpers &#123;</span><br><span class="line">  State: StateBindingHelper</span><br><span class="line">  Getter: BindingHelper</span><br><span class="line">  Mutation: BindingHelper</span><br><span class="line">  Action: BindingHelper</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有了这几个方法后，我们就可以在ts里使用了 那具体是怎么实现的？</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> State = createBindingHelper(<span class="string">'computed'</span>, mapState) <span class="keyword">as</span> StateBindingHelper</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Getter = createBindingHelper(<span class="string">'computed'</span>, mapGetters)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Action = createBindingHelper(<span class="string">'methods'</span>, mapActions)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Mutation = createBindingHelper(<span class="string">'methods'</span>, mapMutations)</span><br></pre></td></tr></table></figure><p>核心处理函数 <code>createBindingHelper</code>单独拿出来分析了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBindingHelper</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 方法或者属性，它已经告诉我们了 在computed或methods上</span></span></span></span><br><span class="line">  bindTo: 'computed' | 'methods',</span><br><span class="line">  <span class="comment">// 这个后面再说，用过应该能想个大概</span></span><br><span class="line">  mapFn: MapHelper</span><br><span class="line">) BindingHelper: &#123;</span><br><span class="line">  <span class="comment">// 返回类型因属于 BindingHelper</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">makeDecorator</span>(<span class="params">may: <span class="built_in">any</span>, <span class="keyword">namespace</span>: <span class="built_in">string</span> | <span class="literal">undefined</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createDecorator(<span class="function">(<span class="params">componentOptions, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 初次处理, 初始化为对象</span></span><br><span class="line">      <span class="keyword">if</span> (!componentOptions[bindTo]) &#123;</span><br><span class="line">        componentOptions[bindTo] = &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> mapObject = &#123;[key]: map&#125;</span><br><span class="line">      <span class="comment">// 这个!号突如其来，没懂…</span></span><br><span class="line">      componentOptions[bindTo]![key] = <span class="keyword">namespace</span> !== <span class="literal">undefined</span></span><br><span class="line">        ? mapFn(<span class="keyword">namespace</span>, mapObject)[key]</span><br><span class="line">        : mapFn(mapObject)[key]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能大致说下意思了…</p><p>可耻地写个 Todo 了，我去看TypeScript最新的官方文档了。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;vuex-class&lt;/code&gt;是&lt;code&gt;vue-class-component&lt;/code&gt;作者写的，质量有保证。且目前这类的库也不多，用法和之前的vue-property-decorator差不多，主要是通过装饰器模式，一来支持ts里的vuex，二来减少冗余的代码量。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="http://blog.fridolph.top/categories/TypeScript/"/>
    
    
      <category term="vue" scheme="http://blog.fridolph.top/tags/vue/"/>
    
      <category term="ts" scheme="http://blog.fridolph.top/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>【TS】装饰器模式与vue-property-decorator</title>
    <link href="http://blog.fridolph.top/2018/04/26/%E3%80%90TS%E3%80%91%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E4%B8%8Evue-property-decorator/"/>
    <id>http://blog.fridolph.top/2018/04/26/【TS】装饰模式与vue-property-decorator/</id>
    <published>2018-04-26T14:29:03.000Z</published>
    <updated>2024-01-01T03:35:09.672Z</updated>
    
    <content type="html"><![CDATA[<p>在用typescript时，vue-property-decorator 是在 vue-class-component 上增强了更多的结合 Vue 特性的装饰器，新增了这 7 个装饰器：</p><ul><li>@Emit</li><li>@Inject</li><li>@Model</li><li>@Prop</li><li>@Provide</li><li>@Watch</li><li>@Component (从 vue-class-component 继承)</li></ul><p>源码也就200来行，于是就有信心来慢慢读了</p><a id="more"></a><p>为什么需要vue-class-component？ 在typescript里写vue 每次都需要写很多额外的形式代码：</p><p>而装饰器就是解决这些冗余代码的（实质上并没有减少，只是用一层函数包装了，后面有源码会讲解）</p><blockquote><p>可自行了解一下<a href="http://blog.csdn.net/zhshulin/article/details/38665187" target="_blank" rel="noopener">装饰模式</a></p></blockquote><h2 id="AOP-面向切面编程"><a href="#AOP-面向切面编程" class="headerlink" title="AOP 面向切面编程"></a>AOP 面向切面编程</h2><p>示例：</p><ul><li>首先创建一个普通的Man类，它的抵御值 2，攻击力为 3，血量为 3；</li><li>然后我们让其带上钢铁侠的盔甲，这样他的抵御力增加 100，变成 102；</li><li>让其带上光束手套，攻击力增加 50，变成 53；</li><li>最后让他增加“飞行”能力</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(def = 2, atk = 3, hp = 3) &#123;</span><br><span class="line">    <span class="keyword">this</span>.init(def, atk, hp)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init(def, atk, hp) &#123;</span><br><span class="line">    <span class="keyword">this</span>.def = def <span class="comment">//防御</span></span><br><span class="line">    <span class="keyword">this</span>.atk = atk <span class="comment">// 攻击</span></span><br><span class="line">    <span class="keyword">this</span>.hp = hp</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`防御力: <span class="subst">$&#123;<span class="keyword">this</span>.def&#125;</span>，攻击力: <span class="subst">$&#123;<span class="keyword">this</span>.atk&#125;</span>，血量：<span class="subst">$&#123;<span class="keyword">this</span>.hp&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tony = <span class="keyword">new</span> Man()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`当前状态 ===&gt; <span class="subst">$&#123;tony&#125;</span>`</span>)</span><br><span class="line"><span class="comment">// 输出：当前状态 ===&gt; 防御力:2,攻击力:3,血量:3</span></span><br></pre></td></tr></table></figure><p>然后 创建 decorateArmour 方法，为钢铁侠装配盔甲——注意 decorateArmour 是装饰在方法init上的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decorateArmour</span>(<span class="params">target, key, descriptor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> method = descriptor.value</span><br><span class="line">  <span class="keyword">let</span> moreDef = <span class="number">100</span></span><br><span class="line">  <span class="keyword">let</span> ret</span><br><span class="line">  descriptor.value = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    args[<span class="number">0</span>] += moreDef</span><br><span class="line">    ret = method.apply(target, args)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> descriptor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(def = 2, atk = 3, hp = 3) &#123;</span><br><span class="line">    <span class="keyword">this</span>.init(def, atk, hp)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @decorateArmour</span><br><span class="line">  init(def, atk, hp) &#123;</span><br><span class="line">    <span class="keyword">this</span>.def = def</span><br><span class="line">    <span class="keyword">this</span>.atk = atk</span><br><span class="line">    <span class="keyword">this</span>.hp = hp</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`防御力:<span class="subst">$&#123;<span class="keyword">this</span>.def&#125;</span>,攻击力:<span class="subst">$&#123;<span class="keyword">this</span>.atk&#125;</span>,血量:<span class="subst">$&#123;<span class="keyword">this</span>.hp&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tony = <span class="keyword">new</span> Man();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`当前状态 ===&gt; <span class="subst">$&#123;tony&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// 输出：当前状态 ===&gt; 防御力:102,攻击力:3,血量:3</span></span><br></pre></td></tr></table></figure><p>Decorators 的本质是利用了 ES5 的 Object.defineProperty 属性，这三个参数其实是和 Object.defineProperty 参数一致的，因此不能更改，详细分析请见 <a href="http://greengerong.com/blog/2015/09/24/es7-javascript-decorators/" target="_blank" rel="noopener">细说 ES7 JavaScript Decorators</a></p><p>同样的代码复制一份，增加攻击力：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decorateLight</span>(<span class="params">target, key, descriptor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> method = descriptor.value;</span><br><span class="line">  <span class="keyword">let</span> moreAtk = <span class="number">50</span>;</span><br><span class="line">  <span class="keyword">let</span> ret;</span><br><span class="line">  descriptor.value = <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">    args[<span class="number">1</span>] += moreAtk;</span><br><span class="line">    ret = method.apply(target, args);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(def = 2,atk = 3,hp = 3)&#123;</span><br><span class="line">    <span class="keyword">this</span>.init(def,atk,hp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @decorateArmour</span><br><span class="line">  @decorateLight</span><br><span class="line">  init(def,atk,hp)&#123;</span><br><span class="line">    <span class="keyword">this</span>.def = def; <span class="comment">// 防御值</span></span><br><span class="line">    <span class="keyword">this</span>.atk = atk;  <span class="comment">// 攻击力</span></span><br><span class="line">    <span class="keyword">this</span>.hp = hp;  <span class="comment">// 血量</span></span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> tony = <span class="keyword">new</span> Man();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`当前状态 ===&gt; <span class="subst">$&#123;tony&#125;</span>`</span>);</span><br><span class="line"><span class="comment">//输出：当前状态 ===&gt; 防御力:102,攻击力:53,血量:3</span></span><br></pre></td></tr></table></figure><hr><p>按装饰模式所言，装饰模式有：纯粹装饰模式和半透明装饰模式</p><p>上面两个属于纯粹装饰模式，它不增加对原有类的接口。而下面给普通人增加飞行能力，给类增加新方法，属于半透明的装饰模式，类似适配器模式：</p><ol><li>增加一个方法</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addFly</span>(<span class="params">canFly</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    target.canFly = canFly</span><br><span class="line">    <span class="keyword">let</span> extra = canFly ? <span class="string">'(技能加成：飞行能力)'</span> : <span class="string">''</span></span><br><span class="line">    <span class="keyword">let</span> method = target.prototype.toString</span><br><span class="line"></span><br><span class="line">    target.prototype.toString = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> method.apply(target.prototype, args) + extra</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>用这个方法去直接装饰类</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addFly</span>(<span class="params">canFly</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 接上， 省略了</span></span><br><span class="line">&#125;</span><br><span class="line">@addFly(<span class="literal">true</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(def = 2, atk = 3, hp = 3) &#123;</span><br><span class="line">    <span class="keyword">this</span>.init(def, atk, hp)</span><br><span class="line">  &#125;</span><br><span class="line">  @decorateArmour</span><br><span class="line">  @decorateLight</span><br><span class="line">  init(def, atk, hp) &#123;</span><br><span class="line">    <span class="keyword">this</span>.def = def</span><br><span class="line">    <span class="keyword">this</span>.atk = atk</span><br><span class="line">    <span class="keyword">this</span>.hp = hp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`当前状态 ===&gt; <span class="subst">$&#123;tony&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// 输出：当前状态 ===&gt; 防御力:102,攻击力:53,血量:3(技能加成:飞行能力)</span></span><br></pre></td></tr></table></figure><p>作用在方法上的decorator接收第一个参数(target)是类的prototype；如果把一个decorator作用到类上，则它的第一个参数target是类本身</p><h2 id="经典实现-Logger"><a href="#经典实现-Logger" class="headerlink" title="经典实现 Logger"></a>经典实现 Logger</h2><p>有了上面的基础，下面我们来写一个简易版<code>日志系统</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> log = <span class="function"><span class="params">type</span> =&gt;</span> (target, name, descriptor) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> method = descriptor.value</span><br><span class="line">  descriptor.value = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">`(<span class="subst">$&#123;type&#125;</span> 正在执行：<span class="subst">$&#123;name&#125;</span>(<span class="subst">$&#123;args&#125;</span>) = ?`</span>)</span><br><span class="line">    <span class="keyword">let</span> ret</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ret = method.apply(target, args)</span><br><span class="line">      <span class="built_in">console</span>.info(<span class="string">`(<span class="subst">$&#123;tytpe&#125;</span> 成功：<span class="subst">$&#123;name&#125;</span>(<span class="subst">$&#123;args&#125;</span>) =&gt; <span class="subst">$&#123;ret&#125;</span>)`</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">`(<span class="subst">$&#123;tytpe&#125;</span> 失败：<span class="subst">$&#123;name&#125;</span>(<span class="subst">$&#123;args&#125;</span>) =&gt; <span class="subst">$&#123;error&#125;</span>)`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IronMan</span> </span>&#123;</span><br><span class="line">  @log(<span class="string">'IronMan 自检阶段'</span>)</span><br><span class="line">  check() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'检查完毕'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @log(<span class="string">'IronMan 攻击阶段'</span>)</span><br><span class="line">  attack() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'击倒敌人'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @log(<span class="string">'IronMan 机体报错'</span>)</span><br><span class="line">  error() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">'something is wrong!'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tony = <span class="keyword">new</span> IronMan()</span><br><span class="line">tony.check();</span><br><span class="line">tony.attack();</span><br><span class="line">tony.error();</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// (IronMan 自检阶段) 正在执行: check() = ?</span></span><br><span class="line"><span class="comment">// (IronMan 自检阶段) 成功 : check() =&gt; 检查完毕</span></span><br><span class="line"><span class="comment">// (IronMan 攻击阶段) 正在执行: attack() = ?</span></span><br><span class="line"><span class="comment">// (IronMan 攻击阶段) 成功 : attack() =&gt; 击倒敌人</span></span><br><span class="line"><span class="comment">// (IronMan 机体报错) 正在执行: error() = ?</span></span><br><span class="line"><span class="comment">// (IronMan 机体报错) 失败: error() =&gt; Something is wrong!</span></span><br></pre></td></tr></table></figure><p>Logger方法的关键在于：</p><ul><li>首先使用 <code>const method = descriptor.value</code> 将原有的方法提取出来，保障原有方法的纯净</li><li>在<code>try catch</code>语句是调用 <code>ret = method.apply(target, args)</code> 在调用之前之后分别进行日志汇报</li><li>最后返回 <code>return ret</code> 原始的调用结果</li></ul><h3 id="vue-property-decorator"><a href="#vue-property-decorator" class="headerlink" title="vue-property-decorator"></a>vue-property-decorator</h3><p>vue-property-decorator 是在 vue-class-component 上增强了更多的结合 Vue 特性的装饰器，新增了这 7 个装饰器：</p><ul><li>@Emit</li><li>@Inject</li><li>@Model</li><li>@Prop</li><li>@Provide</li><li>@Watch</li><li>@Component (从 vue-class-component 继承)</li></ul><p>我们来读读源码上是怎样来实现的吧：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue, &#123;PropOptions, WatchOptions&#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Component, &#123;createDecorator&#125; <span class="keyword">from</span> <span class="string">'vue-class-component'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'reflect-metadata'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Constructor = &#123;</span><br><span class="line">  <span class="keyword">new</span>(...args: <span class="built_in">any</span>[]): <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们在 vue-property-decorator 可调用 Vue 和 Component 是这样继承下来的</span></span><br><span class="line"><span class="keyword">export</span> &#123; Component, Vue &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of an inject</span></span><br><span class="line"><span class="comment"> * @param key key</span></span><br><span class="line"><span class="comment"> * @return PropertyDecorator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Inject</span>(<span class="params">key?: <span class="built_in">string</span> | symbol</span>): <span class="title">PropertyDecorator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createDecorator(<span class="function">(<span class="params">componentOptions, k</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> componentOptions.inject === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      <span class="comment">// inject默认为 空对象</span></span><br><span class="line">      componentOptions.inject = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(componentOptions.inject)) &#123;</span><br><span class="line">      <span class="comment">// 第二个参数 就是我们对 inject的注入</span></span><br><span class="line">      componentOptions.inject[k] = key || k</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of an provide</span></span><br><span class="line"><span class="comment"> * @param key key</span></span><br><span class="line"><span class="comment"> * @return PropertyDecorator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Provide</span>(<span class="params">key?: <span class="built_in">string</span> | symbol</span>): <span class="title">PropertyDecorator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createDecorator(<span class="function">(<span class="params">componentOptions, k</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> provide: <span class="built_in">any</span> = componentOptions.provide</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> provide !== <span class="string">'function'</span> || !provide.managed) &#123;</span><br><span class="line">      <span class="keyword">const</span> original = componentOptions.provide</span><br><span class="line">      provide = componentOptions.provide = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> rv = <span class="built_in">Object</span>.create((<span class="keyword">typeof</span> original === <span class="string">'function'</span> ? original.call(<span class="keyword">this</span>) : original) || <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> provide.managed) rv[provide.managed[i]] = <span class="keyword">this</span>[i]</span><br><span class="line">        <span class="keyword">return</span> rv</span><br><span class="line">      &#125;</span><br><span class="line">      provide.managed = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    provide.managed[k] = key || k</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of model</span></span><br><span class="line"><span class="comment"> * @param  event event name</span></span><br><span class="line"><span class="comment"> * @return PropertyDecorator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">export function Model(event?: string, options: (PropOptions | Constructor[] | Constructor) = &#123;&#125;): PropertyDecorator &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: Vue, key: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(options) &amp;&amp; <span class="keyword">typeof</span> (options <span class="keyword">as</span> PropOptions).type === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      (options <span class="keyword">as</span> PropOptions).type = Reflect.getMetadata(<span class="string">'design:type'</span>, target, key)</span><br><span class="line">    &#125;</span><br><span class="line">    createDecorator(<span class="function">(<span class="params">componentOptions, k</span>) =&gt;</span> &#123;</span><br><span class="line">      (componentOptions.props || (componentOptions.props = &#123;&#125;) <span class="keyword">as</span> <span class="built_in">any</span>)[k] = options</span><br><span class="line">      componentOptions.model = &#123; prop: k, event: event || k &#125;</span><br><span class="line">    &#125;)(target, key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of a prop</span></span><br><span class="line"><span class="comment"> * @param  options the options for the prop</span></span><br><span class="line"><span class="comment"> * @return PropertyDecorator | void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">export function Prop(options: (PropOptions | Constructor[] | Constructor) = &#123;&#125;): PropertyDecorator &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: Vue, key: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(options) &amp;&amp; <span class="keyword">typeof</span> (options <span class="keyword">as</span> PropOptions).type === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      (options <span class="keyword">as</span> PropOptions).type = Reflect.getMetadata(<span class="string">'design:type'</span>, target, key)</span><br><span class="line">    &#125;</span><br><span class="line">    createDecorator(<span class="function">(<span class="params">componentOptions, k</span>) =&gt;</span> &#123;</span><br><span class="line">      (componentOptions.props || (componentOptions.props = &#123;&#125;) <span class="keyword">as</span> <span class="built_in">any</span>)[k] = options</span><br><span class="line">    &#125;)(target, key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of a watch function</span></span><br><span class="line"><span class="comment"> * @param  path the path or the expression to observe</span></span><br><span class="line"><span class="comment"> * @param  WatchOption</span></span><br><span class="line"><span class="comment"> * @return MethodDecorator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Watch</span>(<span class="params">path: <span class="built_in">string</span>, options: WatchOptions = &#123;&#125;</span>): <span class="title">MethodDecorator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; deep = <span class="literal">false</span>, immediate = <span class="literal">false</span> &#125; = options</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> createDecorator(<span class="function">(<span class="params">componentOptions, handler</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> componentOptions.watch !== <span class="string">'object'</span>) &#123;</span><br><span class="line">      componentOptions.watch = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    (componentOptions.watch <span class="keyword">as</span> <span class="built_in">any</span>)[path] = &#123; handler, deep, immediate &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Code copied from Vue/src/shared/util.js</span></span><br><span class="line"><span class="keyword">const</span> hyphenateRE = <span class="regexp">/\B([A-Z])/g</span></span><br><span class="line"><span class="keyword">const</span> hyphenate = <span class="function">(<span class="params">str: <span class="built_in">string</span></span>) =&gt;</span> str.replace(hyphenateRE, <span class="string">'-$1'</span>).toLowerCase()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of an event-emitter function</span></span><br><span class="line"><span class="comment"> * @param  event The name of the event</span></span><br><span class="line"><span class="comment"> * @return MethodDecorator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Emit</span>(<span class="params">event?: <span class="built_in">string</span></span>): <span class="title">MethodDecorator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: Vue, key: <span class="built_in">string</span>, descriptor: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    key = hyphenate(key)</span><br><span class="line">    <span class="keyword">const</span> original = descriptor.value</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span> <span class="title">emitter</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (original.apply(<span class="keyword">this</span>, args) !== <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">this</span>.$emit(event || key, ...args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of $off</span></span><br><span class="line"><span class="comment"> * @param event The name of the event</span></span><br><span class="line"><span class="comment"> * @param method The name of the method</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Off</span>(<span class="params">event?: <span class="built_in">string</span>, method?: <span class="built_in">string</span></span>): <span class="title">MethodDecorator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: Vue, key: <span class="built_in">string</span>, descriptor: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    key = hyphenate(key)</span><br><span class="line">    <span class="keyword">const</span> original = descriptor.value</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span> <span class="title">offer</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (original.apply(<span class="keyword">this</span>, args) !== <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (method) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>[method] === <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.$off(event || key, <span class="keyword">this</span>[method])</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'must be a method name'</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event) &#123;</span><br><span class="line">          <span class="keyword">this</span>.$off(event || key)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.$off()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of $on</span></span><br><span class="line"><span class="comment"> * @param event The name of the event</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">On</span>(<span class="params">event?: <span class="built_in">string</span></span>): <span class="title">MethodDecorator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createDecorator(<span class="function">(<span class="params">componentOptions, k</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> key = hyphenate(k)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> componentOptions.created !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      componentOptions.created = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> original = componentOptions.created</span><br><span class="line">    componentOptions.created = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      original()</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> componentOptions.methods !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$on(event || key, componentOptions.methods[k])</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of $once</span></span><br><span class="line"><span class="comment"> * @param event The name of the event</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Once</span>(<span class="params">event?: <span class="built_in">string</span></span>): <span class="title">MethodDecorator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createDecorator(<span class="function">(<span class="params">componentOptions, k</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> key = hyphenate(k)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> componentOptions.created !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      componentOptions.created = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> original = componentOptions.created</span><br><span class="line">    componentOptions.created = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      original()</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> componentOptions.methods !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$once(event || key, componentOptions.methods[k]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of $nextTick</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @export</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; method</span></span><br><span class="line"><span class="comment"> * @returns &#123;MethodDecorator&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">NextTick</span>(<span class="params">method: <span class="built_in">string</span></span>): <span class="title">MethodDecorator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: Vue, key: <span class="built_in">string</span>, descriptor: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> original = descriptor.value</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span> <span class="title">emitter</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (original.apply(<span class="keyword">this</span>, args) !== <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>[method] === <span class="string">'function'</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.$nextTick(<span class="keyword">this</span>[method])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'must be a method name'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在用typescript时，vue-property-decorator 是在 vue-class-component 上增强了更多的结合 Vue 特性的装饰器，新增了这 7 个装饰器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@Emit&lt;/li&gt;
&lt;li&gt;@Inject&lt;/li&gt;
&lt;li&gt;@Model&lt;/li&gt;
&lt;li&gt;@Prop&lt;/li&gt;
&lt;li&gt;@Provide&lt;/li&gt;
&lt;li&gt;@Watch&lt;/li&gt;
&lt;li&gt;@Component (从 vue-class-component 继承)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;源码也就200来行，于是就有信心来慢慢读了&lt;/p&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="http://blog.fridolph.top/categories/TypeScript/"/>
    
    
      <category term="vue" scheme="http://blog.fridolph.top/tags/vue/"/>
    
      <category term="ts" scheme="http://blog.fridolph.top/tags/ts/"/>
    
  </entry>
  
</feed>
