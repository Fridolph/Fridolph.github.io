<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="【Vue】服务端渲染框架Nuxt入门"><meta name="keywords" content="vue,nuxt,服务端渲染"><meta name="author" content="Fridolph,undefined"><meta name="copyright" content="Fridolph"><title>【Vue】服务端渲染框架Nuxt入门 | 霪霖笙箫的博客</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css?version=1.5.3"><meta http-equiv="Cache-Control" content="no-cache,no-store,must-revalidate"><meta http-equiv="Pragma" content="no-cache"><meta http-equiv="Expires" content="0"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?https://hm.baidu.com/hm.js?66f25c24596db799ce091d9b434b9495";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  localSearch: {"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"},"path":"search.xml"}
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Nuxt"><span class="toc-number">1.</span> <span class="toc-text">Nuxt</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本介绍"><span class="toc-number">1.1.</span> <span class="toc-text">基本介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何运作"><span class="toc-number">1.1.1.</span> <span class="toc-text">如何运作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务端渲染"><span class="toc-number">1.1.2.</span> <span class="toc-text">服务端渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态化"><span class="toc-number">1.1.3.</span> <span class="toc-text">静态化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#demo"><span class="toc-number">1.2.</span> <span class="toc-text">demo</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#安装"><span class="toc-number">1.2.1.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录结构"><span class="toc-number">1.2.2.</span> <span class="toc-text">目录结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#路由"><span class="toc-number">1.2.3.</span> <span class="toc-text">路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#过渡动效"><span class="toc-number">1.2.4.</span> <span class="toc-text">过渡动效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中间件"><span class="toc-number">1.2.5.</span> <span class="toc-text">中间件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#视图"><span class="toc-number">1.2.6.</span> <span class="toc-text">视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#页面"><span class="toc-number">1.2.7.</span> <span class="toc-text">页面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML头部"><span class="toc-number">1.2.8.</span> <span class="toc-text">HTML头部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步数据"><span class="toc-number">1.2.9.</span> <span class="toc-text">异步数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#资源文件"><span class="toc-number">1.2.10.</span> <span class="toc-text">资源文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#插件"><span class="toc-number">1.2.11.</span> <span class="toc-text">插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Vuex"><span class="toc-number">1.2.12.</span> <span class="toc-text">使用Vuex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命令"><span class="toc-number">1.2.13.</span> <span class="toc-text">命令</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/config/avatar.jpg"></div><div class="author-info__name text-center">Fridolph</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">58</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">69</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">14</span></a></div></div><div class="unit"><div class="heart"><div class="heart-piece-0"></div><div class="heart-piece-1"></div><div class="heart-piece-2"></div><div class="heart-piece-3"></div><div class="heart-piece-4"></div><div class="heart-piece-5"></div><div class="heart-piece-6"></div><div class="heart-piece-7"></div><div class="heart-piece-8"></div></div><p class="anime-title"><a href="https://github.com/fridolph" target="_blank">感谢访问本站，若喜欢请star ^_^</a></p></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/config/top-img.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">霪霖笙箫的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">个人主页</a><a class="site-page" href="/archives">文章总览</a><a class="site-page" href="/books">图书推荐</a><a class="site-page" href="/demo">项目实战</a><a class="site-page" href="/gallery">时光轨迹</a></span></div><div id="post-info"><div id="post-title">【Vue】服务端渲染框架Nuxt入门</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-17</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/学习/">学习</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2018/04/17/【Vue】服务端渲染框架Nuxt入门/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2018/04/17/【Vue】服务端渲染框架Nuxt入门/"></span></a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">2,755</span><span class="post-meta__separator">|</span><span>阅读时长: 10 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><blockquote>
<p>对着官方文档一顿敲= = 看官方文档就好，很简单，相比Vue和React那坑爹的服务端渲染配置，Nuxt简直是良心多了，配置灵活，最重要的是简单！！！于是近期会把 我的个人站首页用nuxt重（折腾）构一番，敬请期待~</p>
</blockquote>
<a id="more"></a>
<h1 id="Nuxt"><a href="#Nuxt" class="headerlink" title="Nuxt"></a>Nuxt</h1><p>Nuxt.js（后文Nuxt）是基于Vue.js的通用应用框架</p>
<p>通过对客户端/服务端基础架构的抽象组织，Nuxt主要关注的是应用的UI渲染。其预设了利用Vue开发服务端渲染的应用所需要的各种配置。<br>作为框架，Nuxt.js 为 客户端/服务端 这种典型的应用架构模式提供了许多有用的特性，例如异步数据加载、中间件支持、布局支持等。</p>
<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><h3 id="如何运作"><a href="#如何运作" class="headerlink" title="如何运作"></a>如何运作</h3><p>vue2+ vue-router vuex vue-meta<br>以及webpack、vue-loader、babel-loader来处理代码的自动化构建工作</p>
<p><strong>特性</strong></p>
<ul>
<li>基于Vue</li>
<li>自动代码分层</li>
<li>服务端渲染</li>
<li>强大的路由功能，支持异步数据</li>
<li>静态服务文件</li>
<li>ES6+语法支持</li>
<li>打包和压缩JS/CSS</li>
<li>HTML头部标签管理</li>
<li>本地开发支持热加载</li>
<li>集成ESLint</li>
<li>支持样式预处理</li>
</ul>
<p>下图阐述了 Nuxt.js 应用一个完整的服务器请求到渲染（或用户通过 <code>&lt;nuxt-link&gt;</code> 切换路由渲染页面）的流程：</p>
<p><img src="https://zh.nuxtjs.org/nuxt-schema.png"></p>
<p>请求到来 -&gt; nuxt server拦截处理(事件派发store action) -&gt; middleware处理中间件 (先配置，后布局，再页面) -&gt; 验证 -&gt; 获取异步数据 -&gt; render渲染(通过Navigate作路由跳转)</p>
<h3 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h3><p>使用nuxt作UI渲染框架。当运行<code>nuxt</code>命令时会启动一个支持<code>热加载</code>和<code>服务端渲染</code>（基于Vue的vue-server-renderer模块）的开发服务器。</p>
<h3 id="静态化"><a href="#静态化" class="headerlink" title="静态化"></a>静态化</h3><p>nuxt generate </p>
<p>通过CDN缓存静态页面，进行全球CDN节点布局。相对传统的动态网站，静态化分散了对服务器的请求，降低服务器压力。</p>
<p>简而言之，页面静态文件CDN，数据通过API，前后端分离.</p>
<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>vue init nuxt-community/starter-template nuxt-demo
</code></pre><p>要注意，<code>服务端渲染</code>是前台服务端用相同组件，一份代码，我们跑的其实是静态文件，所以需要打包出来一份bundle</p>
<p>npm run build </p>
<p>npm run dev </p>
<p>现在浏览器打开 localhost:3000 就可以访问nuxt-demo了</p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ul>
<li><p>assets 组织静态资源 css js等</p>
</li>
<li><p>components 放公共组件。注：nuxt不会扩展该目录下的组件，所以不会有asyncData特性</p>
</li>
<li><p>layouts 用于组织布局，除配置外这个优先级很高</p>
</li>
<li><p>middleware 存放中间件</p>
</li>
<li><p>pages 组织页面及路由，在layouts后读取，配置这个就不用写routes了. 后面介绍很爽</p>
</li>
<li><p>plugins 插件，用于组织需要在根vue.js实例化之前运行的JS插件</p>
</li>
<li><p>static 静态文件目录，不会被nuxt调用构建。服务启动，该目录下文件会被映射到根路径下</p>
</li>
<li><p>store Vuex状态文件</p>
</li>
<li><p>nuxt.config.js nuxt配置，优先级最高，用于覆盖默认配置</p>
</li>
</ul>
<p>更多请参考官方文档 <a href="https://zh.nuxtjs.org" target="_blank" rel="noopener">https://zh.nuxtjs.org</a> ~ </p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>Nuxt根据<code>pages</code>目录结构自动生成vue-router模块路由配置，就问你叼不叼~</p>
<p>在pages下新建一个user文件夹，新建index.vue one.vue</p>
<p>访问 localhost:3000/user  localhost:3000/user/one 就能显示了，简直不要太爽</p>
<p><strong>动态路由</strong></p>
<p>以前path里配置 <code>/:id</code> 这样的，在pages/user 里新建 _id.vue即可</p>
<p><strong>路由参数校验</strong></p>
<p>pages/users/_id.vue</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  validate(&#123;params&#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^\d+$/</span>.test(params.id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>嵌套路由</strong></p>
<p>pages/<br>–| users/<br>—–| _id.vue<br>—–| index.vue<br>–| users.vue</p>
<h3 id="过渡动效"><a href="#过渡动效" class="headerlink" title="过渡动效"></a>过渡动效</h3><p>参考文档 - - 我没跑成功，回头再看看</p>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>允许定义一个自定义函数运行在一个页面或一组页面渲染之前。放在middleware目录下，一个中间件接收<code>context</code>作为第一个参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context.userAgent = context.isServer </span><br><span class="line">    ? context.req.headers[<span class="string">'user-agent'</span>]</span><br><span class="line">    : navigator.userAgent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中间件执行顺序：</p>
<ol>
<li>nuxt.config.js</li>
<li>匹配布局</li>
<li>匹配页面</li>
</ol>
<p>中间件可异步执行，只需返回一个<code>Promise</code>或使用第二个callback作为第一个参数：</p>
<p>middleware/stats.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">&#123;route&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.post(<span class="string">'http://xx.com'</span>, &#123;</span><br><span class="line">    url: route.fullPath</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在 上面3个任意地方使用中间件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  router: &#123;</span><br><span class="line">    middleware: <span class="string">'stats'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>stats中间件将在每个路由改变时被调用。</p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p><strong>默认页面</strong></p>
<p>layouts/default.vue </p>
<p><strong>错误页面</strong></p>
<p>layouts/error.vue</p>
<p><strong>个性化布局</strong></p>
<p>在layouts里添加一个dark.vue文件，然后在pages里的组件写. </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  layout: <span class="string">'dark'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h3><p>页面的一些api</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性名</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">asyncData</td>
<td style="text-align:left">最重要的一个键, 支持 异步数据处理，另外该方法的第一个参数为当前页面组件的 上下文对象</td>
</tr>
<tr>
<td style="text-align:center">fetch</td>
<td style="text-align:left">与 asyncData 方法类似，用于在渲染页面之前获取数据填充应用的状态树（store）。不同的是 fetch 方法不会设置组件的数据。详情请参考 关于fetch方法的文档</td>
</tr>
<tr>
<td style="text-align:center">head</td>
<td style="text-align:left">配置当前页面的 Meta 标签, 详情参考 页面头部配置API</td>
</tr>
<tr>
<td style="text-align:center">layout</td>
<td style="text-align:left">指定当前页面使用的布局（layouts 根目录下的布局文件）。详情请参考 关于 布局 的文档</td>
</tr>
<tr>
<td style="text-align:center">transition</td>
<td style="text-align:left">指定当前页面使用的布局（layouts 根目录下的布局文件）。详情请参考 关于 布局 的文档</td>
</tr>
<tr>
<td style="text-align:center">scrollToTop</td>
<td style="text-align:left">布尔值，默认: false。 用于判定渲染页面前是否需要将当前页面滚动至顶部。这个配置用于 嵌套路由的应用场景</td>
</tr>
<tr>
<td style="text-align:center">middleware</td>
<td style="text-align:left">指定页面的中间件，中间件会在页面渲染之前被调用， 请参考 路由中间件</td>
</tr>
</tbody>
</table>
<h3 id="HTML头部"><a href="#HTML头部" class="headerlink" title="HTML头部"></a>HTML头部</h3><p>nuxt使用<code>vue-meta</code>更新应用头部标签和html属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  keyName: <span class="string">'head'</span>, <span class="comment">// 设置meta信息的组件对象的字段，vue-meta会根据key值获取meta信息</span></span><br><span class="line">  attribute: <span class="string">'n-head'</span>, <span class="comment">// vue-meta在监听标签时所添加的属性名</span></span><br><span class="line">  ssrAttribute: <span class="string">'n-head-ssr'</span>, <span class="comment">// 让vue-meta获知meta信息已完成服务端渲染的属性名</span></span><br><span class="line">  tagIDKeyName: <span class="string">'hid'</span> <span class="comment">// 让vue-meta用来决定是否覆盖还是追加tag的属性名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异步数据"><a href="#异步数据" class="headerlink" title="异步数据"></a>异步数据</h3><p>Nuxt扩展了Vue增加一个asyncData方法，使得我们可以在设置组件数据前异步获取处理数据</p>
<p><strong>asyncData</strong></p>
<p>该方法会在组件（限于页面组件）每次加载前被调用。它可以在服务端或路由更新之前被调用。在该方法被调用时，第一个参数被设定为<code>当前页面的上下文对象</code>，可利用<code>asyncData</code>方法来获取数据，Nuxt会将asyncData返回的数据融合组件<code>data</code>方法返回的数据一并返回给当前组件。</p>
<blockquote>
<p>由于asyncData方法是在组件初始化前被调用的，所以在方法内是无法通过this来引用组件实例对象的。</p>
</blockquote>
<p>使用：</p>
<ol>
<li>返回Promise</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">asyncData(&#123;params, error&#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">`/api/<span class="subst">$&#123;params.id&#125;</span>`</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">title</span>: res.data.title&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      error(&#123; <span class="attr">statusCode</span>: <span class="number">404</span>, <span class="attr">message</span>: <span class="string">'not found'</span> &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用async/await</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">asyncData(&#123;params, error&#125;) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;data&#125; = <span class="keyword">await</span> axios.get(<span class="string">`/api/<span class="subst">$&#123;params.id&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">title</span>: data.title&#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    error(&#123; <span class="attr">statusCode</span>: <span class="number">404</span>, <span class="attr">message</span>: <span class="string">'not found'</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h3><p>默认Nuxt使用vue-loader、file-loader及url-loader来处理文件的加载和引用。对于不需要通过webpack处理的静态资源文件，可以放置在static目录中</p>
<p><strong>webpack构建</strong></p>
<p>默认情况下, vue-loader自动使用 css-loader 和Vue模板编译器来编译处理vue文件中的样式和模板。在此编译过程中，所有的资源URL例如 <code>&lt;img src=&quot;...&quot;&gt;</code>、 <code>background: url(...)</code> 和 CSS中的 <code>@import</code> 均会被解析成模块通过 require 引用。</p>
<p><strong>静态文件</strong></p>
<p>如果你的静态资源文件需要 Webpack 做构建编译处理，可以放到 assets 目录，否则可以放到 static 目录中去。</p>
<p>Nuxt 服务器启动的时候，该目录下的文件会映射至应用的根路径 / 下，像 robots.txt 或 sitemap.xml 这种类型的文件就很适合放到 static 目录中。</p>
<p>你可以在代码中使用根路径 / 结合资源相对路径来引用静态资源：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引用 static 目录下的图片 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/my-image.png"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 引用 assets 目录下经过 webpack 构建处理后的图片 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/assets/my-image-2.png"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p><strong>使用第三方模块</strong></p>
<p>在页面内直接 import。但是，如果在另一页面也import相同第三方模块，在打包时该模块会被重复打包，而实际上我们只需要打包一次。该问题可以通过在<code>nuxt.config.js</code>里配置<code>build.vendor</code>来解决：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  build: &#123;</span><br><span class="line">    vendor: [<span class="string">'axios'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用Vue插件</strong></p>
<p>plugins里增加相应插件的js文件，如xxx.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// '~/plugins/xxx',</span></span><br><span class="line">    &#123;</span><br><span class="line">      src: <span class="string">'~/plugins/xxx'</span>,</span><br><span class="line">      ssr: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有些插件可能只是在浏览器里使用，所以你可以用 ssr: false </span></span><br><span class="line">    <span class="comment">// 来配置插件只从客户端还是服务端运行</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用Vuex"><a href="#使用Vuex" class="headerlink" title="使用Vuex"></a>使用Vuex</h3><p>Nuxt已内置了Vuex，所以不需额外安装和use了。</p>
<p><strong>模块方式</strong></p>
<p>状态树还可以拆分成为模块，store 目录下的每个 .js 文件会被转换成为状态树指定命名的子模块</p>
<p>使用状态树模块化的方式，store/index.js 不需要返回 Vuex.Store 实例，而应该直接将 state、mutations 和 actions 暴露出来：</p>
<p><strong>fetch方法</strong></p>
<p>fetch 方法会在渲染页面前被调用，作用是填充状态树 (store) 数据，与 asyncData 方法类似，不同的是它不会设置组件的数据。</p>
<p><strong>nuxtServerInit方法</strong></p>
<p>如果在状态树中指定了<code>nuxtServerInit</code>方法，Nuxt调用它时会将页面的上下文对象作为第2个参数传给它（仅在服务端调用时）。当我们想将服务端数据传到客户端时，就可用此方法。</p>
<p>如，服务端会话状态树可以通过 <code>req.session.user</code> 来访问当前登录用户。将该登录用户信息传给客户端的状态树，只需要更新 <code>store/index.js</code>，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  nuxtServerInit(&#123;commit&#125;, &#123;req&#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (req.session.user) &#123;</span><br><span class="line">      commit(<span class="string">'user'</span>, req.session.user)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果你使用状态树模块化的模式，只有主模块（即 store/index.js）适用设置该方法（其他模块设置了也不会被调用）。nuxtServerInit 方法接收的上下文对象和 fetch 的一样，但不包括 context.redirect() 和 context.error()。</p>
</blockquote>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">nuxt</td>
<td style="text-align:left">启动一个热加载的Web服务器（开发模式） localhost:3000</td>
</tr>
<tr>
<td style="text-align:center">nuxt build</td>
<td style="text-align:left">利用webpack编译应用，压缩JS和CSS资源（发布用）</td>
</tr>
<tr>
<td style="text-align:center">nuxt start</td>
<td style="text-align:left">以生成模式启动一个Web服务器 (nuxt build 会先被执行)</td>
</tr>
<tr>
<td style="text-align:center">nuxt generate</td>
<td style="text-align:left">编译应用，并依据路由配置生成对应的HTML文件 (用于静态站点的部署)</td>
</tr>
</tbody>
</table>
<hr>
<p>大致就这样了，试着自己折腾一下吧。对了，正好可以把个人网站首页用nuxt重构静态发布~~</p>
<p>生命不息，折腾不止！~</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Fridolph</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.fridolph.top/2018/04/17/【Vue】服务端渲染框架Nuxt入门/">http://blog.fridolph.top/2018/04/17/【Vue】服务端渲染框架Nuxt入门/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.fridolph.top" target="_blank">霪霖笙箫的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/vue/">vue</a><a class="post-meta__tags" href="/tags/nuxt/">nuxt</a><a class="post-meta__tags" href="/tags/服务端渲染/">服务端渲染</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/04/22/【Next】一次掌握ES6到ES8新增功能/"><i class="fa fa-chevron-left">  </i><span>【Next】一次掌握ES6到ES8新增功能</span></a></div><div class="next-post pull-right"><a href="/2018/04/15/【JS】函数柯里化[转载]/"><span>【JS】函数柯里化[转载]</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'http://blog.fridolph.top/2018/04/17/【Vue】服务端渲染框架Nuxt入门/';
  this.page.identifier = '2018/04/17/【Vue】服务端渲染框架Nuxt入门/';
  this.page.title = '【Vue】服务端渲染框架Nuxt入门';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'fridolph' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-src" src="https://fridolph.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2016 - 2024 By Fridolph</div><div class="framework-info"><span>driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.3"></script><script src="/js/fancybox.js?version=1.5.3"></script><script src="/js/sidebar.js?version=1.5.3"></script><script src="/js/copy.js?version=1.5.3"></script><script src="/js/fireworks.js?version=1.5.3"></script><script src="/js/transition.js?version=1.5.3"></script><script src="/js/scroll.js?version=1.5.3"></script><script src="/js/head.js?version=1.5.3"></script></body></html>