<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="【JS】变量声明与赋值，引用、值传递与对象拷贝"><meta name="keywords" content="js,es6,引用"><meta name="author" content="Fridolph,undefined"><meta name="copyright" content="Fridolph"><title>【JS】变量声明与赋值，引用、值传递与对象拷贝 | 霪霖笙箫的博客</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css?version=1.5.3"><meta http-equiv="Cache-Control" content="no-cache,no-store,must-revalidate"><meta http-equiv="Pragma" content="no-cache"><meta http-equiv="Expires" content="0"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?https://hm.baidu.com/hm.js?08804673a5fe37365758820497cd9fb1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  localSearch: {"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"},"path":"search.xml"}
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#变量声明"><span class="toc-number">1.</span> <span class="toc-text">变量声明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#var"><span class="toc-number">1.1.</span> <span class="toc-text">var</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#let"><span class="toc-number">1.2.</span> <span class="toc-text">let</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const"><span class="toc-number">1.3.</span> <span class="toc-text">const</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量赋值"><span class="toc-number">2.</span> <span class="toc-text">变量赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#按值传递"><span class="toc-number">2.1.</span> <span class="toc-text">按值传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#连续赋值"><span class="toc-number">2.2.</span> <span class="toc-text">连续赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deconstruction-解构赋值"><span class="toc-number">2.3.</span> <span class="toc-text">Deconstruction: 解构赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组与迭代器"><span class="toc-number">2.4.</span> <span class="toc-text">数组与迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象"><span class="toc-number">2.5.</span> <span class="toc-text">对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#默认值"><span class="toc-number">2.6.</span> <span class="toc-text">默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Three-Dots-…"><span class="toc-number">2.7.</span> <span class="toc-text">Three Dots …</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rest-Operator"><span class="toc-number">2.8.</span> <span class="toc-text">Rest Operator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spread-Operator"><span class="toc-number">2.9.</span> <span class="toc-text">Spread Operator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Copy-Composite-Data-Types-复合类型的拷贝"><span class="toc-number">3.</span> <span class="toc-text">Copy Composite Data Types: 复合类型的拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Shallow-Copy-浅拷贝"><span class="toc-number">3.1.</span> <span class="toc-text">Shallow Copy 浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-assign"><span class="toc-number">3.2.</span> <span class="toc-text">Object.assign</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-concat-来复制数组"><span class="toc-number">3.3.</span> <span class="toc-text">使用 [].concat 来复制数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#浅拷贝的缺陷"><span class="toc-number">3.4.</span> <span class="toc-text">浅拷贝的缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DeepCopy-深拷贝"><span class="toc-number">3.5.</span> <span class="toc-text">DeepCopy: 深拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用JSON深拷贝"><span class="toc-number">3.6.</span> <span class="toc-text">利用JSON深拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考资料"><span class="toc-number">3.7.</span> <span class="toc-text">参考资料</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/config/avatar.jpg"></div><div class="author-info__name text-center">Fridolph</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">58</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">69</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">14</span></a></div></div><div class="unit"><div class="heart"><div class="heart-piece-0"></div><div class="heart-piece-1"></div><div class="heart-piece-2"></div><div class="heart-piece-3"></div><div class="heart-piece-4"></div><div class="heart-piece-5"></div><div class="heart-piece-6"></div><div class="heart-piece-7"></div><div class="heart-piece-8"></div></div><p class="anime-title"><a href="https://github.com/fridolph" target="_blank">感谢访问本站，若喜欢请star ^_^</a></p></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/config/top-img.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">霪霖笙箫的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">个人主页</a><a class="site-page" href="/archives">文章总览</a><a class="site-page" href="/books">图书推荐</a><a class="site-page" href="/demo">项目实战</a><a class="site-page" href="/gallery">时光轨迹</a></span></div><div id="post-info"><div id="post-title">【JS】变量声明与赋值，引用、值传递与对象拷贝</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-06-23</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JavaScript/">JavaScript</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2018/06/23/【JS】变量声明与赋值，引用、值传递与对象拷贝/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2018/06/23/【JS】变量声明与赋值，引用、值传递与对象拷贝/"></span></a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">6,650</span><span class="post-meta__separator">|</span><span>阅读时长: 29 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><blockquote>
<p>夯实基础系列。虽然想整理之前测试相关的东西，不过最近看书有讲到这个，遂将之前收藏的博客、文章结合书里的讲解做了一些整理和例子来加深这块的印象。（今天也才把测试的看了没来得及整理）</p>
</blockquote>
<a id="more"></a>
<p>ES6 为我们引入了 <code>let</code> 与 <code>const</code> 两种新的变量声明关键字，同时也引入了块作用域；本文首先介绍 ES6 中常用的三种变量声明方式，然后讨论了 JavaScript 按值传递的特性以及多种的赋值方式，最后介绍了复合类型拷贝的技巧</p>
<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>在 JavaScript 中，基本的变量声明可以用 var 方式；JavaScript 允许省略 var，直接对未声明的变量赋值。也就是说，var a = 1 与 a = 1，这两条语句的效果相同。但是由于这样的做法很容易不知不觉地创建全局变量（尤其是在函数内部），所以建议总是使用 var 命令声明变量。在 ES6 中，对于变量声明的方式进行了扩展，引入了 let 与 const。var 与 let 两个关键字创建变量的区别在于， var 声明的变量作用域是最近的函数块；而 let 声明的变量作用域是最近的闭合块，往往会小于函数块。另一方面，以 let 关键字创建的变量虽然同样被提升到作用域头部，但是并不能在实际声明前使用；如果强行使用则会抛出 ReferenceError 异常。</p>
<h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><p>var 是 JavaScript 中基础的变量声明方式之一，其基本语法为:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="comment">// Declaration and initialization</span></span><br><span class="line">x = <span class="string">'Hello World'</span> <span class="comment">// Assignment</span></span><br><span class="line"><span class="comment">// Or all in one</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="string">'Hello World'</span></span><br></pre></td></tr></table></figure>
<p>ECMAScript 6 以前我们在 JavaScript 中并没有其他的变量声明方式，以 var 声明的变量作用于函数作用域中，如果没有相应的闭合函数作用域，那么该变量会被当做默认的全局变量进行处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> hello = <span class="string">'Hello World'</span></span><br><span class="line">  <span class="keyword">return</span> hello</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(hello)</span><br></pre></td></tr></table></figure>
<p>像如上这种调用方式会抛出异常: ReferenceError: hello is not defined，因为 hello 变量只能作用于 sayHello 函数中，不过如果按照如下先声明全局变量方式再使用时，其就能够正常调用:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="string">'Hello World'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> hello</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(hello)</span><br></pre></td></tr></table></figure>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>在 ECMAScript 6 中我们可以使用 let 关键字进行变量声明:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x <span class="comment">// Declaration and initialization</span></span><br><span class="line">x = <span class="string">'Hello World'</span> <span class="comment">// Assignment</span></span><br><span class="line"><span class="comment">// Or all in one</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="string">'Hello World'</span></span><br></pre></td></tr></table></figure>
<p>let 关键字声明的变量是属于块作用域，也就是包含在 {} 之内的作用于。使用 let 关键字的优势在于能够降低偶然的错误的概率，因为其保证了每个变量只能在最小的作用域内进行访问。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Peter'</span></span><br><span class="line"><span class="keyword">if</span> (name === <span class="string">'Peter'</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> hello = <span class="string">'Hello Peter'</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> hello = <span class="string">'Hi'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(hello)</span><br></pre></td></tr></table></figure>
<p>上述代码同样会抛出 ReferenceError: hello is not defined 异常，因为 hello 只能够在闭合的块作用域中进行访问，我们可以进行如下修改:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Peter'</span></span><br><span class="line"><span class="keyword">if</span> (name === <span class="string">'Peter'</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> hello = <span class="string">'Hello Peter'</span></span><br><span class="line">  <span class="built_in">console</span>.log(hello)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> hello = <span class="string">'Hi'</span></span><br><span class="line">  <span class="built_in">console</span>.log(hello)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以利用这种块级作用域的特性来避免闭包中因为变量保留而导致的问题，譬如如下两种异步代码，使用 var 时每次循环中使用的都是相同变量；而使用 let 声明的 i 则会在每次循环时进行不同的绑定，即每次循环中闭包捕获的都是不同的 i 实例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`i:<span class="subst">$&#123;i&#125;</span>`</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`j:<span class="subst">$&#123;j&#125;</span>`</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> k = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`k:<span class="subst">$&#123;k&#125;</span>`</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">i: <span class="number">0</span></span><br><span class="line">i: <span class="number">1</span></span><br><span class="line">j: <span class="number">2</span></span><br><span class="line">j: <span class="number">2</span></span><br><span class="line">k: <span class="number">2</span></span><br><span class="line">k: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const 关键字一般用于常量声明，用 const 关键字声明的常量需要在声明时进行初始化并且不可以再进行修改，并且 const 关键字声明的常量被限制于块级作用域中进行访问。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> x;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// okay, block scoped name</span></span><br><span class="line">      <span class="keyword">const</span> x = <span class="string">"sneaky"</span>;</span><br><span class="line">      <span class="comment">// error, const</span></span><br><span class="line">      x = <span class="string">"foo"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// error, already declared in block</span></span><br><span class="line">    <span class="keyword">let</span> x = <span class="string">"inner"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript 中 const 限制的并非值不可变性；而是创建了不可变的绑定，即对于某个值的只读引用，并且禁止了对于该引用的重赋值，即如下的代码会触发错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line">numbers = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>] <span class="comment">// error: assignment to constant variable</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers[<span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<p>我们可以参考如下图片理解这种机制，每个变量标识符都会关联某个存放变量实际值的物理地址；所谓只读的变量即是该变量标识符不可以被重新赋值，而该变量指向的值还是可变的。</p>
<p>JavaScript 中存在着所谓的原始类型与复合类型，使用 const 声明的原始类型是值不可变的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Example 1</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">10</span></span><br><span class="line">a = a + <span class="number">1</span> <span class="comment">// error: assignment to constant variable</span></span><br><span class="line"># Example 2</span><br><span class="line"><span class="keyword">const</span> isTrue = <span class="literal">true</span></span><br><span class="line">isTrue = <span class="literal">false</span> <span class="comment">// error: assignment to constant variable</span></span><br><span class="line"># Example 3</span><br><span class="line"><span class="keyword">const</span> sLower = <span class="string">'hello world'</span></span><br><span class="line"><span class="keyword">const</span> sUpper = sLower.toUpperCase() <span class="comment">// create a new string</span></span><br><span class="line"><span class="built_in">console</span>.log(sLower) <span class="comment">// print hello world</span></span><br><span class="line"><span class="built_in">console</span>.log(sUpper) <span class="comment">// print HELLO WORLD</span></span><br></pre></td></tr></table></figure>
<p>而如果我们希望将某个对象同样变成不可变类型，则需要使用 Object.freeze()；不过该方法仅对于键值对的 Object 起作用，而无法作用于 Date、Map 与 Set 等类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Example 4</span><br><span class="line"><span class="keyword">const</span> me = <span class="built_in">Object</span>.freeze(&#123;<span class="attr">name</span>: “Jacopo”&#125;)</span><br><span class="line">me.age = <span class="number">28</span></span><br><span class="line"><span class="built_in">console</span>.log(me.age) <span class="comment">// print undefined</span></span><br><span class="line"># Example 5</span><br><span class="line"><span class="keyword">const</span> arr = <span class="built_in">Object</span>.freeze([<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>]) <span class="comment">// print -1</span></span><br><span class="line"># Example 6</span><br><span class="line"><span class="keyword">const</span> me = <span class="built_in">Object</span>.freeze(&#123;</span><br><span class="line">  name: <span class="string">'Jacopo'</span>,</span><br><span class="line">  pet: &#123;</span><br><span class="line">    type: <span class="string">'dog'</span>,</span><br><span class="line">    name: <span class="string">'Spock'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">me.pet.name = <span class="string">'Rocky'</span></span><br><span class="line">me.pet.breed = <span class="string">'German Shepherd'</span></span><br><span class="line"><span class="built_in">console</span>.log(me.pet.name) <span class="comment">// print Rocky</span></span><br><span class="line"><span class="built_in">console</span>.log(me.pet.breed) <span class="comment">// print German Shepherd</span></span><br></pre></td></tr></table></figure>
<p>即使是 Object.freeze() 也只能防止顶层属性被修改，而无法限制对于嵌套属性的修改，这一点我们会在下文的浅拷贝与深拷贝部分继续讨论。</p>
<h2 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h2><h3 id="按值传递"><a href="#按值传递" class="headerlink" title="按值传递"></a>按值传递</h3><p>JavaScript 中永远是按值传递（pass-by-value），只不过当我们传递的是某个对象的引用时，这里的值指的是对象的引用。按值传递中函数的形参是被调用时所传实参的副本。修改形参的值并不会影响实参。而按引用传递（pass-by-reference）时，函数的形参接收实参的隐式引用，而不再是副本。这意味着函数形参的值如果被修改，实参也会被修改。同时两者指向相同的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeStuff</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  a = a * <span class="number">10</span>;</span><br><span class="line">  b.item = <span class="string">"changed"</span>;</span><br><span class="line">  c = &#123;<span class="attr">item</span>: <span class="string">"changed"</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">item</span>: <span class="string">"unchanged"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">item</span>: <span class="string">"unchanged"</span>&#125;;</span><br><span class="line">changeStuff(num, obj1, obj2);</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.item); <span class="comment">// changed</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.item); <span class="comment">// unchanged</span></span><br></pre></td></tr></table></figure>
<p>JavaScript 按值传递就表现于在内部修改了 c 的值但是并不会影响到外部的 obj2 变量。如果我们更深入地来理解这个问题，JavaScript 对于对象的传递则是按共享传递的（pass-by-sharing，也叫按对象传递、按对象共享传递）。最早由Barbara Liskov. 在1974年的GLU语言中提出；该求值策略被用于Python、Java、Ruby、JS等多种语言。该策略的重点是：调用函数传参时，函数接受对象实参引用的副本(既不是按值传递的对象副本，也不是按引用传递的隐式引用)。 它和按引用传递的不同在于：在共享传递中对函数形参的赋值，不会影响实参的值。按共享传递的直接表现就是上述代码中的 obj1，当我们在函数内修改了 b 指向的对象的属性值时，我们使用 obj1 来访问相同的变量时同样会得到变化后的值。</p>
<h3 id="连续赋值"><a href="#连续赋值" class="headerlink" title="连续赋值"></a>连续赋值</h3><p>JavaScript 中是支持变量的连续赋值，即譬如：</p>
<pre><code>var a=b=1;
</code></pre><p>为了解释上述问题，我们引入一个新的变量:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">n</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a; <span class="comment">// 持有a，以回查</span></span><br><span class="line">a.x = a = &#123;<span class="attr">n</span>:<span class="number">2</span>&#125;;</span><br><span class="line">alert(a.x);<span class="comment">// --&gt; undefined</span></span><br><span class="line">alert(b.x);<span class="comment">// --&gt; [object Object]</span></span><br></pre></td></tr></table></figure>
<p>实际上在连续赋值中，值是直接赋予给变量指向的内存地址：</p>
<pre><code>a.x  =  a  = {n:2}
        │      │
{n:1}&lt;──┘      └─&gt;{n:2}
</code></pre><h3 id="Deconstruction-解构赋值"><a href="#Deconstruction-解构赋值" class="headerlink" title="Deconstruction: 解构赋值"></a>Deconstruction: 解构赋值</h3><p>解构赋值允许你使用类似数组或对象字面量的语法将数组和对象的属性赋给各种变量。这种赋值语法极度简洁，同时还比传统的属性访问方法更为清晰。传统的访问数组前三个元素的方式为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> first = someArray[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> second = someArray[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> third = someArray[<span class="number">2</span>];</span><br><span class="line"><span class="comment">// 结构赋值</span></span><br><span class="line"><span class="keyword">var</span> [first, second, third] = someArray;</span><br><span class="line"><span class="comment">// === Arrays</span></span><br><span class="line"><span class="keyword">var</span> [a, b] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b);<span class="comment">//=&gt; 1 2</span></span><br><span class="line"><span class="comment">// Use from functions, only select from pattern</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> [a, b] = foo();</span><br><span class="line"><span class="built_in">console</span>.log(a, b);<span class="comment">// =&gt; 1 2</span></span><br><span class="line"><span class="comment">// Omit certain values</span></span><br><span class="line"><span class="keyword">var</span> [a, , b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b);<span class="comment">// =&gt; 1 3</span></span><br><span class="line"><span class="comment">// Combine with spread/rest operator (accumulates the rest of the values)</span></span><br><span class="line"><span class="keyword">var</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b);<span class="comment">// =&gt; 1 [ 2, 3 ]</span></span><br><span class="line"><span class="comment">// Fail-safe.</span></span><br><span class="line"><span class="keyword">var</span> [, , , a, b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b);<span class="comment">// =&gt; undefined undefined</span></span><br><span class="line"><span class="comment">// Swap variables easily without temp</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">[b, a] = [a, b];</span><br><span class="line"><span class="built_in">console</span>.log(a, b);<span class="comment">// =&gt; 2 1</span></span><br><span class="line"><span class="comment">// Advance deep arrays</span></span><br><span class="line"><span class="keyword">var</span> [a, [b, [c, d]]] = [<span class="number">1</span>, [<span class="number">2</span>, [[[<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>], <span class="number">6</span>]]];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a:"</span>, a, <span class="string">"b:"</span>, b, <span class="string">"c:"</span>, c, <span class="string">"d:"</span>, d);<span class="comment">// =&gt; a: 1 , b: 2,  c: [ [ 3, 4 ], 5 ] , d: 6</span></span><br><span class="line"><span class="comment">// === Objects</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">user</span>: x&#125; = &#123;<span class="attr">user</span>: <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(x);<span class="comment">// =&gt; 5</span></span><br><span class="line"><span class="comment">// Fail-safe</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">user</span>: x&#125; = &#123;<span class="attr">user2</span>: <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(x);<span class="comment">// =&gt; undefined</span></span><br><span class="line"><span class="comment">// More values</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">prop</span>: x, <span class="attr">prop2</span>: y&#125; = &#123;<span class="attr">prop</span>: <span class="number">5</span>, <span class="attr">prop2</span>: <span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(x, y);<span class="comment">// =&gt; 5 10</span></span><br><span class="line"><span class="comment">// Short-hand syntax</span></span><br><span class="line"><span class="keyword">var</span> &#123; prop, prop2&#125; = &#123;<span class="attr">prop</span>: <span class="number">5</span>, <span class="attr">prop2</span>: <span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(prop, prop2);<span class="comment">// =&gt; 5 10</span></span><br><span class="line"><span class="comment">// Equal to:</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">prop</span>: prop, <span class="attr">prop2</span>: prop2&#125; = &#123;<span class="attr">prop</span>: <span class="number">5</span>, <span class="attr">prop2</span>: <span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(prop, prop2);<span class="comment">// =&gt; 5 10</span></span><br><span class="line"><span class="comment">// Oops: This doesn't work:</span></span><br><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line">&#123; a, b &#125; = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">// But this does work</span></span><br><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line">(&#123; a, b &#125; = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a, b);<span class="comment">// =&gt; 1 2</span></span><br><span class="line"><span class="comment">// This due to the grammar in JS.</span></span><br><span class="line"><span class="comment">// Starting with &#123; implies a block scope, not an object literal.</span></span><br><span class="line"><span class="comment">// () converts to an expression.</span></span><br><span class="line"><span class="comment">// From Harmony Wiki:</span></span><br><span class="line"><span class="comment">// Note that object literals cannot appear in</span></span><br><span class="line"><span class="comment">// statement positions, so a plain object</span></span><br><span class="line"><span class="comment">// destructuring assignment statement</span></span><br><span class="line"><span class="comment">//  &#123; x &#125; = y must be parenthesized either</span></span><br><span class="line"><span class="comment">// as (&#123; x &#125; = y) or (&#123; x &#125;) = y.</span></span><br><span class="line"><span class="comment">// Combine objects and arrays</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">prop</span>: x, <span class="attr">prop2</span>: [, y]&#125; = &#123;<span class="attr">prop</span>: <span class="number">5</span>, <span class="attr">prop2</span>: [<span class="number">10</span>, <span class="number">100</span>]&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(x, y);<span class="comment">// =&gt; 5 100</span></span><br><span class="line"><span class="comment">// Deep objects</span></span><br><span class="line"><span class="keyword">var</span> &#123;</span><br><span class="line">  prop: x,</span><br><span class="line">  prop2: &#123;</span><br><span class="line">    prop2: &#123;</span><br><span class="line">      nested: [ , , b]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; = &#123; <span class="attr">prop</span>: <span class="string">"Hello"</span>, <span class="attr">prop2</span>: &#123; <span class="attr">prop2</span>: &#123; <span class="attr">nested</span>: [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]&#125;&#125;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(x, b);<span class="comment">// =&gt; Hello c</span></span><br><span class="line"><span class="comment">// === Combining all to make fun happen</span></span><br><span class="line"><span class="comment">// All well and good, can we do more? Yes!</span></span><br><span class="line"><span class="comment">// Using as method parameters</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params">&#123;prop: x&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;;</span><br><span class="line">foo(&#123;<span class="attr">invalid</span>: <span class="number">1</span>&#125;);<span class="comment">// =&gt; undefined</span></span><br><span class="line">foo(&#123;<span class="attr">prop</span>: <span class="number">1</span>&#125;);<span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="comment">// Can also use with the advanced example</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  prop: x,</span></span></span><br><span class="line"><span class="function"><span class="params">  prop2: &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    prop2: &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      nested: b</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, ...b);</span><br><span class="line">&#125;;</span><br><span class="line">foo(&#123; <span class="attr">prop</span>: <span class="string">"Hello"</span>, <span class="attr">prop2</span>: &#123; <span class="attr">prop2</span>: &#123; <span class="attr">nested</span>: [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]&#125;&#125;&#125;); <span class="comment">// =&gt; Hello a b c</span></span><br><span class="line"><span class="comment">// In combination with other ES2015 features.</span></span><br><span class="line"><span class="comment">// Computed property names</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'fieldName'</span>;</span><br><span class="line"><span class="keyword">const</span> computedObject = &#123; [name]: name &#125;; <span class="comment">// (where object is &#123; 'fieldName': 'fieldName' &#125;)</span></span><br><span class="line"><span class="keyword">const</span> &#123; [name]: nameValue &#125; = computedObject;</span><br><span class="line"><span class="built_in">console</span>.log(nameValue) <span class="comment">// =&gt; fieldName</span></span><br><span class="line"><span class="comment">// Rest and defaults</span></span><br><span class="line"><span class="keyword">var</span> ajax = <span class="function"><span class="keyword">function</span> (<span class="params">&#123; url = <span class="string">"localhost"</span>, port: p = <span class="number">80</span>&#125;, ...data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Url:"</span>, url, <span class="string">"Port:"</span>, p, <span class="string">"Rest:"</span>, data);</span><br><span class="line">&#125;;</span><br><span class="line">ajax(&#123; <span class="attr">url</span>: <span class="string">"someHost"</span> &#125;, <span class="string">"additional"</span>, <span class="string">"data"</span>, <span class="string">"hello"</span>);<span class="comment">// =&gt; Url: someHost Port: 80 Rest: [ 'additional', 'data', 'hello' ]</span></span><br><span class="line">ajax(&#123; &#125;, <span class="string">"additional"</span>, <span class="string">"data"</span>, <span class="string">"hello"</span>);<span class="comment">// =&gt; Url: localhost Port: 80 Rest: [ 'additional', 'data', 'hello' ]</span></span><br><span class="line"><span class="comment">// Ooops: Doesn't work (in traceur)</span></span><br><span class="line"><span class="keyword">var</span> ajax = <span class="function">(<span class="params">&#123; url = <span class="string">"localhost"</span>, port: p = <span class="number">80</span>&#125;, ...data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Url:"</span>, url, <span class="string">"Port:"</span>, p, <span class="string">"Rest:"</span>, data);</span><br><span class="line">&#125;;</span><br><span class="line">ajax(&#123; &#125;, <span class="string">"additional"</span>, <span class="string">"data"</span>, <span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// probably due to traceur compiler</span></span><br><span class="line">But <span class="keyword">this</span> does:</span><br><span class="line"><span class="keyword">var</span> ajax = <span class="function">(<span class="params">&#123; url: url = <span class="string">"localhost"</span>, port: p = <span class="number">80</span>&#125;, ...data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Url:"</span>, url, <span class="string">"Port:"</span>, p, <span class="string">"Rest:"</span>, data);</span><br><span class="line">&#125;;</span><br><span class="line">ajax(&#123; &#125;, <span class="string">"additional"</span>, <span class="string">"data"</span>, <span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// Like _.pluck</span></span><br><span class="line"><span class="keyword">var</span> users = [</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">"Name1"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">"Name2"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">"Name2"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">"Name3"</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> names = users.map( <span class="function">(<span class="params">&#123; user &#125;</span>) =&gt;</span> user );</span><br><span class="line"><span class="built_in">console</span>.log(names);<span class="comment">// =&gt; [ 'Name1', 'Name2', 'Name2', 'Name3' ]</span></span><br><span class="line"><span class="comment">// Advanced usage with Array Comprehension and default values</span></span><br><span class="line"><span class="keyword">var</span> users = [</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">"Name1"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">"Name2"</span>, <span class="attr">age</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">"Name2"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">"Name3"</span>, <span class="attr">age</span>: <span class="number">4</span> &#125;</span><br><span class="line">];</span><br><span class="line">[<span class="keyword">for</span> (&#123; user, age = <span class="string">"DEFAULT AGE"</span> &#125; <span class="keyword">of</span> users) <span class="built_in">console</span>.log(user, age)];</span><br><span class="line"><span class="comment">// =&gt; Name1 DEFAULT AGE</span></span><br><span class="line"><span class="comment">// =&gt; Name2 2</span></span><br><span class="line"><span class="comment">// =&gt; Name2 DEFAULT AGE</span></span><br><span class="line"><span class="comment">// =&gt; Name3 4</span></span><br></pre></td></tr></table></figure>
<h3 id="数组与迭代器"><a href="#数组与迭代器" class="headerlink" title="数组与迭代器"></a>数组与迭代器</h3><p>以上是数组解构赋值的一个简单示例，其语法的一般形式为：</p>
<pre><code>[ variable1, variable2, ..., variableN ] = array;
</code></pre><p>事实上，用变量来描述并不恰当，因为你可以对任意深度的嵌套数组进行解构：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line"><span class="built_in">console</span>.log(foo);<span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(bar);<span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(baz);<span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>此外，你可以在对应位留空来跳过被解构数组中的某些元素：</p>
<pre><code>var [,,third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];
console.log(third);  // &quot;baz&quot;
</code></pre><p>而且你还可以通过“不定参数”模式捕获数组中的所有尾随元素：</p>
<pre><code>var [head, ...tail] = [1, 2, 3, 4];
console.log(tail);// [2, 3, 4]
</code></pre><p>当访问空数组或越界访问数组时，对其解构与对其索引的行为一致，最终得到的结果都是：undefined。</p>
<pre><code>console.log([][0]); // undefined
var [missing] = [];
console.log(missing); // undefined
</code></pre><p>请注意，数组解构赋值的模式同样适用于任意迭代器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> [first, second, third, fourth, fifth, sixth] = fibs();</span><br><span class="line"><span class="built_in">console</span>.log(sixth); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>通过解构对象，你可以把它的每个属性与不同的变量绑定，首先指定被绑定的属性，然后紧跟一个要解构的变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> robotA = &#123; <span class="attr">name</span>: <span class="string">"Bender"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> robotB = &#123; <span class="attr">name</span>: <span class="string">"Flexo"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">name</span>: nameA &#125; = robotA;</span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">name</span>: nameB &#125; = robotB;</span><br><span class="line"><span class="built_in">console</span>.log(nameA);<span class="comment">// "Bender"</span></span><br><span class="line"><span class="built_in">console</span>.log(nameB);<span class="comment">// "Flexo"</span></span><br></pre></td></tr></table></figure>
<p>当属性名与变量名一致时，可以通过一种实用的句法简写：</p>
<pre><code>var { foo, bar } = { foo: &quot;lorem&quot;, bar: &quot;ipsum&quot; };
console.log(foo);    // &quot;lorem&quot;
console.log(bar);    // &quot;ipsum&quot;
</code></pre><p>与数组解构一样，你可以随意嵌套并进一步组合对象解构：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> complicatedObj = &#123;</span><br><span class="line">  arrayProp: [</span><br><span class="line">    <span class="string">"Zapp"</span>,</span><br><span class="line">    &#123; <span class="attr">second</span>: <span class="string">"Brannigan"</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">arrayProp</span>: [first, &#123; second &#125;] &#125; = complicatedObj;</span><br><span class="line"><span class="built_in">console</span>.log(first);<span class="comment">// "Zapp"</span></span><br><span class="line"><span class="built_in">console</span>.log(second);<span class="comment">// "Brannigan"</span></span><br></pre></td></tr></table></figure>
<p>当你解构一个未定义的属性时，得到的值为undefined：</p>
<pre><code>var { missing } = {};
console.log(missing);    // undefined
</code></pre><p>请注意，当你解构对象并赋值给变量时，如果你已经声明或不打算声明这些变量（亦即赋值语句前没有let、const或var关键字），你应该注意这样一个潜在的语法错误：</p>
<pre><code>{ blowUp } = { blowUp: 10 };    // Syntax error 语法错误
</code></pre><p>为什么会出错？这是因为JavaScript语法通知解析引擎将任何以{开始的语句解析为一个块语句（例如，{console}是一个合法块语句）。解决方案是将整个表达式用一对小括号包裹：</p>
<pre><code>({ safe } = {});    // No errors 没有语法错误
</code></pre><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>当你要解构的属性未定义时你可以提供一个默认值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [missing = <span class="literal">true</span>] = [];</span><br><span class="line"><span class="built_in">console</span>.log(missing);<span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">message</span>: msg = <span class="string">"Something went wrong"</span> &#125; = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(msg);<span class="comment">// "Something went wrong"</span></span><br><span class="line"><span class="keyword">var</span> &#123; x = <span class="number">3</span> &#125; = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(x);<span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>由于解构中允许对对象进行解构，并且还支持默认值，那么完全可以将解构应用在函数参数以及参数的默认值中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeBreakpoint</span>(<span class="params">&#123; url, line, column &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们构造一个提供配置的对象，并且需要这个对象的属性携带默认值时，解构特性就派上用场了。举个例子，jQuery的ajax函数使用一个配置对象作为它的第二参数，我们可以这样重写函数定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  async = true,</span></span></span><br><span class="line"><span class="function"><span class="params">  beforeSend = noop,</span></span></span><br><span class="line"><span class="function"><span class="params">  cache = true,</span></span></span><br><span class="line"><span class="function"><span class="params">  complete = noop,</span></span></span><br><span class="line"><span class="function"><span class="params">  crossDomain = false,</span></span></span><br><span class="line"><span class="function"><span class="params">  global = true,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="regexp">//</span> ... 更多配置</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同样，解构也可以应用在函数的多重返回值中，可以类似于其他语言中的元组的特性：</p>
<pre><code>function returnMultipleValues() {
  return [1, 2];
}
var [foo, bar] = returnMultipleValues();
</code></pre><h3 id="Three-Dots-…"><a href="#Three-Dots-…" class="headerlink" title="Three Dots …"></a>Three Dots …</h3><p>es6新增的特性</p>
<h3 id="Rest-Operator"><a href="#Rest-Operator" class="headerlink" title="Rest Operator"></a>Rest Operator</h3><p>在 JavaScript 函数调用时我们往往会使用内置的 arguments 对象来获取函数的调用参数，不过这种方式却存在着很多的不方便性。譬如 arguments 对象是 Array-Like 对象，无法直接运用数组的 .map() 或者 .forEach() 函数；并且因为 arguments 是绑定于当前函数作用域，如果我们希望在嵌套函数里使用外层函数的 arguments 对象，我们还需要创建中间变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// store arguments into a separated variable</span></span><br><span class="line">  <span class="keyword">var</span> argsOuter = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// args is an array-like object</span></span><br><span class="line">    <span class="keyword">var</span> even = <span class="built_in">Array</span>.prototype.map.call(argsOuter, <span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// do something with argsOuter</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6 中为我们提供了 Rest Operator 来以数组形式获取函数的调用参数，Rest Operator 也可以用于在解构赋值中以数组方式获取剩余的变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countArguments</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> args.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// get the number of arguments</span></span><br><span class="line">countArguments(<span class="string">'welcome'</span>, <span class="string">'to'</span>, <span class="string">'Earth'</span>); <span class="comment">// =&gt; 3</span></span><br><span class="line"><span class="comment">// destructure an array</span></span><br><span class="line"><span class="keyword">let</span> otherSeasons, autumn;</span><br><span class="line">[autumn, ...otherSeasons] = cold;</span><br><span class="line">otherSeasons  <span class="comment">// =&gt; ['winter']</span></span><br></pre></td></tr></table></figure>
<p>典型的 Rest Operator 的应用场景譬如进行不定数组的指定类型过滤：</p>
<pre><code>function filter(type, ...items) {
  return items.filter(item =&gt; typeof item === type);
}
filter(&apos;boolean&apos;, true, 0, false);        // =&gt; [true, false]
filter(&apos;number&apos;, false, 4, &apos;Welcome&apos;, 7); // =&gt; [4, 7]
</code></pre><p>尽管 Arrow Function 中并没有定义 arguments 对象，但是我们仍然可以使用 Rest Operator 来获取 Arrow Function 的调用参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> outerArguments = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="keyword">const</span> concat = <span class="function">(<span class="params">...items</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span> === outerArguments); <span class="comment">// =&gt; true</span></span><br><span class="line">    <span class="keyword">return</span> items.reduce(<span class="function">(<span class="params">result, item</span>) =&gt;</span> result + item, <span class="string">''</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  concat(<span class="number">1</span>, <span class="number">5</span>, <span class="string">'nine'</span>); <span class="comment">// =&gt; '15nine'</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="Spread-Operator"><a href="#Spread-Operator" class="headerlink" title="Spread Operator"></a>Spread Operator</h3><p>Spread Operator 则与 Rest Opeator 的功能正好相反，其常用于进行数组构建与解构赋值，也可以用于将某个数组转化为函数的参数列表，其基本使用方式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cold = [<span class="string">'autumn'</span>, <span class="string">'winter'</span>];</span><br><span class="line"><span class="keyword">let</span> warm = [<span class="string">'spring'</span>, <span class="string">'summer'</span>];</span><br><span class="line"><span class="comment">// construct an array</span></span><br><span class="line">[...cold, ...warm] <span class="comment">// =&gt; ['autumn', 'winter', 'spring', 'summer']</span></span><br><span class="line"><span class="comment">// function arguments from an array</span></span><br><span class="line">cold.push(...warm);</span><br><span class="line">cold <span class="comment">// =&gt; ['autumn', 'winter', 'spring', 'summer']</span></span><br></pre></td></tr></table></figure>
<p>我们也可以使用 Spread Operator 来简化函数调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, country) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.country = country;</span><br><span class="line">  &#125;</span><br><span class="line">  getDescription() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> leads <span class="subst">$&#123;<span class="keyword">this</span>.country&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> details = [<span class="string">'Alexander the Great'</span>, <span class="string">'Greece'</span>];</span><br><span class="line"><span class="keyword">var</span> Alexander = <span class="keyword">new</span> King(...details);</span><br><span class="line">Alexander.getDescription(); <span class="comment">// =&gt; 'Alexander the Great leads Greece'</span></span><br></pre></td></tr></table></figure>
<p>还有另外一个好处就是可以用来替换 Object.assign 来方便地从旧有的对象中创建新的对象，并且能够修改部分值；譬如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj_new_1 = <span class="built_in">Object</span>.assign(&#123;&#125;,obj,&#123;<span class="attr">a</span>:<span class="number">3</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> obj_new_2 = &#123;</span><br><span class="line">  ...obj,</span><br><span class="line">  a:<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们还需要讨论下 Spread Operator 与 Iteration Protocols，实际上 Spread Operator 也是使用的 Iteration Protocols 来进行元素遍历与结果搜集；因此我们也可以通过自定义 Iterator 的方式来控制 Spread Operator 的表现。Iterable 协议规定了对象必须包含 Symbol.iterator 方法，该方法返回某个 Iterator 对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Iterable &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> Iterator;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该 Iterator 对象从属于 Iterator Protocol，其需要提供 next 成员方法，该方法会返回某个包含 done 与 value 属性的对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Iterator &#123;</span><br><span class="line">  next() &#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">        value: <span class="xml"><span class="tag">&lt;<span class="name">value</span>&gt;</span>,</span></span><br><span class="line">        done: &lt;boolean&gt;</span><br><span class="line">     &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>典型的 Iterable 对象就是字符串：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'hi'</span>;</span><br><span class="line"><span class="keyword">var</span> iterator = str[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">iterator.toString(); <span class="comment">// =&gt; '[object String Iterator]'</span></span><br><span class="line">iterator.next();     <span class="comment">// =&gt; &#123; value: 'h', done: false &#125;</span></span><br><span class="line">iterator.next();     <span class="comment">// =&gt; &#123; value: 'i', done: false &#125;</span></span><br><span class="line">iterator.next();     <span class="comment">// =&gt; &#123; value: undefined, done: true &#125;</span></span><br><span class="line">[...str];            <span class="comment">// =&gt; ['h', 'i']</span></span><br></pre></td></tr></table></figure>
<p>我们可以通过自定义 array-like 对象的 Symbol.iterator 属性来控制其在迭代器上的效果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="comment">// Conform to Iterator protocol</span></span><br><span class="line">      done : index &gt;= <span class="keyword">this</span>.length,</span><br><span class="line">      value: <span class="keyword">this</span>[index++]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'Cat'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'Bird'</span>,</span><br><span class="line">  length: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Conform to Iterable Protocol</span></span><br><span class="line">arrayLike[<span class="built_in">Symbol</span>.iterator] = iterator;</span><br><span class="line"><span class="keyword">var</span> array = [...arrayLike];</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// =&gt; ['Cat', 'Bird']</span></span><br></pre></td></tr></table></figure>
<p>arrayLike[Symbol.iterator] 为该对象创建了值为某个迭代器的属性，从而使该对象符合了 Iterable 协议；而 iterator() 又返回了包含 next 成员方法的对象，使得该对象最终具有和数组相似的行为表现。</p>
<h2 id="Copy-Composite-Data-Types-复合类型的拷贝"><a href="#Copy-Composite-Data-Types-复合类型的拷贝" class="headerlink" title="Copy Composite Data Types: 复合类型的拷贝"></a>Copy Composite Data Types: 复合类型的拷贝</h2><h3 id="Shallow-Copy-浅拷贝"><a href="#Shallow-Copy-浅拷贝" class="headerlink" title="Shallow Copy 浅拷贝"></a>Shallow Copy 浅拷贝</h3><p>浅拷贝是指复制时，指对第一层键值对进行独立的赋值，一个简单的实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!source || <span class="keyword">typeof</span> source !== <span class="string">'object'</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 这个方法有点问题，target一定要事先定好，不然就不能改变实参了</span></span><br><span class="line">  <span class="comment">// 具体原因解释可看参考资料中 JS是值传递还是引用传递</span></span><br><span class="line">  <span class="keyword">if</span> (!target || <span class="keyword">typeof</span> target !== <span class="string">'object'</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这边最好区别一下对象和数组的复制</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">    <span class="keyword">if</span> (source.hasOwnProperty(key)) &#123;</span><br><span class="line">      target[key] = source[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><p>Object.assign() 方法可以把任意多个源对象所拥有的自身可枚举属性拷贝给目标对象，然后返回目标对象。<br>Object.assign 方法只会拷贝 源对象自身的并且可枚举的属性 到目标对象身上。注意，对于访问器属性，该方法会执行那个访问器属性的 getter 函数，然后把得到的值拷贝给目标对象如果你想拷贝访问器属性本身，请使用 <code>Object.getOwnPropertyDescriptor</code> 和 <code>Object.difineProperties()</code>方法</p>
<p>注意，字符串类型和 symbol 类型的属性都会被拷贝。</p>
<p>注意，在属性拷贝过程中可能会产生异常，比如目标对象的某个只读属性和源对象的某个属性同名，这时该方法会抛出一个 TypeError 异常，拷贝过程中断，已经拷贝成功的属性不会受到影响，还未拷贝的属性将不会再被拷贝。</p>
<p>注意， Object.assign 会跳过那些值为 null 或 undefined 的源对象。</p>
<pre><code>Object.assign(target, ...sources)
</code></pre><p>浅拷贝一个对象</p>
<pre><code>var obj = {a: 1}
var copy = Object.assign({}, obj)
console.log(copy) // {a:1}
</code></pre><p>合并若干个对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">var</span> o3 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(o1, o2, o3)</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o1) <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;, 注意目标对象自身也会改变。</span></span><br></pre></td></tr></table></figure>
<p>拷贝 symbol 类型的属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; [<span class="built_in">Symbol</span>(<span class="string">'foo'</span>)]: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, o1, o2)</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123; a: 1, [Symbol("foo")]: 2 &#125;</span></span><br></pre></td></tr></table></figure>
<p>继承属性和不可枚举属性是不能拷贝的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(</span><br><span class="line">  &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// foo是个继承属性</span></span><br><span class="line">    bar: &#123; <span class="attr">value</span>: <span class="number">2</span> &#125;, <span class="comment">// bar是个不可枚举属性</span></span><br><span class="line">    baz: &#123;</span><br><span class="line">      value: <span class="number">3</span>,</span><br><span class="line">      enumerable: <span class="literal">true</span> <span class="comment">// baz是个自身可枚举属性</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj)</span><br><span class="line"><span class="built_in">console</span>.log(copy) <span class="comment">// &#123;baz: 3&#125;</span></span><br></pre></td></tr></table></figure>
<p>原始值会被隐式转换成其包装对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="string">'123'</span></span><br><span class="line"><span class="keyword">var</span> v2 = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> v3 = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> v4 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, v1, <span class="literal">null</span>, v2, <span class="literal">undefined</span>, v3, v4)</span><br><span class="line"><span class="comment">// 源对象如果是原始值，会被自动转换成它们的包装对象，</span></span><br><span class="line"><span class="comment">// 而 null 和 undefined 这两种原始值会被完全忽略。</span></span><br><span class="line"><span class="comment">// 注意，只有字符串的包装对象才有可能有自身可枚举属性。</span></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123; "0": "1", "1": "2", "2": "3" &#125;</span></span><br></pre></td></tr></table></figure>
<p>例子：拷贝属性过程中发生异常</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'foo'</span>, &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  writeable: <span class="literal">false</span></span><br><span class="line">&#125;) <span class="comment">// target 的 foo 属性是个只读属性。</span></span><br><span class="line"><span class="built_in">Object</span>.assign(target, &#123; <span class="attr">bar</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">foo2</span>: <span class="number">3</span>, <span class="attr">foo</span>: <span class="number">3</span>, <span class="attr">foo3</span>: <span class="number">3</span> &#125;, &#123; <span class="attr">baz</span>: <span class="number">4</span> &#125;)</span><br><span class="line"><span class="comment">// TypeError: "foo" is read-only</span></span><br><span class="line"><span class="comment">// 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。</span></span><br><span class="line"><span class="built_in">console</span>.log(target.bar) <span class="comment">// 2，说明第一个源对象拷贝成功了。</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo2) <span class="comment">// 3，说明第二个源对象的第一个属性也拷贝成功了。</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo) <span class="comment">// 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo3) <span class="comment">// undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。</span></span><br><span class="line"><span class="built_in">console</span>.log(target.baz) <span class="comment">// undefined，第三个源对象更是不会被拷贝到的。</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-concat-来复制数组"><a href="#使用-concat-来复制数组" class="headerlink" title="使用 [].concat 来复制数组"></a>使用 [].concat 来复制数组</h3><p>同样类似于对于对象的复制，我们建议使用[].concat 来进行数组的深复制:</p>
<pre><code>ar list = [1, 2, 3];
var changedList = [].concat(list);
changedList[1] = 2;
list === changedList; // false
</code></pre><p>同样的，concat 方法也只能保证一层深复制:</p>
<pre><code>&gt; list = [[1,2,3]]
[ [ 1, 2, 3 ] ]
&gt; new_list = [].concat(list)
[ [ 1, 2, 3 ] ]
&gt; new_list[0][0] = 4
4
&gt; list
[ [ 4, 2, 3 ] ]
</code></pre><h3 id="浅拷贝的缺陷"><a href="#浅拷贝的缺陷" class="headerlink" title="浅拷贝的缺陷"></a>浅拷贝的缺陷</h3><p>不过需要注意的是，assign 是浅拷贝，或者说，它是一级深拷贝，举两个例子说明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultOpt = &#123;</span><br><span class="line">  title: &#123;</span><br><span class="line">    text: <span class="string">'hello world'</span>,</span><br><span class="line">    subtext: <span class="string">"It's my world"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> opt = <span class="built_in">Object</span>.assign(&#123;&#125;, defaultOpt, &#123;</span><br><span class="line">  title: &#123;</span><br><span class="line">    subtext: <span class="string">'Yes, your world'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(opt) <span class="comment">// &#123; title: &#123; subtext: 'Yes, your world.' &#125; &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面这个例子中，对于对象的一级子元素而言，只会替换引用，而不会动态的添加内容。那么，其实 assign 并没有解决对象的引用混乱问题，参考下下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultOpt = &#123;</span><br><span class="line">  title: &#123;</span><br><span class="line">    text: <span class="string">'hello world'</span>,</span><br><span class="line">    subtext: <span class="string">"It's my world."</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> opt1 = <span class="built_in">Object</span>.assign(&#123;&#125;, defaultOpt);</span><br><span class="line"><span class="keyword">const</span> opt2 = <span class="built_in">Object</span>.assign(&#123;&#125;, defaultOpt);</span><br><span class="line">opt2.title.subtext = <span class="string">'Yes, your world.'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(opt1); <span class="comment">// &#123; title: &#123; text: 'hello world', subtext: 'Yes, your world.' &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(opt2); <span class="comment">// &#123; title: &#123; text: 'hello world', subtext: 'Yes, your world.' &#125; &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="DeepCopy-深拷贝"><a href="#DeepCopy-深拷贝" class="headerlink" title="DeepCopy: 深拷贝"></a>DeepCopy: 深拷贝</h3><p><strong>递归属性遍历</strong></p>
<p>一般来说，在JavaScript中考虑复合类型的深层复制的时候，往往就是指对于Date、Object与Array这三个复合类型的处理。我们能想到的最常用的方法就是先创建一个空的新对象，然后递归遍历旧对象，直到发现基础类型的子节点才赋予到新对象对应的位置。不过这种方法会存在一个问题，就是JavaScript中存在着神奇的原型机制，并且这个原型会在遍历的时候出现，然后原型不应该被赋予给新对象。那么在遍历的过程中，我们应该考虑使用hasOenProperty方法来过滤掉那些继承自原型链上的属性:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> copy</span><br><span class="line">  <span class="comment">// 处理基本类型 null undefined</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">null</span> === obj || <span class="string">'object'</span> !== <span class="keyword">typeof</span> obj) <span class="keyword">return</span> obj</span><br><span class="line">  <span class="comment">// 若为 Date 对象时</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">    copy = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    copy.setTime(obj.getTime())</span><br><span class="line">    <span class="keyword">return</span> copy</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理数组</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">    copy = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = obj.length; i &lt; len; i++) &#123;</span><br><span class="line">      copy[i] = clone(obj[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理对象</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">    copy = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj.hasOwnProperty(attr)) &#123;</span><br><span class="line">        copy[attr] = clone(obj[arr])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unable to copy obj! Its type isn\'t supported!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This would be cloneable:</span></span><br><span class="line"><span class="keyword">var</span> tree = &#123;</span><br><span class="line">    <span class="string">"left"</span>  : &#123; <span class="string">"left"</span> : <span class="literal">null</span>, <span class="string">"right"</span> : <span class="literal">null</span>, <span class="string">"data"</span> : <span class="number">3</span> &#125;,</span><br><span class="line">    <span class="string">"right"</span> : <span class="literal">null</span>,</span><br><span class="line">    <span class="string">"data"</span>  : <span class="number">8</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// This would kind-of work, but you would get 2 copies of the</span></span><br><span class="line"><span class="comment">// inner node instead of 2 references to the same copy</span></span><br><span class="line"><span class="keyword">var</span> directedAcylicGraph = &#123;</span><br><span class="line">    <span class="string">"left"</span>  : &#123; <span class="string">"left"</span> : <span class="literal">null</span>, <span class="string">"right"</span> : <span class="literal">null</span>, <span class="string">"data"</span> : <span class="number">3</span> &#125;,</span><br><span class="line">    <span class="string">"data"</span>  : <span class="number">8</span></span><br><span class="line">&#125;;</span><br><span class="line">directedAcyclicGraph[<span class="string">"right"</span>] = directedAcyclicGraph[<span class="string">"left"</span>];</span><br><span class="line"><span class="comment">// Cloning this would cause a stack overflow due to infinite recursion:</span></span><br><span class="line"><span class="keyword">var</span> cylicGraph = &#123;</span><br><span class="line">    <span class="string">"left"</span>  : &#123; <span class="string">"left"</span> : <span class="literal">null</span>, <span class="string">"right"</span> : <span class="literal">null</span>, <span class="string">"data"</span> : <span class="number">3</span> &#125;,</span><br><span class="line">    <span class="string">"data"</span>  : <span class="number">8</span></span><br><span class="line">&#125;;</span><br><span class="line">cylicGraph[<span class="string">"right"</span>] = cylicGraph;</span><br></pre></td></tr></table></figure>
<h3 id="利用JSON深拷贝"><a href="#利用JSON深拷贝" class="headerlink" title="利用JSON深拷贝"></a>利用JSON深拷贝</h3><pre><code>JSON.parse(JSON.stringify(obj))
</code></pre><p>对于一般的需求是可以满足的，但是它有缺点，下例中，可以看到JSON赋值会忽略掉值为undefined以及函数表达式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="literal">undefined</span>,</span><br><span class="line">  sum: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line"><span class="built_in">console</span>.log(obj2) <span class="comment">// Object &#123;a: 1, b: 2&#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zhuanlan.zhihu.com/p/28313321" target="_blank" rel="noopener">基于 JSX 的动态数据绑定</a><br><a href="https://zhuanlan.zhihu.com/p/27844393" target="_blank" rel="noopener">ECMAScript 2017（ES8）特性概述</a><br><a href="https://zhuanlan.zhihu.com/p/27410280" target="_blank" rel="noopener">WebAssembly 初体验：从零开始重构计算模块</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Fridolph</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.fridolph.top/2018/06/23/【JS】变量声明与赋值，引用、值传递与对象拷贝/">http://blog.fridolph.top/2018/06/23/【JS】变量声明与赋值，引用、值传递与对象拷贝/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.fridolph.top" target="_blank">霪霖笙箫的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/js/">js</a><a class="post-meta__tags" href="/tags/es6/">es6</a><a class="post-meta__tags" href="/tags/引用/">引用</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/06/29/【JS】学习正则表达式（一）/"><i class="fa fa-chevron-left">  </i><span>【JS】学习正则表达式</span></a></div><div class="next-post pull-right"><a href="/2018/06/13/【设计模式】从订阅发布模式说起/"><span>【JS】【设计模式】从订阅发布模式说起</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'http://blog.fridolph.top/2018/06/23/【JS】变量声明与赋值，引用、值传递与对象拷贝/';
  this.page.identifier = '2018/06/23/【JS】变量声明与赋值，引用、值传递与对象拷贝/';
  this.page.title = '【JS】变量声明与赋值，引用、值传递与对象拷贝';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'fridolph' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-src" src="https://fridolph.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2016 - 2024 By Fridolph</div><div class="framework-info"><span>driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.3"></script><script src="/js/fancybox.js?version=1.5.3"></script><script src="/js/sidebar.js?version=1.5.3"></script><script src="/js/copy.js?version=1.5.3"></script><script src="/js/fireworks.js?version=1.5.3"></script><script src="/js/transition.js?version=1.5.3"></script><script src="/js/scroll.js?version=1.5.3"></script><script src="/js/head.js?version=1.5.3"></script></body></html>