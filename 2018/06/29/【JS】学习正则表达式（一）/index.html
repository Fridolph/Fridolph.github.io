<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="【JS】学习正则表达式"><meta name="keywords" content="js,正则表达式"><meta name="author" content="Fridolph,undefined"><meta name="copyright" content="Fridolph"><title>【JS】学习正则表达式 | 霪霖笙箫的博客</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css?version=1.5.3"><meta http-equiv="Cache-Control" content="no-cache,no-store,must-revalidate"><meta http-equiv="Pragma" content="no-cache"><meta http-equiv="Expires" content="0"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?https://hm.baidu.com/hm.js?66f25c24596db799ce091d9b434b9495";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  localSearch: {"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"},"path":"search.xml"}
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#子字符串匹配和替换"><span class="toc-number">1.</span> <span class="toc-text">子字符串匹配和替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造正则表达式"><span class="toc-number">2.</span> <span class="toc-text">构造正则表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用正则进行搜索"><span class="toc-number">3.</span> <span class="toc-text">使用正则进行搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用正则表达式进行替换"><span class="toc-number">4.</span> <span class="toc-text">使用正则表达式进行替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匹配-HTML"><span class="toc-number">5.</span> <span class="toc-text">匹配 HTML</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符集"><span class="toc-number">6.</span> <span class="toc-text">字符集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重复"><span class="toc-number">7.</span> <span class="toc-text">重复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#句点元字符和转义"><span class="toc-number">8.</span> <span class="toc-text">句点元字符和转义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分组"><span class="toc-number">9.</span> <span class="toc-text">分组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#懒惰匹配、贪婪匹配"><span class="toc-number">10.</span> <span class="toc-text">懒惰匹配、贪婪匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反向引用"><span class="toc-number">11.</span> <span class="toc-text">反向引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#替换组"><span class="toc-number">12.</span> <span class="toc-text">替换组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数替换"><span class="toc-number">13.</span> <span class="toc-text">函数替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锚点"><span class="toc-number">14.</span> <span class="toc-text">锚点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单词边界匹配"><span class="toc-number">15.</span> <span class="toc-text">单词边界匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#向前查找"><span class="toc-number">16.</span> <span class="toc-text">向前查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态构造正则表达式"><span class="toc-number">17.</span> <span class="toc-text">动态构造正则表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number"></span> <span class="toc-text">总结</span></a></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/config/avatar.jpg"></div><div class="author-info__name text-center">Fridolph</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">58</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">69</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">14</span></a></div></div><div class="unit"><div class="heart"><div class="heart-piece-0"></div><div class="heart-piece-1"></div><div class="heart-piece-2"></div><div class="heart-piece-3"></div><div class="heart-piece-4"></div><div class="heart-piece-5"></div><div class="heart-piece-6"></div><div class="heart-piece-7"></div><div class="heart-piece-8"></div></div><p class="anime-title"><a href="https://github.com/fridolph" target="_blank">感谢访问本站，若喜欢请star ^_^</a></p></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/config/top-img.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">霪霖笙箫的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">个人主页</a><a class="site-page" href="/archives">文章总览</a><a class="site-page" href="/books">图书推荐</a><a class="site-page" href="/demo">项目实战</a><a class="site-page" href="/gallery">时光轨迹</a></span></div><div id="post-info"><div id="post-title">【JS】学习正则表达式</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-06-29</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JavaScript/">JavaScript</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2018/06/29/【JS】学习正则表达式（一）/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2018/06/29/【JS】学习正则表达式（一）/"></span></a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">4,548</span><span class="post-meta__separator">|</span><span>阅读时长: 17 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><blockquote>
<p>最近因工作用到了，顺便查看了一些关于正则的博客，确实非常使用。学好正则看来是以后的一个必选项，趁着最近时间挺充裕的，于是系统的入门了一下，也算是能手写几个简单的正则来匹配规则了。</p>
</blockquote>
<a id="more"></a>
<p><img src="http://blog.fueson.top/18-6-28/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.png?imageView2/0/interlace/1/q/70|watermark/2/text/ZnJpZG9scGg=/font/5a6L5L2T/fontsize/240/fill/IzAwMDAwMA==/dissolve/100/gravity/SouthEast/dx/10/dy/10|imageslim" alt="学习正则表达式"></p>
<h3 id="子字符串匹配和替换"><a href="#子字符串匹配和替换" class="headerlink" title="子字符串匹配和替换"></a>子字符串匹配和替换</h3><p>如果只想知道某个字符串是否包含在一个更大的字符串中，下面的 String.prototype 方法就可以实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="string">'As I was going to Saint Ives'</span></span><br><span class="line">input.startsWith(<span class="string">'As'</span>) <span class="comment">// true</span></span><br><span class="line">input.endsWith(<span class="string">'Ives'</span>) <span class="comment">// true</span></span><br><span class="line">input.startsWith(<span class="string">'going'</span>, <span class="number">9</span>) <span class="comment">// true - 从下标9开始数</span></span><br><span class="line">input.endsWith(<span class="string">'going'</span>, <span class="number">14</span>) <span class="comment">// true - 将下标14当作字符串结尾</span></span><br><span class="line">input.includes(<span class="string">'going'</span>) <span class="comment">// true</span></span><br><span class="line">input.includes(<span class="string">'going'</span>, <span class="number">10</span>) <span class="comment">// false - 从下标10开始</span></span><br><span class="line">input.indexOf(<span class="string">'going'</span>) <span class="comment">// 9</span></span><br><span class="line">input.indexOf(<span class="string">'going'</span>, <span class="number">10</span>) <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 若想进一步操作，如替换掉刚才匹配的字符串，可以使用String.prototype.replace</span></span><br><span class="line"><span class="keyword">const</span> output = input.replace(<span class="string">'going'</span>, <span class="string">'walking'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="构造正则表达式"><a href="#构造正则表达式" class="headerlink" title="构造正则表达式"></a>构造正则表达式</h3><p>在 JS 中，正则可以通过 RegExp 类来表示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re1 = <span class="regexp">/going/</span> <span class="comment">// 可以搜索 'going'的正则表达式</span></span><br><span class="line"><span class="keyword">const</span> re2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'going'</span>) <span class="comment">// 使用对象构造器的等价形式</span></span><br></pre></td></tr></table></figure>
<h3 id="使用正则进行搜索"><a href="#使用正则进行搜索" class="headerlink" title="使用正则进行搜索"></a>使用正则进行搜索</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="string">'As I was going to Saint Ives'</span></span><br><span class="line"><span class="keyword">const</span> re = <span class="regexp">/\w&#123;3,&#125;/gi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串(input)开始</span></span><br><span class="line">input.match(re) <span class="comment">// ['was', 'going', 'Saint', 'Ives']</span></span><br><span class="line">input.search(re) <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从正则表达式开始(re)</span></span><br><span class="line">re.test(input) <span class="comment">// true - input至少包含一个三个字母的单词</span></span><br><span class="line">re.exec(input) <span class="comment">// ['was'] (第一个匹配)</span></span><br><span class="line">re.exec(input) <span class="comment">// ['going'] (exec会记住它所在的位置)</span></span><br><span class="line">re.exec(input) <span class="comment">// ['Saint']</span></span><br><span class="line">re.exec(input) <span class="comment">// ['Ives']</span></span><br><span class="line">re.exec(input) <span class="comment">// null - 匹配完毕</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，所有这些方法都可以直接使用字面量语法</span></span><br><span class="line">input.match(<span class="regexp">/\w&#123;3,&#125;/gi</span>)</span><br><span class="line">input.search(<span class="regexp">/\w&#123;3,&#125;/gi</span>)</span><br><span class="line">;<span class="regexp">/\w&#123;3,&#125;/gi</span>.test(input)</span><br><span class="line">;<span class="regexp">/\w&#123;3,&#125;/gi</span>.exec(input)</span><br></pre></td></tr></table></figure>
<h3 id="使用正则表达式进行替换"><a href="#使用正则表达式进行替换" class="headerlink" title="使用正则表达式进行替换"></a>使用正则表达式进行替换</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="string">'As I was going to Saint Ives'</span></span><br><span class="line"><span class="keyword">const</span> output = input.replace(<span class="regexp">/\w&#123;3,&#125;/gi</span>, <span class="string">'****'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="匹配-HTML"><a href="#匹配-HTML" class="headerlink" title="匹配 HTML"></a>匹配 HTML</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> html1 = <span class="string">`</span></span><br><span class="line"><span class="string">  HTML width &lt;a href="/one"&gt;one link&lt;/a&gt;, and some JavaScript.</span></span><br><span class="line"><span class="string">  &lt;script src="strff.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> matches = html.match(<span class="regexp">/&lt;area|&lt;a|&lt;link|&lt;script|&lt;source/gi</span>)</span><br></pre></td></tr></table></figure>
<p>要了解的是，现在来说正则表达式不能解析 HTML。为解决这个问题，需引入一个解析器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> html2 = <span class="string">'&lt;br&gt; [!CDATA[&lt;br&gt;]]'</span></span><br><span class="line"><span class="keyword">const</span> matches = html.match(<span class="regexp">/&lt;br&gt;/gi</span>) <span class="comment">// ['&lt;br&gt;', '&lt;br&gt;']</span></span><br></pre></td></tr></table></figure>
<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>字符集提供了一种简洁的方式，来表达单个字符的分支。如果想在一个字符串中查找所有的数字，可以使用分支：</p>
<p><strong>具名字符集</strong></p>
<p>\d [0-9]<br>\D [^0-9]<br>\s [\t\v\n \r] 包含制表符、空格和垂直制表符<br>\S [^\t\v\n \r]<br>\w [a-zA-Z_] 破折号和句号没有被包含进来，所以它不能用于域名和 CSS 类<br>\W [^a-za-z_]</p>
<h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><p><strong>重复修饰符</strong></p>
<p><code>{n}</code> 精确 n 次<br>/\d{5}/ 匹配 5 位数字</p>
<p><code>{n,}</code> 至少 n 次<br>/\d{5,}/ 匹配 5 位或 5 位以上数字</p>
<p><code>{n, m}</code> 最少 n 次，最多 m 次<br>/\d{2,5}/ 匹配 2 到 5 位数字</p>
<p><code>?</code> 0 或 1 次，等价于{0,1}<br>/[a-z]\d?/i 匹配跟随了 0 个或 1 个数字的字符</p>
<p><code>*</code> 0 次或多次<br>/[a-z]\d*/i 匹配跟随了 0 个或多个数字的字母</p>
<p><code>+</code> 1 次或多次<br>/[a-z]\d+/i 匹配了至少跟随了 1 个数字的字母</p>
<h3 id="句点元字符和转义"><a href="#句点元字符和转义" class="headerlink" title="句点元字符和转义"></a>句点元字符和转义</h3><p>在正则中，句点是一个特殊的字符，表示“匹配任何内容”（除了新的一行）。通常，这个匹配一切的元字符用来消费哪些输入中并不关心的内容。</p>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>到目前为止，所构造的正则能够识别单个字符（重复允许多次匹配，但这依旧是一个单字符匹配）。而分组则允许构造子表达式，它可以被当作一个独立单元来使用。</p>
<p>除了创建子表达式，分组还可以帮助“捕获”分组结果，以便后续使用。<br>“捕获”结果是默认功能，不过也有办法创建“非捕获组”，这也是接下来要学习的内容。</p>
<p>分组是使用圆括号来指定的，非捕获组看起来像 <code>(?:&lt;subexpression&gt;)</code>，其中<subexpression>是需要匹配的内容</subexpression></p>
<p>看组例子，假设现在要匹配的后缀为.com .org .edu 的域名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">'Visit oreilly.com today!'</span></span><br><span class="line"><span class="keyword">const</span> match = text.match(<span class="regexp">/[a-z]+(?:\.com|\.org|\.edu)/i</span>)</span><br></pre></td></tr></table></figure>
<p>分组的另一个好处是可以在分组时使用重复。一般情况下，重复仅被用在重复元字符前面的单个字符上。分组则允许将其用在一整个字符串上。有一个常见的例子是，如果想匹配 URL,以及那些以http://或https://（独立于协议的URL）开始的URL，可以在分组上使用代表匹配0个或1个<code>?</code>的重复元字符：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;link rel="stylesheet" href="http://insecure.com/stuff.css"&gt;</span></span><br><span class="line"><span class="string">  &lt;link rel="stylesheet" href="https://secure.com/securestuff.css"&gt;</span></span><br><span class="line"><span class="string">  &lt;link rel="stylehseet" href="//anything.comflexible.css"&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> matches = html.match(<span class="regexp">/(?:https?)?\/\/[a-z][a-z0-9-]+[a-z0-9]+/gi</span>)</span><br></pre></td></tr></table></figure>
<p>以一个非捕获组开始 (?:https?)? ，注意这里有两个匹配 0 或 1 个的重复元字符</p>
<p>第一个表示 https 的 s 是可选的（一般情况下重复元字符只作用于它左边最近的字符）第二个指向它左边的整个组（整体来看，它会匹配空字符串：没有 https、http 或者 https）</p>
<p>继续执行，匹配了两个斜杠 \/\/ (必须对斜杠进行转义)<br>然后得到了一个复杂的字符类。</p>
<blockquote>
<p>需要记住一点，使用正则时并不需要一次做完所有事情。事实上，每当浏览网站时，可以先找出所有 URL 或疑似 URL 的东西，然后做二次分析，筛选出那些非法或不完整的 URL 等。 但，为防止注入攻击而检查用户输入等情况就要让正则滴水不漏</p>
</blockquote>
<hr>
<h3 id="懒惰匹配、贪婪匹配"><a href="#懒惰匹配、贪婪匹配" class="headerlink" title="懒惰匹配、贪婪匹配"></a>懒惰匹配、贪婪匹配</h3><p>例：html 文本，想将其中的<code>&lt;i&gt;</code>标签替换成<code>&lt;source&gt;</code>标签，下面是第一次尝试：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = <span class="string">`</span></span><br><span class="line"><span class="string">  Regex pros know the difference between</span></span><br><span class="line"><span class="string">  &lt;i&gt;greedy&lt;/i&gt; and &lt;i&gt;lazy&lt;/i&gt; matching.</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">input.replace(<span class="regexp">/&lt;i&gt;(.*)&lt;\/i&gt;/gi</span>, <span class="string">'&lt;strong&gt;$1&lt;/strong&gt;'</span>)</span><br><span class="line"><span class="comment">// Regex pros know the difference between</span></span><br><span class="line"><span class="comment">// &lt;strong&gt;greedy&lt;/i&gt; and &lt;i&gt;lazy&lt;/strong&gt; matching.</span></span><br></pre></td></tr></table></figure>
<p>我们认识一下正则表达式引擎的工作方式，它只有在找到符合要求的匹配后，才会消费输入并且继续运行。默认情况下，它是通过贪婪模式来实现的，它会找到第一个<code>&lt;i&gt;</code>，然后，在找到<code>&lt;/i&gt;</code>并且确定在这个<code>&lt;/i&gt;</code>之后不存在同样的<code>&lt;/i&gt;</code>，查找都不会停止。因为这里有两个<code>&lt;/i&gt;</code>，所以正则会匹配到第二个<code>&lt;/i&gt;</code>，而非第一个。</p>
<p>这里可以使用重复元字符 * 将其转换成懒惰匹配来解决，在后面添加一个问号即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = <span class="string">`</span></span><br><span class="line"><span class="string">  Regex pros know the difference between</span></span><br><span class="line"><span class="string">  &lt;i&gt;greedy&lt;/i&gt; and &lt;i&gt;lazy&lt;/i&gt; matching.</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">input.replace(<span class="regexp">/&lt;i&gt;(.*?)&lt;\/i&gt;/gi</span>, <span class="string">'&lt;strong&gt;$1&lt;/strong&gt;'</span>)</span><br></pre></td></tr></table></figure>
<p>与之前相比，该正则除了在*后面加了一个问号，其他完全一样。</p>
<p>所有的重复元字符： _ + ？ {n} {n, } {n, m}都可以在后面跟随一个问号将它变成懒惰的（虽然在实践中，通常只把它和_ + 一起使用过）</p>
<h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>先由简单例子入手，假设想匹配符合 XYXY 格式的乐队名字，所以当希望匹配（PJJP、GOOG、ANNA）这些乐队名时，反向引用就可以登场了。正则表达式中的每个组（包括子组）都被分配了一个数字，从左到右依次是 1，2，3…可以通过在反斜杠后加一个数字的方式来引用特定的组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promo = <span class="string">'Opening for XAAX is the dynamic GOOG! At the box office now !'</span></span><br><span class="line"><span class="keyword">const</span> bands = promo.match(<span class="regexp">/(?:[A-Z])(?:[A-Z])/g</span>)</span><br><span class="line"><span class="comment">// 使用重音符，是因为我们将单引号和双引号都用过了</span></span><br><span class="line"><span class="keyword">const</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;img alt="A 'simple' example."&gt;</span></span><br><span class="line"><span class="string">  &lt;img alt="Don't abuse it!"&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> matches = html.match(<span class="regexp">/&lt;img alt=(?:['"]).*?/g</span>)</span><br></pre></td></tr></table></figure>
<h3 id="替换组"><a href="#替换组" class="headerlink" title="替换组"></a>替换组</h3><p>分组带来的好处是，可以利用它做一些更加复杂的替换，继续看 HTML 的例子，加入想要去掉一个<code>&lt;a&gt;</code>标签中除了 href 以外的内容</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> html = <span class="string">`&lt;a class="nope" href="/yep"&gt;Yep&lt;/a&gt;`</span></span><br><span class="line"><span class="keyword">let</span> str = html.replace(<span class="regexp">/&lt;a .*?(href=".*?").*?/</span>, <span class="string">'&lt;a $1&gt;'</span>)</span><br><span class="line"><span class="comment">// str -&gt; "&lt;a href="/yep"&gt;&gt;Yep&lt;/a&gt;"</span></span><br></pre></td></tr></table></figure>
<p>所有的组都被分配了一个从 1 开始的数字，这个正则表达式中，通过\1 来引用第一个组；而在替换字符串上，用的是$1。注意，在这个表达式中使用懒惰量词是为了防止它在匹配时跨域多个<code>&lt;a&gt;</code>标签。不过，如果<code>&lt;a&gt;</code>标签的 href 属性使用的是单引号而非双号，也会匹配失败。</p>
<p>下面来扩展这个例子，希望保持 class 和 href，依旧删除其他元素：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> html = <span class="string">`&lt;a class="yep" href="/yep" id="nope"&gt;Yep&lt;/a&gt;`</span></span><br><span class="line"><span class="keyword">let</span> str = html.replace(<span class="regexp">/&lt;a .*?(class=".*?").*?(href=".*?").*?&gt;/</span>, <span class="string">'&lt;a $2 $1&gt;'</span>)</span><br></pre></td></tr></table></figure>
<p>注意在这个表达式中，将 class 和 href 的顺序颠倒了，使得 href 始终先出现，这个表达啊是的问题在于 class 和 href 始终要保持相同的顺序，并且，一旦<code>&lt;a&gt;</code>标签中的属性使用了单引号，就会匹配失败</p>
<p>除了$1,$2,$3…这些组引用，还有$` 匹配项之前的所有内容， $&amp; 匹配目标本身， $’匹配项之后的所有内容，如果想使用一个美元符号，可以使用$$:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="string">'One two three'</span></span><br><span class="line">input.replace(<span class="regexp">/two/</span>, <span class="string">'($`)'</span>) <span class="comment">// "One (One ) three"</span></span><br><span class="line">input.replace(<span class="regexp">/\w+/g</span>, <span class="string">'($&amp;)'</span>) <span class="comment">// "(One) (two) (three)"</span></span><br><span class="line">input.replace(<span class="regexp">/two/</span>, <span class="string">"($')"</span>) <span class="comment">// "One ( three) three"</span></span><br><span class="line">input.replace(<span class="regexp">/two/</span>, <span class="string">'($$)'</span>) <span class="comment">// "One ($) three"</span></span><br></pre></td></tr></table></figure>
<h3 id="函数替换"><a href="#函数替换" class="headerlink" title="函数替换"></a>函数替换</h3><p>这是正则最棒的一个特性之一，因为它允许将一个非常复杂的正则表达式拆分成一些简单的表达式。</p>
<p>再来看一个实际修改 HTML 的例子：希望保留 class, id, href 属性并删除其他内容</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;a class="foo" href="/foo" id="foo"&gt;Foo&lt;/a&gt;</span></span><br><span class="line"><span class="string">  &lt;A href='/foo' Class="foo"&gt;Foo&lt;/a&gt;</span></span><br><span class="line"><span class="string">  &lt;a href="/foo"&gt;Foo&lt;/a&gt;</span></span><br><span class="line"><span class="string">  &lt;a onclick="javascript:alert('foo!')" href="/foo"&gt;Foo&lt;/a&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>
<p>用正则来实现感觉很麻烦，因为变化太多！确实，不过之前说过，并不一定要一次到位。可以通过将表达式拆分成两个，从而大大减少变化的数量：一个用于识别<code>&lt;a&gt;</code>标签，而另一个用于将<code>&lt;a&gt;</code>替换成期望的内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sanitizeATag</span>(<span class="params">aTag</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取标签</span></span><br><span class="line">  <span class="keyword">const</span> parts = aTag.match(<span class="regexp">/&lt;a\s+(.*?)&gt;(.*?)&lt;\/a&gt;/i</span>)</span><br><span class="line">  <span class="comment">// parts[1]是&lt;a&gt;标签中间的属性</span></span><br><span class="line">  <span class="comment">// parts[2]是&lt;a&gt;和&lt;/a&gt;中间的内容</span></span><br><span class="line">  <span class="keyword">const</span> attributes = parts[<span class="number">1</span>]</span><br><span class="line">    <span class="comment">// 接下来将其分割成独立的属性</span></span><br><span class="line">    .split(<span class="regexp">/\s+/</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&lt;a <span class="subst">$&#123;attributes</span></span></span><br><span class="line"><span class="string"><span class="subst">    .filter(attr =&gt; <span class="regexp">/^(?:class|id|href)[\s=]/i</span>.test(attr))</span></span></span><br><span class="line"><span class="string"><span class="subst">    .join(<span class="string">' '</span>)&#125;</span>&gt;</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;parts[<span class="number">2</span>]&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/a&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数比想象中要长，不过为了更加清晰，可以将它分成不同的部分。注意即使在这个函数中，依旧使用了多个正则表达式：一个用来匹配<code>&lt;a&gt;</code>，一个用来切割（使用一个正则表达十来识别一个或多个空格字符）字符串，还有一个用来过滤期望的属性。如果只用一个正则表达式来完成这些工作将会非常复杂。</p>
<p>接下来：在一个包含很多<code>&lt;a&gt;</code>的 HTML 块中使用 sanitizeATag 函数，编写一个只匹配<code>&lt;a&gt;</code>的正则表达式就很简单了：</p>
<pre><code>html.match(/&lt;a .*?&gt;(.*?)&lt;\/a&gt;/ig);
</code></pre><p>在匹配时，可以将函数当作一个替换参数传给 String.prototype.replace。目前为止，只 ongoing 过字符串作为替换参数。而使用函数则允许对每一个替换执行一个特定的操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">html.replace(<span class="regexp">/&lt;a .*?&gt;(.*?)&lt;\/a&gt;/gi</span>, <span class="function"><span class="keyword">function</span>(<span class="params">m, g1, offset</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`&lt;a&gt; tag found at <span class="subst">$&#123;offset&#125;</span>. contents: <span class="subst">$&#123;g1&#125;</span>&lt;/a&gt;`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*undefined</span></span><br><span class="line"><span class="comment">  undefined</span></span><br><span class="line"><span class="comment">  undefined</span></span><br><span class="line"><span class="comment">  undefined</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// &lt;a&gt; tag found at 3. contents: Foo&lt;/a&gt;</span></span><br><span class="line"><span class="comment">// &lt;a&gt; tag found at 49. contents: Foo&lt;/a&gt;</span></span><br><span class="line"><span class="comment">// &lt;a&gt; tag found at 86. contents: Foo&lt;/a&gt;</span></span><br><span class="line"><span class="comment">// &lt;a&gt; tag found at 111. contents: Foo&lt;/a&gt;</span></span><br></pre></td></tr></table></figure>
<p>传给 String.prototype.replace 的函数会按顺序接收以下参数：</p>
<ul>
<li>整个匹配的字符串(等价于$&amp;)</li>
<li>匹配上的组(如果存在)，有多少个组，这种参数就会有多少个</li>
<li>原始字符串中的匹配偏移量(一个数字)</li>
<li>原始字符串(很少使用到)</li>
</ul>
<p>该函数的返回值就是用来替换正则表达式的字符串。在上例中，没有指定返回值，所以默认返回 undefined。它会被转换成字符串后当作替换字符串使用。上例的重点就是强调这种工作机制，而非真实的转换，所以这里并没有返回最终结果。现在来回顾一下这个例子，有了能够清理单个<code>&lt;a&gt;</code>标签的函数，以及在 HTML 中查找<code>&lt;a&gt;</code>标签的方法，所以可以将它们结合起来使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html.replace(<span class="regexp">/&lt;a .*?&lt;\/a&gt;/gi</span>, sanitizeATag)</span><br></pre></td></tr></table></figure>
<p>当需要从一个大字符串中匹配小字符串，并且还要对小字符串做额外处理时，都可以通过向<code>String.prototype.replace</code>中传入函数来解决这个问题！</p>
<h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>通常，我们会关心一个字符串的开始和结束，或者整个字符串（而不只是一部分），这时<code>锚点</code>就派上用场了。有两种锚点：分别是用于匹配行开始的<code>^</code>，以及用于匹配行结束的<code>$</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="string">'It was the best of times, it was the worst of times'</span></span><br><span class="line"><span class="keyword">const</span> begin = input.match(<span class="regexp">/^\w+/g</span>) <span class="comment">// "It"</span></span><br><span class="line"><span class="keyword">const</span> end = input.match(<span class="regexp">/\w+$/g</span>) <span class="comment">// "times"</span></span><br><span class="line"><span class="keyword">const</span> everything = input.match(<span class="regexp">/^.*$/g</span>)</span><br><span class="line"><span class="comment">// "It was the best of times, it was the worst of times"</span></span><br><span class="line"><span class="keyword">const</span> nomatch1 = input.match(<span class="regexp">/^best/gi</span>)</span><br><span class="line"><span class="keyword">const</span> nomatch2 = input.match(<span class="regexp">/worst$/gi</span>)</span><br></pre></td></tr></table></figure>
<p>关于锚点，一般情况下，它匹配的是整个 字符串的开始和末尾，即使字符串中有换行。如果想把某个字符串当作多行字符串（以换行符分隔）来处理，就需要用到 m(多行选项)：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="string">'One line\nTwo lines\nThree lines\nFour'</span></span><br><span class="line"><span class="keyword">const</span> begin = input.match(<span class="regexp">/^\w+/gm</span>)</span><br><span class="line"><span class="keyword">const</span> end = input.match(<span class="regexp">/\w+$/gm</span>)</span><br></pre></td></tr></table></figure>
<h3 id="单词边界匹配"><a href="#单词边界匹配" class="headerlink" title="单词边界匹配"></a>单词边界匹配</h3><p>正则中一个经常被忽视，但却非常有用的特性。类似开始锚点和行末锚点，单词边界匹配的是\b，取反是\B，它不消费输入内容。单词边界界定为一个\w 匹配之前或之后紧挨着一个\W（非单词字符），或字符串的开始或结尾。来看个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inputs = [</span><br><span class="line">  <span class="string">'yinlinshengxiao@gmail.com'</span>,</span><br><span class="line">  <span class="string">'yinlinshengxiao@gmail.com is my email'</span>,</span><br><span class="line">  <span class="string">'my email is yinlinshengxiao@gmail.com'</span>,</span><br><span class="line">  <span class="string">'use yinlinshengxiao@gmail.com, my email'</span>,</span><br><span class="line">  <span class="string">'my email: yinlinshengxiao@gmail.com.'</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">  虽然有多种不同情况，这些邮箱有一个共同点：它们都处在单词边界。</span></span><br><span class="line"><span class="string">  单词边界标记的另一个好处是，因为它们不消费输入，所以不用担心“将它们放回”到替换字符串中：</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> emailMatcher = <span class="regexp">/\b[a-z][a-z0-9._-]*@[a-z][a-z0-9_-]+\.[a-z]+(?:\.[a-z]+)?\b/gi</span></span><br><span class="line">inputs.map(<span class="function"><span class="params">s</span> =&gt;</span> s.replace(emailMatcher, <span class="string">'&lt;a href="mailto:$&amp;"&gt;$&amp;&lt;/a&gt;'</span>))</span><br></pre></td></tr></table></figure>
<p>当需要搜索以外的单词开始、结束或包含其他单词的文本时，使用单词边界也非常方便。例如：/\bcount/ 会找到 count countdown， 但不会找到 discount recount 等。而 /\bcount\B/只能找到 countdown，/\Bcount\b/会找到 discount 和 recount，而 /\Bcount\B/只能找到 accountable</p>
<h3 id="向前查找"><a href="#向前查找" class="headerlink" title="向前查找"></a>向前查找</h3><p>与锚点和单词边界元字符一样，它不消费输入。然而，不同于锚点和单词边界的是，它们是通用的，可以匹配任何子表达式却不消费它。事实上，正如单词边界元字符，向前查找的这种不消费的特性，解决了有时候不得不进行“原封不动”的替换问题。只要有内容重复，向前查找就是必须的，而且他们可以简化某些特定类型的匹配。</p>
<p>例子：验证密码是否符合预设规则</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validPassword</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    /[A-Z]/.test(p) &amp;&amp;</span><br><span class="line">    /[<span class="number">0</span><span class="number">-9</span>]/.test(p) &amp;&amp;</span><br><span class="line">    /[a-z]/.test(p) &amp;&amp;</span><br><span class="line">    !<span class="regexp">/[^a-zA-Z0-9]/</span>.test(p)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 假设想将它们组合成一个正则表达式：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validPassword</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/[A-Z].*[0-9][a-z]/</span>.test(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该表达式对顺序有要求，不仅要求大写字母出现在数字之前，数字出现在两个小写字母前，而且没有对非法字符做任何校验。实际上也没有有个好办法可以实现它，因为字符在正则表达式运行时就被消费了。</p>
<p><code>向前查找</code>通过不消费输入来解决这个问题，本质上每个向前查找都是一个不消费输入的独立正则表达式，在 JS 中，向前查找是这样的 <code>(?=&lt;subexpression&gt;)</code>, 还有一个“否定向前查找” <code>:(?!&lt;subexpression&gt;)</code> 只会匹配不存在于子表达式中的内容。下面继续来重写上面的验证密码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validPassword</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/(?=.*[A-Z])(?=.*[0-9])(?=.*[a-z])(?!.*[^a-zA-Z0-9])/</span>.test(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该例子展示了向前检查（以及否定向前检查）的一个重要场景。</p>
<h3 id="动态构造正则表达式"><a href="#动态构造正则表达式" class="headerlink" title="动态构造正则表达式"></a>动态构造正则表达式</h3><p>这里提倡优先使用正则表达式字面语法而非构造器，因为不用对反斜杠进行转义。需要使用构造器的地方是动态构造。例如，想在一个字符串中匹配一个包含多个用户名的数组，但却没有办法将这些用户名整合在一个正则表达式字面量中。此时正则构造器就有用了，它可以通过字符串来构造正则表达式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = [<span class="string">'mary'</span>, <span class="string">'nick'</span>, <span class="string">'arthur'</span>, <span class="string">'sam'</span>, <span class="string">'yevtte'</span>]</span><br><span class="line"><span class="keyword">const</span> text =</span><br><span class="line">  <span class="string">'User @arthur started the backup and 15:15, '</span> +</span><br><span class="line">  <span class="string">'and @nick and @yvette restored it at 18:35.'</span></span><br><span class="line"><span class="keyword">const</span> userRegexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`@(?:<span class="subst">$&#123;users.join(<span class="string">'|'</span>)&#125;</span>)\\b`</span>, <span class="string">'g'</span>)</span><br><span class="line">text.match(userRegexp)</span><br></pre></td></tr></table></figure>
<p>与该例正则等价的字面量是： <code>/@(?:mary|nick|arthur|sam|yevtte)\b/g</code><br>需要注意的是：必须在 b 单词边界元字符之前使用双反斜杠</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一篇已经涉及了正则表达式中的主要知识点，但对于正则中包含的技术、例子和其固有的复杂性，也只是浅尝辄止。想要深入学习正则表达式，需要更多的练习与理解，那么以后在工作与学习中多多运用进去吧。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Fridolph</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.fridolph.top/2018/06/29/【JS】学习正则表达式（一）/">http://blog.fridolph.top/2018/06/29/【JS】学习正则表达式（一）/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.fridolph.top" target="_blank">霪霖笙箫的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/js/">js</a><a class="post-meta__tags" href="/tags/正则表达式/">正则表达式</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/07/07/【跨域】理解跨域及相关解决方案/"><i class="fa fa-chevron-left">  </i><span>【JS】理解跨域及相关解决方案</span></a></div><div class="next-post pull-right"><a href="/2018/06/23/【JS】变量声明与赋值，引用、值传递与对象拷贝/"><span>【JS】变量声明与赋值，引用、值传递与对象拷贝</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'http://blog.fridolph.top/2018/06/29/【JS】学习正则表达式（一）/';
  this.page.identifier = '2018/06/29/【JS】学习正则表达式（一）/';
  this.page.title = '【JS】学习正则表达式';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'fridolph' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-src" src="https://fridolph.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2016 - 2024 By Fridolph</div><div class="framework-info"><span>driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.3"></script><script src="/js/fancybox.js?version=1.5.3"></script><script src="/js/sidebar.js?version=1.5.3"></script><script src="/js/copy.js?version=1.5.3"></script><script src="/js/fireworks.js?version=1.5.3"></script><script src="/js/transition.js?version=1.5.3"></script><script src="/js/scroll.js?version=1.5.3"></script><script src="/js/head.js?version=1.5.3"></script></body></html>