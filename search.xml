<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>【总结】2023年底面临的危机及反思</title>
      <link href="/2023/12/28/%E3%80%90%E6%80%BB%E7%BB%93%E3%80%912023%E5%B9%B4%E5%BA%95%E9%9D%A2%E4%B8%B4%E7%9A%84%E5%8D%B1%E6%9C%BA%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%8F%8D%E6%80%9D/"/>
      <url>/2023/12/28/%E3%80%90%E6%80%BB%E7%BB%93%E3%80%912023%E5%B9%B4%E5%BA%95%E9%9D%A2%E4%B8%B4%E7%9A%84%E5%8D%B1%E6%9C%BA%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%8F%8D%E6%80%9D/</url>
      <content type="html"><![CDATA[<h3 id="吐槽（为什么又开始写博客了）"><a href="#吐槽（为什么又开始写博客了）" class="headerlink" title="吐槽（为什么又开始写博客了）"></a>吐槽（为什么又开始写博客了）</h3><blockquote><p>16年毕业，趁着互联网的风口，选择了前端岗位。那时技术更新日新月异可谓百鸟争鸣，从jQuery面向对象的开发模式，逐渐过渡到以现代构建工具，利用React、Vue等框架，高效率的开发模式，需要持续学习来应对接连的挑战。    随着工作稳定，慢慢将重心转移到生活和家庭中，这无可厚非。本以为段子里的程序猿中年危机离我还很遥远，但它还是来了，随之而来的还有无尽的焦虑及大数据伴生的各种烦恼、负能量推送。对此我很抗拒、迷茫，在短期的自我调整中，我偶然翻起了之前看了一半的《学习产品思维》，受益良多。  遂决定写下这篇博客，以此吹响“反击”的号角。</p></blockquote><a id="more"></a><p>运用产品思维的一个好处就是可以跳脱当前，站在一个客观的角度俯瞰全局，在此就预设一个命题来进行思考——如何看待当下的失业危机，该怎样调整和应对？</p><h2 id="明确目的"><a href="#明确目的" class="headerlink" title="明确目的"></a>明确目的</h2><h3 id="解决焦虑，设定目标"><a href="#解决焦虑，设定目标" class="headerlink" title="解决焦虑，设定目标"></a>解决焦虑，设定目标</h3><p>焦虑无非是不知道做什么，对自己能力的不自信，从而产生的一种大众跟随情绪。但自从学完了产品思维后，不良情绪逐渐消散。正因设定了许许多多可完成的目标，哪还能再此停留不前呢？</p><h3 id="接受现实，坦然面对"><a href="#接受现实，坦然面对" class="headerlink" title="接受现实，坦然面对"></a>接受现实，坦然面对</h3><p>首先是年底前（元旦后可能还会有部分）工作对接处理。需要注意的：19年、21年某几个项目的开发环境readme添加，环境搭建node版本不同的几个坑；当前维护的两个项目代码提交及注释，写完交接文档。</p><p>对于公司欠薪很遗憾，好聚好散，生活还得继续，接下来走劳动仲裁途径维护自己权益，积累了一波仲裁经验，希望以后用不到吧：</p><h3 id="XXX公司工作相关思考"><a href="#XXX公司工作相关思考" class="headerlink" title="XXX公司工作相关思考"></a>XXX公司工作相关思考</h3><p>这里就不写太多了，作为一个引子，会把相关内容移到简历中，这里写个大纲：</p><ul><li>完成的项目<ul><li>时间</li><li>收益</li><li>技术架构</li><li>难点</li><li>启发</li></ul></li><li>经验<ul><li>团队管理</li><li>项目管理</li><li>项目维护</li></ul></li><li>个人<ul><li>贡献</li><li>优势</li><li>不足</li></ul></li></ul><h2 id="如何调整"><a href="#如何调整" class="headerlink" title="如何调整"></a>如何调整</h2><p>其实写到这里，那种压力和负担感已缓解了不少。本地启了下之前的博客备份，被几个同事看到，还被尴夸了一波（害羞），说：没看出来你以前弄的东西这么牛逼。（某：合着现在菜狗是吧 … 但好像无力反驳）学习下周董的心态呗，哥20年前的歌现在依旧牛逼，那我几年前的产出现在也勉强能打没问题吧？</p><p>心理上没了负担，只需把目标转化为行动，并坚持下去 ^_^<br>不断获得反馈，及时校正和处理。</p><h2 id="如何应对"><a href="#如何应对" class="headerlink" title="如何应对"></a>如何应对</h2><p>结合着个人情况设立了以下目标，并会根据实际情况做出反馈及时更新该篇博客。</p><ol><li>设定阶段计划 与 每天学习计划<ul><li>保持学习状态，按计划执行</li><li>若因家事等不能执行，也要留出1h进行阅读</li><li>每天至少有一次梳理提交到github、gitee中</li></ul></li><li>个人网站重新搭建<ul><li>[&#x2714;]购买服务器、恢复域名</li><li>[&#x2716;]2024年1月中旬左右完成备案</li><li>[&#x2716;]备案搞定后技术博客更新，部署上线</li></ul></li><li>23年底做完资料大整理<ul><li>[&#x2714;] 学习云盘，个人移动盘资料内容同步更新、整理</li><li>[&#x2714;] github、gitee垃圾项目，fork等清理</li><li>[&#x2714;] [fridolph]学习项目，按新的目录重新分类、整理</li><li>[&#x2714;] 制定1-2月的学习计划，并开始执行</li></ul></li><li>技术学习提高 与 博客上新计划<ul><li>[&#x2716;] 元旦前写一篇《学习产品思维》 的学习总结</li><li>[&#x2716;] 一周内看完 《TypeScript晋级》并写一篇技术博客</li><li>[&#x2716;] 一周内看完 《web安全实战宝典》并写一篇技术博客</li><li>[&#x2716;] 一周内看完 《vue3+ts二次封装组件》并写一篇技术博客</li></ul></li><li>恢复驾驶资格（悲催，忙着忘换驾照超过一年）<ul><li>[&#x2716;] 计划1月15日考过科目一（下载驾考宝典，每天至少刷一遍）</li><li>[&#x2716;] 计划1月8日 去指定医院 进行C1的体检</li><li>[&#x2716;] 计划1月8日 拍一寸免冠白底照，app上预约考科目一</li><li>[&#x2716;] 通过科目一，成功换驾照</li></ul></li><li>羽毛球技术提升计划<ul><li>每周保持 2-3 次的打球频率</li><li>坚持、节制</li><li>提高反手吊球稳定性</li><li>针对性刻意练习杀球</li></ul></li></ol><h2 id="温故知新，迎接挑战"><a href="#温故知新，迎接挑战" class="headerlink" title="温故知新，迎接挑战"></a>温故知新，迎接挑战</h2><p>相信自己，回想一下毕业时找工作的情形吧。需要把知识形成体系，多借助思维脑图，把掌握的东西表达出来即可。</p><h3 id="准备面试"><a href="#准备面试" class="headerlink" title="准备面试"></a>准备面试</h3><ul><li>[&#x2716;] 刷完 《【前端面试】全家桶》 - 学习笔记提交到github（1个月）</li><li>[&#x2716;] 更新个人简历pdf，并同步到BOSS直聘、拉钩（可趁着春节前后）</li><li>[&#x2716;] 用vue3+ts重构<code>myresume</code>项目部署上线</li></ul><blockquote><p>ps <code>myresume</code>是之前自己写着玩的项目，正好趁此机会升级一波，看看能不能加点新东西，保持活力。有那么点想法了，看有否有时间去完善吧</p></blockquote><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>作为一名理科生，写作真的是过不去的坎 …… ORZ，但带有目的性 的写作会相对让码字变得容易些。设立目的尽量遵循SMART原则，给予一定的反馈和奖励，让自己能坚持下去。</p><p>每个人都身处于当下的环境中，相信自己，你能做到的，加油！！！<br>愿自己能找到一份不996，少加班有双休的工作，希望自己与家人朋友都健康平安！！！</p>]]></content>
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【性能】（七）浏览器缓存优化</title>
      <link href="/2019/02/03/%E3%80%90%E6%80%A7%E8%83%BD%E3%80%917%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/"/>
      <url>/2019/02/03/%E3%80%90%E6%80%A7%E8%83%BD%E3%80%917%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<section><br>    <h2>七、浏览器缓存优化</h2><br>    <h3>核心点</h3><br>    <ul><br>        <li>了解缓存策略相关设置</li><br>    <li>缓存优化实践</li><br>    </ul><br></section><section><br>  <h2>设置 HTTP Header</h2><br>  <ul><br>    <li>Cache-Control</li><br>    <li>Expires</li><br>    <li>Last-Modified / If-Modified-Since</li><br>    <li>Etag / If-None-Match</li><br>  </ul><br></section><section><br>  <h3>Cache-Control</h3><br>  <p>可出现在request header和response header中，其作用是 让浏览器和客户端相互知道各自的缓存策略情况</p><br>  <ul><br>    <li>max-age</li><br>    <li>private</li><br>    <li>public</li><br>    <li>no-cache</li><br>    <li>no-store</li><br>  </ul><br></section><section><br>  <h3>Cache-Control</h3><br>  <ul><br>    <li class="fragment">max-age 缓存的最大有效时间，浏览器再次请求该资源时不会向服务端发起请求 </li><br>    <li class="fragment">s-maxage 同上，但只能指定public缓存</li><br>    <li class="fragment">public</li><br>    <li class="fragment">no-cache 发请求到服务端判断浏览器缓存是否过期</li><br>    <li class="fragment">no-store 完全不使用缓存策略</li><br>  </ul><br></section><section><br>  <h3>Last-Modified / If-Modified-Since</h3><br>  <h4>基于客户端和服务端协商的缓存机制</h4><br>  <ul><br>    <li class="fragment">Last-Modified - response header</li><br>    <li class="fragment">If-Modified-Since - request header</li><br>    <li class="fragment">需要与cache-control一起使用</li><br>  </ul><br>  <h4>缺点</h4><br>  <ul><br>    <li class="fragment">某些服务端不能获取精确的修改时间</li><br>    <li class="fragment">文件修改时间改了，但文件内容没有变</li><br>  </ul><br></section><section><br>  <h3>Etag / If-None-Match</h3><br>  <ul><br>    <li class="fragment">文件内容的hash值</li><br>    <li class="fragment">Etag - response header</li><br>    <li class="fragment">If-none-match - request header</li><br>    <li class="fragment">需要与cache-control 共同使用</li><br>  </ul><br></section><section><br>  <h2>分级缓存策略<br></h2></section><section><br>  <h3>200 HTTP Code</h3><br>  <p>当浏览器本地没有缓存或者下一层失效时，可通过ctrl+f5 浏览器去服务器下载最新数据</p><br></section><section><br>  <h3>304 HTTP Code</h3><br>  <p>这一层由 last-modified / Etag 控制，当下一层失效时或用户点击refresh f5，浏览器发送请求给服务器，若服务端没变化则返回304给浏览器</p><br></section><section><br>  <h3>200 HTTP Code (from cache)</h3><br>  <p>这一层由 expires/cache-control 控制</p><br><br>  <ul><br>    <li class="fragment">expires (http 1.0) 是绝对时间</li><br>    <li class="fragment">cache-control (http 1.1) 相对时间，两者都存在，cache-control覆盖expire，只要没失效，浏览器只访问自己的缓存</li><br>  </ul><br></section>]]></content>
      
      <categories>
          
          <category> 性能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【性能】（六）浏览器存储</title>
      <link href="/2019/02/02/%E3%80%90%E6%80%A7%E8%83%BD%E3%80%916%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8/"/>
      <url>/2019/02/02/%E3%80%90%E6%80%A7%E8%83%BD%E3%80%916%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8/</url>
      <content type="html"><![CDATA[<section><br>    <h2>六、浏览器存储</h2><br>    <h3>核心点</h3><br>    <ul><br>        <li>理解localStorage、cookie、sessionStorage、indexDB的概念和使用</li><br>        <li>学习理解PWA和Service Worker的应用</li><br>    <li>多种浏览器存储方式并存</li><br>    </ul><br></section><section><br>  <h3>什么是Cookie</h3><br>  <p>Cookie 是在 HTTP 协议下，服务器或脚本可以维护客户工作站上信息的一种方式，也可叫作浏览器缓存</p><br>  <h4>Cookie 生成方式</h4><br>  <ul><br>    <li>http response header 中的 set-cookie</li><br>  </ul><br></section><section><br>  <h4>Cookie 用途</h4><br>  <ul><br>    <li class="fragment">用于浏览器端和服务器端的交互</li><br>    <li class="fragment">客户端自身数据的存储</li><br>  </ul><br>  <h4 class="fragment">过期时间 expire</h4><br>  <p class="fragment">因为HTTP请求无状态，所以需要Cookie去维持客户端状态</p><br></section><section><br>  <h3>Cookie存储限制</h3><br>  <ul><br>    <li class="fragment">浏览器存储 大小4KB左右</li><br>    <li class="fragment">需要设置过期时间 expire</li><br>    <li class="fragment">cookie属性有 httponly 是不支持js读写</li><br>    <li class="fragment">CDN的流量损耗(故CDN域名不要携带cookie)</li><br>    <li class="fragment">CDN的域名和主站的域名要分开</li><br>  </ul><br></section><section><br>  <h3>LocalStorage</h3><br>  <ul><br>    <li class="fragment">HTML5设计出来专门用于浏览器存储的</li><br>    <li class="fragment">本地存储大小为5M左右</li><br>    <li class="fragment">仅在客户端使用，不和服务端进行通信</li><br>    <li class="fragment">接口封装较好</li><br>    <li class="fragment">浏览器本地缓存方案</li><br>  </ul><br></section><section><br>  <h3>SessionStorage</h3><br>  <ul><br>    <li class="fragment">会话级别的浏览器存储</li><br>    <li class="fragment">大小为5M左右</li><br>    <li class="fragment">仅在客户端使用，不和服务端进行通信</li><br>    <li class="fragment">接口封装较好</li><br>    <li class="fragment">对于表单信息的维护</li><br>  </ul><br></section><section><br>  <h3>IndexDB</h3><br>  <p class="fragment">IndexDB是一种低级API，用于客户端存储大量数据化数据。该API使用索引来实现对该数据的高性能搜索。</p><br>  <p class="fragment">虽然Web Storage对于存储较少量数据很有用，但对于存储更大量结构化数据来说，这种方法不太有用，IndexDB提供了一个解决方案为应用创建离线版本</p><br></section><section><br>  <h3>Service Workers</h3><br>  <p class="fragment">Service Worker 是一个脚本，浏览器独立于当前网页，将其在后台运行，为实现一些不依赖页面或者用户交互的特性打开了一扇大门。</p><br>  <p class="fragment">在未来这些特性将包括推送消息，背景后台同步，geofencing(地理围栏定位)，但它将推送的第一个首要特性就是拦截和处理网络请求的能力，包括以编程方式来管理被缓存的响应。</p><br></section><section><br>  <h3>PWA (Progressive Web App)</h3><br>  <p class="fragment">是一种Web APP新模型，并不是具体指某一种前沿技术或者某一个单一的知识点。这是一系列新的Web特性，配合优秀的UI交互设计，逐步地增强Web APP的用户体验</p><br>  <ul><br>    <li class="fragment">可靠：在没有网络的环境也能提供基本的页面访问，而不会出现未连接到互联网的页面</li><br>    <li class="fragment">快速：针对网页渲染及网络数据访问有较好地优化</li><br>    <li class="fragment">融入：应用可以被增加到手机桌面，并且和普通应用一样有全屏、推送等特性</li><br>  </ul><br></section>]]></content>
      
      <categories>
          
          <category> 性能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> localstorage </tag>
            
            <tag> sessionstorage </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【性能】（五）回流与重绘</title>
      <link href="/2019/01/31/%E3%80%90%E6%80%A7%E8%83%BD%E3%80%915%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98/"/>
      <url>/2019/01/31/%E3%80%90%E6%80%A7%E8%83%BD%E3%80%915%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98/</url>
      <content type="html"><![CDATA[<section><br>    <h2>五、回流与重绘</h2><br>    <h3>核心点</h3><br>    <ul><br>        <li>理解浏览器重绘与回流的机制</li><br>        <li>对于一些经典案例进行分析</li><br>    <li>重绘与回流的案例相关解读</li><br>    </ul><br></section><section><br>  <h3>CSS性能让JavaScript变慢？</h3><br>  <p class="fragment">因为CSS放在head中，加载CSS也会阻塞浏览器资源加载</p><br>  <ul><br>    <li class="fragment">一个线程 =&gt; UI渲染</li><br>    <li class="fragment">一个线程 =&gt; JS引擎</li><br>  </ul><br>  <p class="fragment">频繁触发重绘与回流，会导致UI频繁渲染，从而阻塞JS执行，最终导致JS变慢</p><br></section><section><br>  <h3>回流 Reflow</h3><br>  <p class="fragment">当render tree中的一部分或全部因为元素的规模尺寸、布局、隐藏等改变而需要重新构建。这就称为回流，Reflow</p><br>  <p class="fragment">当页面布局和几何属性改变时就需要Reflow。Reflow涉及到页面布局、大小变化等</p><br></section><section><br>  <h3>重绘 Repaint</h3><br>  <p class="fragment">当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不影响布局的，比如backgrond-color 则就称为重绘 Repaint</p><br>  <p class="fragment">页面发生（任何）变化，都会发生重绘</p><br>  <p class="fragment"><b>回流必将引起重绘，而重绘不一定引起回流</b></p><br></section><section><br>  <h3>触发Repaint的属性 - 盒模型相关</h3><br>  <ul><br>    <li>display</li><br>    <li>padding margin</li><br>    <li>border-width border</li><br>    <li>width height min-height</li><br>  </ul><br></section><section><br>  <h3>触发Repaint的属性 - 定位、浮动</h3><br>  <ul><br>    <li>clear</li><br>    <li>float</li><br>    <li>position</li><br>    <li>top bottom left right</li><br>  </ul><br></section><section><br>  <h3>触发Repaint的属性 - 改变文字结构</h3><br>  <ul><br>    <li>overflow overflow-y</li><br>    <li>vertical-align</li><br>    <li>line-height</li><br>    <li>font-size font-family font-weight</li><br>    <li>text-align</li><br>    <li>white-space</li><br>  </ul><br></section><section><br>  <h3>只触发Reflow的属性</h3><br>  <ul><br>    <li>visibility</li><br>    <li>color box-shadow</li><br>    <li>border-style border-radius</li><br>    <li>text-decoration</li><br>    <li>background background-image background-position background-repeat background-size</li><br>    <li>outline outline-color outline-style outline-width</li><br>  </ul><br></section><section><br>  <h3>Reflow、Repaint优化</h3><br>  <ul><br>    <li class="fragment">避免使用触发回流、重绘的CSS属性</li><br>    <li class="fragment">将回流、重绘的影响范围限制在单独的图层之内</li><br>    <li class="fragment">将频繁重绘回流的DOM元素单独作为一个独立图层，那么这个DOM元素的重绘和回流影响只会在这个图层中</li><br>  </ul><br></section><section><br>  <h3>新建DOM的过程</h3><br>  <ol><br>    <li>获取DOM后分隔为多个图层</li><br>    <li>对每个图层的节点计算样式结果 Recalculate style</li><br>    <li>为每个节点生成图形和位置 Layout</li><br>    <li>将每个节点绘制填充到图层位图中</li><br>    <li>图层作为纹理上传至GPU</li><br>    <li>符合多个图层到页面上生成最终屏幕图像</li><br>  </ol><br></section><section><br>  <h3>Chrome 创建图层的条件</h3><br>  <ol><br>    <li>3D或透视变换的CSS属性 perspective transform</li><br>    <li>使用加速视频解码 video节点</li><br>    <li>拥有3D (WebGL) 上下文或加速的2D上下文的canvas节点</li><br>    <li>混合插件 如Flash</li><br>    <li>对自己的opacity 做CSS动画或使用一个动画webkit变换的元素</li><br>    <li>拥有加速CSS过滤器的元素</li><br>    <li>元素有一个包含复合层的后代节点</li><br>    <li>元素有一个 z-index 较低且包含一个复合层的兄弟元素</li><br>  </ol><br></section><section><br>  <h3>实战优化点 1</h3><br>  <ol><br>    <li>用 translate 替代 top 改变</li><br>    <li>用opacity 替代 visibility</li><br>    <li>不直接修改DOM样式，而是预先定义好class</li><br>    <li>把DOM离线后修改（先隐藏计算后再显示）</li><br>    <li>不要把DOM结点的属性值放在循环里当成循环里的变量</li><br>  </ol><br></section><section><br>  <h3>实战优化点 2</h3><br>  <ol><br>    <li>不要使用table布局</li><br>    <li>动画实现的速度的选择</li><br>    <li>对于动画新建图层</li><br>    <li>合理启用GPU硬件加速</li><br>  </ol><br></section>]]></content>
      
      <categories>
          
          <category> 性能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渲染 </tag>
            
            <tag> 回流 </tag>
            
            <tag> 重绘 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【性能】（四）懒加载与预加载</title>
      <link href="/2019/01/30/%E3%80%90%E6%80%A7%E8%83%BD%E3%80%914%E6%87%92%E5%8A%A0%E8%BD%BD%E4%B8%8E%E9%A2%84%E5%8A%A0%E8%BD%BD/"/>
      <url>/2019/01/30/%E3%80%90%E6%80%A7%E8%83%BD%E3%80%914%E6%87%92%E5%8A%A0%E8%BD%BD%E4%B8%8E%E9%A2%84%E5%8A%A0%E8%BD%BD/</url>
      <content type="html"><![CDATA[<section><br>    <h2>四、懒加载和预加载</h2><br>    <h3>核心点（这里只以图片举例）</h3><br>    <ul><br>        <li>理解懒加载和预加载的原理</li><br>        <li>懒加载与预加载案例</li><br>    <li>懒加载与预加载实战</li><br>    </ul><br></section><section><br>  <h3>什么是懒加载</h3><br>  <ul><br>    <li class="fragment">图片进入可视区之后请求图片资源</li><br>    <li class="fragment">对于电商等图片很多、页面很长的业务场景适用</li><br>    <li class="fragment">减少无效资源的加载</li><br>    <li class="fragment">并发加载的资源过多会阻塞js的加载，影响网站的正常使用</li><br>  </ul><br></section><section><br>  <h3>图片懒加载</h3><br>  <ul><br>    <li class="fragment">需要监听scroll事件，在scroll事件的回调中</li><br>    <li class="fragment">去判断设置的懒加载图片是否进入可视区域</li><br>    <li class="fragment">到可视区通过data-src，将src赋给图片从而发出请求</li><br>  </ul><br></section><section><br>  <h3>什么是预加载</h3><br>  <ul><br>    <li class="fragment">图片等静态资源在使用之前提前请求</li><br>    <li class="fragment">资源使用到时能从缓存中加载，提升用户体验</li><br>    <li class="fragment">页面展示的依赖关系维护</li><br>  </ul><br></section><section><br>  <h3>预加载的几种实践方案</h3><br>  <ul><br>    <li class="fragment">通过设置样式，默认是通过DOM加载的，但不显示</li><br>    <li class="fragment">使用Image对象，并设置src，这样脚本运行便会加载，动态添加到需要的DOM中即可</li><br>    <li class="fragment">通过XHR加载（可能会有跨域问题）</li><br>  </ul><br></section>]]></content>
      
      <categories>
          
          <category> 性能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 懒加载 </tag>
            
            <tag> 预加载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【性能】（三）JS加载与执行</title>
      <link href="/2019/01/27/%E3%80%90%E6%80%A7%E8%83%BD%E3%80%913JS%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C/"/>
      <url>/2019/01/27/%E3%80%90%E6%80%A7%E8%83%BD%E3%80%913JS%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C/</url>
      <content type="html"><![CDATA[<section><br>    <h2>三、JS脚本加载与执行</h2><br>    <h3>核心点</h3><br>    <ul><br>        <li>理解浏览器端html、css、js的加载过程</li><br>        <li>css、js加载过程中的优化点</li><br>    <li>深入理解和学习JS相关优化点</li><br>    </ul><br></section><section><br>    <h3>网站在浏览器端是如何进行渲染的？</h3><br>    <ul><br>    <li class="fragment">1. 通过HTTP请求拿回的html文件，读取html</li><br>    <li class="fragment">2. 字节流(服务器端) -&gt; 字符流(浏览器端) -&gt; 语法分析 拿到相应 token 添加到DOM树</li><br>    <li class="fragment">3. （html -&gt; DOM树）link方式 并发 同时css -&gt; CSSOM树)</li><br>    <li class="fragment">4. V8引擎解析JavaScript(阻塞)</li><br>    <li class="fragment">5. Render Tree (DOM CSSOM都准备好才做这步)</li><br>    <li class="fragment">6. 回流 reflow 重绘 repaint</li><br>  </ul><br></section><section><br>  <h3>HTML渲染过程的一些特点</h3><br>  <ul><br>    <li class="fragment">顺序执行、并发加载</li><br>    <li class="fragment">是否阻塞</li><br>    <li class="fragment">依赖关系</li><br>    <li class="fragment">引入方式</li><br>  </ul><br></section><section><br>  <h4>顺序执行、并发加载</h4><br>  <ul><br>    <li class="fragment">词法分析 - token分析从上到下，从而html是从上到下解析</li><br>    <li class="fragment">并发加载 - html中引入的外部资源是并发加载的</li><br>    <li class="fragment">并发上限 - 根据浏览器不同 一般来说HTTP1.1下是6个</li><br>  </ul><br></section><section><br>  <h4>CSS阻塞</h4><br>  <ul><br>    <li class="fragment">css加载会阻塞页面的渲染  -&gt; css文件在head标签中通过link引入</li><br>    <li class="fragment">css阻塞js的执行 -&gt;  在加载css时后续js的执行是会被阻塞的</li><br>    <li class="fragment">css不阻塞外部脚本的加载 （阻塞执行js而不阻塞加载js）</li><br>  </ul><br></section><section><br>  <h4>js阻塞</h4><br>  <ul><br>    <li class="fragment">直接引入的js阻塞页面的渲染</li><br>    <li class="fragment">js的执行不阻塞资源的加载</li><br>    <li class="fragment">js顺序执行，阻塞后续js逻辑的执行</li><br>  </ul><br></section>]]></content>
      
      <categories>
          
          <category> 性能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 渲染 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【性能】（二）图片优化相关</title>
      <link href="/2019/01/22/%E3%80%90%E6%80%A7%E8%83%BD%E3%80%912%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/01/22/%E3%80%90%E6%80%A7%E8%83%BD%E3%80%912%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<section><br>    <h2>二、图片相关知识与优化</h2><br>    <h3>核心点</h3><br>    <ul><br>        <li>超过一半的流量和时间都用来下载图片</li><br>        <li>图片优化效果明显将大大提高网站性能</li><br>    </ul><br></section><section><br>    <h3>有损压缩，一张JPG图片的解析过程</h3><br>    <p class="fragment">Raw Image Data -&gt; Color Transform -&gt; Down sampling -&gt; Forward DCT -&gt; Quantization -&gt; Encoding</p><br>    <hr><br>    <p class="fragment">源数据 -&gt; 颜色转换 -&gt; 颜色采样（区分高频低频颜色变化） -&gt; 对高频颜色进行压缩DCT -&gt; 质量控制 -&gt; 编码</p><br></section><section><br>    <h3>不同格式图片常用的业务场景</h3><br>    <ul><br>        <li class="fragment">1. jpg有损压缩，压缩率高，不支持透明。用于大部分不需要透明图片的业务场景</li><br>        <li class="fragment">2. png支持透明，浏览器兼容性好。用于大部分需要透明图片的业务场景</li><br>        <li class="fragment">3. webp压缩程度更好，在ios webview有兼容性问题。适用所有高版安卓</li><br>        <li class="fragment">4. svg矢量图，代码内嵌，相对较小，图片样式相对简单的场景</li><br>    </ul><br></section><section><br>    <h3>图片压缩</h3><br>    <ul><br>        <li class="fragment">1. CSS雪碧图 减少HTTP请求数（至少1次）整张图较大时也会存在加载慢的现象</li><br>        <li class="fragment">2. Image inline base64 （将图片的内容内嵌到html中 -&gt; 减少网站的HTTP请求数(0)）</li><br>        <li class="fragment">3. 在安卓下使用webp</li><br>        <li class="fragment">webp 优势在于更好的图像压缩压缩算法带来的更小图片体积。同时具备有损和无损压缩模式、alpha透明及动画特性，在jpg和png上转化效果都很优秀、统一和稳定</li><br>    </ul><br></section>]]></content>
      
      <categories>
          
          <category> 性能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图片 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【性能】（一）资源压缩与合并</title>
      <link href="/2019/01/20/%E3%80%90%E6%80%A7%E8%83%BD%E3%80%911%E8%B5%84%E6%BA%90%E5%8E%8B%E7%BC%A9%E4%B8%8E%E5%90%88%E5%B9%B6/"/>
      <url>/2019/01/20/%E3%80%90%E6%80%A7%E8%83%BD%E3%80%911%E8%B5%84%E6%BA%90%E5%8E%8B%E7%BC%A9%E4%B8%8E%E5%90%88%E5%B9%B6/</url>
      <content type="html"><![CDATA[<section><br>    <h2>一、资源的合并与压缩</h2><br>    <h3>核心点</h3><br>    <ul><br>        <li>减少HTTP数量请求</li><br>        <li>减少请求资源大小</li><br>    </ul><br></section><section><br>    <h3>浏览器的一个请求从发送到返回经历了什么</h3><br>    <p class="fragment">1. 浏览器输入url -&gt; 回车</p><br>    <p class="fragment">2. 解析 domain -&gt; DNS服务器 -&gt; 返回ip</p><br>    <p class="fragment">3. IP地址打在协议中 -&gt; 发送到网络 (经过局域网 -&gt; 交换机 -&gt; 路由器 -&gt; 主干网络 -&gt; 服务端)</p><br>    <p class="fragment">4. 服务端返回资源（GET请求）浏览器进行渲染</p><br>    <p class="fragment">5. render -&gt; DOM -&gt; CSSOM -&gt; 下载并加载css、js、img等资源 -&gt; reflow &amp; repaint</p><br></section><section><br>    <h3>针对以上，可作的优化工作</h3><br>    <p class="fragment">1. DNS 资源缓存 -&gt; 减少初次请求数及时间</p><br>    <p class="fragment">2. 网络请求 CDN -&gt; 解决网络高并发和缓存（不带主站cookie）</p><br>    <p class="fragment">3. 接口优化 -&gt; 浏览器的缓存策略 (相同资源、接口在浏览器读取缓存)</p><br></section><section><br>    <h3>减少HTTP请求大小和HTTP请求次数</h3><br>    <p><b>浏览器端渲染</b> vue、react 走框架代码渲染数据，而不是直出HTML（该过程对首屏有损耗，不利于性能）</p><br>    <p class="fragment">服务端渲染 SSR，整个HTML直出到浏览器端</p><br></section><section><br>    <h3>请求过程中一些潜在的性能优化点</h3><br>    <ul><br>        <li class="fragment">DNS是否可以通过缓存减少DNS查询时间？</li><br>        <li class="fragment">网络请求的过程中走最近的网络环境？</li><br>        <li class="fragment">相同的静态资源是否可以缓存？</li><br>        <li class="fragment">能否减少请求HTTP请求大小</li><br>        <li class="fragment">减少HTTP请求数</li><br>        <li class="fragment">服务端渲染</li><br>    </ul><br>    <hr><br>    <h3 class="fragment">深入理解 HTTP请求过程 是前端性能优化的核心</h3><br></section><section><br>    <h3>通过案例学习，理解以下优化点</h3><br>    <hr><br>    <ul><br>        <li>HTML文件压缩</li><br>        <li>CSS压缩</li><br>        <li>JS的压缩和混乱</li><br>        <li>文件合并</li><br>        <li>图片压缩并使用CDN</li><br>        <li>开启Gzip</li><br>    </ul><br></section><section><br>    <h3>HTML压缩</h3><br>    <p style="text-align: left">HTML代码压缩就是压缩这些在文本文件中有意义，但是在HTML中不显示的字符，包括<code>空格、制表符、换行符</code>等，还有一些其他意义的字符，如<code>HTML注释</code>也可以被压缩</p><br>    <hr><br>    <h3>如何进行HTML压缩</h3><br>    <ul><br>        <li>使用在线网站进行压缩</li><br>        <li>Node.js提供了<code>html-minifier</code>工具(Node.js的压缩方案： 1构建阶段 2服务端)</li><br>        <li>后端模版引擎渲染压缩</li><br>    </ul><br></section><section><br>    <h3>CSS压缩</h3><br>    <ul><br>        <li>无效代码删除</li><br>        <li>css语义合并</li><br>    </ul><br>    <hr><br>    <h3>如何进行css压缩</h3><br>    <ul><br>        <li>使用在线网站进行压缩</li><br>        <li>使用<code>html-minifier</code>对html中的css进行压缩</li><br>        <li>配置postcss等进行压缩</li><br>    </ul><br></section><section><br>    <h3>JS压缩与混乱</h3><br>    <ul><br>        <li>无效字符的删除</li><br>        <li>剔除注释</li><br>        <li>代码语义的缩减和优化</li><br>        <li>代码保护</li><br>    </ul><br>    <hr><br>    <h3>如何进行JS压缩</h3><br>    <ul><br>        <li>使用在线网站进行压缩</li><br>        <li>使用 uglifyjs2 对js代码进行压缩</li><br>        <li>在webpack、gulp中配置js压缩</li><br>    </ul><br></section><section><br>    <h3>文件合并</h3><br>    <p>不合并带来的弊端：</p><br>    <ul><br>        <li>文件与文件之间有插入的上行请求，增加了 N-1 个网络延迟</li><br>        <li>受丢包问题影响更严重</li><br>        <li>经过代理服务器时可能会被断开</li><br>    </ul><br>    <p>合并所带来的问题思考：1.首屏渲染问题  2.缓存失效问题</p><br></section><section><br>    <h3>如何进行文件合并</h3><br>    <ul><br>        <li>使用在线网站进行文件合并</li><br>        <li>使用Node.js实现文件合并(webpack、gulp)</li><br>    </ul><br></section>]]></content>
      
      <categories>
          
          <category> 性能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> 压缩 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【Node】学习stream模块</title>
      <link href="/2018/11/15/%E3%80%90Node%E3%80%91%E5%AD%A6%E4%B9%A0stream%E6%A8%A1%E5%9D%97/"/>
      <url>/2018/11/15/%E3%80%90Node%E3%80%91%E5%AD%A6%E4%B9%A0stream%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<blockquote><p>正好读到了相关的文章推送，正巧也把之前看到的和弄了一小半的资料整理一下。- - node的学习又再此开启</p></blockquote><h1 id="stream的基本概念和常用API概述"><a href="#stream的基本概念和常用API概述" class="headerlink" title="stream的基本概念和常用API概述"></a>stream的基本概念和常用API概述</h1><p>让数据流动起来。数据从原来的source流向dest，要像水一样，慢慢的一点一点通过一个管道流过去。stream并不是node.js独有的概念，而是一个操作系统最基本的操作方式，只不过node.js有API支持这种操作方式。linux命令的<code>|</code>就是stream，因此所有server端语言都应该实现stream的API。</p><a id="more"></a><h2 id="为何要使用stream"><a href="#为何要使用stream" class="headerlink" title="为何要使用stream"></a>为何要使用stream</h2><p>例子，在线播放视频。一点一点从服务端将视频流动到本地播放器，一边流动一边播放，直到播放完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>)</span><br><span class="line">  fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    res.end(data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">8000</span>)</span><br></pre></td></tr></table></figure><p>这段node.js代码跑起来会读取文件，语法上没问题，但如果data.txt文件非常大，在响应大量用户的并发请求时，程序可能会消耗大量的内存，这样很可能会造成用户连接缓慢的问题。而且，如果并发请求过大，服务器内存开销也很大。</p><p>要解决该问题很简单，用stream改造一下。即不是把全部文件读取了再返回，而是一边读取一边返回，一点点地把数据流动到客户端。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>)</span><br><span class="line">  <span class="keyword">var</span> stream = fs.createReadStream(fileName)</span><br><span class="line">  stream.pipe(res)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">8000</span>)</span><br></pre></td></tr></table></figure><p>小结一下，之所以用stream，是因为一次性读取、操作大文件，内存和网络是吃不消的，因此要让数据流动起来，一点一点地进行操作。这符合分而治之的思想。</p><h2 id="stream流转的过程"><a href="#stream流转的过程" class="headerlink" title="stream流转的过程"></a>stream流转的过程</h2><p>从管道换水的例子可看出，stream包括source, dest还有中间的管道，下面将通过这三方面介绍stream的过程。其中比较关键的api有：</p><ul><li>data事件，用来监听stream数据的输入</li><li>end事件，用来监听stream数据输入完成</li><li>fs.createReadStream方法，返回一个文件读取的stream对象</li><li>fs.createWriteStream方法， 返回一个文件读取的stream对象</li><li>pipe方法，用来做数据流转</li></ul><h3 id="source-——-从哪里来"><a href="#source-——-从哪里来" class="headerlink" title="source —— 从哪里来"></a>source —— 从哪里来</h3><p>stream常见的来源主要有三种：</p><ul><li>从控制台输入</li><li>http请求中的request</li><li>读取文件</li></ul><p>运行如下代码，然后从控制台输入任何内容，都会被data事件监听到，process.stdin就是一个stream对象。<code>注意data就是stream用来监听数据传入的一个自定义函数</code>，后续会大量用到该方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.stdin.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'stream by stdin'</span>, chunk.toString())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>http请求中的request输入可以参考如下代码片段。即客户端发起http请求，服务端可以通过这种方式（用到了data事件监听）。这种http请求一般是一个post请求，上传数据。注意，end用来监听stream数据传输完毕，一般和data共用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 一点一点 接受内容</span></span><br><span class="line">  data += chunk.toString()</span><br><span class="line">&#125;)</span><br><span class="line">res.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// end表示数据接受完成</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>读取文件用 fs.createReadStream(…) 可以返回一个读取文件的stream对象，该对象可以监听data和end事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> readStream = fs.createReadStream(<span class="string">'./file1.txt'</span>)</span><br><span class="line"><span class="keyword">var</span> length = <span class="number">0</span></span><br><span class="line">readStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">  length += chunk.toString().length</span><br><span class="line">&#125;)</span><br><span class="line">readStream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(length)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>以上source三种代码示例有一个共同特点，就是对stream对象可以监听data和end事件。nodejs监听自定义事件要使用.on方法，例如 process.stdin.on(‘data’, …) ，能很直观地监听到stream数据的传入和结束。</p><h3 id="dest-——-到哪里去"><a href="#dest-——-到哪里去" class="headerlink" title="dest —— 到哪里去"></a>dest —— 到哪里去</h3><p>stream常见的输出方式主要有三种：</p><ul><li>输出到控制台</li><li>http请求中的response</li><li>写入文件</li></ul><p>如果让控制台输入这个source直接通过管道连接到控制台输入，即让数据从输入直接流向输出，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.stdin.pipe(process.stdout)</span><br></pre></td></tr></table></figure><p>nodejs处理http请求时会用到req和res，其实这两者都是stream对象。其中，req是source，res是dest。所以stream方式读取文件然后直接返回http请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stream = fs.createReadStream(fileName)</span><br><span class="line">stream.pipe(res)</span><br></pre></td></tr></table></figure><p>读取文件可以用stream，写入文件也可以用stream，其中 fs.createWriteStream(…) 会返回一个写入文件的stream对象，即dest。这段代码，就是将一个文件中的内容，一点一点地流动到另外的文件中，完成复制功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> readStream = fs.createReadStream(<span class="string">'./file1.txt'</span>)</span><br><span class="line"><span class="keyword">var</span> writeStrea = fs.createWriteStream(<span class="string">'./file2.txt'</span>)</span><br><span class="line">readStream.pipe(writeStream)</span><br></pre></td></tr></table></figure><h3 id="stream常见使用场景"><a href="#stream常见使用场景" class="headerlink" title="stream常见使用场景"></a>stream常见使用场景</h3><p>stream常见的使用场景是http请求和文件操作。 总结来看，http请求和文件操作都属于IO，即stream主要的应用场景是处理IO，这又回到了stream的本质——由于一次性IO操作过大，硬件开销太多，影响软件运行效率，因此将IO分批分段操作，让数据一点一点地流动起来，直到操作完成。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本章主要介绍了stream的基本概念和常用API</p><ul><li>stream的基本概念，即 source -&gt; 管道 -&gt; dest</li><li>为何要用stream —— 一次性操作IO，内存和网络开销过大</li><li>source pipe dest各部分常用API</li><li>stream的常见应用场景——IO操作</li></ul><hr><h2 id="node-js实现http请求"><a href="#node-js实现http请求" class="headerlink" title="node.js实现http请求"></a>node.js实现http请求</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>)</span><br><span class="line">  fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    res.end(data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">8000</span>)</span><br></pre></td></tr></table></figure><h2 id="get请求和response"><a href="#get请求和response" class="headerlink" title="get请求和response"></a>get请求和response</h2><p>通过req.method可获取请求方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> method = req.method</span><br><span class="line">  <span class="keyword">if</span> (method === <span class="string">'GET'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>)</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      res.end(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">8000</span>)</span><br></pre></td></tr></table></figure><h3 id="response和stream"><a href="#response和stream" class="headerlink" title="response和stream"></a>response和stream</h3><p>response常用的API有send、end等，如上面代码中的<code>res.end(data)</code>，但是response也是一个stream对象。大家再次回顾一开始的管道换水的图，以及source.pipe(dest)模型，response就是一个dest</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> method = req.method</span><br><span class="line">  <span class="keyword">if</span> (method === <span class="string">'GET'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>)</span><br><span class="line">    <span class="keyword">var</span> stream = fs.createReadStream(fileName)</span><br><span class="line">    stream.pipe(res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8000</span>)</span><br></pre></td></tr></table></figure><h3 id="使用stream对性能的提升"><a href="#使用stream对性能的提升" class="headerlink" title="使用stream对性能的提升"></a>使用stream对性能的提升</h3><p>略</p><p>###　实际应用</p><p>对response使用stream特性能提高性能。因此，在nodejs中如果要返回的数据是经过IO操作得来的，例如上面例子中读取文件内容，可以直接使用stream.pipe(res)这种方式，而不再使用res.end(data)了。</p><p>这种应用的实例很多，主要有两种场景：</p><ul><li>使用node.js作为服务代理，即客户端通过node.js服务作为跳板去请求其他服务，返回请求的内容</li><li>使用node.js作为静态文件服务器，直接返回静态文件</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本节主要讲解了node.js如何处理http的get请求，以及如何对response使用stream特性，并做了压力测试证明可以提高性能。</p><h2 id="在http-post请求中使用stream"><a href="#在http-post请求中使用stream" class="headerlink" title="在http post请求中使用stream"></a>在http post请求中使用stream</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> method = req.method</span><br><span class="line">  <span class="keyword">if</span> (method === <span class="string">'POST'</span>) &#123;</span><br><span class="line">    req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 接受到部分数据</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'chunk'</span>, chunk.toString().length)</span><br><span class="line">    &#125;)</span><br><span class="line">    req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">      res.end(<span class="string">'ok'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">8000</span>)</span><br></pre></td></tr></table></figure><p>post请求发送数据量若很大， res.on(‘data’, …) 要分多次才能把数据接受完毕</p><p>小结一下，request和response一样，本身也是一个stream对象，可以用stream的特性，那肯定也能提高性能。两者的区别在于，request是source类型，是stream的源头，而response是dest类型，是stream的目的地。</p><p>再举个例子，如果要把request请求的数据直接response，那么最快的方式就是res.pipe(res)</p><h3 id="使用stream对性能的提升-1"><a href="#使用stream对性能的提升-1" class="headerlink" title="使用stream对性能的提升"></a>使用stream对性能的提升</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> method = req.method</span><br><span class="line">  <span class="keyword">if</span> (method === <span class="string">'POST'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> dataStr = <span class="string">''</span></span><br><span class="line">    req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> chunkStr = chunk.toString()</span><br><span class="line">      dataStr += chunkStr</span><br><span class="line">    &#125;)</span><br><span class="line">    res.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>)</span><br><span class="line">      fs.writeFile(fileName, dataStr)</span><br><span class="line">      res.end(<span class="string">'ok'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8000</span>)</span><br></pre></td></tr></table></figure><p>用stream改良后如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> method = req.method</span><br><span class="line">  <span class="keyword">if</span> (method === <span class="string">'POST'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> dataStr = <span class="string">''</span></span><br><span class="line">    req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> chunkStr = chunk.toString()</span><br><span class="line">      dataStr += chunkStr</span><br><span class="line">    &#125;)</span><br><span class="line">    res.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>)</span><br><span class="line">      <span class="keyword">var</span> writeStream = fs.createWriteStream(fileName)</span><br><span class="line">      res.pipe(writeStream)</span><br><span class="line">      req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        res.end(<span class="string">'ok'</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>和get请求使用stream场景类似，post请求使用stream的场景，主要是用于将接受的数据直接进行IO操作，例如：</p><ul><li>将接收的数据直接存储为文件</li><li>将接收的数据直接post给其他的web server</li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>介绍了stream在http请求中的应用和性能提升，IO操作不仅仅包括网络IO，还包括文件IO，下一节讲解stream在文件操作中的使用，以及性能提升。</p><hr><h2 id="node-js读写文件"><a href="#node-js读写文件" class="headerlink" title="node.js读写文件"></a>node.js读写文件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>)</span><br><span class="line"><span class="comment">// 读文件</span></span><br><span class="line">fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span></span><br><span class="line">  <span class="built_in">console</span>.log(data.toString())</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 写文件</span></span><br><span class="line">fs.writeFile(fileName, <span class="string">'xxx'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'写入成功'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>根据以上读写操作，可以做一个简单的文件拷贝程序，将data.txt中的内容拷贝到data-bak.txt 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读文件</span></span><br><span class="line"><span class="keyword">var</span> fileName1 = path.resolve(__dirname, <span class="string">'data.txt'</span>)</span><br><span class="line">fs.readFile(fileName1, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">var</span> dataStr = data.toString()</span><br><span class="line">  <span class="comment">// 写入文件</span></span><br><span class="line">  <span class="keyword">var</span> fileName2 = path.resolve(__dirname, <span class="string">'data-bak.txt'</span>)</span><br><span class="line">  fs.writeFile(fileName2, dataStr, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'拷贝文件成功'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="使用stream读写文件"><a href="#使用stream读写文件" class="headerlink" title="使用stream读写文件"></a>使用stream读写文件</h3><ul><li>使用 fs.cretaeReadStream(filename) 来创建读取文件的stream对象</li><li>使用 fs.createWriteStream(filename) 来创建写入文件的stream对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> filename1 = path.resolve(__dirname, <span class="string">'data.txt'</span>)</span><br><span class="line"><span class="keyword">var</span> filename2 = path.resolve(__dirname, <span class="string">'data-bak.txt'</span>)</span><br><span class="line"><span class="keyword">var</span> readStream = fs.createReadStream(filename1)</span><br><span class="line"><span class="keyword">var</span> writeStream = fs.createWriteStream(filename2)</span><br><span class="line">readStream.pipe(writeStream)</span><br><span class="line">readStream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'拷贝完成'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="使用stream带来的性能提升"><a href="#使用stream带来的性能提升" class="headerlink" title="使用stream带来的性能提升"></a>使用stream带来的性能提升</h3><p>略</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>所有执行文件操作的场景，都应该尝试使用stream，例如文件的读写、拷贝、解压缩、格式转换等。除非是体积小且读写次数少，性能上可忽略。</p><hr><p>原生的stream对“行”无能为力，它只是把文件当作一个数据流，简单粗暴地流动。很多文件格式都是分行的，例如csv文件、日志文件等</p><p>node.js提供了按行读取API——readline，它本质上也是stream，只不过是以“行”作为数据流动的单位</p><h2 id="readline的使用"><a href="#readline的使用" class="headerlink" title="readline的使用"></a>readline的使用</h2><p>相比于stream的data和end自定义事件，readline需要监听line和close两个自定义事件。readline的基本使用示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> path = requrie(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> readline = <span class="built_in">require</span>(<span class="string">'readline'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'readline-data.txt'</span>)</span><br><span class="line"><span class="comment">// 创建读取文件的stream对象</span></span><br><span class="line"><span class="keyword">var</span> readStream = fs.createReadStream(fileName)</span><br><span class="line"><span class="comment">// 创建readline对象</span></span><br><span class="line"><span class="keyword">var</span> rl = readline.createInterface(&#123;</span><br><span class="line">  <span class="comment">// 输入，依赖于stream对象</span></span><br><span class="line">  input: readStream</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 监听逐行读取的内容</span></span><br><span class="line">rl.on(<span class="string">'line'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">lineData</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'lineData: '</span>, lineData)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 监听读取完成</span></span><br><span class="line">rl.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'readline end'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上代码，需要先根据文件名，创建读取文件的stream对象，然后传入并生成一个readline对象，然后通过line事件监听逐行读取，通过close事件监听读取完成。</p><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>对于处理按行为单位的文件，如日志文件，使用readline是最佳选择。下面是一个实际例子，用来记录访问数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line"><span class="comment">// 监听逐行读取的内容</span></span><br><span class="line">rl.on(<span class="string">'line'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">lineData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lineData.indexOf(<span class="string">'2018-10-30 14:00'</span>) &gt;= <span class="number">0</span> &amp;&amp; lineData.indexOf(<span class="string">'user.html'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    num++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 监听读取完成</span></span><br><span class="line">rl.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'num: '</span>, num)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>最后，将这个示例所用的代码贴到下面，供学习参考：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> memeye = <span class="built_in">require</span>(<span class="string">'memeye'</span>)</span><br><span class="line"><span class="keyword">var</span> readline = <span class="built_in">require</span>(<span class="string">'readline'</span>)</span><br><span class="line"></span><br><span class="line">memeye()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doReadLine</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'readline-data.txt'</span>)</span><br><span class="line">  <span class="keyword">var</span> readStream = fs.createReadStream(fileName)</span><br><span class="line">  <span class="keyword">var</span> rl = readline.createInterface(&#123;</span><br><span class="line">    input: readStream</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line">  rl.on(<span class="string">'line'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">lineData</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lineData.indexOf(<span class="string">'2018-10-30 14:00'</span>) &gt;= <span class="number">0</span> &amp;&amp; lineData.indexOf(<span class="string">'user.html'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      num++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 监听读取完成</span></span><br><span class="line">  rl.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'num: '</span>, num)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(doReadLine, <span class="number">5000</span>)</span><br></pre></td></tr></table></figure><hr><p>stream就是数据一点一点地流动起来，那么每次流动的数据是什么呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readStream = fs.createReadStream(<span class="string">'./file.txt'</span>)</span><br><span class="line">readStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>冯诺依曼结构，其核心内容之一就是：计算机使用二进制形式存储计算。</p><p>计算机内存由若干个存储单元组成，每个存储单元只能存储0或1（因为内存是硬件，计算机硬件本质上就是一个一个的电子元件，只能识别充电和放电的状态，充电代表1，放电代表0），即二进制单元（bit）。但是这一个单元所能存储的信息太少，因此约定将8个二进制单元为一个基本存储单元，叫做字节（byte）。一个字节所能存储的最大整数就是(2^8 = 256)，也正好是16^2，因此也常常使用两位的16进制数代表一个字节。例如css常见的颜色值就是6位16进制数字，它占用3个字节的空间。</p><p>二进制是计算机最底层的数据格式，也是一种通用格式。计算机中的任何数据格式，字符串、数字、视频、音频、程序、网络包等，在最底层都是用二进制来进行存储的。这些高级格式和二进制之间，都可通过固定的编码格式进行相互转换。例如，C语言中int32类型的十进制数，就占用32bit即4byte。总之，计算机底层存储的数据都是二进制格式，各种高级类型都有对应的编码规则，和二进制进行相互转化。</p><h2 id="nodejs表示二进制"><a href="#nodejs表示二进制" class="headerlink" title="nodejs表示二进制"></a>nodejs表示二进制</h2><p>Buffer就是nodejs中二进制的表述形式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'学习nodejs stream'</span></span><br><span class="line"><span class="keyword">var</span> buf = Buffer.from(str, <span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure><p>以上代码，先通过 Buffer.from 将一段字符串转化为二进制形式，其中utf-8是一个编码规则。二进制打印出来之后是一个类数组的对象，每个元素都是两位的16进制数字，即代表一个byte，打印出来的buf一共有20byte。即根据utf-8的编码规则，这段字符串需要20byte进行存储，最后再通过utf-8规则将二进制转换为字符串并打印出来</p><h3 id="流动的数据是二进制格式"><a href="#流动的数据是二进制格式" class="headerlink" title="流动的数据是二进制格式"></a>流动的数据是二进制格式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readStrem = fs.createReadStream(<span class="string">'./file.txt'</span>)</span><br><span class="line">readStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(chunk <span class="keyword">instanceof</span> Buffer)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'chunk: '</span>, chunk)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看到stream中流动的数据就是Buffer类型。因此，在使用stream chunk时，需要将这些二进制数据转换为相应的格式。例如之前讲解post请求是，从request中接收数据就是这样。再回归一下之前的代码，就能明白了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataStr = <span class="string">''</span></span><br><span class="line">req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将二进制数据先转化为字符串</span></span><br><span class="line">  <span class="keyword">var</span> chunkStr = chunk.toString()</span><br><span class="line">  dataStr += chunkStr</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>stream中为何要“流动”二进制格式的数据呢？</p><p>为了优化IO操作。无论是文件IO还是网络IO，其中包含的数据格式是未知的，如字符串、音频、视频、网络包等。即便这些字符串，其编码规则也是未知的，如ASC编码、utf-8编码。再这么多未可知的情况下，只能是以不变应万变，直接用最通过的二进制格式，谁都能认识，且二进制格式进行流动和传输，效率是最高的。</p><h3 id="Buffer带来的性能提升"><a href="#Buffer带来的性能提升" class="headerlink" title="Buffer带来的性能提升"></a>Buffer带来的性能提升</h3><p>略</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li>二进制和字节的基本认识</li><li>node.js中Buffer表示二进制</li><li>stream中的chunk是二进制格式，以及和字符串格式的转换</li><li>二进制格式在http请求中的性能提升</li></ul><hr><h2 id="stream常用类型总结"><a href="#stream常用类型总结" class="headerlink" title="stream常用类型总结"></a>stream常用类型总结</h2><p>再次回顾这张图 source通过一个管道流向了dest，如下图：</p><p>这里的source可能是http请求中的request，也可能是读取文件的stream对象，也可能是process.stdin；这里的dest可能是请求中的response，也可能是写入文件的stream对象，也可能是process.stdout；这里的管道就是pipe函数。</p><p>先不管pipe函数。source和dest完全就是两个不同的类型，一个是读取数据的，叫做readable stream，一个是写入数据的，叫作Writeable stream。除了这两种类型之外，还有一种类型叫作duplex stream（双工流），即有读取又有写入能力。示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>)</span><br><span class="line"><span class="keyword">var</span> readStream = fs.createReadStream(<span class="string">'./file.txt'</span>)</span><br><span class="line"><span class="keyword">var</span> writeStream = fs.createWriteStream(<span class="string">'./file.txt'</span>)</span><br><span class="line">readStream.pipe(zlib.createGzip()).pipe(writeStream)</span><br></pre></td></tr></table></figure><h3 id="readable-stream"><a href="#readable-stream" class="headerlink" title="readable stream"></a>readable stream</h3><p>http请求中的request和读取文件的stream对象都是readable stream。它有两种常用操作方式，第一种是直接将数据pipe到一个Writeable stream</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>)</span><br><span class="line"><span class="keyword">var</span> stream = fs.createReadStream(fileName)</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">stream.pipe(res)</span><br></pre></td></tr></table></figure><p>第二种是通过监听on end自定义事件来获取数据再手动处理，例如之前讲解post请求时的代码示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataStr = <span class="string">''</span></span><br><span class="line">req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 接收到数据先存储起来</span></span><br><span class="line">  <span class="keyword">var</span> chunkStr = chunk.toString()</span><br><span class="line">  dataStr += chunkStr</span><br><span class="line">&#125;)</span><br><span class="line">req.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 接收完数据将数据写入文件</span></span><br><span class="line">  <span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'post.txt'</span>)</span><br><span class="line">  fs.writeFile(fileName, dataStr)</span><br><span class="line">  res.end(<span class="string">'OK'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上说的两个例子，都是已经分装好的readable stream，那么它本来的面目是怎样的？如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Readable = <span class="built_in">require</span>(<span class="string">'stream'</span>).Readable</span><br><span class="line"><span class="comment">// 构造一个readable stream并往里添数据</span></span><br><span class="line"><span class="keyword">var</span> rs = <span class="keyword">new</span> Readable</span><br><span class="line">rs.push(<span class="string">'learn'</span>)</span><br><span class="line">rs.push(<span class="string">'nodejs'</span>)</span><br><span class="line">rs.push(<span class="string">'stream'</span>)</span><br><span class="line">rs.push(<span class="literal">null</span>)</span><br><span class="line"><span class="comment">// pipe到一个Writeable stream</span></span><br><span class="line">rs.pipe(process.stdout)</span><br></pre></td></tr></table></figure><p>从上代码可看出，nodejs提供了readable stream的构造函数，可以new出一个新的readable stream对象。然后通过push函数往里灌入完成，即可输入了。最后pipe到了一个Writeable stream</p><h3 id="Writeable-stream"><a href="#Writeable-stream" class="headerlink" title="Writeable stream"></a>Writeable stream</h3><p>根据之前的分析，http请求中的response和写入文件的stream对象都是Writeable stream，它可以作为参数传入pipe函数，以读取上游的数据。例如之前讲解文件操作时拷贝文件的代码示例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'post.txt'</span>)</span><br><span class="line"><span class="keyword">var</span> writeStream = fs.createWriteStream(fileName)</span><br><span class="line">res.pipe(writeStream)</span><br></pre></td></tr></table></figure><p>以上代码中 writeStream 是已经封装好了的 Writeable stream ，下面再来看看它的真实面目。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Writeable = <span class="built_in">require</span>(<span class="string">'stream'</span>).Writeable</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ws = Writeable()</span><br><span class="line">ws._write = <span class="function"><span class="keyword">function</span>(<span class="params">chunk, enc, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 输出流动的数据</span></span><br><span class="line">  <span class="built_in">console</span>.log(chunk.toString())</span><br><span class="line">  <span class="comment">// 继续监听下一次输出</span></span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 作为参数传递到pipe函数中</span></span><br><span class="line">process.stdin.pipe(ws)</span><br></pre></td></tr></table></figure><p>根据以上代码得知，nodejs提供了Writeable构造函数可以new一个新的Writeable stream。通过实现它的_write方法即可监听到每次流动的数据，运行next()可继续监听.</p><h3 id="再谈pipe"><a href="#再谈pipe" class="headerlink" title="再谈pipe"></a>再谈pipe</h3><p>之前一直是用<code>source.pipe(dest)</code>这种模式来用pipe的，其实pipe可以链式调用。例如上文演示的duplex stream示例代码<code>readStream.pipe(zlib.createGzip()).pipe(writeStream)</code>，还有之前讲解文件操作最后列举的gulp配置文件~</p><p>之前讲解<code>source.pipe(dest)</code>模式是为了方便理解和使用，现在我们更新一个更严谨的pipe用法：</p><ul><li>调用pipe的对象必须是readable stream或者duplex stream，即具有读取数据的功能，如req.pipe(…)</li><li>传入pipe的参数必须是writeable stream或者duplex stream, 即具有写入数据的功能，如req.pipe(res)</li><li>pipe支持链式调用</li></ul><p>更新了pipe的最新规则，再来看就不会有困惑了。</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>这里主要讲解了stream的常用类型和pipe函数的规则：</p><ul><li>stream的常见类型：readable stream和writeable stream</li><li>readable stream的本质和用法</li><li>writeable stream的本质和用法</li><li>pipe的新规则</li></ul>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> stream </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【学习】cookie、session和token</title>
      <link href="/2018/07/28/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91cookie%E3%80%81session%E5%92%8Ctoken/"/>
      <url>/2018/07/28/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91cookie%E3%80%81session%E5%92%8Ctoken/</url>
      <content type="html"><![CDATA[<h2 id="Cookie定义"><a href="#Cookie定义" class="headerlink" title="Cookie定义"></a>Cookie定义</h2><p>Cookie 是一小段文本信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递。Cookie 包含每次用户访问站点时 Web 应用程序都可以读取的信息。</p><a id="more"></a><p>例如，如果在用户请求站点中的页面时应用程序发送给该用户的不仅仅是一个页面，还有一个包含日期和时间的 Cookie，用户的浏览器在获得页面的同时还获得了该 Cookie，并将它存储在用户硬盘上的某个文件夹中。</p><p>以后，如果该用户再次请求您站点中的页面，当该用户输入 URL 时，浏览器便会在本地硬盘上查找与该 URL 关联的 Cookie。如果该 Cookie 存在，浏览器便将该 Cookie 与页请求一起发送到您的站点。然后，应用程序便可以确定该用户上次访问站点的日期和时间。您可以使用这些信息向用户显示一条消息，也可以检查到期日期。</p><p>Cookie 与网站关联，而不是与特定的页面关联。因此，无论用户请求站点中的哪一个页面，浏览器和服务器都将交换 Cookie 信息。用户访问不同站点时，各个站点都可能会向用户的浏览器发送一个 Cookie；浏览器会分别存储所有 Cookie。</p><p>Cookie 帮助网站存储有关访问者的信息。一般来说，Cookie 是一种保持 Web 应用程序连续性（即执行状态管理）的方法。除短暂的实际交换信息的时间外，浏览器和 Web 服务器间都是断开连接的。对于用户向 Web 服务器发出的每个请求，Web 服务器都会单独处理。但是在很多情况下，Web 服务器在用户请求页时识别出用户会十分有用。例如，购物站点上的 Web 服务器跟踪每位购物者，这样站点就可以管理购物车和其他的用户特定信息。因此，Cookie 可以作为一种名片，提供相关的标识信息帮助应用程序确定如何继续执行。</p><p>使用 Cookie 能够达到多种目的，所有这些目的都是为了帮助网站记住用户。例如，一个实施民意测验的站点可以简单地将 Cookie 作为一个 Boolean 值，用它来指示用户的浏览器是否已参与了投票，这样用户便无法进行第二次投票。要求用户登录的站点则可以通过 Cookie 来记录用户已经登录，这样用户就不必每次都输入凭据。</p><p>分类：一般分为两种形式的Cookie：1.会话型的，2.持久性的。会话型的是浏览器的处理过程中保留的，是暂时性的，当浏览器关闭时则消除了！而持久性的是保存在客户端的硬盘上的，就像论坛的Cookie一样。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：极高的扩展性和可用性</p><p>通过良好的编程，控制保存在cookie中的session对象的大小。<br>通过加密和安全传输技术（SSL），减少cookie被破解的可能性。<br>只在cookie中存放不敏感数据，即使被盗也不会有重大损失。<br>控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。</p><p>缺点：</p><p>Cookie数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。<br>安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。<br>有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。</p><h2 id="Session定义"><a href="#Session定义" class="headerlink" title="Session定义"></a>Session定义</h2><p>在Web开发中，服务器可以为每个用户浏览器创建一个会话对象(session对象)。注意：一个浏览器独占一个session对象（默认）。因此，在需要保存用户数据时，服务器可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问时，可以从用户的session中取出该用户的数据。</p><p>注：新开浏览器窗口会生成新的Session，子标签页除外。子标签页公用父窗口的Session</p><h3 id="Session用途"><a href="#Session用途" class="headerlink" title="Session用途"></a>Session用途</h3><ol><li>记录用户登录与行为数据. 考虑到这些数据用户修改随意性大，没必要直接存到数据库</li><li>用户执行刷新时，可直接根据session打开上次访问网页的状态，优化体验</li><li>通过session把用户行为联系起来，构建出完整模型，进行数据挖掘</li></ol><blockquote><p>session其实就是会话变量的保存地，只要是能使用变量的地方，都能使用session变量。一般地session就是像一个临时容器，来存放临时东西。</p></blockquote><h3 id="Session和Cookie的区别和联系"><a href="#Session和Cookie的区别和联系" class="headerlink" title="Session和Cookie的区别和联系"></a>Session和Cookie的区别和联系</h3><blockquote><p>具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务端保存状态的方案。两者存储的都是用户相关行为信息</p></blockquote><ul><li><p>cookie是把用户的数据写在本地浏览器上，其他网站也可以扫描使用该cookie，容易泄漏自己网站的用户隐私，且一般浏览器对单个网站站点有cookie数量与大小限制</p></li><li><p>session是把用户数据写在用户独占的session上，存储在服务端，一般只将session的id存储在cookie中。但将数据存储在服务器，成本相对高些</p></li><li><p>session是由服务端创建，开发人员可以在服务器上通过request对象拿到</p></li><li><p>一般情况，登录信息等重要信息存储在session中，其他信息存储在cookie中</p></li></ul><p>由于HTTP协议是无状态协议，所以服务端需要记录用户状态时，就需要用某种机制（Session）来识别具体用户。服务端为特定用户创建特定 Session 用于标识这个用户。Session是保存在服务端的，有一个唯一标识。</p><p>在服务端保存Session方法很多，内存、数据库、文件都有，集群时也要考虑Session的转移，使用一些缓存服务如Memcached之类来存放。</p><p>那么服务端如何识别特定用户？ Cookie，每次HTTP请求时，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用Cookie来实现Session跟踪。第一次创建Session时，服务端会在HTTP协议中告诉客户端，需要在Cookie里记录一个Session ID，以后每次请求都把这个会话ID发送到服务器，这样服务端就能识别客户端了。</p><ul><li>Session是在服务端保存的一个数据结构，用来跟踪用户的状态，该数据可以保存在集群、数据库、文件中</li><li>Cookie是在客户端保存用户信息的一种机制，用来记录用户信息，也是Session的一种实现方式</li></ul><h3 id="Session的实现原理"><a href="#Session的实现原理" class="headerlink" title="Session的实现原理"></a>Session的实现原理</h3><p>服务器会为每一个访问服务器的用户创建一个session对象，且把session对象的id保存在本地cookie上，只要用户再次访问服务器时，带着session id，服务器就会匹配用户在服务器上的session。根据session中的数据，还原用户上次的浏览状态或提供其他人性化服务。</p><h3 id="浏览器禁用Cookie后如何实现Session"><a href="#浏览器禁用Cookie后如何实现Session" class="headerlink" title="浏览器禁用Cookie后如何实现Session"></a>浏览器禁用Cookie后如何实现Session</h3><p><strong>URL地址重写</strong></p><p>原理是将用户session的id信息重写到url地址中。服务器能够解析重写后的url以获取sessionId。这样即时客户端不支持Cookie，也可以使用Session来记录用户状态。</p><h3 id="Session和Cookie有效时长"><a href="#Session和Cookie有效时长" class="headerlink" title="Session和Cookie有效时长"></a>Session和Cookie有效时长</h3><ul><li>session</li></ul><p>服务器会把长时间没有活动的session从服务器内存中清除，此时session便失效。具体根据服务端设置</p><ul><li>cookie</li></ul><p>主要内容包括：Key、value、过期时间、路径和域。路径与域一起构成cookie的作用范围，通过过期时间expires设置cookie的有效时长</p><blockquote><p>若不设置过期时间，表示这个cookie的生命周期为浏览器的会话期间，关闭访问服务器的浏览器窗口，cookie就消失，一般称为会话cookie。若保存在内存中设置了过期时间，则cookie会存储在硬盘上直到超过有效时间</p></blockquote><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>前端 http 里所说的 Token  是指 <code>访问资源的凭据</code>。</p><p>例如当调用 google api 需要带上有效的token来表明请求的合法性。 这个token是google给的，代表了有权访问api背后的资源。</p><ul><li>access token 调用api时携带的token</li></ul><ol><li>首先需要向google api注册应用程序，注册完毕后拿到认证信息（credentials）包括id和secret</li><li>接下来向google请求access token。如果想访问用户资源，这里会提醒用户授权</li><li>授权完毕，google会返回access token，或者授权代码（authorization code）, 再通过代码取得access token</li><li>token获取到后，就能带上token访问api了</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/7/3/1646088e5837a9a2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="access token流程"></p><p>在第3步通过code兑换access token的过程中，google不仅会返回access token，还会返回额外信息，这其中和之后更新相关的就是refresh token</p><p>一旦access token过期，就可以通过refresh token再次请求access token。当然这要根据请求方式和访问的资源类型而定，这又会引起两个问题：</p><ol><li>如果refresh token也过期了怎么办？需要用户重新登录授权</li><li>为什么要区分refresh token和access token？如果合并成一个token然后把过期时间调整更长，且每次失效后用户重新登录授权就好？</li></ol><h2 id="OAuth"><a href="#OAuth" class="headerlink" title="OAuth"></a>OAuth</h2><p>从获取token到使用token访问接口。这其实是标准的OAuth2.0机制下访问api的流程。</p><h3 id="SSO-Single-Sign-On"><a href="#SSO-Single-Sign-On" class="headerlink" title="SSO Single Sign-On"></a>SSO Single Sign-On</h3><p>单点登录（公司内部，一个用户登录，可访问所有系统）</p><p>SSO是一类解决方案的统称，而在具体实施，我们有两种策略可供选择：</p><ol><li>SAML 2.0</li><li>OAuth 2.0</li></ol><p><strong>Authentication VS Authorisation</strong></p><ul><li>Authentication 身份鉴别 认证</li><li>Authorisation 授权</li></ul><p>认证的作用在于认可你有权限访问系统，用于鉴别访问者是否是合法用户；而授权用于决定你有访问哪些资源的权限。作为系统设计者来说，这两者的差别是不同的工作职责。</p><p>Authorization Server/Identity Provider(IdP) VS Service Provider(SP)/Resource Server<br>把负责认证的服务称为 Authorization Server 或者 Identity Provider，以下简称 IdP；而负责提供资源（API调用）的服务称为  Resource Server 或者 Service Provider，以下简称 SP</p><h3 id="SMAL-2-0"><a href="#SMAL-2-0" class="headerlink" title="SMAL 2.0"></a>SMAL 2.0</h3><p><img src="https://user-gold-cdn.xitu.io/2018/7/3/16460893ef7a34a4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="SMAL2.0流程图"></p><ul><li>还未登录的用户打开浏览器访问网站（SP）网站提供服务但是不负责用户认证</li><li>SP向IdP发送一个SAML认证请求，同时SP向用户浏览器重定向到IdP</li><li>IdP在验证完来自SAML的请求无误后，在浏览器中呈现登录表单让用户进行填写用户名和密码进行登录</li><li>一旦用户登录成功，IdP会生成一个包含用户信息（用户名和密码）的SAML token（SAML token 又称为 SAML Assertion，本质上是 XML 节点）IdP向SP返回token，并且将用户重定向到SP（token的返回是在重定向步骤中实现的）</li><li>SP对拿到的token进行验证，并且解析用户信息。此时就能够根据这些信息允许用户访问我们网站的内容了</li></ul><p>当用户在IdP登录成功后，IdP需要将用户再次重定向至SP站点，这一步有两个方法：</p><ul><li>HTTP重定向（不推荐，因无法携带更长的信息）</li><li>HTTP POST请求，当用户登录后渲染表单，点击向SP提交POST</li></ul><p>如果是应用是基于web，无问题。但若是Android和IOS问题就来了：</p><ul><li>用户在iphone上打开应用，需要通过IdP认证</li><li>应用跳转safari登录认证完毕后，需要通过http post形式将token返回至手机应用</li></ul><p>虽然post的url可以拉起应用，但无法解析post内容，也就无法获取SAML token</p><hr><h3 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h3><p><img src="https://user-gold-cdn.xitu.io/2018/7/3/164608b5c33898d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="OAutho2.0流程图"></p><ul><li>用户通过客户端（也可以是浏览器或手机应用）想要访问SP上的资源，但是SP告诉用户需要认证，将用户重定向至IdP</li><li>IdP向用户询问SP是否可以访问用户信息，若用户同意，IdP向客户端返回access code</li><li>客户端拿code向IdP换access token，并拿着access token向SP请求资源</li><li>SP接受请求后拿着附带token向IdP验证用户身份</li></ul><p>OAuth本意是一个应用允许另一个应用在用户授权的情况下访问自己的数据，OAuth设计本意更倾向于授权而非认证（当然授权用户信息就间接实现了认证）</p><h3 id="OpenID"><a href="#OpenID" class="headerlink" title="OpenID"></a>OpenID</h3><ul><li>OpenID只用于身份验证，允许你以同一个账户在多个网站登录。它仅仅是为你的合法身份背书，当你以xx帐号登录某个站点后，该站点无权访问你在xxb上的数据</li><li>OAuth用户授权，允许被授权方访问授权方的用户数据</li></ul><h3 id="Refresh-Token"><a href="#Refresh-Token" class="headerlink" title="Refresh Token"></a>Refresh Token</h3><p>为什么需要？</p><p>这样处理是为了职责分离：refresh token负责身份验证， access token负责资源请求。虽然两者都由IdP发出，但access token还要和SP进行数据交换，如果公用会有身份泄漏可能。</p><hr><p>token其实是为OAuth服务的，它是访问数据的一把钥匙。</p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JWT 也是token，它是访问资源的凭证。甚至你可以不需要向 Google 索要 access token，而是携带 JWT 作为 HTTP header 里的 bearer token 直接访问 API 也是可以的。</p><p>顾名思义，它是json结构的token，由三部分组成：</p><ul><li>header</li></ul><p>用于描述元信息，例如产生signature的算法</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span>,</span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>payload</li></ul><p>用于携带你希望向服务端传递的信息。即可以往里面添加字段，也可以塞入自定义字段</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"userId"</span>: <span class="string">"b08f86af-35da-48f2-8fab-cef3904660bd"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>signature</li></ul><p>创建签名需要分以下几个步骤</p><ol><li>需要从接口服务端拿到密钥 假设为 <code>secret</code></li><li>将header进行base64编码，假设为 <code>headerStr</code></li><li>将payload进行base64编码，假设为 <code>payloadStr</code></li><li>将headerStr和payloadStr用 <code>.</code> 字符串拼接，成为字符 <code>data</code></li><li>以data和secret作为参数，使用哈希算法计算出签名</li></ol><p>下面是伪代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// signature algorithm</span></span><br><span class="line">data = base64URLEncoded(header) + <span class="string">'.'</span> + base64URLEncoded(payload)</span><br><span class="line">signature = Hash(data, secret)</span><br></pre></td></tr></table></figure><p>假设我们的原始 JSON 结构是这样的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Header</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span>,</span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span></span><br><span class="line">&#125;</span><br><span class="line">// Payload:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"userId"</span>: <span class="string">"b08f86af-35da-48f2-8fab-cef3904660bd"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果密钥是字符串secret的话，那么最终 JWT 的结果就是这样的</p><pre><code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM</code></pre><p>你可以在 <a href="https://jwt.io/" target="_blank" rel="noopener">jwt.io</a> 上验证这个结果</p><hr><p>JWT的目的不是为了隐藏或者保密数据，而是为了确保数据确实来自被授权的人创建的（不被篡改）</p><p>用于接口调用</p><h2 id="有状态的会话"><a href="#有状态的会话" class="headerlink" title="有状态的会话"></a>有状态的会话</h2><p>因为HTTP是无状态的，所以客户端和服务端需要解决如何让之间的对话变得有状态。例如只有登录状态的用户才有权限去调用某些接口，那么在用户登录后，需要记住该用户是已经登录的状态。常见的方法是使用session机制。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/3/164608d56ba8fc6e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="常见的session模型"></p><ul><li>用户在浏览器登录后，服务端为用户生成唯一的session id，存储在服务端的存储服务（mysql redis）</li><li>该session id也返回给浏览器以SESSION_ID为key存储在cookie中</li><li>如果用户再次访问该站，cookie里的SESSION_ID会随着请求一同发往服务端</li><li>服务端通过判断SESSION_ID是否在redis判断用户是否处于登录状态</li></ul>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cookie </tag>
            
            <tag> session </tag>
            
            <tag> token </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【数据结构】栈、队列、链表及其区别</title>
      <link href="/2018/07/20/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E3%80%81%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/07/20/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E3%80%81%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<blockquote><p>写这篇是因为之前在群里看到小伙伴在讨论算法相关知识，对于前端来说，这块也是很重要嘛，正好把之前没看完的那本电子书，《学习JavaScript数据结构与算法》复习下~</p></blockquote><a id="more"></a><h2 id="栈数据结构"><a href="#栈数据结构" class="headerlink" title="栈数据结构"></a>栈数据结构</h2><p>栈是一种遵从后进先出(LIFO, Last in First out)原则的有序集合。新添加的或待删除的元素都保存在栈的同一端，称作栈顶，另一端叫作栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。</p><hr><p>我们只是用ES6的简化语法把Stack函数转换成类。但变量items却是公共的，ES6的类是基于原型的，虽然基于原型的类比基于函数的类更节省内存，也更适合创建多个实例，却不能够声明私有属性或方法，而且，在这种情况下，我们希望Stack类的用户只能访问暴露给类的方法，否则就有可能从栈的中间移除元素（因为我们用数组来存储其值）</p><p>以下是ES6方法，创建私有属性的方式：</p><ul><li>用ES6的限定作用域Symbol实现类</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _items = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>[_items] = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// stack方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法创建了一个假的私有属性，因为 Object.getOwnPropertySymbols能够取到类里面声明的所有Symbols属性</p><p>下面是一个破坏Stack类的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stack = <span class="keyword">new</span> Stack();</span><br><span class="line">stack.push(<span class="number">5</span>);</span><br><span class="line">stack.push(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">let</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(stack);</span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols.length); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols); <span class="comment">// [Symbol()]</span></span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols[<span class="number">0</span>]); <span class="comment">// Symbol()</span></span><br><span class="line">stack[objectSymbols[<span class="number">0</span>]].push(<span class="number">1</span>);</span><br><span class="line">stack.print(); <span class="comment">// 5, 8, 1</span></span><br></pre></td></tr></table></figure><p>访问stack[objectSymbols[0]]是可以得到_items的，并且_items属性是一个数组，可以进行任意的数组操作，于是还有下面的方案：</p><p>用ES6的WeakMap实现类</p><p>有一种数据类型可以确保属性是私有的，这就是WeakMap，现在只需要知道WeakMap可以存储键值对，其中键是对象，值可以是任意数据类型。</p><p>如果用WeakMap类存储items变量，Stack类就是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    items.set(<span class="keyword">this</span>, [])</span><br><span class="line">  &#125;</span><br><span class="line">  push(element) &#123;</span><br><span class="line">    <span class="keyword">let</span> s = items.get(<span class="keyword">this</span>);</span><br><span class="line">    s.push(element);</span><br><span class="line">  &#125;</span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = items.get(<span class="keyword">this</span>);</span><br><span class="line">    r = s.pop();</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们知道items在Stack类里是真正的私有属性了，但还有一件事要做。items现在仍然是在Stack类以外声明的，因此谁都可以改动它。我们要用一个闭包（外层函数）把Stack类包起来，这样就只能在这个函数里访问WeakMap：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Stack = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">      items.set(<span class="keyword">this</span>, []);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Stack;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>完整代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.items = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向栈添加元素</span></span><br><span class="line">  push(element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.items.push(element);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从栈移除元素</span></span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 查看栈顶元素</span></span><br><span class="line">  peek() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="keyword">this</span>.items.length - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 检查栈是否为空</span></span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`当前栈是否为空：<span class="subst">$&#123;<span class="keyword">this</span>.items.length === <span class="number">0</span>&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清空栈元素</span></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.items = [];</span><br><span class="line">  &#125;</span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`当前栈的元素有<span class="subst">$&#123;<span class="keyword">this</span>.items.length&#125;</span>个`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 打印栈元素</span></span><br><span class="line">  print() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.items.toString())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> stack = <span class="keyword">new</span> Stack();</span><br><span class="line"><span class="comment">// console.log(stack.isEmpty())</span></span><br><span class="line">stack.push(<span class="number">5</span>)</span><br><span class="line">stack.push(<span class="number">8</span>)</span><br><span class="line"><span class="built_in">console</span>.log(stack.peek())</span><br><span class="line">stack.push(<span class="number">11</span>)</span><br><span class="line">stack.size()</span><br><span class="line">stack.isEmpty()</span><br><span class="line">stack.pop();</span><br><span class="line">stack.pop();</span><br><span class="line">stack.size()</span><br></pre></td></tr></table></figure><h2 id="队列数据结构"><a href="#队列数据结构" class="headerlink" title="队列数据结构"></a>队列数据结构</h2><p>队列是遵循FIFO(First In First Out，先进先出)原则的一组有序的项。<br>队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。</p><h3 id="JS任务队列"><a href="#JS任务队列" class="headerlink" title="JS任务队列"></a>JS任务队列</h3><p>当我们在浏览器中打开新标签时，就会创建一个任务队列。这是因为每个标签都是单线程处理所有的任务，它被称为事件循环。<br>浏览器要负责多个任务，如渲染HTML，执行JS代码，处理用户交互（输入、点击等），执行和处理异步请求。</p><p>代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建队列</span></span><br><span class="line"><span class="keyword">let</span> Queue = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">      items.set(<span class="keyword">this</span>, []);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向队列添加元素</span></span><br><span class="line">    enqueue(elem) &#123;</span><br><span class="line">      items.push(elem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向队列移除元素</span></span><br><span class="line">    dequeue() &#123;</span><br><span class="line">      <span class="keyword">return</span> items.shift();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看队列头元素</span></span><br><span class="line">    front() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(items[<span class="number">0</span>])</span><br><span class="line">      <span class="keyword">return</span> items[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查队列是否为空</span></span><br><span class="line">    isEmpty() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`是否为空：<span class="subst">$&#123;items.length === <span class="number">0</span>&#125;</span>`</span>)</span><br><span class="line">      <span class="keyword">return</span> items.length === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`队列长度为：<span class="subst">$&#123;items.length&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">return</span> items.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印队列元素</span></span><br><span class="line">    print() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(items.valueOf());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 使用Queue类</span></span><br><span class="line"><span class="keyword">let</span> queue = <span class="keyword">new</span> Queue();</span><br><span class="line">queue.isEmpty();</span><br><span class="line">queue.enqueue(<span class="string">'John'</span>);</span><br><span class="line">queue.enqueue(<span class="string">'Jack'</span>);</span><br><span class="line">queue.enqueue(<span class="string">'Camila'</span>);</span><br><span class="line">queue.print();</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表是种动态的数据结构，这意味着我们可以从中任意添加或移除项，它会按需进行扩充。</p><p>要存储多个元素，数组（或列表）可能是最常用的数据结构。每种语言都实现了数组，它提供了一个便利的[]语法来访问其元素。然而这种数据结构有一种缺点，其数组大小是固定的。<br>从数组的起点或中间插入或移除项的成本很高，因为它需要移动元素（尽管我们知道JS的Array类可以帮我们做这类事，但情况还是相同）<br>链表存储有序的元素集合，但不同于数组，链表的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称为指针或链接）组成。<br>相对于传统的数组，链表的好处在于，添加或移除元素时不需要移动其他元素。然而，链表需要使用指针，因此实现链表时需要额外注意。数组的另一个细节是可以直接访问任何位置的任何元素。而想要访问链表中间的一个元素，需要从起点（表头）开始迭代列表直到找到所需元素。</p><p>完整代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> Node = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> length = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> head = <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 向列表尾部添加一个新的项</span></span><br><span class="line">  <span class="keyword">this</span>.append = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element)</span><br><span class="line">    <span class="keyword">let</span> current</span><br><span class="line">    <span class="comment">// 列表中第一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (head === <span class="literal">null</span>) &#123;</span><br><span class="line">      head = node</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      current = node</span><br><span class="line">      <span class="comment">// 循环列表，直到找到最后一项</span></span><br><span class="line">      <span class="keyword">while</span> (current.next) &#123;</span><br><span class="line">        current = current.next</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 找到最后一项，将其next赋为node，建立连接</span></span><br><span class="line">      current.next = node</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新列表长度</span></span><br><span class="line">    length++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向列表的特定位置插入一个新的项</span></span><br><span class="line">  <span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span>(<span class="params">position, element</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 检查越界值</span></span><br><span class="line">    <span class="keyword">if</span> (position &gt;= <span class="number">0</span> &amp;&amp; position &lt;= length) &#123;</span><br><span class="line">      <span class="keyword">let</span> node = <span class="keyword">new</span> Node(element)</span><br><span class="line">      <span class="keyword">let</span> current = head</span><br><span class="line">      <span class="keyword">let</span> previous</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">      <span class="comment">// 在第一个位置添加</span></span><br><span class="line">      <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">        node.next = current</span><br><span class="line">        head = node</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (index++ <span class="xml"><span class="tag">&lt; <span class="attr">position</span>) &#123;</span></span></span><br><span class="line"><span class="xml">          previous = current</span></span><br><span class="line"><span class="xml">          current = current.next</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">        node.next = current</span></span><br><span class="line"><span class="xml">        previous.next = node</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">      // 更新列表长度</span></span><br><span class="line"><span class="xml">      length++</span></span><br><span class="line"><span class="xml">      return true</span></span><br><span class="line"><span class="xml">    &#125; else &#123;</span></span><br><span class="line"><span class="xml">      return false</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  // 从列表的特定位置移除一项</span></span><br><span class="line"><span class="xml">  this.removeAt = function(position) &#123;</span></span><br><span class="line"><span class="xml">    // 检查越界值</span></span><br><span class="line"><span class="xml">    if (position &gt; -1 &amp;&amp; position <span class="tag">&lt; <span class="attr">length</span>) &#123;</span></span></span><br><span class="line"><span class="xml">      let current = head</span></span><br><span class="line"><span class="xml">      let previous</span></span><br><span class="line"><span class="xml">      let index = 0</span></span><br><span class="line"><span class="xml">      // 移除第一项</span></span><br><span class="line"><span class="xml">      if (position === 0) &#123;</span></span><br><span class="line"><span class="xml">        head = current.next</span></span><br><span class="line"><span class="xml">      &#125; else &#123;</span></span><br><span class="line"><span class="xml">        while (index++ <span class="tag">&lt; <span class="attr">position</span>) &#123;</span></span></span><br><span class="line"><span class="xml">          previous = current</span></span><br><span class="line"><span class="xml">          current = current.next</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">        // 将previous与current的下一项连接起来；跳过current，从而移除它</span></span><br><span class="line"><span class="xml">        previous.next = current.next</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">      length--</span></span><br><span class="line"><span class="xml">      return current.element</span></span><br><span class="line"><span class="xml">    &#125; else &#123;</span></span><br><span class="line"><span class="xml">      return null</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  // 从列表中移除一项</span></span><br><span class="line"><span class="xml">  this.remove = function(element) &#123;</span></span><br><span class="line"><span class="xml">    let index = this.indexOf(element)</span></span><br><span class="line"><span class="xml">    return this.removeAt(index)</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  // 返回元素在列表中的索引，若列表中没有该元素则返回-1</span></span><br><span class="line"><span class="xml">  this.indexOf = function(element) &#123;</span></span><br><span class="line"><span class="xml">    let current = head</span></span><br><span class="line"><span class="xml">    let index = -1</span></span><br><span class="line"><span class="xml">    while (current) &#123;</span></span><br><span class="line"><span class="xml">      if (element === current.element) &#123;</span></span><br><span class="line"><span class="xml">        return index</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">      index++</span></span><br><span class="line"><span class="xml">      current = current.next</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    return -1</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  this.isEmpty = function() &#123;</span></span><br><span class="line"><span class="xml">    return length === 0</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  // 返回链表包含的元素个数，与数组的length属性类似</span></span><br><span class="line"><span class="xml">  this.size = function() &#123;</span></span><br><span class="line"><span class="xml">    return length</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  this.getHead = function() &#123;</span></span><br><span class="line"><span class="xml">    return head</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  // 由于列表项使用了Node类，就需要重写继承自JS默认的toString方法，让其只输出元素值</span></span><br><span class="line"><span class="xml">  this.toString = function() &#123;</span></span><br><span class="line"><span class="xml">    // 首先要访问列表中的所有元素，就需要有一个起点，也就是head。我们会把current变量当作索引，控制循环访问列表</span></span><br><span class="line"><span class="xml">    // 我们还需要初始化用于拼接元素值的变量，接下来就是循环访问列表中的每个元素</span></span><br><span class="line"><span class="xml">    // 我们要用current来检查元素是否存在，然后得到元素内容进行拼接</span></span><br><span class="line"><span class="xml">    // 最后迭代下一个元素，最终返回列表内容的字符串</span></span><br><span class="line"><span class="xml">    let current = head</span></span><br><span class="line"><span class="xml">    let string = ''</span></span><br><span class="line"><span class="xml">    while (current) &#123;</span></span><br><span class="line"><span class="xml">      string += current.element + (current.next ? 'n' : '')</span></span><br><span class="line"><span class="xml">      current = current.next</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    return string</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  this.print = function() &#123;&#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">var md1 = `</span></span><br><span class="line"><span class="xml">  LinkedList数据结构还需要一个Node辅助类。Node类表示要加入列表的项，它包含一个element属性，即要添加到列表的值，以及一个next属性，即指向列表中下一个节点项的指针。</span></span><br><span class="line"><span class="xml">  LinkedList类也有存储列表项的数组的length属性（是一个私有变量）</span></span><br><span class="line"><span class="xml">  另一个重要点是，我们还需要存储第一个节点的引用。为此，可以把这个引用存储在称为head的变量中</span></span><br><span class="line"><span class="xml">  然后就是LinkedList类的方法</span></span><br><span class="line"><span class="xml">`</span></span><br></pre></td></tr></table></figure><h3 id="链表优点"><a href="#链表优点" class="headerlink" title="链表优点"></a>链表优点</h3><ol><li><p>使用链表数据结构可以克服数组链表需要预先知道数据大小的缺点，链表数据结构可以充分内存空间，实现灵活的内存动态管理</p></li><li><p>数据的存取往往要在不同的排列顺序中转换，而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的指针。链表允许插入和移除链表上任意位置上的节点，但是不允许随机存取</p></li></ol><h3 id="链表缺点"><a href="#链表缺点" class="headerlink" title="链表缺点"></a>链表缺点</h3><p>链表失去了数组随机读取的优点，同时链表由于增加了节点的指针域，空间开销比较大</p><hr><p>先到这里，后面再补充吧~~</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【JS】脚本错误及错误捕获</title>
      <link href="/2018/07/14/%E3%80%90JS%E3%80%91%E8%84%9A%E6%9C%AC%E9%94%99%E8%AF%AF%E5%8F%8A%E9%94%99%E8%AF%AF%E6%8D%95%E8%8E%B7/"/>
      <url>/2018/07/14/%E3%80%90JS%E3%80%91%E8%84%9A%E6%9C%AC%E9%94%99%E8%AF%AF%E5%8F%8A%E9%94%99%E8%AF%AF%E6%8D%95%E8%8E%B7/</url>
      <content type="html"><![CDATA[<blockquote><p>从脚本错误开始，了解脚本为什么会报错以及抛出错误，最后介绍了用window.onerror、try catch捕获错误。</p></blockquote><a id="more"></a><h2 id="什么是脚本错误"><a href="#什么是脚本错误" class="headerlink" title="什么是脚本错误"></a>什么是脚本错误</h2><p>如果您以前使用过JavaScript onerror事件做过任何工作，您可能会遇到以下情况：</p><p>“Script error.”</p><p>“脚本错误”是当错误源自从不同来源（不同域，端口或协议）提供的JavaScript文件时，浏览器发送到onerror回调的内容。这很痛苦，因为即使出现错误，您也不知道错误是什么，也不知道它来自哪个代码。这就是window.onerror的全部目的 - 深入了解应用程序中未捕获的错误。</p><h2 id="产生原因：跨源脚本"><a href="#产生原因：跨源脚本" class="headerlink" title="产生原因：跨源脚本"></a>产生原因：跨源脚本</h2><p>为了更好地了解正在发生的事情，请考虑以下示例HTML文档，假设从<a href="http://example.com/test提供：" target="_blank" rel="noopener">http://example.com/test提供：</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>example.com/test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://another-domain.com/app.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">message, url, line, column, error</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(message, url, line, column, error);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    foo(); <span class="comment">// call function declared in app.js</span></span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是<a href="http://another-domain.com/app.js的内容。它声明了一个函数foo，其调用将始终抛出ReferenceError。" target="_blank" rel="noopener">http://another-domain.com/app.js的内容。它声明了一个函数foo，其调用将始终抛出ReferenceError。</a></p><p>在浏览器中加载此文档并执行JavaScript时，会将以下内容输出到控制台（通过window.onerror回调记录）：</p><p>“Script error.”, “”, 0, 0, undefined</p><p>这不是JavaScript错误 - 出于安全原因，浏览器故意隐藏源自不同来源的脚本文件的错误。这是为了避免脚本无意中将潜在敏感信息泄露给它无法控制的onerror回调。出于这个原因，浏览器只允许window.onerror洞察来自同一域的错误。我们所知道的是发生了一个错误 - 没有别的！</p><h2 id="但这并不坏"><a href="#但这并不坏" class="headerlink" title="但这并不坏"></a>但这并不坏</h2><p>尽管浏览器有良好的意图，但是有一些很好的理由可以让您深入了解从不同来源提供的脚本引发的错误：</p><ol><li>您的应用程序JavaScript文件是从不同的主机名提供的，例如static.sentry.io/app.js</li><li>您正在使用社区CDN提供的库，例如cdnjs或Google的托管库</li><li>您正在使用商业第三方JavaScript库，该库仅由外部服务器提供</li></ol><p>但不要担心 - 深入了解这些文件所提供的JavaScript错误只需要进行一些简单的调整。</p><h2 id="修复：CORS-attributes-amp-headers"><a href="#修复：CORS-attributes-amp-headers" class="headerlink" title="修复：CORS attributes &amp; headers"></a>修复：CORS attributes &amp; headers</h2><p>为了了解源自不同来源的脚本引发的JavaScript异常，您必须做两件事:</p><ol><li>添加 crossorigin=”anonymous” 脚本属性</li></ol><p><code>&lt;script src=&quot;http://another-domain.com/app.js&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;</code></p><p>这告诉浏览器应该“anonymous”(匿名)获取目标文件。这意味着在请求此文件时，浏览器不会将任何潜在的用户识别信息（如cookie或HTTP凭据）传输到服务器。</p><ol><li>添加Cross Origin HTTP header</li></ol><p><code>Access-Control-Allow-Origin: *</code></p><p>CORS是“跨源资源共享”的缩写，它是一组API（主要是HTTP标头），它们规定了文件应该如何从源头下载和提供。</p><p>通过设置Access-Control-Allow-Origin：*，服务器向浏览器指示任何源可以获取此文件。或者，您可以将其限制为您控制的已知来源，例如</p><p><code>Access-Control-Allow-Origin: https://www.example.com</code></p><p>注意：大多数社区CDN正确设置了Access-Control-Allow-Origin标头。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl --head https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.js | \</span><br><span class="line">  grep -i <span class="string">"access-control-allow-origin"</span></span><br><span class="line"></span><br><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure><p>完成这两个步骤后，此脚本触发的任何错误都将向window.onerror报告，就像任何常规的同域脚本一样。因此，代替“脚本错误”，从一开始的onerror示例将产生：</p><p><code>&quot;ReferenceError: bar is not defined&quot;, &quot;http://another-domain.com/app.js&quot;, 2, 1, [Object Error]</code></p><h2 id="另一种解决方案：try-catch"><a href="#另一种解决方案：try-catch" class="headerlink" title="另一种解决方案：try / catch"></a>另一种解决方案：try / catch</h2><p>有时，我们并不总是能够调整Web应用程序正在使用的脚本的HTTP头。在这些情况下，有一种替代方法：使用try / catch。</p><p>再次考虑原始示例，这次使用try / catch：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- <span class="doctag">note:</span> crossorigin="anonymous" intentionally absent --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://another-domain.com/app.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">message, url, line, column, error</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(message, url, line, column, error);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">    foo(); <span class="comment">// call function declared in app.js</span></span></span><br><span class="line"><span class="javascript">  &#125; <span class="keyword">catch</span> (e) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(e);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">throw</span> e; <span class="comment">// intentionally re-throw (caught by window.onerror)</span></span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于后代，some-domain.com/app.js再次看起来像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// another-domain.com/app.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  bar(); <span class="comment">// ReferenceError: bar is not a function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行示例HTML将向控制台输出以下2个条目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">=&gt; ReferenceError: bar is not defined</span><br><span class="line">    at foo (http://another-domain.com/b.js:2:3)</span><br><span class="line">    at http://example.com/<span class="built_in">test</span>/:15:3</span><br><span class="line"></span><br><span class="line">=&gt; <span class="string">"Script error."</span>, <span class="string">""</span>, 0, 0, undefined</span><br></pre></td></tr></table></figure><p>第一个控制台语句 - 来自try / catch - 设法获取一个错误对象，包括类型，消息和堆栈跟踪，包括文件名和行号。来自window.onerror的第二个控制台语句再一次只能输出“脚本错误”。</p><p>现在，这是否意味着您需要尝试/捕获所有代码？可能不是 - 如果您可以轻松更改HTML并在CDN上指定CORS标题，则最好这样做并坚持使用window.onerror。但是，如果您不控制这些资源，使用try / catch包装第三方代码是一种可靠的（虽然是乏味的）方式，可以深入了解跨源脚本引发的错误。</p><p>注意：默认情况下，Raven.js - Sentry的JavaScript SDK - 仔细设备内置方法，尝试自动将代码包装在try / catch块中。它这样做是为了尝试捕获所有脚本中的错误消息和堆栈跟踪，无论它们来自哪个来源。如果可能，仍建议设置CORS属性和标头。</p><h2 id="window-onerror"><a href="#window-onerror" class="headerlink" title="window.onerror"></a>window.onerror</h2><p>onerror是一个特殊的浏览器事件，只要抛出未捕获的JavaScript错误就会触发该事件。这是记录客户端错误并将其报告给服务器的最简单方法之一。它也是Sentry的客户端JavaScript集成（raven-js）工作的主要机制之一。</p><p>你通过向window.onerror分配一个函数来监听onerror事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">msg, url, lineNo, columnNo, error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... handle error ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抛出错误时，以下参数将传递给函数：</p><ul><li>msg - 与错误相关的消息，例如“未捕获的ReferenceError：foo未定义”</li><li>url - 与错误关联的脚本或文档的URL，例如“/dist/app.js”</li><li>lineNo - 行号（如果有）</li><li>columnNo - 列号（如果可用）</li><li>error - 与此错误关联的Error对象（如果可用）</li></ul><p>前四个参数告诉你错误发生在哪个脚本，行和列中。最后一个参数Error对象可能是最有价值的。让我们来了解原因。</p><h3 id="Error对象和error-stack"><a href="#Error对象和error-stack" class="headerlink" title="Error对象和error.stack"></a>Error对象和error.stack</h3><p>乍一看，Error对象不是很特别。它包含3个标准化属性：message，fileName和lineNumber。已通过window.onerror提供给你的冗余值。</p><p>有价值的部分是非标准属性：Error.prototype.stack。此堆栈属性告诉你错误发生时程序的每个帧的源位置。错误堆栈跟踪可能是调试的关键部分。尽管不标准，但每个现代浏览器都提供此属性。</p><p>以下是Chrome 46中Error对象的堆栈属性的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Error: foobar\n    at new bar (&lt;anonymous&gt;:241:11)\n    at foo (&lt;anonymous&gt;:245:5)\n    at &lt;anonymous&gt;:250:5\n    at &lt;anonymous&gt;:251:3\n    at &lt;anonymous&gt;:267:4\n    at callFunction (&lt;anonymous&gt;:229:33)\n    at &lt;anonymous&gt;:239:23\n    at &lt;anonymous&gt;:240:3\n    at Object.InjectedScript._evaluateOn (&lt;anonymous&gt;:875:140)\n    at Object.InjectedScript._evaluateAndWrap (&lt;anonymous&gt;:808:34)"</span></span><br></pre></td></tr></table></figure><p>难以阅读，对吗？stack属性实际上只是一个未格式化的字符串。这是格式化的样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Error: foobar</span></span><br><span class="line"><span class="string">    at new bar (&lt;anonymous&gt;:241:11)</span></span><br><span class="line"><span class="string">    at foo (&lt;anonymous&gt;:245:5)</span></span><br><span class="line"><span class="string">    at &lt;anonymous&gt;:250:5</span></span><br><span class="line"><span class="string">    at &lt;anonymous&gt;:251:3</span></span><br><span class="line"><span class="string">    at &lt;anonymous&gt;:267:4</span></span><br><span class="line"><span class="string">    at callFunction (&lt;anonymous&gt;:229:33)</span></span><br><span class="line"><span class="string">    at &lt;anonymous&gt;:239:23</span></span><br><span class="line"><span class="string">    at &lt;anonymous&gt;:240:3</span></span><br><span class="line"><span class="string">    at Object.InjectedScript._evaluateOn (&lt;anonymous&gt;:875:140)</span></span><br><span class="line"><span class="string">    at Object.InjectedScript._evaluateAndWrap (&lt;anonymous&gt;:808:34)"</span></span><br></pre></td></tr></table></figure><p>一旦格式化，就很容易看出堆栈属性如何在帮助调试错误时起到关键作用。只有一个障碍：堆栈属性是非标准的，它的实现在浏览器之间有所不同。例如，这是来自Internet Explorer 11的相同堆栈跟踪：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Error</span>: foobar</span><br><span class="line">   at bar (Unknown script code:<span class="number">2</span>:<span class="number">5</span>)</span><br><span class="line">   at foo (Unknown script code:<span class="number">6</span>:<span class="number">5</span>)</span><br><span class="line">   at Anonymous <span class="function"><span class="keyword">function</span> (<span class="params">Unknown script code:<span class="number">11</span>:<span class="number">5</span></span>)</span></span><br><span class="line"><span class="function">   <span class="title">at</span> <span class="title">Anonymous</span> <span class="title">function</span> (<span class="params">Unknown script code:<span class="number">10</span>:<span class="number">2</span></span>)</span></span><br><span class="line"><span class="function">   <span class="title">at</span> <span class="title">Anonymous</span> <span class="title">function</span> (<span class="params">Unknown script code:<span class="number">1</span>:<span class="number">73</span></span>)</span></span><br></pre></td></tr></table></figure><p>不仅每个帧的格式不同，帧也具有较少的细节。例如，Chrome会识别出已使用新关键字，并且对eval调用有更深入的了解。这只是IE 11与Chrome的比较 - 其他类似的浏览器具有不同的格式和细节。</p><p>幸运的是，有一些工具可以规范化堆栈属性，使其在浏览器中保持一致。例如，raven-js使用TraceKit来规范化错误字符串。还有stacktrace.js和其他一些项目。</p><h3 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h3><p>window.onerror已经在浏览器中出现了一段时间 - 你会在浏览器中找到它与IE6和Firefox 2一样古老的版本。</p><p>问题是每个浏览器都以不同的方式实现window.onerror。特别是，将多少个参数发送给onerror侦听器，以及这些参数的结构。</p><p>这是一个在大多数浏览器中将参数传递给onerror的表：</p><table><thead><tr><th style="text-align:center">Browser</th><th style="text-align:center">Message</th><th style="text-align:center">URL</th><th style="text-align:center">lineNo</th><th style="text-align:center">colNo</th><th style="text-align:center">errorObj</th></tr></thead><tbody><tr><td style="text-align:center">Firefox</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center">Chrome</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center">Edge</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center">IE 11</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center">IE 10</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center">IE 9, 8</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center">Safari 10 and up</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center">Safari 9</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr><tr><td style="text-align:center">Android Browser 4.4</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td></tr></tbody></table><p>Internet Explorer 8,9和10对onerror的支持有限，这可能不足为奇。但是你可能会惊讶于Safari只在Safari 10中添加了对错误对象的支持（2016年发布）。此外，仍旧使用现有Android浏览器（现已替换为Chrome Mobile）的旧手机版仍然在那里，并且不会传递错误对象。</p><p>没有错误对象，就没有堆栈跟踪属性。这意味着这些浏览器无法从错误捕获的错误中检索有价值的堆栈信息。</p><h3 id="使用try-catch-兼容-window-onerror"><a href="#使用try-catch-兼容-window-onerror" class="headerlink" title="使用try / catch 兼容 window.onerror"></a>使用try / catch 兼容 window.onerror</h3><p>但是有一种解决方法 - 你可以将应用程序中的代码包装在try / catch中并自己捕获错误。这个错误对象将在每个现代浏览器中包含我们令人垂涎的堆栈属性。</p><p>考虑以下帮助器方法invoke，它使用参数数组调用对象上的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invoke</span>(<span class="params">obj, method, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[method].apply(<span class="keyword">this</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">invoke(<span class="built_in">Math</span>, <span class="string">'max'</span>, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// returns 2</span></span><br></pre></td></tr></table></figure><p>这里再次调用，这次包装在try / catch中，以捕获任何抛出的错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invoke</span>(<span class="params">obj, method, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj[method].apply(<span class="keyword">this</span>, args);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    captureError(e); <span class="comment">// report the error</span></span><br><span class="line">    <span class="keyword">throw</span> e; <span class="comment">// re-throw the error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">invoke(<span class="built_in">Math</span>, <span class="string">'highest'</span>, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// throws error, no method Math.highest</span></span><br></pre></td></tr></table></figure><p>当然，在任何地方手动执行此操作非常麻烦。你可以通过创建通用包装器实用程序函数来使其更容易：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapErrors</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// don't wrap function more than once</span></span><br><span class="line">  <span class="keyword">if</span> (!fn.__wrapped__) &#123;</span><br><span class="line">    fn.__wrapped__ = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        captureError(e); <span class="comment">// report the error</span></span><br><span class="line">        <span class="keyword">throw</span> e; <span class="comment">// re-throw the error</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fn.__wrapped__;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> invoke = wrapErrors(<span class="function"><span class="keyword">function</span>(<span class="params">obj, method, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[method].apply(<span class="keyword">this</span>, args);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">invoke(<span class="built_in">Math</span>, <span class="string">'highest'</span>, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// no method Math.highest</span></span><br></pre></td></tr></table></figure><p>因为JavaScript是单线程的，所以你不需要在任何地方使用wrap  - 只是在每个新堆栈的开头。</p><p>这意味着你需要包装函数声明：</p><ul><li>在你的应用程序开始时（例如，如果你使用jQuery，请在$（document）.ready中）</li><li>在事件处理程序中，例如addEventListener或$ .fn.click</li><li>基于计时器的回调，例如setTimeout或requestAnimationFrame</li></ul><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$(wrapErrors(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// application start</span></span><br><span class="line">  doSynchronousStuff1(); <span class="comment">// doesn't need to be wrapped</span></span><br><span class="line"></span><br><span class="line">  setTimeout(wrapErrors(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    doSynchronousStuff2(); <span class="comment">// doesn't need to be wrapped</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  $(<span class="string">'.foo'</span>).click(wrapErrors(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    doSynchronousStuff3(); <span class="comment">// doesn't need to be wrapped</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>如果这看起来像是很多工作，请不要担心！大多数错误报告库都具有增强内置函数（如addEventListener和setTimeout）的机制，因此你不必每次都调用包装实用程序。是的，raven-js也这样做。</p><h3 id="将错误传输到你的服务器"><a href="#将错误传输到你的服务器" class="headerlink" title="将错误传输到你的服务器"></a>将错误传输到你的服务器</h3><p>好的，所以你已经完成了你的工作 - 你已经插入window.onerror，并且你还在try / catch中包装函数，以便捕获尽可能多的错误信息。</p><p>最后一步是：将错误信息传输到你的服务器。为了实现这一点，你需要设置某种报告Web服务，该服务将通过HTTP接受你的错误数据，将其记录到文件和/或将其存储在数据库中。</p><p>如果此Web服务与Web应用程序位于同一个域中，则可以使用XMLHttpRequest轻松实现。在下面的示例中，我们使用jQuery的AJAX函数将数据传输到我们的服务器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">captureError</span>(<span class="params">ex</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> errorData = &#123;</span><br><span class="line">    name: ex.name, <span class="comment">// e.g. ReferenceError</span></span><br><span class="line">    message: ex.line, <span class="comment">// e.g. x is undefined</span></span><br><span class="line">    url: <span class="built_in">document</span>.location.href,</span><br><span class="line">    stack: ex.stack <span class="comment">// stacktrace string; remember, different per-browser!</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  $.post(<span class="string">'/logger/js/'</span>, &#123;</span><br><span class="line">    data: errorData</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，如果必须跨源传输错误，则报告端点需要支持CORS（跨源资源共享）。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.sentry.io/2016/05/17/what-is-script-error" target="_blank" rel="noopener">什么是脚本错误</a></li><li><a href="https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror.html" target="_blank" rel="noopener">window.onerror捕获错误</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你已经做到这一点，那么你现在可以拥有所需的所有工具来推送自己的基本错误报告库并将其与你的应用程序集成：</p><ul><li>window.onerror的工作原理以及它支持的浏览器</li><li>如何使用try / catch来捕获缺少window.onerror的堆栈跟踪</li><li>将错误数据传输到你的服务器</li></ul>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> Error </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【JS】理解跨域及相关解决方案</title>
      <link href="/2018/07/07/%E3%80%90%E8%B7%A8%E5%9F%9F%E3%80%91%E7%90%86%E8%A7%A3%E8%B7%A8%E5%9F%9F%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2018/07/07/%E3%80%90%E8%B7%A8%E5%9F%9F%E3%80%91%E7%90%86%E8%A7%A3%E8%B7%A8%E5%9F%9F%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<blockquote><p>写这篇一是为复习，二来是有个良好的总结。对于知识点的理解总是一知半解，不深入，这篇希望在此基础上不断深化加深印象和理解。</p></blockquote><a id="more"></a><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><blockquote><p>A cross-domain solution (CDS) is a means of information assurance that provides the ability to manually or automatically access or transfer between two or more differing security domains.</p></blockquote><p>解决两个安全域之间的信息传递，这个就叫做CDS——跨域解决方案。跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。</p><h3 id="为什么需要跨域"><a href="#为什么需要跨域" class="headerlink" title="为什么需要跨域"></a>为什么需要跨域</h3><p>浏览器有同源策略限制。</p><p>同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p><p>这是一个用于隔离潜在恶意文件的重要安全机制。同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。</p><p>我们要知道协议、域名和端口一致就是同源的就好。这里有点不直观，举例来看好了，以下列出了常见的跨域场景：</p><table><thead><tr><th style="text-align:center">URL</th><th style="text-align:center">说明</th><th style="text-align:center">是否允许通信</th></tr></thead><tbody><tr><td style="text-align:center"><a href="http://www.domain.com/a.js" target="_blank" rel="noopener">http://www.domain.com/a.js</a><br><a href="http://www.domain.com/b.js" target="_blank" rel="noopener">http://www.domain.com/b.js</a><br><a href="http://www.domain.com/lab/c.js" target="_blank" rel="noopener">http://www.domain.com/lab/c.js</a></td><td style="text-align:center">同一域名，不同文件或路径</td><td style="text-align:center">允许</td></tr><tr><td style="text-align:center"><a href="http://www.domain.com:8000/a.js" target="_blank" rel="noopener">http://www.domain.com:8000/a.js</a><br><a href="http://www.domain.com/b.js" target="_blank" rel="noopener">http://www.domain.com/b.js</a></td><td style="text-align:center">同一域名，不同端口</td><td style="text-align:center">不允许</td></tr><tr><td style="text-align:center"><a href="http://www.domain.com/a.js" target="_blank" rel="noopener">http://www.domain.com/a.js</a><br><a href="https://www.domain.com/b.js" target="_blank" rel="noopener">https://www.domain.com/b.js</a></td><td style="text-align:center">同一域名，不同协议</td><td style="text-align:center">不允许</td></tr><tr><td style="text-align:center"><a href="http://www.domain.com/a.js" target="_blank" rel="noopener">http://www.domain.com/a.js</a><br><a href="http://192.168.4.12/b.js" target="_blank" rel="noopener">http://192.168.4.12/b.js</a></td><td style="text-align:center">域名和域名对应相同ip</td><td style="text-align:center">不允许</td></tr><tr><td style="text-align:center"><a href="http://www.domain.com/a.js" target="_blank" rel="noopener">http://www.domain.com/a.js</a><br><a href="http://192.168.4.12/b.js" target="_blank" rel="noopener">http://192.168.4.12/b.js</a></td><td style="text-align:center">域名和域名对应相同ip</td><td style="text-align:center">不允许</td></tr><tr><td style="text-align:center"><a href="http://www.domain.com/a.js" target="_blank" rel="noopener">http://www.domain.com/a.js</a><br><a href="http://x.domain.com/b.js" target="_blank" rel="noopener">http://x.domain.com/b.js</a><br><a href="http://domain.com/c.js" target="_blank" rel="noopener">http://domain.com/c.js</a></td><td style="text-align:center">主域相同，子域不同</td><td style="text-align:center">不允许</td></tr><tr><td style="text-align:center"><a href="http://www.domain1.com/a.js" target="_blank" rel="noopener">http://www.domain1.com/a.js</a><br><a href="http://www.domain2.com/b.js" target="_blank" rel="noopener">http://www.domain2.com/b.js</a></td><td style="text-align:center">不同域名</td><td style="text-align:center">不允许</td></tr></tbody></table><p>data：URLs获得一个新的，空的安全上下文。</p><p>在页面中用 about:blank 或 javascript: URL 执行的脚本会继承打开该 URL 的文档的源，因为这些类型的 URLs 没有明确包含有关原始服务器的信息。</p><h2 id="避免同源限制"><a href="#避免同源限制" class="headerlink" title="避免同源限制"></a>避免同源限制</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>同源网页的Cookie才能共享，但是两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享cookie</p><blockquote><p>该方法只适用于Cookie和iframe窗口。 localStorage和IndexDB无法通过这种方法规避，而要使用PostMessage API</p></blockquote><p>另外，服务器也可以在设置cookie时，指定cookie所属域名为一级域名</p><pre><code>Set-Cookie: key=value; domain=.example.com; path=/</code></pre><p>这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie</p><h3 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h3><p>如果两个网页不同源，就无法拿到对方的DOM，典型例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。</p><p>如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的document.domain属性，就可以规避同源政策，拿到DOM。</p><p>对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。</p><ul><li>片段识别符 fragment identifier</li><li>window.name</li><li>跨文档通信API Cross-document messaging</li></ul><ol><li>片段识别符</li></ol><p>片段识别符指的是 url的#号后面部分，如果只是改变片段标识符，页面不会重新刷新。父窗口可以把信息，写入子窗口的片段标识符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> src = originURL + <span class="string">'#'</span> + data</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'myIframe'</span>).src = src</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子窗口通过监听hashchange事件得到通知</span></span><br><span class="line"><span class="built_in">window</span>.onhashchange = checkMessage</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkMessage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> message = <span class="built_in">window</span>.location.hash</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样子窗口也可以改变父窗口的片段标识符</p><pre><code>parent.location.href = target + &apos;#&apos; + hash</code></pre><ol><li>window.name</li></ol><p>浏览器窗口有window.name属性。这个属性最大特点是，无论是否同源，只要是在同一个窗口里，前一个网页设置里这个属性，后一个网页可以读取它。</p><p>父窗口先打开一个子窗口，载入一个不同源的页面，该页面将信息写入window.name属性</p><pre><code>window.name = data</code></pre><p>接着，子窗口跳回一个与主窗口同域的网址</p><pre><code>location = &apos;http://parent.url.com/xxx.html&apos;</code></pre><p>然后，主窗口就可以读取子窗口的window.name了</p><pre><code>var data = document.getElementById(&apos;myFrame&apos;).contentWindow.name</code></pre><p>该方法的优点是，window.name容量很大，可以放置很长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能。</p><p><strong>document.domain</strong></p><p>通过修改document的domain属性，我们可以在域和子域或者不同的子域之间通信。同域策略认为域和子域隶属于不同的域，比如<a href="http://www.a.com和sub.a.com是不同的域，这时，我们无法在www.a.com下的页面中调用sub.a.com中定义的JavaScript方法。但是当我们把它们document的domain属性都修改为a.com，浏览器就会认为它们处于同一个域下，那么我们就可以互相调用对方的method来通信了。" target="_blank" rel="noopener">www.a.com和sub.a.com是不同的域，这时，我们无法在www.a.com下的页面中调用sub.a.com中定义的JavaScript方法。但是当我们把它们document的domain属性都修改为a.com，浏览器就会认为它们处于同一个域下，那么我们就可以互相调用对方的method来通信了。</a></p><ol><li>window.postMessage</li></ol><p>上两种都属于抖机灵操作，HTML为解决该问题，引入了一个全新的API，跨文档通信API Cross-document messaging</p><p>该API为window对象新增了一个<code>window.postMessage</code>方法，允许跨窗口通信，无论这两个窗口是否同源</p><p>举例来说，父窗口<a href="http://aaa.com向子窗口http://bbb.com发消息，调用postMessage方法就可以了。" target="_blank" rel="noopener">http://aaa.com向子窗口http://bbb.com发消息，调用postMessage方法就可以了。</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> popup = <span class="built_in">window</span>.open(<span class="string">'http://bbb.com'</span>, title)</span><br><span class="line">popup.postMessage(<span class="string">'hello world'</span>, <span class="string">'http://bbb.com'</span>)</span><br></pre></td></tr></table></figure><p>postMessage方法的第一个参数是具体的信息内容，第二个参数是接受消息的窗口的源origin，即协议+域名+端口。也可以设为*，表示不限制域名，向所有窗口发送。</p><p>子窗口向父窗口发送消息的写法类似：</p><pre><code>widnow.opener.postMessage(&apos;Nice to see you&apos;, &apos;http://aaa.com&apos;)</code></pre><p>父窗口和子窗口都可以通过message事件，监听对方的消息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h3 id="server-proxy"><a href="#server-proxy" class="headerlink" title="server proxy"></a>server proxy</h3><p>在数据提供方没有提供对JSONP协议或者window.name协议的支持，也没有对其它域开放访问权限时，我们可以通过server proxy的方式来抓取数据。</p><p>例如当<a href="http://www.a.com域下的页面需要请求www.b.com下的资源文件asset.txt时，直接发送一个指向www.b.com/asset.txt的Ajax请求肯定是会被浏览器阻止。这时，我们在www.a.com下配一个代理，然后把Ajax请求绑定到这个代理路径下，例如www.a.com/proxy/" target="_blank" rel="noopener">www.a.com域下的页面需要请求www.b.com下的资源文件asset.txt时，直接发送一个指向www.b.com/asset.txt的Ajax请求肯定是会被浏览器阻止。这时，我们在www.a.com下配一个代理，然后把Ajax请求绑定到这个代理路径下，例如www.a.com/proxy/</a>, 然后这个代理发送HTTP请求访问<a href="http://www.b.com下的asset.txt，跨域的HTTP请求是在服务器端进行的，客户端并没有产生跨域的Ajax请求。这个跨域方式不需要和目标资源签订协议，带有侵略性，另外需要注意的是实践中应该对这个代理实施一定程度的保护，比如限制他人使用或者使用频率。" target="_blank" rel="noopener">www.b.com下的asset.txt，跨域的HTTP请求是在服务器端进行的，客户端并没有产生跨域的Ajax请求。这个跨域方式不需要和目标资源签订协议，带有侵略性，另外需要注意的是实践中应该对这个代理实施一定程度的保护，比如限制他人使用或者使用频率。</a></p><h2 id="Ajax跨域"><a href="#Ajax跨域" class="headerlink" title="Ajax跨域"></a>Ajax跨域</h2><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老实浏览器全部支持，服务器改造小。</p><p>它的基本思想是，网页通过添加一个<code>script</code>标签，向服务器请求json数据，这种做法不受同源策略限制；服务器接受请求后，将数据放在一个指定名字的回调里传回来</p><p>首先，网页动态插入<code>script</code>元素，由它向跨源网址发出请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addScriptTag</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElmement(<span class="string">'script'</span>)</span><br><span class="line">  script.src = src</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  addScriptTag(<span class="string">'http://example.com/ip=0.0.0.0?callback=foo'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'your public IP address is: '</span> + data.ip)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>script</code>元素请求的脚本， 直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为js对象，而不是字符串，因此避免了使用JSON.parse的步骤</p><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p><code>WebSocket</code>是一种通信协议，使用ws:// (非加密) 和 wss:// (加密) 作为协议前缀。该协议不实行同源限制，只要服务器支持，就可以使用它进行跨源通信。</p><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。</p><p>我们来看下例子，下面是前端部分代码：(原生WebSocket API使用起来不太方便，我们使用Socket.io)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>user: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"text"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./socket.io.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> socket = io(<span class="string">'http://www.domain2.com:8080'</span>)</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 连接成功处理</span></span></span><br><span class="line"><span class="javascript">  socket.on(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 监听服务端消息</span></span></span><br><span class="line"><span class="javascript">    socket.on(<span class="string">'message'</span>, msg =&gt; &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'data from server: '</span> + msg)</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>).onblur = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    socket.send(<span class="keyword">this</span>.value)</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>node.js socket 部分实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> socket = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)</span><br><span class="line"><span class="comment">// 启http服务</span></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'text/html'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  res.end()</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">8080</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'server is running at port 8080'</span>)</span><br><span class="line"><span class="comment">// 监听socket连接</span></span><br><span class="line">socket.listen(server).on(<span class="string">'connection'</span>, client =&gt; &#123;</span><br><span class="line">  <span class="comment">// 接受消息</span></span><br><span class="line">  client.on(<span class="string">'message'</span>, msg =&gt; &#123;</span><br><span class="line">    client.send(<span class="string">'hello: '</span> + msg)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'data from client: '</span> + msg)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 断开处理</span></span><br><span class="line">  client.on(<span class="string">'disconnect'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'client socket has closed.'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>下例是浏览器发出的WebSocket请求的头信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP /1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http://example.com</span><br></pre></td></tr></table></figure><p>上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。</p><p>正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS是一个W3C标准，全称是”跨域资源共享” Cross Origin Resource Share，它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</p><blockquote><p>实现CORS通信的关键是服务端，只要服务端实现了CORS接口，就可以跨源通信</p></blockquote><p>具体看软一峰老师这篇就好<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></p><p>CORS目前是跨域的主流解决方案，相比JSONP更为强大。JSONP只支持GET请求，而CORS支持所有类型的HTTP请求。但是JSONP有优势在于兼容性，所以还是需要根据场景来决定是否使用该方案。</p><h3 id="nginx代理跨域"><a href="#nginx代理跨域" class="headerlink" title="nginx代理跨域"></a>nginx代理跨域</h3><p><strong>nginx配置解决iconfont跨域</strong></p><p>浏览器跨域访问JS、CSS、img等常规静态资源被同源策略许可，但iconfont字体文件例外，此时可在nginx的静态资源服务器中加入以下配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  add_header Access-Control-Allow-Origin: *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>nginx反向代理跨域接口</strong></p><p>跨域原理：同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略也就不存在跨域问题了。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做桥接，反向代理访问domain2接口，并且可顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。下面是具体配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># proxy服务器</span></span><br><span class="line">server &#123;</span><br><span class="line">  listen 81;</span><br><span class="line">  server_name www.domain1.com;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://www.domain2.com:8080; <span class="comment"># 反向代理</span></span><br><span class="line">    proxy_cookie_domain www.domain2.com www.domain1.com; <span class="comment"># 修改cookie里域名</span></span><br><span class="line">    index index.html index.htm;</span><br><span class="line">    <span class="comment"># 当用webpack-dev-server等中间件代理接口访问nginx时，此时无浏览器参与</span></span><br><span class="line">    <span class="comment"># 所以没有同源限制，下面的跨域配置可不启用</span></span><br><span class="line">    add_header Access-Control-Allow-Origin http://www.domain1.com; <span class="comment"># 当前端只跨域不带cookie时，可为 *</span></span><br><span class="line">    add_header Access-Control-Allow-Credentails <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="comment">// 前端开关，浏览器是否读写cookie</span></span><br><span class="line">xhr.withCredentails = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 访问nginx中的代理服务器</span></span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'http://www.domain1.com:81/?user=admin'</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure><p>node.js后台示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> server = http.createServer()</span><br><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>)</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> params = qs.parse(req.url.substring(<span class="number">2</span>))</span><br><span class="line">  <span class="comment">// 向前台写cookie</span></span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">'Set-Cookie'</span>: <span class="string">'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'</span></span><br><span class="line">    <span class="comment">// 设置HttpOnly 前端无法通过document.cookie读取</span></span><br><span class="line">  &#125;)</span><br><span class="line">  res.write(<span class="built_in">JSON</span>.stringify(params))</span><br><span class="line">  res.end()</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">8080</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'server is running at port 8080'</span>)</span><br></pre></td></tr></table></figure><h2 id="常见安全问题及思考"><a href="#常见安全问题及思考" class="headerlink" title="常见安全问题及思考"></a>常见安全问题及思考</h2><h3 id="JSONP导致的安全问题"><a href="#JSONP导致的安全问题" class="headerlink" title="JSONP导致的安全问题"></a>JSONP导致的安全问题</h3><p>我们知道，一切用户输入都是“有害”的。传入callback值会在结果里面直接返回。因此，如果该参数过滤不严格，会导致XSS</p><ol><li>Callback可自定义导致的安全问题</li></ol><p>当输出 JSON 时，没有严格定义好 Content-Type（ Content-Type: application/json ）然后加上 callback 这个输出点没有进行过滤直接导致了一个典型的 XSS 漏洞。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">v</span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">  alert(v.name);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://0.0.0.0/1.php?callback=test"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$callback = $_GET[<span class="string">'callback'</span>]</span><br><span class="line"><span class="keyword">print</span> $callback.<span class="string">'(&#123; "id": "1", "name": "vincent" &#125;);'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>对于这种漏洞，主要修复手段：</p><ul><li>严格定义 <code>Content-Type: application/json</code></li><li>过滤callback以及JSON数据输出(针对输出结果进行转码处理)</li></ul><ol><li>json劫持</li></ol><p>json劫持属于CSRF的范畴。攻击者可以在自己的站点中写入一条访问JSON的JS，在用户cookie未过期的情况下，JSON中会返回敏感的用户信息，然后攻击者可以获取到数据，并发送到自己的站点</p><p>敏感数据获取程序如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// alert(v.name)</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> url = <span class="string">'http://0.0.0.0/'</span> + <span class="built_in">JSON</span>.stringify(data)</span></span><br><span class="line"><span class="javascript">  xhr.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>)</span></span><br><span class="line"><span class="undefined">  xhr.send()</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://x.x.x.x/1.php?callback=test"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是<code>Content-Type</code>和<code>X-Content-Type-Options</code>头，如果在API请求的响应标头中，<code>X-Content-Type-Options</code>设置为<code>nosniff</code>，则必须将<code>Content-Type</code>设置为 JS(text/javascript、application/javascript, text/ecmascript)来在所有浏览器上生效。这是因为通过在响应中包含回调，响应不再是JSON，而是JavaScript</p><p>若配置</p><pre><code>header(&apos;Content-type: application/json; chartset=utf-8&apos;)header(&apos;X-Content-Type-Options: nosniff&apos;)</code></pre><p>console输入如下：</p><pre><code>Refused to execute script from &apos;http://10.59.0.248/1.php?callback=test&apos; because its MIME type (&apos;application/json&apos;) is not executable, and strict MIME type checking is enabled.</code></pre><p>常见的修复方案：</p><ol><li>Referer正则匹配</li></ol><p>常见的有Referer匹配正则编写错误导致正则绕过。（一般情况下浏览器直接访问某URL是不带Referer的，所以很多防御部署是允许空Referer的）</p><ol><li>添加Token</li><li>放弃使用jsonp跨域获取数据，使用CORS或PostMessage</li></ol><h3 id="CORS的安全性问题"><a href="#CORS的安全性问题" class="headerlink" title="CORS的安全性问题"></a>CORS的安全性问题</h3><p>重点参考这篇</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#" target="_blank" rel="noopener">MDN HTTP访问控制（CORS）</a></p><p><a href="https://dailc.github.io/2018/01/04/security_ajaxissafeornot.html" target="_blank" rel="noopener">AJAX请求真的不安全么？谈谈Web安全与AJAX的关系</a></p><p>Access-Control-Allow-Origin就是一个允许请求的域白名单，只有是这个域里有的，服务器才会统一跨域请求，如果合理的设置白名单，反而可以避免CSRF攻击。</p><p>设置成*的一般是公共的API，为了避免被频繁请求或DDOS，一般会多出密钥验证的步骤，并且限制请求频率和次数。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">浏览器同源政策及其规避方法</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></li><li><a href="http://www.cnblogs.com/hustskyking/archive/2013/03/31/CDS-introduce.html" target="_blank" rel="noopener">JavaScript跨域（1）：什么是跨域，如何跨域</a></li><li><a href="http://www.cnblogs.com/hustskyking/articles/ten-methods-cross-domain.html" target="_blank" rel="noopener">跨域资源共享的10种方式</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#" target="_blank" rel="noopener">MDN HTTP访问控制（CORS）</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/domain#helloworld" target="_blank" rel="noopener">MDN - Document.domain</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">MDN - 浏览器的同源策略</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#" target="_blank" rel="noopener">MDN HTTP访问控制（CORS）</a></li><li><a href="https://dailc.github.io/2018/01/04/security_ajaxissafeornot.html" target="_blank" rel="noopener">AJAX请求真的不安全么？谈谈Web安全与AJAX的关系</a></li></ul>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【JS】学习正则表达式</title>
      <link href="/2018/06/29/%E3%80%90JS%E3%80%91%E5%AD%A6%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/06/29/%E3%80%90JS%E3%80%91%E5%AD%A6%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote><p>最近因工作用到了，顺便查看了一些关于正则的博客，确实非常使用。学好正则看来是以后的一个必选项，趁着最近时间挺充裕的，于是系统的入门了一下，也算是能手写几个简单的正则来匹配规则了。</p></blockquote><a id="more"></a><h3 id="子字符串匹配和替换"><a href="#子字符串匹配和替换" class="headerlink" title="子字符串匹配和替换"></a>子字符串匹配和替换</h3><p>如果只想知道某个字符串是否包含在一个更大的字符串中，下面的 String.prototype 方法就可以实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="string">'As I was going to Saint Ives'</span></span><br><span class="line">input.startsWith(<span class="string">'As'</span>) <span class="comment">// true</span></span><br><span class="line">input.endsWith(<span class="string">'Ives'</span>) <span class="comment">// true</span></span><br><span class="line">input.startsWith(<span class="string">'going'</span>, <span class="number">9</span>) <span class="comment">// true - 从下标9开始数</span></span><br><span class="line">input.endsWith(<span class="string">'going'</span>, <span class="number">14</span>) <span class="comment">// true - 将下标14当作字符串结尾</span></span><br><span class="line">input.includes(<span class="string">'going'</span>) <span class="comment">// true</span></span><br><span class="line">input.includes(<span class="string">'going'</span>, <span class="number">10</span>) <span class="comment">// false - 从下标10开始</span></span><br><span class="line">input.indexOf(<span class="string">'going'</span>) <span class="comment">// 9</span></span><br><span class="line">input.indexOf(<span class="string">'going'</span>, <span class="number">10</span>) <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 若想进一步操作，如替换掉刚才匹配的字符串，可以使用String.prototype.replace</span></span><br><span class="line"><span class="keyword">const</span> output = input.replace(<span class="string">'going'</span>, <span class="string">'walking'</span>)</span><br></pre></td></tr></table></figure><h3 id="构造正则表达式"><a href="#构造正则表达式" class="headerlink" title="构造正则表达式"></a>构造正则表达式</h3><p>在 JS 中，正则可以通过 RegExp 类来表示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re1 = <span class="regexp">/going/</span> <span class="comment">// 可以搜索 'going'的正则表达式</span></span><br><span class="line"><span class="keyword">const</span> re2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'going'</span>) <span class="comment">// 使用对象构造器的等价形式</span></span><br></pre></td></tr></table></figure><h3 id="使用正则进行搜索"><a href="#使用正则进行搜索" class="headerlink" title="使用正则进行搜索"></a>使用正则进行搜索</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="string">'As I was going to Saint Ives'</span></span><br><span class="line"><span class="keyword">const</span> re = <span class="regexp">/\w&#123;3,&#125;/gi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串(input)开始</span></span><br><span class="line">input.match(re) <span class="comment">// ['was', 'going', 'Saint', 'Ives']</span></span><br><span class="line">input.search(re) <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从正则表达式开始(re)</span></span><br><span class="line">re.test(input) <span class="comment">// true - input至少包含一个三个字母的单词</span></span><br><span class="line">re.exec(input) <span class="comment">// ['was'] (第一个匹配)</span></span><br><span class="line">re.exec(input) <span class="comment">// ['going'] (exec会记住它所在的位置)</span></span><br><span class="line">re.exec(input) <span class="comment">// ['Saint']</span></span><br><span class="line">re.exec(input) <span class="comment">// ['Ives']</span></span><br><span class="line">re.exec(input) <span class="comment">// null - 匹配完毕</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，所有这些方法都可以直接使用字面量语法</span></span><br><span class="line">input.match(<span class="regexp">/\w&#123;3,&#125;/gi</span>)</span><br><span class="line">input.search(<span class="regexp">/\w&#123;3,&#125;/gi</span>)</span><br><span class="line">;<span class="regexp">/\w&#123;3,&#125;/gi</span>.test(input)</span><br><span class="line">;<span class="regexp">/\w&#123;3,&#125;/gi</span>.exec(input)</span><br></pre></td></tr></table></figure><h3 id="使用正则表达式进行替换"><a href="#使用正则表达式进行替换" class="headerlink" title="使用正则表达式进行替换"></a>使用正则表达式进行替换</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="string">'As I was going to Saint Ives'</span></span><br><span class="line"><span class="keyword">const</span> output = input.replace(<span class="regexp">/\w&#123;3,&#125;/gi</span>, <span class="string">'****'</span>)</span><br></pre></td></tr></table></figure><h3 id="匹配-HTML"><a href="#匹配-HTML" class="headerlink" title="匹配 HTML"></a>匹配 HTML</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> html1 = <span class="string">`</span></span><br><span class="line"><span class="string">  HTML width &lt;a href="/one"&gt;one link&lt;/a&gt;, and some JavaScript.</span></span><br><span class="line"><span class="string">  &lt;script src="strff.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> matches = html.match(<span class="regexp">/&lt;area|&lt;a|&lt;link|&lt;script|&lt;source/gi</span>)</span><br></pre></td></tr></table></figure><p>要了解的是，现在来说正则表达式不能解析 HTML。为解决这个问题，需引入一个解析器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> html2 = <span class="string">'&lt;br&gt; [!CDATA[&lt;br&gt;]]'</span></span><br><span class="line"><span class="keyword">const</span> matches = html.match(<span class="regexp">/&lt;br&gt;/gi</span>) <span class="comment">// ['&lt;br&gt;', '&lt;br&gt;']</span></span><br></pre></td></tr></table></figure><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>字符集提供了一种简洁的方式，来表达单个字符的分支。如果想在一个字符串中查找所有的数字，可以使用分支：</p><p><strong>具名字符集</strong></p><p>\d [0-9]<br>\D [^0-9]<br>\s [\t\v\n \r] 包含制表符、空格和垂直制表符<br>\S [^\t\v\n \r]<br>\w [a-zA-Z_] 破折号和句号没有被包含进来，所以它不能用于域名和 CSS 类<br>\W [^a-za-z_]</p><h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><p><strong>重复修饰符</strong></p><p><code>{n}</code> 精确 n 次<br>/\d{5}/ 匹配 5 位数字</p><p><code>{n,}</code> 至少 n 次<br>/\d{5,}/ 匹配 5 位或 5 位以上数字</p><p><code>{n, m}</code> 最少 n 次，最多 m 次<br>/\d{2,5}/ 匹配 2 到 5 位数字</p><p><code>?</code> 0 或 1 次，等价于{0,1}<br>/[a-z]\d?/i 匹配跟随了 0 个或 1 个数字的字符</p><p><code>*</code> 0 次或多次<br>/[a-z]\d*/i 匹配跟随了 0 个或多个数字的字母</p><p><code>+</code> 1 次或多次<br>/[a-z]\d+/i 匹配了至少跟随了 1 个数字的字母</p><h3 id="句点元字符和转义"><a href="#句点元字符和转义" class="headerlink" title="句点元字符和转义"></a>句点元字符和转义</h3><p>在正则中，句点是一个特殊的字符，表示“匹配任何内容”（除了新的一行）。通常，这个匹配一切的元字符用来消费哪些输入中并不关心的内容。</p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>到目前为止，所构造的正则能够识别单个字符（重复允许多次匹配，但这依旧是一个单字符匹配）。而分组则允许构造子表达式，它可以被当作一个独立单元来使用。</p><p>除了创建子表达式，分组还可以帮助“捕获”分组结果，以便后续使用。<br>“捕获”结果是默认功能，不过也有办法创建“非捕获组”，这也是接下来要学习的内容。</p><p>分组是使用圆括号来指定的，非捕获组看起来像 <code>(?:&lt;subexpression&gt;)</code>，其中<subexpression>是需要匹配的内容</subexpression></p><p>看组例子，假设现在要匹配的后缀为.com .org .edu 的域名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">'Visit oreilly.com today!'</span></span><br><span class="line"><span class="keyword">const</span> match = text.match(<span class="regexp">/[a-z]+(?:\.com|\.org|\.edu)/i</span>)</span><br></pre></td></tr></table></figure><p>分组的另一个好处是可以在分组时使用重复。一般情况下，重复仅被用在重复元字符前面的单个字符上。分组则允许将其用在一整个字符串上。有一个常见的例子是，如果想匹配 URL,以及那些以http://或https://（独立于协议的URL）开始的URL，可以在分组上使用代表匹配0个或1个<code>?</code>的重复元字符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;link rel="stylesheet" href="http://insecure.com/stuff.css"&gt;</span></span><br><span class="line"><span class="string">  &lt;link rel="stylesheet" href="https://secure.com/securestuff.css"&gt;</span></span><br><span class="line"><span class="string">  &lt;link rel="stylehseet" href="//anything.comflexible.css"&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> matches = html.match(<span class="regexp">/(?:https?)?\/\/[a-z][a-z0-9-]+[a-z0-9]+/gi</span>)</span><br></pre></td></tr></table></figure><p>以一个非捕获组开始 (?:https?)? ，注意这里有两个匹配 0 或 1 个的重复元字符</p><p>第一个表示 https 的 s 是可选的（一般情况下重复元字符只作用于它左边最近的字符）第二个指向它左边的整个组（整体来看，它会匹配空字符串：没有 https、http 或者 https）</p><p>继续执行，匹配了两个斜杠 \/\/ (必须对斜杠进行转义)<br>然后得到了一个复杂的字符类。</p><blockquote><p>需要记住一点，使用正则时并不需要一次做完所有事情。事实上，每当浏览网站时，可以先找出所有 URL 或疑似 URL 的东西，然后做二次分析，筛选出那些非法或不完整的 URL 等。 但，为防止注入攻击而检查用户输入等情况就要让正则滴水不漏</p></blockquote><hr><h3 id="懒惰匹配、贪婪匹配"><a href="#懒惰匹配、贪婪匹配" class="headerlink" title="懒惰匹配、贪婪匹配"></a>懒惰匹配、贪婪匹配</h3><p>例：html 文本，想将其中的<code>&lt;i&gt;</code>标签替换成<code>&lt;source&gt;</code>标签，下面是第一次尝试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = <span class="string">`</span></span><br><span class="line"><span class="string">  Regex pros know the difference between</span></span><br><span class="line"><span class="string">  &lt;i&gt;greedy&lt;/i&gt; and &lt;i&gt;lazy&lt;/i&gt; matching.</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">input.replace(<span class="regexp">/&lt;i&gt;(.*)&lt;\/i&gt;/gi</span>, <span class="string">'&lt;strong&gt;$1&lt;/strong&gt;'</span>)</span><br><span class="line"><span class="comment">// Regex pros know the difference between</span></span><br><span class="line"><span class="comment">// &lt;strong&gt;greedy&lt;/i&gt; and &lt;i&gt;lazy&lt;/strong&gt; matching.</span></span><br></pre></td></tr></table></figure><p>我们认识一下正则表达式引擎的工作方式，它只有在找到符合要求的匹配后，才会消费输入并且继续运行。默认情况下，它是通过贪婪模式来实现的，它会找到第一个<code>&lt;i&gt;</code>，然后，在找到<code>&lt;/i&gt;</code>并且确定在这个<code>&lt;/i&gt;</code>之后不存在同样的<code>&lt;/i&gt;</code>，查找都不会停止。因为这里有两个<code>&lt;/i&gt;</code>，所以正则会匹配到第二个<code>&lt;/i&gt;</code>，而非第一个。</p><p>这里可以使用重复元字符 * 将其转换成懒惰匹配来解决，在后面添加一个问号即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = <span class="string">`</span></span><br><span class="line"><span class="string">  Regex pros know the difference between</span></span><br><span class="line"><span class="string">  &lt;i&gt;greedy&lt;/i&gt; and &lt;i&gt;lazy&lt;/i&gt; matching.</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">input.replace(<span class="regexp">/&lt;i&gt;(.*?)&lt;\/i&gt;/gi</span>, <span class="string">'&lt;strong&gt;$1&lt;/strong&gt;'</span>)</span><br></pre></td></tr></table></figure><p>与之前相比，该正则除了在*后面加了一个问号，其他完全一样。</p><p>所有的重复元字符： _ + ？ {n} {n, } {n, m}都可以在后面跟随一个问号将它变成懒惰的（虽然在实践中，通常只把它和_ + 一起使用过）</p><h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>先由简单例子入手，假设想匹配符合 XYXY 格式的乐队名字，所以当希望匹配（PJJP、GOOG、ANNA）这些乐队名时，反向引用就可以登场了。正则表达式中的每个组（包括子组）都被分配了一个数字，从左到右依次是 1，2，3…可以通过在反斜杠后加一个数字的方式来引用特定的组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promo = <span class="string">'Opening for XAAX is the dynamic GOOG! At the box office now !'</span></span><br><span class="line"><span class="keyword">const</span> bands = promo.match(<span class="regexp">/(?:[A-Z])(?:[A-Z])/g</span>)</span><br><span class="line"><span class="comment">// 使用重音符，是因为我们将单引号和双引号都用过了</span></span><br><span class="line"><span class="keyword">const</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;img alt="A 'simple' example."&gt;</span></span><br><span class="line"><span class="string">  &lt;img alt="Don't abuse it!"&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> matches = html.match(<span class="regexp">/&lt;img alt=(?:['"]).*?/g</span>)</span><br></pre></td></tr></table></figure><h3 id="替换组"><a href="#替换组" class="headerlink" title="替换组"></a>替换组</h3><p>分组带来的好处是，可以利用它做一些更加复杂的替换，继续看 HTML 的例子，加入想要去掉一个<code>&lt;a&gt;</code>标签中除了 href 以外的内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> html = <span class="string">`&lt;a class="nope" href="/yep"&gt;Yep&lt;/a&gt;`</span></span><br><span class="line"><span class="keyword">let</span> str = html.replace(<span class="regexp">/&lt;a .*?(href=".*?").*?/</span>, <span class="string">'&lt;a $1&gt;'</span>)</span><br><span class="line"><span class="comment">// str -&gt; "&lt;a href="/yep"&gt;&gt;Yep&lt;/a&gt;"</span></span><br></pre></td></tr></table></figure><p>所有的组都被分配了一个从 1 开始的数字，这个正则表达式中，通过\1 来引用第一个组；而在替换字符串上，用的是$1。注意，在这个表达式中使用懒惰量词是为了防止它在匹配时跨域多个<code>&lt;a&gt;</code>标签。不过，如果<code>&lt;a&gt;</code>标签的 href 属性使用的是单引号而非双号，也会匹配失败。</p><p>下面来扩展这个例子，希望保持 class 和 href，依旧删除其他元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> html = <span class="string">`&lt;a class="yep" href="/yep" id="nope"&gt;Yep&lt;/a&gt;`</span></span><br><span class="line"><span class="keyword">let</span> str = html.replace(<span class="regexp">/&lt;a .*?(class=".*?").*?(href=".*?").*?&gt;/</span>, <span class="string">'&lt;a $2 $1&gt;'</span>)</span><br></pre></td></tr></table></figure><p>注意在这个表达式中，将 class 和 href 的顺序颠倒了，使得 href 始终先出现，这个表达啊是的问题在于 class 和 href 始终要保持相同的顺序，并且，一旦<code>&lt;a&gt;</code>标签中的属性使用了单引号，就会匹配失败</p><p>除了$1,$2,$3…这些组引用，还有$` 匹配项之前的所有内容， $&amp; 匹配目标本身， $’匹配项之后的所有内容，如果想使用一个美元符号，可以使用$$:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="string">'One two three'</span></span><br><span class="line">input.replace(<span class="regexp">/two/</span>, <span class="string">'($`)'</span>) <span class="comment">// "One (One ) three"</span></span><br><span class="line">input.replace(<span class="regexp">/\w+/g</span>, <span class="string">'($&amp;)'</span>) <span class="comment">// "(One) (two) (three)"</span></span><br><span class="line">input.replace(<span class="regexp">/two/</span>, <span class="string">"($')"</span>) <span class="comment">// "One ( three) three"</span></span><br><span class="line">input.replace(<span class="regexp">/two/</span>, <span class="string">'($$)'</span>) <span class="comment">// "One ($) three"</span></span><br></pre></td></tr></table></figure><h3 id="函数替换"><a href="#函数替换" class="headerlink" title="函数替换"></a>函数替换</h3><p>这是正则最棒的一个特性之一，因为它允许将一个非常复杂的正则表达式拆分成一些简单的表达式。</p><p>再来看一个实际修改 HTML 的例子：希望保留 class, id, href 属性并删除其他内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;a class="foo" href="/foo" id="foo"&gt;Foo&lt;/a&gt;</span></span><br><span class="line"><span class="string">  &lt;A href='/foo' Class="foo"&gt;Foo&lt;/a&gt;</span></span><br><span class="line"><span class="string">  &lt;a href="/foo"&gt;Foo&lt;/a&gt;</span></span><br><span class="line"><span class="string">  &lt;a onclick="javascript:alert('foo!')" href="/foo"&gt;Foo&lt;/a&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>用正则来实现感觉很麻烦，因为变化太多！确实，不过之前说过，并不一定要一次到位。可以通过将表达式拆分成两个，从而大大减少变化的数量：一个用于识别<code>&lt;a&gt;</code>标签，而另一个用于将<code>&lt;a&gt;</code>替换成期望的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sanitizeATag</span>(<span class="params">aTag</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取标签</span></span><br><span class="line">  <span class="keyword">const</span> parts = aTag.match(<span class="regexp">/&lt;a\s+(.*?)&gt;(.*?)&lt;\/a&gt;/i</span>)</span><br><span class="line">  <span class="comment">// parts[1]是&lt;a&gt;标签中间的属性</span></span><br><span class="line">  <span class="comment">// parts[2]是&lt;a&gt;和&lt;/a&gt;中间的内容</span></span><br><span class="line">  <span class="keyword">const</span> attributes = parts[<span class="number">1</span>]</span><br><span class="line">    <span class="comment">// 接下来将其分割成独立的属性</span></span><br><span class="line">    .split(<span class="regexp">/\s+/</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&lt;a <span class="subst">$&#123;attributes</span></span></span><br><span class="line"><span class="string"><span class="subst">    .filter(attr =&gt; <span class="regexp">/^(?:class|id|href)[\s=]/i</span>.test(attr))</span></span></span><br><span class="line"><span class="string"><span class="subst">    .join(<span class="string">' '</span>)&#125;</span>&gt;</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;parts[<span class="number">2</span>]&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/a&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数比想象中要长，不过为了更加清晰，可以将它分成不同的部分。注意即使在这个函数中，依旧使用了多个正则表达式：一个用来匹配<code>&lt;a&gt;</code>，一个用来切割（使用一个正则表达十来识别一个或多个空格字符）字符串，还有一个用来过滤期望的属性。如果只用一个正则表达式来完成这些工作将会非常复杂。</p><p>接下来：在一个包含很多<code>&lt;a&gt;</code>的 HTML 块中使用 sanitizeATag 函数，编写一个只匹配<code>&lt;a&gt;</code>的正则表达式就很简单了：</p><pre><code>html.match(/&lt;a .*?&gt;(.*?)&lt;\/a&gt;/ig);</code></pre><p>在匹配时，可以将函数当作一个替换参数传给 String.prototype.replace。目前为止，只 ongoing 过字符串作为替换参数。而使用函数则允许对每一个替换执行一个特定的操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">html.replace(<span class="regexp">/&lt;a .*?&gt;(.*?)&lt;\/a&gt;/gi</span>, <span class="function"><span class="keyword">function</span>(<span class="params">m, g1, offset</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`&lt;a&gt; tag found at <span class="subst">$&#123;offset&#125;</span>. contents: <span class="subst">$&#123;g1&#125;</span>&lt;/a&gt;`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*undefined</span></span><br><span class="line"><span class="comment">  undefined</span></span><br><span class="line"><span class="comment">  undefined</span></span><br><span class="line"><span class="comment">  undefined</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// &lt;a&gt; tag found at 3. contents: Foo&lt;/a&gt;</span></span><br><span class="line"><span class="comment">// &lt;a&gt; tag found at 49. contents: Foo&lt;/a&gt;</span></span><br><span class="line"><span class="comment">// &lt;a&gt; tag found at 86. contents: Foo&lt;/a&gt;</span></span><br><span class="line"><span class="comment">// &lt;a&gt; tag found at 111. contents: Foo&lt;/a&gt;</span></span><br></pre></td></tr></table></figure><p>传给 String.prototype.replace 的函数会按顺序接收以下参数：</p><ul><li>整个匹配的字符串(等价于$&amp;)</li><li>匹配上的组(如果存在)，有多少个组，这种参数就会有多少个</li><li>原始字符串中的匹配偏移量(一个数字)</li><li>原始字符串(很少使用到)</li></ul><p>该函数的返回值就是用来替换正则表达式的字符串。在上例中，没有指定返回值，所以默认返回 undefined。它会被转换成字符串后当作替换字符串使用。上例的重点就是强调这种工作机制，而非真实的转换，所以这里并没有返回最终结果。现在来回顾一下这个例子，有了能够清理单个<code>&lt;a&gt;</code>标签的函数，以及在 HTML 中查找<code>&lt;a&gt;</code>标签的方法，所以可以将它们结合起来使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html.replace(<span class="regexp">/&lt;a .*?&lt;\/a&gt;/gi</span>, sanitizeATag)</span><br></pre></td></tr></table></figure><p>当需要从一个大字符串中匹配小字符串，并且还要对小字符串做额外处理时，都可以通过向<code>String.prototype.replace</code>中传入函数来解决这个问题！</p><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>通常，我们会关心一个字符串的开始和结束，或者整个字符串（而不只是一部分），这时<code>锚点</code>就派上用场了。有两种锚点：分别是用于匹配行开始的<code>^</code>，以及用于匹配行结束的<code>$</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="string">'It was the best of times, it was the worst of times'</span></span><br><span class="line"><span class="keyword">const</span> begin = input.match(<span class="regexp">/^\w+/g</span>) <span class="comment">// "It"</span></span><br><span class="line"><span class="keyword">const</span> end = input.match(<span class="regexp">/\w+$/g</span>) <span class="comment">// "times"</span></span><br><span class="line"><span class="keyword">const</span> everything = input.match(<span class="regexp">/^.*$/g</span>)</span><br><span class="line"><span class="comment">// "It was the best of times, it was the worst of times"</span></span><br><span class="line"><span class="keyword">const</span> nomatch1 = input.match(<span class="regexp">/^best/gi</span>)</span><br><span class="line"><span class="keyword">const</span> nomatch2 = input.match(<span class="regexp">/worst$/gi</span>)</span><br></pre></td></tr></table></figure><p>关于锚点，一般情况下，它匹配的是整个 字符串的开始和末尾，即使字符串中有换行。如果想把某个字符串当作多行字符串（以换行符分隔）来处理，就需要用到 m(多行选项)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="string">'One line\nTwo lines\nThree lines\nFour'</span></span><br><span class="line"><span class="keyword">const</span> begin = input.match(<span class="regexp">/^\w+/gm</span>)</span><br><span class="line"><span class="keyword">const</span> end = input.match(<span class="regexp">/\w+$/gm</span>)</span><br></pre></td></tr></table></figure><h3 id="单词边界匹配"><a href="#单词边界匹配" class="headerlink" title="单词边界匹配"></a>单词边界匹配</h3><p>正则中一个经常被忽视，但却非常有用的特性。类似开始锚点和行末锚点，单词边界匹配的是\b，取反是\B，它不消费输入内容。单词边界界定为一个\w 匹配之前或之后紧挨着一个\W（非单词字符），或字符串的开始或结尾。来看个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inputs = [</span><br><span class="line">  <span class="string">'yinlinshengxiao@gmail.com'</span>,</span><br><span class="line">  <span class="string">'yinlinshengxiao@gmail.com is my email'</span>,</span><br><span class="line">  <span class="string">'my email is yinlinshengxiao@gmail.com'</span>,</span><br><span class="line">  <span class="string">'use yinlinshengxiao@gmail.com, my email'</span>,</span><br><span class="line">  <span class="string">'my email: yinlinshengxiao@gmail.com.'</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">  虽然有多种不同情况，这些邮箱有一个共同点：它们都处在单词边界。</span></span><br><span class="line"><span class="string">  单词边界标记的另一个好处是，因为它们不消费输入，所以不用担心“将它们放回”到替换字符串中：</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> emailMatcher = <span class="regexp">/\b[a-z][a-z0-9._-]*@[a-z][a-z0-9_-]+\.[a-z]+(?:\.[a-z]+)?\b/gi</span></span><br><span class="line">inputs.map(<span class="function"><span class="params">s</span> =&gt;</span> s.replace(emailMatcher, <span class="string">'&lt;a href="mailto:$&amp;"&gt;$&amp;&lt;/a&gt;'</span>))</span><br></pre></td></tr></table></figure><p>当需要搜索以外的单词开始、结束或包含其他单词的文本时，使用单词边界也非常方便。例如：/\bcount/ 会找到 count countdown， 但不会找到 discount recount 等。而 /\bcount\B/只能找到 countdown，/\Bcount\b/会找到 discount 和 recount，而 /\Bcount\B/只能找到 accountable</p><h3 id="向前查找"><a href="#向前查找" class="headerlink" title="向前查找"></a>向前查找</h3><p>与锚点和单词边界元字符一样，它不消费输入。然而，不同于锚点和单词边界的是，它们是通用的，可以匹配任何子表达式却不消费它。事实上，正如单词边界元字符，向前查找的这种不消费的特性，解决了有时候不得不进行“原封不动”的替换问题。只要有内容重复，向前查找就是必须的，而且他们可以简化某些特定类型的匹配。</p><p>例子：验证密码是否符合预设规则</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validPassword</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    /[A-Z]/.test(p) &amp;&amp;</span><br><span class="line">    /[<span class="number">0</span><span class="number">-9</span>]/.test(p) &amp;&amp;</span><br><span class="line">    /[a-z]/.test(p) &amp;&amp;</span><br><span class="line">    !<span class="regexp">/[^a-zA-Z0-9]/</span>.test(p)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 假设想将它们组合成一个正则表达式：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validPassword</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/[A-Z].*[0-9][a-z]/</span>.test(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该表达式对顺序有要求，不仅要求大写字母出现在数字之前，数字出现在两个小写字母前，而且没有对非法字符做任何校验。实际上也没有有个好办法可以实现它，因为字符在正则表达式运行时就被消费了。</p><p><code>向前查找</code>通过不消费输入来解决这个问题，本质上每个向前查找都是一个不消费输入的独立正则表达式，在 JS 中，向前查找是这样的 <code>(?=&lt;subexpression&gt;)</code>, 还有一个“否定向前查找” <code>:(?!&lt;subexpression&gt;)</code> 只会匹配不存在于子表达式中的内容。下面继续来重写上面的验证密码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validPassword</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/(?=.*[A-Z])(?=.*[0-9])(?=.*[a-z])(?!.*[^a-zA-Z0-9])/</span>.test(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该例子展示了向前检查（以及否定向前检查）的一个重要场景。</p><h3 id="动态构造正则表达式"><a href="#动态构造正则表达式" class="headerlink" title="动态构造正则表达式"></a>动态构造正则表达式</h3><p>这里提倡优先使用正则表达式字面语法而非构造器，因为不用对反斜杠进行转义。需要使用构造器的地方是动态构造。例如，想在一个字符串中匹配一个包含多个用户名的数组，但却没有办法将这些用户名整合在一个正则表达式字面量中。此时正则构造器就有用了，它可以通过字符串来构造正则表达式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = [<span class="string">'mary'</span>, <span class="string">'nick'</span>, <span class="string">'arthur'</span>, <span class="string">'sam'</span>, <span class="string">'yevtte'</span>]</span><br><span class="line"><span class="keyword">const</span> text =</span><br><span class="line">  <span class="string">'User @arthur started the backup and 15:15, '</span> +</span><br><span class="line">  <span class="string">'and @nick and @yvette restored it at 18:35.'</span></span><br><span class="line"><span class="keyword">const</span> userRegexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`@(?:<span class="subst">$&#123;users.join(<span class="string">'|'</span>)&#125;</span>)\\b`</span>, <span class="string">'g'</span>)</span><br><span class="line">text.match(userRegexp)</span><br></pre></td></tr></table></figure><p>与该例正则等价的字面量是： <code>/@(?:mary|nick|arthur|sam|yevtte)\b/g</code><br>需要注意的是：必须在 b 单词边界元字符之前使用双反斜杠</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一篇已经涉及了正则表达式中的主要知识点，但对于正则中包含的技术、例子和其固有的复杂性，也只是浅尝辄止。想要深入学习正则表达式，需要更多的练习与理解，那么以后在工作与学习中多多运用进去吧。</p>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【JS】变量声明与赋值，引用、值传递与对象拷贝</title>
      <link href="/2018/06/23/%E3%80%90JS%E3%80%91%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%8E%E8%B5%8B%E5%80%BC%EF%BC%8C%E5%BC%95%E7%94%A8%E3%80%81%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/"/>
      <url>/2018/06/23/%E3%80%90JS%E3%80%91%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%8E%E8%B5%8B%E5%80%BC%EF%BC%8C%E5%BC%95%E7%94%A8%E3%80%81%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D/</url>
      <content type="html"><![CDATA[<blockquote><p>夯实基础系列。虽然想整理之前测试相关的东西，不过最近看书有讲到这个，遂将之前收藏的博客、文章结合书里的讲解做了一些整理和例子来加深这块的印象。（今天也才把测试的看了没来得及整理）</p></blockquote><a id="more"></a><p>ES6 为我们引入了 <code>let</code> 与 <code>const</code> 两种新的变量声明关键字，同时也引入了块作用域；本文首先介绍 ES6 中常用的三种变量声明方式，然后讨论了 JavaScript 按值传递的特性以及多种的赋值方式，最后介绍了复合类型拷贝的技巧</p><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>在 JavaScript 中，基本的变量声明可以用 var 方式；JavaScript 允许省略 var，直接对未声明的变量赋值。也就是说，var a = 1 与 a = 1，这两条语句的效果相同。但是由于这样的做法很容易不知不觉地创建全局变量（尤其是在函数内部），所以建议总是使用 var 命令声明变量。在 ES6 中，对于变量声明的方式进行了扩展，引入了 let 与 const。var 与 let 两个关键字创建变量的区别在于， var 声明的变量作用域是最近的函数块；而 let 声明的变量作用域是最近的闭合块，往往会小于函数块。另一方面，以 let 关键字创建的变量虽然同样被提升到作用域头部，但是并不能在实际声明前使用；如果强行使用则会抛出 ReferenceError 异常。</p><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><p>var 是 JavaScript 中基础的变量声明方式之一，其基本语法为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="comment">// Declaration and initialization</span></span><br><span class="line">x = <span class="string">'Hello World'</span> <span class="comment">// Assignment</span></span><br><span class="line"><span class="comment">// Or all in one</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="string">'Hello World'</span></span><br></pre></td></tr></table></figure><p>ECMAScript 6 以前我们在 JavaScript 中并没有其他的变量声明方式，以 var 声明的变量作用于函数作用域中，如果没有相应的闭合函数作用域，那么该变量会被当做默认的全局变量进行处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> hello = <span class="string">'Hello World'</span></span><br><span class="line">  <span class="keyword">return</span> hello</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(hello)</span><br></pre></td></tr></table></figure><p>像如上这种调用方式会抛出异常: ReferenceError: hello is not defined，因为 hello 变量只能作用于 sayHello 函数中，不过如果按照如下先声明全局变量方式再使用时，其就能够正常调用:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="string">'Hello World'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> hello</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(hello)</span><br></pre></td></tr></table></figure><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>在 ECMAScript 6 中我们可以使用 let 关键字进行变量声明:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x <span class="comment">// Declaration and initialization</span></span><br><span class="line">x = <span class="string">'Hello World'</span> <span class="comment">// Assignment</span></span><br><span class="line"><span class="comment">// Or all in one</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="string">'Hello World'</span></span><br></pre></td></tr></table></figure><p>let 关键字声明的变量是属于块作用域，也就是包含在 {} 之内的作用于。使用 let 关键字的优势在于能够降低偶然的错误的概率，因为其保证了每个变量只能在最小的作用域内进行访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Peter'</span></span><br><span class="line"><span class="keyword">if</span> (name === <span class="string">'Peter'</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> hello = <span class="string">'Hello Peter'</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> hello = <span class="string">'Hi'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(hello)</span><br></pre></td></tr></table></figure><p>上述代码同样会抛出 ReferenceError: hello is not defined 异常，因为 hello 只能够在闭合的块作用域中进行访问，我们可以进行如下修改:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Peter'</span></span><br><span class="line"><span class="keyword">if</span> (name === <span class="string">'Peter'</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> hello = <span class="string">'Hello Peter'</span></span><br><span class="line">  <span class="built_in">console</span>.log(hello)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> hello = <span class="string">'Hi'</span></span><br><span class="line">  <span class="built_in">console</span>.log(hello)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以利用这种块级作用域的特性来避免闭包中因为变量保留而导致的问题，譬如如下两种异步代码，使用 var 时每次循环中使用的都是相同变量；而使用 let 声明的 i 则会在每次循环时进行不同的绑定，即每次循环中闭包捕获的都是不同的 i 实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`i:<span class="subst">$&#123;i&#125;</span>`</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`j:<span class="subst">$&#123;j&#125;</span>`</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> k = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`k:<span class="subst">$&#123;k&#125;</span>`</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">i: <span class="number">0</span></span><br><span class="line">i: <span class="number">1</span></span><br><span class="line">j: <span class="number">2</span></span><br><span class="line">j: <span class="number">2</span></span><br><span class="line">k: <span class="number">2</span></span><br><span class="line">k: <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const 关键字一般用于常量声明，用 const 关键字声明的常量需要在声明时进行初始化并且不可以再进行修改，并且 const 关键字声明的常量被限制于块级作用域中进行访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> x;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// okay, block scoped name</span></span><br><span class="line">      <span class="keyword">const</span> x = <span class="string">"sneaky"</span>;</span><br><span class="line">      <span class="comment">// error, const</span></span><br><span class="line">      x = <span class="string">"foo"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// error, already declared in block</span></span><br><span class="line">    <span class="keyword">let</span> x = <span class="string">"inner"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaScript 中 const 限制的并非值不可变性；而是创建了不可变的绑定，即对于某个值的只读引用，并且禁止了对于该引用的重赋值，即如下的代码会触发错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line">numbers = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>] <span class="comment">// error: assignment to constant variable</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers[<span class="number">4</span>])</span><br></pre></td></tr></table></figure><p>我们可以参考如下图片理解这种机制，每个变量标识符都会关联某个存放变量实际值的物理地址；所谓只读的变量即是该变量标识符不可以被重新赋值，而该变量指向的值还是可变的。</p><p>JavaScript 中存在着所谓的原始类型与复合类型，使用 const 声明的原始类型是值不可变的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Example 1</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">10</span></span><br><span class="line">a = a + <span class="number">1</span> <span class="comment">// error: assignment to constant variable</span></span><br><span class="line"># Example 2</span><br><span class="line"><span class="keyword">const</span> isTrue = <span class="literal">true</span></span><br><span class="line">isTrue = <span class="literal">false</span> <span class="comment">// error: assignment to constant variable</span></span><br><span class="line"># Example 3</span><br><span class="line"><span class="keyword">const</span> sLower = <span class="string">'hello world'</span></span><br><span class="line"><span class="keyword">const</span> sUpper = sLower.toUpperCase() <span class="comment">// create a new string</span></span><br><span class="line"><span class="built_in">console</span>.log(sLower) <span class="comment">// print hello world</span></span><br><span class="line"><span class="built_in">console</span>.log(sUpper) <span class="comment">// print HELLO WORLD</span></span><br></pre></td></tr></table></figure><p>而如果我们希望将某个对象同样变成不可变类型，则需要使用 Object.freeze()；不过该方法仅对于键值对的 Object 起作用，而无法作用于 Date、Map 与 Set 等类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Example 4</span><br><span class="line"><span class="keyword">const</span> me = <span class="built_in">Object</span>.freeze(&#123;<span class="attr">name</span>: “Jacopo”&#125;)</span><br><span class="line">me.age = <span class="number">28</span></span><br><span class="line"><span class="built_in">console</span>.log(me.age) <span class="comment">// print undefined</span></span><br><span class="line"># Example 5</span><br><span class="line"><span class="keyword">const</span> arr = <span class="built_in">Object</span>.freeze([<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>]) <span class="comment">// print -1</span></span><br><span class="line"># Example 6</span><br><span class="line"><span class="keyword">const</span> me = <span class="built_in">Object</span>.freeze(&#123;</span><br><span class="line">  name: <span class="string">'Jacopo'</span>,</span><br><span class="line">  pet: &#123;</span><br><span class="line">    type: <span class="string">'dog'</span>,</span><br><span class="line">    name: <span class="string">'Spock'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">me.pet.name = <span class="string">'Rocky'</span></span><br><span class="line">me.pet.breed = <span class="string">'German Shepherd'</span></span><br><span class="line"><span class="built_in">console</span>.log(me.pet.name) <span class="comment">// print Rocky</span></span><br><span class="line"><span class="built_in">console</span>.log(me.pet.breed) <span class="comment">// print German Shepherd</span></span><br></pre></td></tr></table></figure><p>即使是 Object.freeze() 也只能防止顶层属性被修改，而无法限制对于嵌套属性的修改，这一点我们会在下文的浅拷贝与深拷贝部分继续讨论。</p><h2 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h2><h3 id="按值传递"><a href="#按值传递" class="headerlink" title="按值传递"></a>按值传递</h3><p>JavaScript 中永远是按值传递（pass-by-value），只不过当我们传递的是某个对象的引用时，这里的值指的是对象的引用。按值传递中函数的形参是被调用时所传实参的副本。修改形参的值并不会影响实参。而按引用传递（pass-by-reference）时，函数的形参接收实参的隐式引用，而不再是副本。这意味着函数形参的值如果被修改，实参也会被修改。同时两者指向相同的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeStuff</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  a = a * <span class="number">10</span>;</span><br><span class="line">  b.item = <span class="string">"changed"</span>;</span><br><span class="line">  c = &#123;<span class="attr">item</span>: <span class="string">"changed"</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">item</span>: <span class="string">"unchanged"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">item</span>: <span class="string">"unchanged"</span>&#125;;</span><br><span class="line">changeStuff(num, obj1, obj2);</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.item); <span class="comment">// changed</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.item); <span class="comment">// unchanged</span></span><br></pre></td></tr></table></figure><p>JavaScript 按值传递就表现于在内部修改了 c 的值但是并不会影响到外部的 obj2 变量。如果我们更深入地来理解这个问题，JavaScript 对于对象的传递则是按共享传递的（pass-by-sharing，也叫按对象传递、按对象共享传递）。最早由Barbara Liskov. 在1974年的GLU语言中提出；该求值策略被用于Python、Java、Ruby、JS等多种语言。该策略的重点是：调用函数传参时，函数接受对象实参引用的副本(既不是按值传递的对象副本，也不是按引用传递的隐式引用)。 它和按引用传递的不同在于：在共享传递中对函数形参的赋值，不会影响实参的值。按共享传递的直接表现就是上述代码中的 obj1，当我们在函数内修改了 b 指向的对象的属性值时，我们使用 obj1 来访问相同的变量时同样会得到变化后的值。</p><h3 id="连续赋值"><a href="#连续赋值" class="headerlink" title="连续赋值"></a>连续赋值</h3><p>JavaScript 中是支持变量的连续赋值，即譬如：</p><pre><code>var a=b=1;</code></pre><p>为了解释上述问题，我们引入一个新的变量:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">n</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a; <span class="comment">// 持有a，以回查</span></span><br><span class="line">a.x = a = &#123;<span class="attr">n</span>:<span class="number">2</span>&#125;;</span><br><span class="line">alert(a.x);<span class="comment">// --&gt; undefined</span></span><br><span class="line">alert(b.x);<span class="comment">// --&gt; [object Object]</span></span><br></pre></td></tr></table></figure><p>实际上在连续赋值中，值是直接赋予给变量指向的内存地址：</p><pre><code>a.x  =  a  = {n:2}        │      │{n:1}&lt;──┘      └─&gt;{n:2}</code></pre><h3 id="Deconstruction-解构赋值"><a href="#Deconstruction-解构赋值" class="headerlink" title="Deconstruction: 解构赋值"></a>Deconstruction: 解构赋值</h3><p>解构赋值允许你使用类似数组或对象字面量的语法将数组和对象的属性赋给各种变量。这种赋值语法极度简洁，同时还比传统的属性访问方法更为清晰。传统的访问数组前三个元素的方式为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> first = someArray[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> second = someArray[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> third = someArray[<span class="number">2</span>];</span><br><span class="line"><span class="comment">// 结构赋值</span></span><br><span class="line"><span class="keyword">var</span> [first, second, third] = someArray;</span><br><span class="line"><span class="comment">// === Arrays</span></span><br><span class="line"><span class="keyword">var</span> [a, b] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b);<span class="comment">//=&gt; 1 2</span></span><br><span class="line"><span class="comment">// Use from functions, only select from pattern</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> [a, b] = foo();</span><br><span class="line"><span class="built_in">console</span>.log(a, b);<span class="comment">// =&gt; 1 2</span></span><br><span class="line"><span class="comment">// Omit certain values</span></span><br><span class="line"><span class="keyword">var</span> [a, , b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b);<span class="comment">// =&gt; 1 3</span></span><br><span class="line"><span class="comment">// Combine with spread/rest operator (accumulates the rest of the values)</span></span><br><span class="line"><span class="keyword">var</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b);<span class="comment">// =&gt; 1 [ 2, 3 ]</span></span><br><span class="line"><span class="comment">// Fail-safe.</span></span><br><span class="line"><span class="keyword">var</span> [, , , a, b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b);<span class="comment">// =&gt; undefined undefined</span></span><br><span class="line"><span class="comment">// Swap variables easily without temp</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">[b, a] = [a, b];</span><br><span class="line"><span class="built_in">console</span>.log(a, b);<span class="comment">// =&gt; 2 1</span></span><br><span class="line"><span class="comment">// Advance deep arrays</span></span><br><span class="line"><span class="keyword">var</span> [a, [b, [c, d]]] = [<span class="number">1</span>, [<span class="number">2</span>, [[[<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>], <span class="number">6</span>]]];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a:"</span>, a, <span class="string">"b:"</span>, b, <span class="string">"c:"</span>, c, <span class="string">"d:"</span>, d);<span class="comment">// =&gt; a: 1 , b: 2,  c: [ [ 3, 4 ], 5 ] , d: 6</span></span><br><span class="line"><span class="comment">// === Objects</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">user</span>: x&#125; = &#123;<span class="attr">user</span>: <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(x);<span class="comment">// =&gt; 5</span></span><br><span class="line"><span class="comment">// Fail-safe</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">user</span>: x&#125; = &#123;<span class="attr">user2</span>: <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(x);<span class="comment">// =&gt; undefined</span></span><br><span class="line"><span class="comment">// More values</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">prop</span>: x, <span class="attr">prop2</span>: y&#125; = &#123;<span class="attr">prop</span>: <span class="number">5</span>, <span class="attr">prop2</span>: <span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(x, y);<span class="comment">// =&gt; 5 10</span></span><br><span class="line"><span class="comment">// Short-hand syntax</span></span><br><span class="line"><span class="keyword">var</span> &#123; prop, prop2&#125; = &#123;<span class="attr">prop</span>: <span class="number">5</span>, <span class="attr">prop2</span>: <span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(prop, prop2);<span class="comment">// =&gt; 5 10</span></span><br><span class="line"><span class="comment">// Equal to:</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">prop</span>: prop, <span class="attr">prop2</span>: prop2&#125; = &#123;<span class="attr">prop</span>: <span class="number">5</span>, <span class="attr">prop2</span>: <span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(prop, prop2);<span class="comment">// =&gt; 5 10</span></span><br><span class="line"><span class="comment">// Oops: This doesn't work:</span></span><br><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line">&#123; a, b &#125; = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">// But this does work</span></span><br><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line">(&#123; a, b &#125; = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a, b);<span class="comment">// =&gt; 1 2</span></span><br><span class="line"><span class="comment">// This due to the grammar in JS.</span></span><br><span class="line"><span class="comment">// Starting with &#123; implies a block scope, not an object literal.</span></span><br><span class="line"><span class="comment">// () converts to an expression.</span></span><br><span class="line"><span class="comment">// From Harmony Wiki:</span></span><br><span class="line"><span class="comment">// Note that object literals cannot appear in</span></span><br><span class="line"><span class="comment">// statement positions, so a plain object</span></span><br><span class="line"><span class="comment">// destructuring assignment statement</span></span><br><span class="line"><span class="comment">//  &#123; x &#125; = y must be parenthesized either</span></span><br><span class="line"><span class="comment">// as (&#123; x &#125; = y) or (&#123; x &#125;) = y.</span></span><br><span class="line"><span class="comment">// Combine objects and arrays</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">prop</span>: x, <span class="attr">prop2</span>: [, y]&#125; = &#123;<span class="attr">prop</span>: <span class="number">5</span>, <span class="attr">prop2</span>: [<span class="number">10</span>, <span class="number">100</span>]&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(x, y);<span class="comment">// =&gt; 5 100</span></span><br><span class="line"><span class="comment">// Deep objects</span></span><br><span class="line"><span class="keyword">var</span> &#123;</span><br><span class="line">  prop: x,</span><br><span class="line">  prop2: &#123;</span><br><span class="line">    prop2: &#123;</span><br><span class="line">      nested: [ , , b]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; = &#123; <span class="attr">prop</span>: <span class="string">"Hello"</span>, <span class="attr">prop2</span>: &#123; <span class="attr">prop2</span>: &#123; <span class="attr">nested</span>: [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]&#125;&#125;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(x, b);<span class="comment">// =&gt; Hello c</span></span><br><span class="line"><span class="comment">// === Combining all to make fun happen</span></span><br><span class="line"><span class="comment">// All well and good, can we do more? Yes!</span></span><br><span class="line"><span class="comment">// Using as method parameters</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params">&#123;prop: x&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;;</span><br><span class="line">foo(&#123;<span class="attr">invalid</span>: <span class="number">1</span>&#125;);<span class="comment">// =&gt; undefined</span></span><br><span class="line">foo(&#123;<span class="attr">prop</span>: <span class="number">1</span>&#125;);<span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="comment">// Can also use with the advanced example</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  prop: x,</span></span></span><br><span class="line"><span class="function"><span class="params">  prop2: &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    prop2: &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      nested: b</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, ...b);</span><br><span class="line">&#125;;</span><br><span class="line">foo(&#123; <span class="attr">prop</span>: <span class="string">"Hello"</span>, <span class="attr">prop2</span>: &#123; <span class="attr">prop2</span>: &#123; <span class="attr">nested</span>: [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]&#125;&#125;&#125;); <span class="comment">// =&gt; Hello a b c</span></span><br><span class="line"><span class="comment">// In combination with other ES2015 features.</span></span><br><span class="line"><span class="comment">// Computed property names</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'fieldName'</span>;</span><br><span class="line"><span class="keyword">const</span> computedObject = &#123; [name]: name &#125;; <span class="comment">// (where object is &#123; 'fieldName': 'fieldName' &#125;)</span></span><br><span class="line"><span class="keyword">const</span> &#123; [name]: nameValue &#125; = computedObject;</span><br><span class="line"><span class="built_in">console</span>.log(nameValue) <span class="comment">// =&gt; fieldName</span></span><br><span class="line"><span class="comment">// Rest and defaults</span></span><br><span class="line"><span class="keyword">var</span> ajax = <span class="function"><span class="keyword">function</span> (<span class="params">&#123; url = <span class="string">"localhost"</span>, port: p = <span class="number">80</span>&#125;, ...data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Url:"</span>, url, <span class="string">"Port:"</span>, p, <span class="string">"Rest:"</span>, data);</span><br><span class="line">&#125;;</span><br><span class="line">ajax(&#123; <span class="attr">url</span>: <span class="string">"someHost"</span> &#125;, <span class="string">"additional"</span>, <span class="string">"data"</span>, <span class="string">"hello"</span>);<span class="comment">// =&gt; Url: someHost Port: 80 Rest: [ 'additional', 'data', 'hello' ]</span></span><br><span class="line">ajax(&#123; &#125;, <span class="string">"additional"</span>, <span class="string">"data"</span>, <span class="string">"hello"</span>);<span class="comment">// =&gt; Url: localhost Port: 80 Rest: [ 'additional', 'data', 'hello' ]</span></span><br><span class="line"><span class="comment">// Ooops: Doesn't work (in traceur)</span></span><br><span class="line"><span class="keyword">var</span> ajax = <span class="function">(<span class="params">&#123; url = <span class="string">"localhost"</span>, port: p = <span class="number">80</span>&#125;, ...data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Url:"</span>, url, <span class="string">"Port:"</span>, p, <span class="string">"Rest:"</span>, data);</span><br><span class="line">&#125;;</span><br><span class="line">ajax(&#123; &#125;, <span class="string">"additional"</span>, <span class="string">"data"</span>, <span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// probably due to traceur compiler</span></span><br><span class="line">But <span class="keyword">this</span> does:</span><br><span class="line"><span class="keyword">var</span> ajax = <span class="function">(<span class="params">&#123; url: url = <span class="string">"localhost"</span>, port: p = <span class="number">80</span>&#125;, ...data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Url:"</span>, url, <span class="string">"Port:"</span>, p, <span class="string">"Rest:"</span>, data);</span><br><span class="line">&#125;;</span><br><span class="line">ajax(&#123; &#125;, <span class="string">"additional"</span>, <span class="string">"data"</span>, <span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// Like _.pluck</span></span><br><span class="line"><span class="keyword">var</span> users = [</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">"Name1"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">"Name2"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">"Name2"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">"Name3"</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> names = users.map( <span class="function">(<span class="params">&#123; user &#125;</span>) =&gt;</span> user );</span><br><span class="line"><span class="built_in">console</span>.log(names);<span class="comment">// =&gt; [ 'Name1', 'Name2', 'Name2', 'Name3' ]</span></span><br><span class="line"><span class="comment">// Advanced usage with Array Comprehension and default values</span></span><br><span class="line"><span class="keyword">var</span> users = [</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">"Name1"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">"Name2"</span>, <span class="attr">age</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">"Name2"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">"Name3"</span>, <span class="attr">age</span>: <span class="number">4</span> &#125;</span><br><span class="line">];</span><br><span class="line">[<span class="keyword">for</span> (&#123; user, age = <span class="string">"DEFAULT AGE"</span> &#125; <span class="keyword">of</span> users) <span class="built_in">console</span>.log(user, age)];</span><br><span class="line"><span class="comment">// =&gt; Name1 DEFAULT AGE</span></span><br><span class="line"><span class="comment">// =&gt; Name2 2</span></span><br><span class="line"><span class="comment">// =&gt; Name2 DEFAULT AGE</span></span><br><span class="line"><span class="comment">// =&gt; Name3 4</span></span><br></pre></td></tr></table></figure><h3 id="数组与迭代器"><a href="#数组与迭代器" class="headerlink" title="数组与迭代器"></a>数组与迭代器</h3><p>以上是数组解构赋值的一个简单示例，其语法的一般形式为：</p><pre><code>[ variable1, variable2, ..., variableN ] = array;</code></pre><p>事实上，用变量来描述并不恰当，因为你可以对任意深度的嵌套数组进行解构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line"><span class="built_in">console</span>.log(foo);<span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(bar);<span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(baz);<span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>此外，你可以在对应位留空来跳过被解构数组中的某些元素：</p><pre><code>var [,,third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];console.log(third);  // &quot;baz&quot;</code></pre><p>而且你还可以通过“不定参数”模式捕获数组中的所有尾随元素：</p><pre><code>var [head, ...tail] = [1, 2, 3, 4];console.log(tail);// [2, 3, 4]</code></pre><p>当访问空数组或越界访问数组时，对其解构与对其索引的行为一致，最终得到的结果都是：undefined。</p><pre><code>console.log([][0]); // undefinedvar [missing] = [];console.log(missing); // undefined</code></pre><p>请注意，数组解构赋值的模式同样适用于任意迭代器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> [first, second, third, fourth, fifth, sixth] = fibs();</span><br><span class="line"><span class="built_in">console</span>.log(sixth); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>通过解构对象，你可以把它的每个属性与不同的变量绑定，首先指定被绑定的属性，然后紧跟一个要解构的变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> robotA = &#123; <span class="attr">name</span>: <span class="string">"Bender"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> robotB = &#123; <span class="attr">name</span>: <span class="string">"Flexo"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">name</span>: nameA &#125; = robotA;</span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">name</span>: nameB &#125; = robotB;</span><br><span class="line"><span class="built_in">console</span>.log(nameA);<span class="comment">// "Bender"</span></span><br><span class="line"><span class="built_in">console</span>.log(nameB);<span class="comment">// "Flexo"</span></span><br></pre></td></tr></table></figure><p>当属性名与变量名一致时，可以通过一种实用的句法简写：</p><pre><code>var { foo, bar } = { foo: &quot;lorem&quot;, bar: &quot;ipsum&quot; };console.log(foo);    // &quot;lorem&quot;console.log(bar);    // &quot;ipsum&quot;</code></pre><p>与数组解构一样，你可以随意嵌套并进一步组合对象解构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> complicatedObj = &#123;</span><br><span class="line">  arrayProp: [</span><br><span class="line">    <span class="string">"Zapp"</span>,</span><br><span class="line">    &#123; <span class="attr">second</span>: <span class="string">"Brannigan"</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">arrayProp</span>: [first, &#123; second &#125;] &#125; = complicatedObj;</span><br><span class="line"><span class="built_in">console</span>.log(first);<span class="comment">// "Zapp"</span></span><br><span class="line"><span class="built_in">console</span>.log(second);<span class="comment">// "Brannigan"</span></span><br></pre></td></tr></table></figure><p>当你解构一个未定义的属性时，得到的值为undefined：</p><pre><code>var { missing } = {};console.log(missing);    // undefined</code></pre><p>请注意，当你解构对象并赋值给变量时，如果你已经声明或不打算声明这些变量（亦即赋值语句前没有let、const或var关键字），你应该注意这样一个潜在的语法错误：</p><pre><code>{ blowUp } = { blowUp: 10 };    // Syntax error 语法错误</code></pre><p>为什么会出错？这是因为JavaScript语法通知解析引擎将任何以{开始的语句解析为一个块语句（例如，{console}是一个合法块语句）。解决方案是将整个表达式用一对小括号包裹：</p><pre><code>({ safe } = {});    // No errors 没有语法错误</code></pre><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>当你要解构的属性未定义时你可以提供一个默认值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [missing = <span class="literal">true</span>] = [];</span><br><span class="line"><span class="built_in">console</span>.log(missing);<span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">message</span>: msg = <span class="string">"Something went wrong"</span> &#125; = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(msg);<span class="comment">// "Something went wrong"</span></span><br><span class="line"><span class="keyword">var</span> &#123; x = <span class="number">3</span> &#125; = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(x);<span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>由于解构中允许对对象进行解构，并且还支持默认值，那么完全可以将解构应用在函数参数以及参数的默认值中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeBreakpoint</span>(<span class="params">&#123; url, line, column &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们构造一个提供配置的对象，并且需要这个对象的属性携带默认值时，解构特性就派上用场了。举个例子，jQuery的ajax函数使用一个配置对象作为它的第二参数，我们可以这样重写函数定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  async = true,</span></span></span><br><span class="line"><span class="function"><span class="params">  beforeSend = noop,</span></span></span><br><span class="line"><span class="function"><span class="params">  cache = true,</span></span></span><br><span class="line"><span class="function"><span class="params">  complete = noop,</span></span></span><br><span class="line"><span class="function"><span class="params">  crossDomain = false,</span></span></span><br><span class="line"><span class="function"><span class="params">  global = true,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="regexp">//</span> ... 更多配置</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样，解构也可以应用在函数的多重返回值中，可以类似于其他语言中的元组的特性：</p><pre><code>function returnMultipleValues() {  return [1, 2];}var [foo, bar] = returnMultipleValues();</code></pre><h3 id="Three-Dots-…"><a href="#Three-Dots-…" class="headerlink" title="Three Dots …"></a>Three Dots …</h3><p>es6新增的特性</p><h3 id="Rest-Operator"><a href="#Rest-Operator" class="headerlink" title="Rest Operator"></a>Rest Operator</h3><p>在 JavaScript 函数调用时我们往往会使用内置的 arguments 对象来获取函数的调用参数，不过这种方式却存在着很多的不方便性。譬如 arguments 对象是 Array-Like 对象，无法直接运用数组的 .map() 或者 .forEach() 函数；并且因为 arguments 是绑定于当前函数作用域，如果我们希望在嵌套函数里使用外层函数的 arguments 对象，我们还需要创建中间变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// store arguments into a separated variable</span></span><br><span class="line">  <span class="keyword">var</span> argsOuter = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// args is an array-like object</span></span><br><span class="line">    <span class="keyword">var</span> even = <span class="built_in">Array</span>.prototype.map.call(argsOuter, <span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// do something with argsOuter</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6 中为我们提供了 Rest Operator 来以数组形式获取函数的调用参数，Rest Operator 也可以用于在解构赋值中以数组方式获取剩余的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countArguments</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> args.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// get the number of arguments</span></span><br><span class="line">countArguments(<span class="string">'welcome'</span>, <span class="string">'to'</span>, <span class="string">'Earth'</span>); <span class="comment">// =&gt; 3</span></span><br><span class="line"><span class="comment">// destructure an array</span></span><br><span class="line"><span class="keyword">let</span> otherSeasons, autumn;</span><br><span class="line">[autumn, ...otherSeasons] = cold;</span><br><span class="line">otherSeasons  <span class="comment">// =&gt; ['winter']</span></span><br></pre></td></tr></table></figure><p>典型的 Rest Operator 的应用场景譬如进行不定数组的指定类型过滤：</p><pre><code>function filter(type, ...items) {  return items.filter(item =&gt; typeof item === type);}filter(&apos;boolean&apos;, true, 0, false);        // =&gt; [true, false]filter(&apos;number&apos;, false, 4, &apos;Welcome&apos;, 7); // =&gt; [4, 7]</code></pre><p>尽管 Arrow Function 中并没有定义 arguments 对象，但是我们仍然可以使用 Rest Operator 来获取 Arrow Function 的调用参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> outerArguments = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="keyword">const</span> concat = <span class="function">(<span class="params">...items</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span> === outerArguments); <span class="comment">// =&gt; true</span></span><br><span class="line">    <span class="keyword">return</span> items.reduce(<span class="function">(<span class="params">result, item</span>) =&gt;</span> result + item, <span class="string">''</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  concat(<span class="number">1</span>, <span class="number">5</span>, <span class="string">'nine'</span>); <span class="comment">// =&gt; '15nine'</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="Spread-Operator"><a href="#Spread-Operator" class="headerlink" title="Spread Operator"></a>Spread Operator</h3><p>Spread Operator 则与 Rest Opeator 的功能正好相反，其常用于进行数组构建与解构赋值，也可以用于将某个数组转化为函数的参数列表，其基本使用方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cold = [<span class="string">'autumn'</span>, <span class="string">'winter'</span>];</span><br><span class="line"><span class="keyword">let</span> warm = [<span class="string">'spring'</span>, <span class="string">'summer'</span>];</span><br><span class="line"><span class="comment">// construct an array</span></span><br><span class="line">[...cold, ...warm] <span class="comment">// =&gt; ['autumn', 'winter', 'spring', 'summer']</span></span><br><span class="line"><span class="comment">// function arguments from an array</span></span><br><span class="line">cold.push(...warm);</span><br><span class="line">cold <span class="comment">// =&gt; ['autumn', 'winter', 'spring', 'summer']</span></span><br></pre></td></tr></table></figure><p>我们也可以使用 Spread Operator 来简化函数调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">King</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, country) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.country = country;</span><br><span class="line">  &#125;</span><br><span class="line">  getDescription() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> leads <span class="subst">$&#123;<span class="keyword">this</span>.country&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> details = [<span class="string">'Alexander the Great'</span>, <span class="string">'Greece'</span>];</span><br><span class="line"><span class="keyword">var</span> Alexander = <span class="keyword">new</span> King(...details);</span><br><span class="line">Alexander.getDescription(); <span class="comment">// =&gt; 'Alexander the Great leads Greece'</span></span><br></pre></td></tr></table></figure><p>还有另外一个好处就是可以用来替换 Object.assign 来方便地从旧有的对象中创建新的对象，并且能够修改部分值；譬如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj_new_1 = <span class="built_in">Object</span>.assign(&#123;&#125;,obj,&#123;<span class="attr">a</span>:<span class="number">3</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> obj_new_2 = &#123;</span><br><span class="line">  ...obj,</span><br><span class="line">  a:<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们还需要讨论下 Spread Operator 与 Iteration Protocols，实际上 Spread Operator 也是使用的 Iteration Protocols 来进行元素遍历与结果搜集；因此我们也可以通过自定义 Iterator 的方式来控制 Spread Operator 的表现。Iterable 协议规定了对象必须包含 Symbol.iterator 方法，该方法返回某个 Iterator 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Iterable &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> Iterator;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该 Iterator 对象从属于 Iterator Protocol，其需要提供 next 成员方法，该方法会返回某个包含 done 与 value 属性的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Iterator &#123;</span><br><span class="line">  next() &#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">        value: <span class="xml"><span class="tag">&lt;<span class="name">value</span>&gt;</span>,</span></span><br><span class="line">        done: &lt;boolean&gt;</span><br><span class="line">     &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>典型的 Iterable 对象就是字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'hi'</span>;</span><br><span class="line"><span class="keyword">var</span> iterator = str[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">iterator.toString(); <span class="comment">// =&gt; '[object String Iterator]'</span></span><br><span class="line">iterator.next();     <span class="comment">// =&gt; &#123; value: 'h', done: false &#125;</span></span><br><span class="line">iterator.next();     <span class="comment">// =&gt; &#123; value: 'i', done: false &#125;</span></span><br><span class="line">iterator.next();     <span class="comment">// =&gt; &#123; value: undefined, done: true &#125;</span></span><br><span class="line">[...str];            <span class="comment">// =&gt; ['h', 'i']</span></span><br></pre></td></tr></table></figure><p>我们可以通过自定义 array-like 对象的 Symbol.iterator 属性来控制其在迭代器上的效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="comment">// Conform to Iterator protocol</span></span><br><span class="line">      done : index &gt;= <span class="keyword">this</span>.length,</span><br><span class="line">      value: <span class="keyword">this</span>[index++]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'Cat'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'Bird'</span>,</span><br><span class="line">  length: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Conform to Iterable Protocol</span></span><br><span class="line">arrayLike[<span class="built_in">Symbol</span>.iterator] = iterator;</span><br><span class="line"><span class="keyword">var</span> array = [...arrayLike];</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// =&gt; ['Cat', 'Bird']</span></span><br></pre></td></tr></table></figure><p>arrayLike[Symbol.iterator] 为该对象创建了值为某个迭代器的属性，从而使该对象符合了 Iterable 协议；而 iterator() 又返回了包含 next 成员方法的对象，使得该对象最终具有和数组相似的行为表现。</p><h2 id="Copy-Composite-Data-Types-复合类型的拷贝"><a href="#Copy-Composite-Data-Types-复合类型的拷贝" class="headerlink" title="Copy Composite Data Types: 复合类型的拷贝"></a>Copy Composite Data Types: 复合类型的拷贝</h2><h3 id="Shallow-Copy-浅拷贝"><a href="#Shallow-Copy-浅拷贝" class="headerlink" title="Shallow Copy 浅拷贝"></a>Shallow Copy 浅拷贝</h3><p>浅拷贝是指复制时，指对第一层键值对进行独立的赋值，一个简单的实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!source || <span class="keyword">typeof</span> source !== <span class="string">'object'</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 这个方法有点问题，target一定要事先定好，不然就不能改变实参了</span></span><br><span class="line">  <span class="comment">// 具体原因解释可看参考资料中 JS是值传递还是引用传递</span></span><br><span class="line">  <span class="keyword">if</span> (!target || <span class="keyword">typeof</span> target !== <span class="string">'object'</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这边最好区别一下对象和数组的复制</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">    <span class="keyword">if</span> (source.hasOwnProperty(key)) &#123;</span><br><span class="line">      target[key] = source[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><p>Object.assign() 方法可以把任意多个源对象所拥有的自身可枚举属性拷贝给目标对象，然后返回目标对象。<br>Object.assign 方法只会拷贝 源对象自身的并且可枚举的属性 到目标对象身上。注意，对于访问器属性，该方法会执行那个访问器属性的 getter 函数，然后把得到的值拷贝给目标对象如果你想拷贝访问器属性本身，请使用 <code>Object.getOwnPropertyDescriptor</code> 和 <code>Object.difineProperties()</code>方法</p><p>注意，字符串类型和 symbol 类型的属性都会被拷贝。</p><p>注意，在属性拷贝过程中可能会产生异常，比如目标对象的某个只读属性和源对象的某个属性同名，这时该方法会抛出一个 TypeError 异常，拷贝过程中断，已经拷贝成功的属性不会受到影响，还未拷贝的属性将不会再被拷贝。</p><p>注意， Object.assign 会跳过那些值为 null 或 undefined 的源对象。</p><pre><code>Object.assign(target, ...sources)</code></pre><p>浅拷贝一个对象</p><pre><code>var obj = {a: 1}var copy = Object.assign({}, obj)console.log(copy) // {a:1}</code></pre><p>合并若干个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">var</span> o3 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(o1, o2, o3)</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o1) <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;, 注意目标对象自身也会改变。</span></span><br></pre></td></tr></table></figure><p>拷贝 symbol 类型的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; [<span class="built_in">Symbol</span>(<span class="string">'foo'</span>)]: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, o1, o2)</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123; a: 1, [Symbol("foo")]: 2 &#125;</span></span><br></pre></td></tr></table></figure><p>继承属性和不可枚举属性是不能拷贝的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(</span><br><span class="line">  &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// foo是个继承属性</span></span><br><span class="line">    bar: &#123; <span class="attr">value</span>: <span class="number">2</span> &#125;, <span class="comment">// bar是个不可枚举属性</span></span><br><span class="line">    baz: &#123;</span><br><span class="line">      value: <span class="number">3</span>,</span><br><span class="line">      enumerable: <span class="literal">true</span> <span class="comment">// baz是个自身可枚举属性</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj)</span><br><span class="line"><span class="built_in">console</span>.log(copy) <span class="comment">// &#123;baz: 3&#125;</span></span><br></pre></td></tr></table></figure><p>原始值会被隐式转换成其包装对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="string">'123'</span></span><br><span class="line"><span class="keyword">var</span> v2 = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> v3 = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> v4 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, v1, <span class="literal">null</span>, v2, <span class="literal">undefined</span>, v3, v4)</span><br><span class="line"><span class="comment">// 源对象如果是原始值，会被自动转换成它们的包装对象，</span></span><br><span class="line"><span class="comment">// 而 null 和 undefined 这两种原始值会被完全忽略。</span></span><br><span class="line"><span class="comment">// 注意，只有字符串的包装对象才有可能有自身可枚举属性。</span></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123; "0": "1", "1": "2", "2": "3" &#125;</span></span><br></pre></td></tr></table></figure><p>例子：拷贝属性过程中发生异常</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'foo'</span>, &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  writeable: <span class="literal">false</span></span><br><span class="line">&#125;) <span class="comment">// target 的 foo 属性是个只读属性。</span></span><br><span class="line"><span class="built_in">Object</span>.assign(target, &#123; <span class="attr">bar</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">foo2</span>: <span class="number">3</span>, <span class="attr">foo</span>: <span class="number">3</span>, <span class="attr">foo3</span>: <span class="number">3</span> &#125;, &#123; <span class="attr">baz</span>: <span class="number">4</span> &#125;)</span><br><span class="line"><span class="comment">// TypeError: "foo" is read-only</span></span><br><span class="line"><span class="comment">// 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。</span></span><br><span class="line"><span class="built_in">console</span>.log(target.bar) <span class="comment">// 2，说明第一个源对象拷贝成功了。</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo2) <span class="comment">// 3，说明第二个源对象的第一个属性也拷贝成功了。</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo) <span class="comment">// 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。</span></span><br><span class="line"><span class="built_in">console</span>.log(target.foo3) <span class="comment">// undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。</span></span><br><span class="line"><span class="built_in">console</span>.log(target.baz) <span class="comment">// undefined，第三个源对象更是不会被拷贝到的。</span></span><br></pre></td></tr></table></figure><h3 id="使用-concat-来复制数组"><a href="#使用-concat-来复制数组" class="headerlink" title="使用 [].concat 来复制数组"></a>使用 [].concat 来复制数组</h3><p>同样类似于对于对象的复制，我们建议使用[].concat 来进行数组的深复制:</p><pre><code>ar list = [1, 2, 3];var changedList = [].concat(list);changedList[1] = 2;list === changedList; // false</code></pre><p>同样的，concat 方法也只能保证一层深复制:</p><pre><code>&gt; list = [[1,2,3]][ [ 1, 2, 3 ] ]&gt; new_list = [].concat(list)[ [ 1, 2, 3 ] ]&gt; new_list[0][0] = 44&gt; list[ [ 4, 2, 3 ] ]</code></pre><h3 id="浅拷贝的缺陷"><a href="#浅拷贝的缺陷" class="headerlink" title="浅拷贝的缺陷"></a>浅拷贝的缺陷</h3><p>不过需要注意的是，assign 是浅拷贝，或者说，它是一级深拷贝，举两个例子说明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultOpt = &#123;</span><br><span class="line">  title: &#123;</span><br><span class="line">    text: <span class="string">'hello world'</span>,</span><br><span class="line">    subtext: <span class="string">"It's my world"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> opt = <span class="built_in">Object</span>.assign(&#123;&#125;, defaultOpt, &#123;</span><br><span class="line">  title: &#123;</span><br><span class="line">    subtext: <span class="string">'Yes, your world'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(opt) <span class="comment">// &#123; title: &#123; subtext: 'Yes, your world.' &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>上面这个例子中，对于对象的一级子元素而言，只会替换引用，而不会动态的添加内容。那么，其实 assign 并没有解决对象的引用混乱问题，参考下下面这个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultOpt = &#123;</span><br><span class="line">  title: &#123;</span><br><span class="line">    text: <span class="string">'hello world'</span>,</span><br><span class="line">    subtext: <span class="string">"It's my world."</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> opt1 = <span class="built_in">Object</span>.assign(&#123;&#125;, defaultOpt);</span><br><span class="line"><span class="keyword">const</span> opt2 = <span class="built_in">Object</span>.assign(&#123;&#125;, defaultOpt);</span><br><span class="line">opt2.title.subtext = <span class="string">'Yes, your world.'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(opt1); <span class="comment">// &#123; title: &#123; text: 'hello world', subtext: 'Yes, your world.' &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(opt2); <span class="comment">// &#123; title: &#123; text: 'hello world', subtext: 'Yes, your world.' &#125; &#125;</span></span><br></pre></td></tr></table></figure><h3 id="DeepCopy-深拷贝"><a href="#DeepCopy-深拷贝" class="headerlink" title="DeepCopy: 深拷贝"></a>DeepCopy: 深拷贝</h3><p><strong>递归属性遍历</strong></p><p>一般来说，在JavaScript中考虑复合类型的深层复制的时候，往往就是指对于Date、Object与Array这三个复合类型的处理。我们能想到的最常用的方法就是先创建一个空的新对象，然后递归遍历旧对象，直到发现基础类型的子节点才赋予到新对象对应的位置。不过这种方法会存在一个问题，就是JavaScript中存在着神奇的原型机制，并且这个原型会在遍历的时候出现，然后原型不应该被赋予给新对象。那么在遍历的过程中，我们应该考虑使用hasOenProperty方法来过滤掉那些继承自原型链上的属性:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> copy</span><br><span class="line">  <span class="comment">// 处理基本类型 null undefined</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">null</span> === obj || <span class="string">'object'</span> !== <span class="keyword">typeof</span> obj) <span class="keyword">return</span> obj</span><br><span class="line">  <span class="comment">// 若为 Date 对象时</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">    copy = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    copy.setTime(obj.getTime())</span><br><span class="line">    <span class="keyword">return</span> copy</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理数组</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">    copy = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = obj.length; i &lt; len; i++) &#123;</span><br><span class="line">      copy[i] = clone(obj[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理对象</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">    copy = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj.hasOwnProperty(attr)) &#123;</span><br><span class="line">        copy[attr] = clone(obj[arr])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unable to copy obj! Its type isn\'t supported!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This would be cloneable:</span></span><br><span class="line"><span class="keyword">var</span> tree = &#123;</span><br><span class="line">    <span class="string">"left"</span>  : &#123; <span class="string">"left"</span> : <span class="literal">null</span>, <span class="string">"right"</span> : <span class="literal">null</span>, <span class="string">"data"</span> : <span class="number">3</span> &#125;,</span><br><span class="line">    <span class="string">"right"</span> : <span class="literal">null</span>,</span><br><span class="line">    <span class="string">"data"</span>  : <span class="number">8</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// This would kind-of work, but you would get 2 copies of the</span></span><br><span class="line"><span class="comment">// inner node instead of 2 references to the same copy</span></span><br><span class="line"><span class="keyword">var</span> directedAcylicGraph = &#123;</span><br><span class="line">    <span class="string">"left"</span>  : &#123; <span class="string">"left"</span> : <span class="literal">null</span>, <span class="string">"right"</span> : <span class="literal">null</span>, <span class="string">"data"</span> : <span class="number">3</span> &#125;,</span><br><span class="line">    <span class="string">"data"</span>  : <span class="number">8</span></span><br><span class="line">&#125;;</span><br><span class="line">directedAcyclicGraph[<span class="string">"right"</span>] = directedAcyclicGraph[<span class="string">"left"</span>];</span><br><span class="line"><span class="comment">// Cloning this would cause a stack overflow due to infinite recursion:</span></span><br><span class="line"><span class="keyword">var</span> cylicGraph = &#123;</span><br><span class="line">    <span class="string">"left"</span>  : &#123; <span class="string">"left"</span> : <span class="literal">null</span>, <span class="string">"right"</span> : <span class="literal">null</span>, <span class="string">"data"</span> : <span class="number">3</span> &#125;,</span><br><span class="line">    <span class="string">"data"</span>  : <span class="number">8</span></span><br><span class="line">&#125;;</span><br><span class="line">cylicGraph[<span class="string">"right"</span>] = cylicGraph;</span><br></pre></td></tr></table></figure><h3 id="利用JSON深拷贝"><a href="#利用JSON深拷贝" class="headerlink" title="利用JSON深拷贝"></a>利用JSON深拷贝</h3><pre><code>JSON.parse(JSON.stringify(obj))</code></pre><p>对于一般的需求是可以满足的，但是它有缺点，下例中，可以看到JSON赋值会忽略掉值为undefined以及函数表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="literal">undefined</span>,</span><br><span class="line">  sum: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line"><span class="built_in">console</span>.log(obj2) <span class="comment">// Object &#123;a: 1, b: 2&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zhuanlan.zhihu.com/p/28313321" target="_blank" rel="noopener">基于 JSX 的动态数据绑定</a><br><a href="https://zhuanlan.zhihu.com/p/27844393" target="_blank" rel="noopener">ECMAScript 2017（ES8）特性概述</a><br><a href="https://zhuanlan.zhihu.com/p/27410280" target="_blank" rel="noopener">WebAssembly 初体验：从零开始重构计算模块</a></p>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> es6 </tag>
            
            <tag> 引用 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【JS】【设计模式】从订阅发布模式说起</title>
      <link href="/2018/06/13/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%8E%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F%E8%AF%B4%E8%B5%B7/"/>
      <url>/2018/06/13/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E4%BB%8E%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F%E8%AF%B4%E8%B5%B7/</url>
      <content type="html"><![CDATA[<blockquote><p>先扯点闲话。一时兴起，遂决定之后采用这个前缀来写这个十多篇的系列总结了。在之前的学习和博客整理中，感觉都挺没方向，很散乱。除了看书的总结外，其他时候都是零碎性地学习，我想，若能系统性地带着目的去散落这些点，再类似依赖收集一样把这些零碎的东西汇总整理出来，那应该也挺不错的~</p></blockquote><!-- ![学习正则表达式](/18-6-14/4361135.jpg) --><p>这周的复习知识点主要是以下几方面：</p><ul><li>设计模式之发布订阅/观察者模式</li><li>事件相关，事件、模型、处理机制</li><li>Ajax</li><li>异步</li></ul><a id="more"></a><p>我将这些点梳理到了脑图中，并作了一些批注，感觉一边整理了知识点，也让自己有了一个整体的脉络和方向感，树越分散也就是所谓的深度，让树更深也就是知识的深度。</p><!-- ![知识点梳理](/18-6-14/52685215.jpg) --><h2 id="从设计原则说起"><a href="#从设计原则说起" class="headerlink" title="从设计原则说起"></a>从设计原则说起</h2><p>一个优秀的程序员通常由其<strong>操作技能</strong>、<strong>知识水平</strong>，<strong>经验层力</strong>和<strong>能力</strong>四个方面组成。这些原则，也就是巨人的肩膀，总结而出流传至今，每一个程序员都应该了解，运用于开发和生活中。</p><p>要我来说的话就是，先去了解，知道有这些东西，也许不能马上运用到实际项目中，但当我们遇到困难时，就可以回顾一下图里的各原则，结合以下经验：</p><ol><li>粗浅地了解这些原则</li><li>在（公司或开源）项目中观察或总结他人或自己的设计</li><li>实践、回顾，再总结</li><li>总结后再回到第1步深入了解以此往复</li></ol><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>比较概念的解释是，目标和观察者是基类，目标提供维护观察者的一系列方法，观察者提供更新接口。具体观察者和具体目标继承各自的基类，然后具体观察者把自己注册到具体目标里，在具体目标发生变化时候，调度观察者的更新方法</p><!-- ![观察者模式](/18-6-14/636423.jpg) --><p>简易版观察者模式实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObserverList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.observerList = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observerList.push(observer)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get(index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="keyword">this</span>.count()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.observerList[index]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeAt(index) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observerList.splice(index, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  count() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.observerList.length</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  indexOf(observer, startIndex = <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = startIndex</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="keyword">this</span>.count()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.observerList[i] === observer) &#123;</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">      &#125;</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers = <span class="keyword">new</span> ObserverList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addObserver(observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.add(observer)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeObserver(observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.removeAt(<span class="keyword">this</span>.observers.indexOf(observer))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify(...args) &#123;</span><br><span class="line">    <span class="keyword">let</span> observerCount = <span class="keyword">this</span>.observers.count()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; observerCount; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>.observers.get(i).update(args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p>比较概念的解释是，订阅者把自己想订阅的事件注册到调度中心，当该事件触发时候，发布者发布该事件到调度中心（顺带上下文），由调度中心统一调度订阅者注册到调度中心的处理代码。</p><!-- ![发布订阅模式](/18-6-14/91374451.jpg) --><p>简易版发布订阅模式实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">PubSub</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subscribers = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  subscribe(type, fn) &#123;</span><br><span class="line">    <span class="keyword">let</span> listeners = <span class="keyword">this</span>.subscribers[type] || []</span><br><span class="line">    listeners.push(fn)</span><br><span class="line">    <span class="keyword">this</span>.subscribers[type] = listeners</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  unsubscribe(type, fn) &#123;</span><br><span class="line">    <span class="keyword">let</span> listeners = <span class="keyword">this</span>.subscribers[type]</span><br><span class="line">    <span class="keyword">if</span> (!listeners) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">this</span>.subscribers[type] = listeners.filter(<span class="function"><span class="params">v</span> =&gt;</span> v !== fn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  publish(type, ...args) &#123;</span><br><span class="line">    <span class="keyword">let</span> listeners = <span class="keyword">this</span>.subscribers[type]</span><br><span class="line">    <span class="keyword">if</span> (!listeners) <span class="keyword">return</span></span><br><span class="line">    listeners.forEach(<span class="function"><span class="params">item</span> =&gt;</span> (item.apply(type, args)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><ul><li>两者最大的区别是调度的地方<br>虽然两种模式都存在订阅者和发布者（具体观察者可认为是订阅者，具体目标可认为是观察者），但是观察者模式是由具体目标调度的，而发布/订阅模式是统一由调度中心调度的。所以观察者模式的订阅者和发布者之间是存在依赖的，而发布/订阅模式则不会</li><li>两种模式都可以用于松散耦合，改进代码管理和潜在的复用</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>观察者和发布/订阅模式鼓励我们认真思考应用程序不同部分之间的关​​系。他们还帮助我们确定包含直接关系的层次，而这些关系可以用主题和观察者集合取而代之。这可以有效地将应用程序分解为更小，更松散的块，以改善代码管理和重用的潜力。</p><p>使用Observer模式的进一步动机是我们需要保持相关对象之间的一致性，而不需要使类紧密耦合。例如，当一个对象需要能够通知其他对象而不做这些对象的假设时。</p><p>使用这两种模式时，观察者和主体之间可能存在动态关系。这提供了很大的灵活性，当我们的应用程序的不同部分紧密耦合时，这可能不容易实现。</p><p>尽管对于每个问题来说，这并不总是最好的解决方案，但这些模式仍然是设计分离系统的最佳工具之一，应该被视为任何JavaScript开发人员的工具带中的重要工具。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>因此，这些模式的一些问题实际上源于其主要益处。在“发布/订阅”中，通过将发布者与订阅者分离，有时可能难以获得我们应用程序的特定部分正常运行的保证。</p><p>例如，发布商可能会假定一个或多个订阅者正在倾听他们。假设我们正在使用这样的假设来记录或输出关于某些应用程序过程的错误。如果执行日志记录的用户崩溃（或出于某种原因无法运行），由于系统的解耦特性，发布者将无法看到这种情况。</p><p>这种模式的另一个缺点是用户对彼此的存在并不知情，并且对转换发布商的成本视而不见。由于用户和发布者之间的动态关系，更新依赖性很难追踪。</p><hr><h3 id="实践应用-实现Vue的双向绑定"><a href="#实践应用-实现Vue的双向绑定" class="headerlink" title="实践应用 - 实现Vue的双向绑定"></a>实践应用 - 实现Vue的双向绑定</h3><p>这么一看的话，其实Vue里的双向绑定的实现也是发布订阅模式吧。为什么不是观察者？ 因为多了一个Watcher，这就是相当于调度中心，通过这一层为中间人进行的更新。</p><p>这类的代码看多少次都不嫌多，这是之前网上一个不错的实现，我拿过来学习了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVue</span> </span>&#123;</span><br><span class="line">  <span class="comment">// new Vue(&#123; ... &#125;) 这个options就是这里的对象啦</span></span><br><span class="line">  <span class="comment">// 初始化 将 options 赋值到实例对象上</span></span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$options = options</span><br><span class="line">    <span class="keyword">this</span>.$el = <span class="built_in">document</span>.querySelector(options.el)</span><br><span class="line">    <span class="keyword">this</span>.$data = options.data</span><br><span class="line">    <span class="keyword">this</span>.$methods = options.methods</span><br><span class="line">    <span class="comment">// data的内容会放到这里来， 这也就说明了 初始化结束后，手动加的值不会被监听到</span></span><br><span class="line">    <span class="keyword">this</span>._binding = &#123;&#125;</span><br><span class="line">    <span class="comment">// 初始化时会监听data上的属性</span></span><br><span class="line">    <span class="keyword">this</span>._observe(<span class="keyword">this</span>.$data)</span><br><span class="line">    <span class="comment">// 初始化时 编译 $el 里的子节点</span></span><br><span class="line">    <span class="keyword">this</span>._compile(<span class="keyword">this</span>.$el)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _observe(obj) &#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">        that._binding[key] = &#123;</span><br><span class="line">          <span class="comment">// 添加依赖收集， 是个数组</span></span><br><span class="line">          _directives: []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(that._binding[key])</span><br><span class="line">        <span class="keyword">let</span> val = obj[key]</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'object'</span>) &#123;</span><br><span class="line">          <span class="comment">// 若是对象就递归</span></span><br><span class="line">          that._observe(val)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> binding = that._binding[key]</span><br><span class="line">        <span class="comment">// 响应式 双向绑定的核心操作</span></span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(that.$data, key, &#123;</span><br><span class="line">          enumerable: <span class="literal">true</span>,</span><br><span class="line">          configurable: <span class="literal">true</span>,</span><br><span class="line">          get() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> 获取 <span class="subst">$&#123;val&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">          &#125;,</span><br><span class="line">          set(newVal) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> 更新 <span class="subst">$&#123;newVal&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">if</span> (val !== newVal) &#123;</span><br><span class="line">              val = newVal</span><br><span class="line">              binding._directives.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">                item.update()</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _compile(root) &#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> nodes = root.children</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nodes.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> node = nodes[i]</span><br><span class="line">      <span class="keyword">if</span> (node.children.length) &#123;</span><br><span class="line">        <span class="keyword">this</span>._compile(node)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (node.hasAttribute(<span class="string">'v-click'</span>)) &#123;</span><br><span class="line">        node.onclick = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">let</span> attrVal = nodes[i].getAttribute(<span class="string">'v-click'</span>)</span><br><span class="line">          <span class="keyword">return</span> that.$methods[attrVal].bind(that.$data)</span><br><span class="line">        &#125;)()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (node.hasAttribute(<span class="string">'v-model'</span>) &amp;&amp; (node.tagName === <span class="string">'INPUT'</span> || node.tagName === <span class="string">'TEXTAREA'</span>)) &#123;</span><br><span class="line">        node.addEventListener(<span class="string">'input'</span>, (<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">let</span> attrVal = node.getAttribute(<span class="string">'v-model'</span>)</span><br><span class="line">          that._binding[attrVal]._directives.push(<span class="keyword">new</span> Wathcer(</span><br><span class="line">            <span class="string">'input'</span>,</span><br><span class="line">            node,</span><br><span class="line">            that,</span><br><span class="line">            attrVal,</span><br><span class="line">            <span class="string">'value'</span></span><br><span class="line">          ))</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            that.$data[attrVal] = nodes[key].value</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)(i))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (node.hasAttribute(<span class="string">'v-bind'</span>)) &#123;</span><br><span class="line">        <span class="keyword">let</span> attrVal = node.getAttribute(<span class="string">'v-bind'</span>)</span><br><span class="line">        that._binding[attrVal]._directives.push(<span class="keyword">new</span> Watcher(</span><br><span class="line">          <span class="string">'text'</span>,</span><br><span class="line">          node,</span><br><span class="line">          that,</span><br><span class="line">          attrVal,</span><br><span class="line">          <span class="string">'innerHTML'</span></span><br><span class="line">        ))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, el, vm, exp, attr) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name    <span class="comment">// 指令名</span></span><br><span class="line">    <span class="keyword">this</span>.el = el        <span class="comment">// 指令对应dom</span></span><br><span class="line">    <span class="keyword">this</span>.vm = vm        <span class="comment">// 指令所属MyVue实例</span></span><br><span class="line">    <span class="keyword">this</span>.exp = exp      <span class="comment">// 指令对应值</span></span><br><span class="line">    <span class="keyword">this</span>.attr = attr    <span class="comment">// 绑定的属性值</span></span><br><span class="line">    <span class="keyword">this</span>.update()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="keyword">this</span>.el[<span class="keyword">this</span>.attr] = <span class="keyword">this</span>.vm.$data[<span class="keyword">this</span>.exp]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>这里说一下，我们通过 new 生成了一个 MyVue实例，而传入的参数（对象）作为配置，在初始化阶段做了这些事情：</p><ol><li>赋值，实例的 $options $el $data $method 都是从options里获取到的</li><li>_observe 为每一个实例上的data属性添加监听 （通过Object.defineProperty）</li><li>_compile 编译节点，指令对应的value对应一个新的Watcher，进行依赖收集从而触发数据响应</li></ol><p>于是到codepen上试试吧</p><iframe height="300" scrolling="no" title="simple Vue ~ MVVM" src="//codepen.io/fridolph/embed/gKxrBO/?height=300&theme-id=dark&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/fridolph/pen/gKxrBO/" target="_blank" rel="noopener">simple Vue ~ MVVM</a> by fridolph (<a href="https://codepen.io/fridolph" target="_blank" rel="noopener">@fridolph</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><hr><h2 id="event-js-的实现"><a href="#event-js-的实现" class="headerlink" title="event.js 的实现"></a>event.js 的实现</h2><p>这是一个典型的发布订阅模式的应用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义R对象 如果支持es6用原生的Reflect，没就相当于提供polyfill</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> R = <span class="keyword">typeof</span> <span class="built_in">Reflect</span> === <span class="string">'object'</span> ? <span class="built_in">Reflect</span> : <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> ReflectApply = R &amp;&amp; <span class="keyword">typeof</span> R.apply === <span class="string">'function'</span></span><br><span class="line">  ? R.apply</span><br><span class="line">  : <span class="function"><span class="keyword">function</span> <span class="title">ReflectApply</span>(<span class="params">target, receiver, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.apply.call(target, receiver, args);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">var</span> ReflectOwnKeys</span><br><span class="line"><span class="keyword">if</span> (R &amp;&amp; <span class="keyword">typeof</span> R.ownKeys === <span class="string">'function'</span>) &#123;</span><br><span class="line">  ReflectOwnKeys = R.ownKeys</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Object</span>.getOwnPropertySymbols) &#123;</span><br><span class="line">  ReflectOwnKeys = <span class="function"><span class="keyword">function</span> <span class="title">ReflectOwnKeys</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.getOwnPropertyNames(target)</span><br><span class="line">      .concat(<span class="built_in">Object</span>.getOwnPropertySymbols(target));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ReflectOwnKeys = <span class="function"><span class="keyword">function</span> <span class="title">ReflectOwnKeys</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.getOwnPropertyNames(target);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.warn的封装</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProcessEmitWarning</span>(<span class="params">warning</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">console</span> &amp;&amp; <span class="built_in">console</span>.warn) <span class="built_in">console</span>.warn(warning);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Number.isNaN 是es6加入的，后面是并联的兼容处理，Number类型 自身与自身不相等的只有NaN了</span></span><br><span class="line"><span class="keyword">var</span> NumberIsNaN = <span class="built_in">Number</span>.isNaN || <span class="function"><span class="keyword">function</span> <span class="title">NumberIsNaN</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value !== value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventEmitter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  EventEmitter.init.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将EventEmitter构造函数作为默认导出</span></span><br><span class="line"><span class="built_in">module</span>.exports = EventEmitter;</span><br><span class="line"><span class="comment">// 向后兼容node 0.10.x 版本 看来这个库相当老了啊，不过也不妨碍我们学习</span></span><br><span class="line"></span><br><span class="line">EventEmitter.EventEmitter = EventEmitter;</span><br><span class="line">EventEmitter.prototype._events = <span class="literal">undefined</span>;</span><br><span class="line">EventEmitter.prototype._eventsCount = <span class="number">0</span>;</span><br><span class="line">EventEmitter.prototype._maxListeners = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认情况下，如果超过10个侦听器，EventEmitters将会输出警告添加到它</span></span><br><span class="line"><span class="comment">// 这是一个有用的默认值，它有助于查找内存泄漏</span></span><br><span class="line"><span class="keyword">var</span> defaultMaxListeners = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(EventEmitter, <span class="string">'defaultMaxListeners'</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> defaultMaxListeners;</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">'number'</span> || arg &lt; <span class="number">0</span> || NumberIsNaN(arg)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '</span> + arg + <span class="string">'.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    defaultMaxListeners = arg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造类的静态方法</span></span><br><span class="line">EventEmitter.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 相当于constructor的构造函数调用 初始化</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._events === <span class="literal">undefined</span> ||</span><br><span class="line">      <span class="keyword">this</span>._events === <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>)._events) &#123;</span><br><span class="line">    <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">this</span>._eventsCount = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._maxListeners = <span class="keyword">this</span>._maxListeners || <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显然不是所有的Emitters侦听器都应该限制为10个。这个功能允许增加</span></span><br><span class="line">EventEmitter.prototype.setMaxListeners = <span class="function"><span class="keyword">function</span> <span class="title">setMaxListeners</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> n !== <span class="string">'number'</span> || n &lt; <span class="number">0</span> || NumberIsNaN(n)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'The value of "n" is out of range. It must be a non-negative number. Received '</span> + n + <span class="string">'.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._maxListeners = n;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给下面的 getMaxListeners方法用  EventEmitter原型方法里的 this指向实例对象</span></span><br><span class="line"><span class="comment">// 所以可从实例中 拿到 属性值 _maxListeners</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$getMaxListeners</span>(<span class="params">that</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (that._maxListeners === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> EventEmitter.defaultMaxListeners;</span><br><span class="line">  <span class="keyword">return</span> that._maxListeners;</span><br><span class="line">&#125;</span><br><span class="line">EventEmitter.prototype.getMaxListeners = <span class="function"><span class="keyword">function</span> <span class="title">getMaxListeners</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> $getMaxListeners(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span> <span class="title">emit</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="comment">// emit第一个参数一般是方法名，所以 从arguments[1]开始</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">  <span class="comment">// 右边的表达式返回一个布尔值 ，type报错就为true。doError可理解为错误标记的flag</span></span><br><span class="line">  <span class="keyword">var</span> doError = (type === <span class="string">'error'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拿到 实例的 _events 对象</span></span><br><span class="line">  <span class="keyword">var</span> events = <span class="keyword">this</span>._events;</span><br><span class="line">  <span class="keyword">if</span> (events !== <span class="literal">undefined</span>)</span><br><span class="line">    <span class="comment">// 没有错就直接返回 false</span></span><br><span class="line">    doError = (doError &amp;&amp; events.error === <span class="literal">undefined</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!doError)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面是错误处理</span></span><br><span class="line">  <span class="keyword">if</span> (doError) &#123;</span><br><span class="line">    <span class="keyword">var</span> er;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>)</span><br><span class="line">      er = args[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (er <span class="keyword">instanceof</span> <span class="built_in">Error</span>) &#123;</span><br><span class="line">      <span class="comment">// 注意：“throw”这一行的注释是有意的，他们表示 如果这导致未处理的异常，则在Node的输出中输入。</span></span><br><span class="line">      <span class="keyword">throw</span> er;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 错误上下文为er 这里的er就是传进来的type的报错环境上下文</span></span><br><span class="line">    <span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unhandled error.'</span> + (er ? <span class="string">' ('</span> + er.message + <span class="string">')'</span> : <span class="string">''</span>));</span><br><span class="line">    err.context = er;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从events里找type对应的函数 拿到 并赋给handler</span></span><br><span class="line">  <span class="keyword">var</span> handler = events[type];</span><br><span class="line">  <span class="keyword">if</span> (handler === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handler === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// 绑定上下文</span></span><br><span class="line">    ReflectApply(handler, <span class="keyword">this</span>, args);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// handler多次调用  把多个handler 放到数组里来处理</span></span><br><span class="line">    <span class="keyword">var</span> len = handler.length;</span><br><span class="line">    <span class="keyword">var</span> listeners = arrayClone(handler, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">      ReflectApply(listeners[i], <span class="keyword">this</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_addListener</span>(<span class="params">target, type, listener, prepend</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m;</span><br><span class="line">  <span class="keyword">var</span> events;</span><br><span class="line">  <span class="keyword">var</span> existing;</span><br><span class="line">  <span class="comment">// listener类型判断</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The "listener" argument must be of type Function. Received type '</span> + <span class="keyword">typeof</span> listener);</span><br><span class="line">  &#125;</span><br><span class="line">  events = target._events;</span><br><span class="line">  <span class="keyword">if</span> (events === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    events = target._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    target._eventsCount = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 为了避免在 type === "newListener" 这种情况下递归</span></span><br><span class="line">    <span class="comment">// 在将其添加到侦听器之前，首先触发 "newListener"</span></span><br><span class="line">    <span class="keyword">if</span> (events.newListener !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      target.emit(<span class="string">'newListener'</span>, type,</span><br><span class="line">                  listener.listener ? listener.listener : listener);</span><br><span class="line">      <span class="comment">// 重新分配 `events`，因为newListener处理程序可能导致了 this._events被分配给一个新的对象</span></span><br><span class="line">      events = target._events;</span><br><span class="line">    &#125;</span><br><span class="line">    existing = events[type];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (existing === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// 优化一个listener的情况。不需要额外的数组对象</span></span><br><span class="line">    existing = events[type] = listener;</span><br><span class="line">    ++target._eventsCount;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> existing === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// 添加第二个元素，需要更改为数组</span></span><br><span class="line">      existing = events[type] =</span><br><span class="line">        prepend ? [listener, existing] : [existing, listener];</span><br><span class="line">      <span class="comment">//如果我们已经有了一个数组，只需追加</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prepend) &#123;</span><br><span class="line">      existing.unshift(listener);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      existing.push(listener);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查监听器泄漏</span></span><br><span class="line">    m = $getMaxListeners(target);</span><br><span class="line">    <span class="comment">// m &gt; 0 &amp;&amp; (exiting.length &gt; m &amp;&amp; !existing.warned )</span></span><br><span class="line">    <span class="keyword">if</span> (m &gt; <span class="number">0</span> &amp;&amp; existing.length &gt; m &amp;&amp; !existing.warned) &#123;</span><br><span class="line">      existing.warned = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 没有错误代码，因为它是一个warning</span></span><br><span class="line">      <span class="keyword">var</span> w = <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">'Possible EventEmitter memory leak detected. '</span> +</span><br><span class="line">        existing.length + <span class="string">' '</span> + <span class="built_in">String</span>(type) + <span class="string">' listeners '</span> +</span><br><span class="line">        <span class="string">'added. Use emitter.setMaxListeners() to '</span> +</span><br><span class="line">        <span class="string">'increase limit'</span></span><br><span class="line">      )</span><br><span class="line">      w.name = <span class="string">'MaxListenersExceededWarning'</span>;</span><br><span class="line">      w.emitter = target;</span><br><span class="line">      w.type = type;</span><br><span class="line">      w.count = existing.length;</span><br><span class="line">      ProcessEmitWarning(w);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结合上面的函数，这是高阶函数的用法 普通地，我们一般会传 事件名和回调</span></span><br><span class="line"><span class="comment">// 这里返回 _addListner方法 第一个参数是 this 实例对象作为上下文环境</span></span><br><span class="line"><span class="comment">// 然后是 事件名，回调，prepend默认为false</span></span><br><span class="line">EventEmitter.prototype.addListener = <span class="function"><span class="keyword">function</span> <span class="title">addListener</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _addListener(<span class="keyword">this</span>, type, listener, <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 同名方法 addListner 和用 on等效</span></span><br><span class="line">EventEmitter.prototype.on = EventEmitter.prototype.addListener;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和on的区别在于 prepend为true，当前已经是数组了才会这样用（不同我们来，已经封装在内部逻辑里了）</span></span><br><span class="line">EventEmitter.prototype.prependListener = <span class="function"><span class="keyword">function</span> <span class="title">prependListener</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _addListener(<span class="keyword">this</span>, type, listener, <span class="literal">true</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onceWrapper</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 把参数放到 args中。 我们先看下面的 _onceWrap方法</span></span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">  <span class="comment">// 显然，这个if逻辑会走到里</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.fired) &#123;</span><br><span class="line">    <span class="comment">// removeListener会被调用</span></span><br><span class="line">    <span class="keyword">this</span>.target.removeListener(<span class="keyword">this</span>.type, <span class="keyword">this</span>.wrapFn);</span><br><span class="line">    <span class="comment">// 然后再把fired 设回true</span></span><br><span class="line">    <span class="keyword">this</span>.fired = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 这里因为ReflectApply的原因，this上下文回到了 实例对象上</span></span><br><span class="line">    ReflectApply(<span class="keyword">this</span>.listener, <span class="keyword">this</span>.target, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_onceWrap</span>(<span class="params">target, type, listener</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始state</span></span><br><span class="line">  <span class="keyword">var</span> state = &#123; <span class="attr">fired</span>: <span class="literal">false</span>, <span class="attr">wrapFn</span>: <span class="literal">undefined</span>, <span class="attr">target</span>: target, <span class="attr">type</span>: type, <span class="attr">listener</span>: listener &#125;;</span><br><span class="line">  <span class="comment">// 好 有了这个bind后，上面onceWrapper的this就知道了，我们再跳回去</span></span><br><span class="line">  <span class="keyword">var</span> wrapped = onceWrapper.bind(state);</span><br><span class="line">  wrapped.listener = listener;</span><br><span class="line">  state.wrapFn = wrapped;</span><br><span class="line">  <span class="keyword">return</span> wrapped;</span><br><span class="line">  <span class="comment">// 回到wrapped这个上下文中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法可理解为调用一次后 自动把方法注销掉</span></span><br><span class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span> <span class="title">once</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The "listener" argument must be of type Function. Received type '</span> + <span class="keyword">typeof</span> listener);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.on(type, _onceWrap(<span class="keyword">this</span>, type, listener));</span><br><span class="line">  <span class="comment">// 后同，return this 是返回实例对象自身，方便链式调用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.prependOnceListener = <span class="function"><span class="keyword">function</span> <span class="title">prependOnceListener</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The "listener" argument must be of type Function. Received type '</span> + <span class="keyword">typeof</span> listener);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.prependListener(type, _onceWrap(<span class="keyword">this</span>, type, listener));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除监听方法</span></span><br><span class="line">EventEmitter.prototype.removeListener = <span class="function"><span class="keyword">function</span> <span class="title">removeListener</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> list, events, position, i, originalListener;</span><br><span class="line">  <span class="comment">// 错误判断，这里先略过了</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The "listener" argument must be of type Function. Received type '</span> + <span class="keyword">typeof</span> listener);</span><br><span class="line">  &#125;</span><br><span class="line">  events = <span class="keyword">this</span>._events;</span><br><span class="line">  <span class="keyword">if</span> (events === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// list被赋值为evnets[type] 即 一个注册的事件</span></span><br><span class="line">  list = events[type];</span><br><span class="line">  <span class="keyword">if</span> (list === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前list 和所传的注册事件若一致就进入这个逻辑里</span></span><br><span class="line">  <span class="keyword">if</span> (list === listener || list.listener === listener) &#123;</span><br><span class="line">    <span class="comment">// 处理 注册事件 为单个函数 的情况</span></span><br><span class="line">    <span class="keyword">if</span> (--<span class="keyword">this</span>._eventsCount === <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">delete</span> events[type];</span><br><span class="line">      <span class="keyword">if</span> (events.removeListener)</span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">'removeListener'</span>, type, list.listener || listener);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> list !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理 注册事件 为数组的情况</span></span><br><span class="line">    position = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = list.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (list[i] === listener || list[i].listener === listener) &#123;</span><br><span class="line">        originalListener = list[i].listener;</span><br><span class="line">        position = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>)</span><br><span class="line">      list.shift();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      spliceOne(list, position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list.length === <span class="number">1</span>)</span><br><span class="line">      events[type] = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (events.removeListener !== <span class="literal">undefined</span>)</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="string">'removeListener'</span>, type, originalListener || listener);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同名方法，等同于 removeListener</span></span><br><span class="line">EventEmitter.prototype.off = EventEmitter.prototype.removeListener;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除所有的监听</span></span><br><span class="line">EventEmitter.prototype.removeAllListeners = <span class="function"><span class="keyword">function</span> <span class="title">removeAllListeners</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> listeners, events, i;</span><br><span class="line">  events = <span class="keyword">this</span>._events;</span><br><span class="line">  <span class="keyword">if</span> (events === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不侦听removeListener，不需要触发emit</span></span><br><span class="line">  <span class="keyword">if</span> (events.removeListener === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 通过赋值的方式 让 实例对象的 _events 为空</span></span><br><span class="line">      <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">      <span class="comment">// 事件数清0</span></span><br><span class="line">      <span class="keyword">this</span>._eventsCount = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[type] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (--<span class="keyword">this</span>._eventsCount === <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">delete</span> events[type];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为所有事件上的所有侦听器发出removeListener</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(events);</span><br><span class="line">    <span class="keyword">var</span> key;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; keys.length; ++i) &#123;</span><br><span class="line">      key = keys[i];</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">'removeListener'</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">this</span>.removeAllListeners(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.removeAllListeners(<span class="string">'removeListener'</span>);</span><br><span class="line">    <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">this</span>._eventsCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  listeners = events[type];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> listeners === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.removeListener(type, listeners);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (listeners !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// LIFO order</span></span><br><span class="line">    <span class="keyword">for</span> (i = listeners.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">this</span>.removeListener(type, listeners[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样的，我们先看 原型方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_listeners</span>(<span class="params">target, type, unwrap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> events = target._events;</span><br><span class="line">  <span class="keyword">if</span> (events === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  <span class="comment">// 参数type为事件名</span></span><br><span class="line">  <span class="keyword">var</span> evlistener = events[type];</span><br><span class="line">  <span class="keyword">if</span> (evlistener === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> evlistener === <span class="string">'function'</span>)</span><br><span class="line">    <span class="keyword">return</span> unwrap ? [evlistener.listener || evlistener] : [evlistener];</span><br><span class="line">  <span class="keyword">return</span> unwrap ?</span><br><span class="line">    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventEmitter.prototype.listeners = <span class="function"><span class="keyword">function</span> <span class="title">listeners</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回 _listeners调用的结果，回到 _listener函数</span></span><br><span class="line">  <span class="keyword">return</span> _listeners(<span class="keyword">this</span>, type, <span class="literal">true</span>);</span><br><span class="line">&#125;;</span><br><span class="line">EventEmitter.prototype.rawListeners = <span class="function"><span class="keyword">function</span> <span class="title">rawListeners</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _listeners(<span class="keyword">this</span>, type, <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br><span class="line">EventEmitter.listenerCount = <span class="function"><span class="keyword">function</span>(<span class="params">emitter, type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> emitter.listenerCount === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> emitter.listenerCount(type);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> listenerCount.call(emitter, type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">EventEmitter.prototype.listenerCount = listenerCount;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listenerCount</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> events = <span class="keyword">this</span>._events;</span><br><span class="line">  <span class="keyword">if</span> (events !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> evlistener = events[type];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> evlistener === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (evlistener !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> evlistener.length;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EventEmitter.prototype.eventNames = <span class="function"><span class="keyword">function</span> <span class="title">eventNames</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._eventsCount &gt; <span class="number">0</span> ? ReflectOwnKeys(<span class="keyword">this</span>._events) : [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助方法，浅拷贝数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayClone</span>(<span class="params">arr, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> copy = <span class="keyword">new</span> <span class="built_in">Array</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    copy[i] = arr[i];</span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组中删除某项</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spliceOne</span>(<span class="params">list, index</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; index + <span class="number">1</span> &lt; list.length; index++)</span><br><span class="line">    list[index] = list[index + <span class="number">1</span>];</span><br><span class="line">  list.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// listner的拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unwrapListeners</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = <span class="keyword">new</span> <span class="built_in">Array</span>(arr.length);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ret.length; ++i) &#123;</span><br><span class="line">    ret[i] = arr[i].listener || arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 观察者 </tag>
            
            <tag> 发布订阅 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【年中总结】提升学习效率，良好习惯养成与坚持</title>
      <link href="/2018/06/03/%E3%80%90%E5%B9%B4%E6%80%BB%E7%BB%93%E3%80%91%E6%8F%90%E5%8D%87%E5%AD%A6%E4%B9%A0%E6%95%88%E7%8E%87%EF%BC%8C%E8%89%AF%E5%A5%BD%E4%B9%A0%E6%83%AF%E5%85%BB%E6%88%90%E4%B8%8E%E5%9D%9A%E6%8C%81/"/>
      <url>/2018/06/03/%E3%80%90%E5%B9%B4%E6%80%BB%E7%BB%93%E3%80%91%E6%8F%90%E5%8D%87%E5%AD%A6%E4%B9%A0%E6%95%88%E7%8E%87%EF%BC%8C%E8%89%AF%E5%A5%BD%E4%B9%A0%E6%83%AF%E5%85%BB%E6%88%90%E4%B8%8E%E5%9D%9A%E6%8C%81/</url>
      <content type="html"><![CDATA[<p><img src="/2018/06/03/【年总结】提升学习效率，良好习惯养成与坚持/18-6-6/82300696.jpg" alt=""></p><blockquote><p>2018年已过了一半，自己的目标也在稳步进行着，但这还不够，于是制定了这个年底前的冲刺计划。希望自己能坚持下来，顺利达成今年的最终目标！  于是这篇没什么技术含量，纯抒情~</p></blockquote><a id="more"></a><p>好在春节后工作上压力少了些，周末基本没加班了。在周二或三，周末拿一天出去打打羽毛球或者乒乓球的运动节奏下，颈椎基本没事了。身体才是革命的本钱啊。闹钟定在6点半，提醒自己一定吃了饭后再回公司，以免8点半后除了面没什么吃的了。</p><p>在年中也写好了年中总结和相关计划，对于自己的表现只能说中规中矩吧，克服了几个技术难点：</p><ul><li>v18n国际化</li><li>权限控制分级下的组件模块化</li><li>vuex模块分层及本地api缓存</li></ul><p>感觉完成度不是太高，还有待继续优化和学习。新入坑了好几个技能点（感觉技能点都没点亮的程度）</p><ul><li>Vue SSR服务端渲染 （勉强算是把demo做出来了。。 对于原生ssr还是一知半解）</li><li>Nuxt 入坑了一小半，个人网站的搭建用到了，目前完成66%吧（就差作品整理了希望9月左右能完善上线）</li><li>微信小程序 原生貌似是 view - text -&gt; div - span 的感觉，最近美团开源的mpvue拿来练手，把个人网站的图书模块拿来做demo了</li><li>TypeScript 拿来把vue-where-go项目重构了下，但build失败只能跑dev - - 引better-scroll报错还是没解决，趁deno的热劲，后半年的重点之一就是系统学习TypeScript了</li></ul><p>上面的感觉完成度都在80%左右吧，还有就是网上看到个不错的在线简历，自己拿来改成了响应式，感觉还不错，在下一份工作确定后我就开源出来 -w- 后半年继续了解把demo做了博客写了，以上先告一段落吧。</p><hr><p>之后的目标计划和达成目标：</p><ol><li>前端测试相关</li><li>前端基础、难点、考点梳理</li><li>正则表达式强化学习</li><li>webpack再学习 （还停留在3.11 初步了解4.5 现在貌似4.8了？）</li><li>前端性能相关</li><li>原生Node模块 + express + koa</li><li>再深入框架 Vue React</li></ol><hr><p>2 的话，新入的几个知乎live，掘金的小册可以帮到梳理不少，之前慕课的几个好课程也有很多参考。</p><p>性能的话，受到之前掘金一篇文章影响，（作者是应届生啊，现在的人真是越来越牛了，再不努力以后要失业了）准备后面有时间好好学习下 <a href="https://github.com/pod4g/hiper" target="_blank" rel="noopener">hiper</a> 源码</p><p>Node很纠结啦，说不会，天天用天天写？ 说会，也就writeFile、npm install npm run 什么的… 大前端就在前方，虽然被亲爹抛弃了，还是有很高的学习价值，服务端 express -&gt; koa -&gt; egg 我是按这个流程先过渡啦</p><p><img src="https://img1.doubanio.com/view/subject/l/public/s29715097.jpg" alt=""></p><p><img src="https://img1.doubanio.com/view/subject/l/public/s29735438.jpg" alt=""></p><p>这两本对于上面的总结很有帮助，顺便就安利出来了。打折活动顺便还买了几个Node、Vue、React相关的书，再此期间，每周坚持写博客，希望不会打脸。</p><p>我相信时间是真的可以挤出来的（相信有什么X用，道理懂就是想说啊） … 但问题是世界杯来了 - - 还好喜欢的荷兰今年没入选，作为一名伪球迷小组赛德国阿根廷巴西西班牙可以看看，之后就是1/4和决赛了吧</p><p>还有房租到期了，该搬家了 … 想着就头大。 等等，好像可以去摇号了？ 各种麻烦，还是再租5年房吧，期待以久的7月—— OverLoad、绮玉sense、巨人 …… 真美好，于是，存到10月吧？！</p><hr><p>我还是想说 ~ 恭喜RNG</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1528284389223&amp;di=989cd89eea25cc50b626e0f290f32517&amp;imgtype=0&amp;src=http%3A%2F%2Fnpic7.edushi.com%2Fcn%2Fzixun%2Fzh-chs%2F2018-05%2F21%2F4404599-201805210954256741.jpg" alt=""></p><p>大声告诉自己，此刻的我最想：</p><p><del>补番、打游戏、打球、K歌、狼人杀、旅行</del> 敲代码，好好学习，天天向上。</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1528285008590&amp;di=61ab62cee77c0250c5d4b954d8f8150c&amp;imgtype=0&amp;src=http%3A%2F%2Fcdn.oss.gaokaopai.com%2Fmobile%2Fface%2Fpost%2F2017%2F11%2F06%2Fthumb%2F2017110692731509975374500_and.jpg" alt=""></p>]]></content>
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【小程序】mpvue开发小程序初体验</title>
      <link href="/2018/05/07/%E3%80%90%E5%B0%8F%E7%A8%8B%E5%BA%8F%E3%80%91mpvue%E5%BC%80%E5%8F%91%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/2018/05/07/%E3%80%90%E5%B0%8F%E7%A8%8B%E5%BA%8F%E3%80%91mpvue%E5%BC%80%E5%8F%91%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      <content type="html"><![CDATA[<blockquote><p>mpvue （github 地址请参见）是一个使用 Vue.js 开发小程序的前端框架。框架基于 Vue.js 核心，mpvue 修改了 Vue.js 的 runtime 和 compiler 实现，使其可以运行在小程序环境中，从而为小程序开发引入了整套 Vue.js 开发体验。</p></blockquote><p>具体可以参考官方文档，之前虽然也尝试过小程序，就觉得是vue + react，半杂着es6和模版代码，由于没有css预处理器写起来样式和组件化感觉都很麻烦，正好趁着火热，把一直想做的小程序继续完成了。</p><a id="more"></a><p>周末做了2天总算是熬出来了 ……实在是不想写博客啊。 好了不发牢骚，开始正文</p><p>小程序的初始化这里就不介绍了，搬网上的文字也没意思， 直接看这里 <a href="http://mpvue.com/mpvue/quickstart/" target="_blank" rel="noopener">http://mpvue.com/mpvue/quickstart/</a></p><p>项目跑起来打包出来的dist就是我们需要的文件了，我们先看下根目录下的配置文件 project.config.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"description"</span>: <span class="string">"项目配置文件。"</span>,</span><br><span class="line"><span class="attr">"setting"</span>: &#123;</span><br><span class="line"><span class="attr">"urlCheck"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">"es6"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"postcss"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">"minified"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">"newFeature"</span>: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"miniprogramRoot"</span>: <span class="string">"./dist/"</span>,</span><br><span class="line"><span class="attr">"client"</span>: <span class="string">"./dist"</span>,</span><br><span class="line"><span class="attr">"svr"</span>: <span class="string">"./server"</span>,</span><br><span class="line"><span class="attr">"qcloudRoot"</span>: <span class="string">"./server"</span>,</span><br><span class="line"><span class="attr">"appid"</span>: <span class="string">"你的小程序id"</span>,</span><br><span class="line"><span class="attr">"projectname"</span>: <span class="string">"my-miniapp"</span>,</span><br><span class="line"><span class="attr">"compileType"</span>: <span class="string">"miniprogram"</span></span><br><span class="line">  // condition 不知道干啥的，这里没贴</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>很有意思的点在于，小程序每个文件都有一个json配置文件，可理解为这是多页的SPA组合而成。如果要引入vuex需在每<code>页</code>的entry中引入。那问题是会不会出现类似于flux多个store导致状态管理混乱的情况？ 这个具体的还没有试过，等有时间把应用做大点，想尝试下。</p></blockquote><p>一看就明白的配置，还是要说说。 setting里是针对打包后的dist目录，这里没有开启es6（毕竟babel本来就是编译为es5的）</p><p>miniprogramRoot 就是小程序开发工具 读的app入口了。client和svr是我根据官方的demo改的，这样，可以上传server到测试环境里，直接mock数据。</p><hr><p>不用写那啥wxss和小程序原生的模版还是挺好，用多了和React、Vue挺混乱的，感觉后期会精分。</p><p>npm run dev 其实会打包出来 dist 而小程序找的是这个dist，其内容被mpvue转成了 微信小程序的原生模版映射。小程序会在开发环境下分配测试域名，我们要mock数据貌似只能通过该方式来（没了解太多，有其他方式请批评指教）</p><p>server/routes/index.js</p><pre><code>router.get(&apos;/books&apos;, ccontrollers.books)</code></pre><p>server端是express，看着还是挺熟悉，这是定义接口，于是我们顺藤摸瓜到 server/controllers 下</p><p><code>index.js</code>文件是作路由映射，<code>module.exports = mapDir(path.join(__dirname))</code> 找到当前文件夹下的文件或文件夹。我们随便打开个文件看看，如 user.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line"><span class="comment">// 通过 Koa 中间件进行登录态校验之后</span></span><br><span class="line"><span class="comment">// 登录信息会被存储到 ctx.state.$wxInfo</span></span><br><span class="line"><span class="comment">// 具体查看：</span></span><br><span class="line"><span class="keyword">if</span> (ctx.state.$wxInfo.loginState === <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// loginState 为 1，登录态校验成功</span></span><br><span class="line">ctx.state.data = ctx.state.$wxInfo.userinfo</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ctx.state.code = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释得很清楚，若访问服务端 <code>/user</code> 就能在<code>ctx.state</code>中拿到我们想到的数据了。</p><p>于是编写一个 books.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">  ctx.state.data = &#123;</span><br><span class="line">    books: [</span><br><span class="line"><span class="comment">// 数据省略</span></span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前台访问</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HOST = <span class="string">'用腾讯云分配的域名即可'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="comment">// 省略</span></span><br><span class="line">methods: &#123;</span><br><span class="line">getCgiBooks() &#123;</span><br><span class="line">      <span class="comment">// util.showBusy('请求中...')</span></span><br><span class="line">      <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">      wx.getStorage(&#123;</span><br><span class="line">        key: <span class="string">'booklist'</span>,</span><br><span class="line">        success(res) &#123;</span><br><span class="line">          <span class="comment">// console.log('从缓存拿booklist', res.data)</span></span><br><span class="line">          that.books = res.data</span><br><span class="line">        &#125;,</span><br><span class="line">        fail(err) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(err)</span><br><span class="line">          wx.request(&#123;</span><br><span class="line">            url: <span class="string">`<span class="subst">$&#123;HOST&#125;</span>/weapp/books`</span>,</span><br><span class="line">            login: <span class="literal">false</span>,</span><br><span class="line">            success(result) &#123;</span><br><span class="line">              <span class="comment">// util.showSuccess('请求成功完成')</span></span><br><span class="line">              <span class="comment">// console.log('请求服务端拿到booklist', result.data.data.books)</span></span><br><span class="line">              that.books = result.data.data.books</span><br><span class="line">              wx.setStorage(&#123;</span><br><span class="line">                key: <span class="string">'booklist'</span>,</span><br><span class="line">                data: result.data.data.books</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            fail(error) &#123;</span><br><span class="line">              <span class="comment">// util.showModel('请求失败', error)</span></span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">'request fail'</span>, error)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步和回调很多，随着业务场景的复杂度提升感觉后期的回调会很可怕…… 所以可根据场景自行封装Promise，使用async/await的方式</p><h2 id="先挖坑"><a href="#先挖坑" class="headerlink" title="先挖坑"></a>先挖坑</h2><p>小程序还在开发中。直接拿vue来写，上手超快，有其他坑再上来补充好来。。</p><p>主要是小程序还未发布，只能本地玩，之后再把项目踩坑等传上来。</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mpvue </tag>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【TS】使用vuex-class</title>
      <link href="/2018/05/01/%E3%80%90TS%E3%80%91%E4%BD%BF%E7%94%A8vuex-class/"/>
      <url>/2018/05/01/%E3%80%90TS%E3%80%91%E4%BD%BF%E7%94%A8vuex-class/</url>
      <content type="html"><![CDATA[<blockquote><p><code>vuex-class</code>是<code>vue-class-component</code>作者写的，质量有保证。且目前这类的库也不多，用法和之前的vue-property-decorator差不多，主要是通过装饰器模式，一来支持ts里的vuex，二来减少冗余的代码量。</p></blockquote><a id="more"></a><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>我们直接来看官方的例子就好，引入相关依赖</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">'vue-class-component'</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  State,</span><br><span class="line">  Getter,</span><br><span class="line">  Action,</span><br><span class="line">  Mutation,</span><br><span class="line">  namespace</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'vuex-class'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> someModule = namespace(<span class="string">'path/to/module'</span>)</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  @State(<span class="string">'foo'</span>) stateFoo</span><br><span class="line">  @State(<span class="function"><span class="params">state</span> =&gt;</span> state.bar) stateBar</span><br><span class="line">  @Getter(<span class="string">'foo'</span>) getterFoo</span><br><span class="line">  @Action(<span class="string">'foo'</span>) actionFoo</span><br><span class="line">  @Mutation(<span class="string">'foo'</span>) mutationFoo</span><br><span class="line">  @someModule.Getter(<span class="string">'foo'</span>) moduleGetterFoo</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 若省略参数，直接使用参数名称</span></span><br><span class="line">  @State foo</span><br><span class="line">  @Getter bar</span><br><span class="line">  @Action baz</span><br><span class="line">  @Mutation qux</span><br><span class="line"></span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="keyword">this</span>.stateFoo <span class="comment">// -&gt; store.state.foo</span></span><br><span class="line">    <span class="keyword">this</span>.stateBar <span class="comment">// -&gt; store.state.bar</span></span><br><span class="line">    <span class="keyword">this</span>.getterFoo <span class="comment">// -&gt; store.getters.foo</span></span><br><span class="line">    <span class="keyword">this</span>.actionFoo(&#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; store.dispatch('foo', &#123; value: true &#125;)</span></span><br><span class="line">    <span class="keyword">this</span>.mutationFoo(&#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; store.commit('foo', &#123; value: true &#125;)</span></span><br><span class="line">    <span class="keyword">this</span>.moduleGetterFoo <span class="comment">// -&gt; store.getters['path/to/module/foo']</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看着非常简单… 好像懂了 大概就是这种感觉？！</p><p>然而 namespace 这个就找不到，需要自己在 <code>*.d.ts</code>文件里定义接口</p><p>和我们之前用的vuex提供的 mapMutations mapGetters 这些一样，只是换了种形式进来了而已。</p><p>源码也更少，增加点信心一探究竟吧~</p><p>vuex-class/src/index.ts</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  State,</span><br><span class="line">  Getter,</span><br><span class="line">  Action,</span><br><span class="line">  Mutation,</span><br><span class="line">  <span class="keyword">namespace</span></span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'./bindings'</span></span><br></pre></td></tr></table></figure><p>vuex-class/src/bindings.ts</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createDecorator&#125; <span class="keyword">from</span> <span class="string">'vue-class-component'</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  mapState,</span><br><span class="line">  mapGetters,</span><br><span class="line">  mapActions,</span><br><span class="line">  mapMutations</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们在使用时，ts有各种烦人的检查，若类型不一致报错是无法运行的</span></span><br><span class="line"><span class="comment">// 把其他的省略了- - 只保留了看得懂和我们关心，使用的那几个</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> BindingHelpers &#123;</span><br><span class="line">  State: StateBindingHelper</span><br><span class="line">  Getter: BindingHelper</span><br><span class="line">  Mutation: BindingHelper</span><br><span class="line">  Action: BindingHelper</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有了这几个方法后，我们就可以在ts里使用了 那具体是怎么实现的？</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> State = createBindingHelper(<span class="string">'computed'</span>, mapState) <span class="keyword">as</span> StateBindingHelper</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Getter = createBindingHelper(<span class="string">'computed'</span>, mapGetters)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Action = createBindingHelper(<span class="string">'methods'</span>, mapActions)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Mutation = createBindingHelper(<span class="string">'methods'</span>, mapMutations)</span><br></pre></td></tr></table></figure><p>核心处理函数 <code>createBindingHelper</code>单独拿出来分析了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBindingHelper</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 方法或者属性，它已经告诉我们了 在computed或methods上</span></span></span></span><br><span class="line">  bindTo: 'computed' | 'methods',</span><br><span class="line">  <span class="comment">// 这个后面再说，用过应该能想个大概</span></span><br><span class="line">  mapFn: MapHelper</span><br><span class="line">) BindingHelper: &#123;</span><br><span class="line">  <span class="comment">// 返回类型因属于 BindingHelper</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">makeDecorator</span>(<span class="params">may: <span class="built_in">any</span>, <span class="keyword">namespace</span>: <span class="built_in">string</span> | <span class="literal">undefined</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createDecorator(<span class="function">(<span class="params">componentOptions, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 初次处理, 初始化为对象</span></span><br><span class="line">      <span class="keyword">if</span> (!componentOptions[bindTo]) &#123;</span><br><span class="line">        componentOptions[bindTo] = &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> mapObject = &#123;[key]: map&#125;</span><br><span class="line">      <span class="comment">// 这个!号突如其来，没懂…</span></span><br><span class="line">      componentOptions[bindTo]![key] = <span class="keyword">namespace</span> !== <span class="literal">undefined</span></span><br><span class="line">        ? mapFn(<span class="keyword">namespace</span>, mapObject)[key]</span><br><span class="line">        : mapFn(mapObject)[key]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能大致说下意思了…</p><p>可耻地写个 Todo 了，我去看TypeScript最新的官方文档了。。。</p>]]></content>
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> ts </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【TS】装饰器模式与vue-property-decorator</title>
      <link href="/2018/04/26/%E3%80%90TS%E3%80%91%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E4%B8%8Evue-property-decorator/"/>
      <url>/2018/04/26/%E3%80%90TS%E3%80%91%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E4%B8%8Evue-property-decorator/</url>
      <content type="html"><![CDATA[<p>在用typescript时，vue-property-decorator 是在 vue-class-component 上增强了更多的结合 Vue 特性的装饰器，新增了这 7 个装饰器：</p><ul><li>@Emit</li><li>@Inject</li><li>@Model</li><li>@Prop</li><li>@Provide</li><li>@Watch</li><li>@Component (从 vue-class-component 继承)</li></ul><p>源码也就200来行，于是就有信心来慢慢读了</p><a id="more"></a><p>为什么需要vue-class-component？ 在typescript里写vue 每次都需要写很多额外的形式代码：</p><p>而装饰器就是解决这些冗余代码的（实质上并没有减少，只是用一层函数包装了，后面有源码会讲解）</p><blockquote><p>可自行了解一下<a href="http://blog.csdn.net/zhshulin/article/details/38665187" target="_blank" rel="noopener">装饰模式</a></p></blockquote><h2 id="AOP-面向切面编程"><a href="#AOP-面向切面编程" class="headerlink" title="AOP 面向切面编程"></a>AOP 面向切面编程</h2><p>示例：</p><ul><li>首先创建一个普通的Man类，它的抵御值 2，攻击力为 3，血量为 3；</li><li>然后我们让其带上钢铁侠的盔甲，这样他的抵御力增加 100，变成 102；</li><li>让其带上光束手套，攻击力增加 50，变成 53；</li><li>最后让他增加“飞行”能力</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(def = 2, atk = 3, hp = 3) &#123;</span><br><span class="line">    <span class="keyword">this</span>.init(def, atk, hp)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init(def, atk, hp) &#123;</span><br><span class="line">    <span class="keyword">this</span>.def = def <span class="comment">//防御</span></span><br><span class="line">    <span class="keyword">this</span>.atk = atk <span class="comment">// 攻击</span></span><br><span class="line">    <span class="keyword">this</span>.hp = hp</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`防御力: <span class="subst">$&#123;<span class="keyword">this</span>.def&#125;</span>，攻击力: <span class="subst">$&#123;<span class="keyword">this</span>.atk&#125;</span>，血量：<span class="subst">$&#123;<span class="keyword">this</span>.hp&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tony = <span class="keyword">new</span> Man()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`当前状态 ===&gt; <span class="subst">$&#123;tony&#125;</span>`</span>)</span><br><span class="line"><span class="comment">// 输出：当前状态 ===&gt; 防御力:2,攻击力:3,血量:3</span></span><br></pre></td></tr></table></figure><p>然后 创建 decorateArmour 方法，为钢铁侠装配盔甲——注意 decorateArmour 是装饰在方法init上的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decorateArmour</span>(<span class="params">target, key, descriptor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> method = descriptor.value</span><br><span class="line">  <span class="keyword">let</span> moreDef = <span class="number">100</span></span><br><span class="line">  <span class="keyword">let</span> ret</span><br><span class="line">  descriptor.value = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    args[<span class="number">0</span>] += moreDef</span><br><span class="line">    ret = method.apply(target, args)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> descriptor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(def = 2, atk = 3, hp = 3) &#123;</span><br><span class="line">    <span class="keyword">this</span>.init(def, atk, hp)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @decorateArmour</span><br><span class="line">  init(def, atk, hp) &#123;</span><br><span class="line">    <span class="keyword">this</span>.def = def</span><br><span class="line">    <span class="keyword">this</span>.atk = atk</span><br><span class="line">    <span class="keyword">this</span>.hp = hp</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`防御力:<span class="subst">$&#123;<span class="keyword">this</span>.def&#125;</span>,攻击力:<span class="subst">$&#123;<span class="keyword">this</span>.atk&#125;</span>,血量:<span class="subst">$&#123;<span class="keyword">this</span>.hp&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tony = <span class="keyword">new</span> Man();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`当前状态 ===&gt; <span class="subst">$&#123;tony&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// 输出：当前状态 ===&gt; 防御力:102,攻击力:3,血量:3</span></span><br></pre></td></tr></table></figure><p>Decorators 的本质是利用了 ES5 的 Object.defineProperty 属性，这三个参数其实是和 Object.defineProperty 参数一致的，因此不能更改，详细分析请见 <a href="http://greengerong.com/blog/2015/09/24/es7-javascript-decorators/" target="_blank" rel="noopener">细说 ES7 JavaScript Decorators</a></p><p>同样的代码复制一份，增加攻击力：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decorateLight</span>(<span class="params">target, key, descriptor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> method = descriptor.value;</span><br><span class="line">  <span class="keyword">let</span> moreAtk = <span class="number">50</span>;</span><br><span class="line">  <span class="keyword">let</span> ret;</span><br><span class="line">  descriptor.value = <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">    args[<span class="number">1</span>] += moreAtk;</span><br><span class="line">    ret = method.apply(target, args);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(def = 2,atk = 3,hp = 3)&#123;</span><br><span class="line">    <span class="keyword">this</span>.init(def,atk,hp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @decorateArmour</span><br><span class="line">  @decorateLight</span><br><span class="line">  init(def,atk,hp)&#123;</span><br><span class="line">    <span class="keyword">this</span>.def = def; <span class="comment">// 防御值</span></span><br><span class="line">    <span class="keyword">this</span>.atk = atk;  <span class="comment">// 攻击力</span></span><br><span class="line">    <span class="keyword">this</span>.hp = hp;  <span class="comment">// 血量</span></span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> tony = <span class="keyword">new</span> Man();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`当前状态 ===&gt; <span class="subst">$&#123;tony&#125;</span>`</span>);</span><br><span class="line"><span class="comment">//输出：当前状态 ===&gt; 防御力:102,攻击力:53,血量:3</span></span><br></pre></td></tr></table></figure><hr><p>按装饰模式所言，装饰模式有：纯粹装饰模式和半透明装饰模式</p><p>上面两个属于纯粹装饰模式，它不增加对原有类的接口。而下面给普通人增加飞行能力，给类增加新方法，属于半透明的装饰模式，类似适配器模式：</p><ol><li>增加一个方法</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addFly</span>(<span class="params">canFly</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    target.canFly = canFly</span><br><span class="line">    <span class="keyword">let</span> extra = canFly ? <span class="string">'(技能加成：飞行能力)'</span> : <span class="string">''</span></span><br><span class="line">    <span class="keyword">let</span> method = target.prototype.toString</span><br><span class="line"></span><br><span class="line">    target.prototype.toString = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> method.apply(target.prototype, args) + extra</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>用这个方法去直接装饰类</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addFly</span>(<span class="params">canFly</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 接上， 省略了</span></span><br><span class="line">&#125;</span><br><span class="line">@addFly(<span class="literal">true</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(def = 2, atk = 3, hp = 3) &#123;</span><br><span class="line">    <span class="keyword">this</span>.init(def, atk, hp)</span><br><span class="line">  &#125;</span><br><span class="line">  @decorateArmour</span><br><span class="line">  @decorateLight</span><br><span class="line">  init(def, atk, hp) &#123;</span><br><span class="line">    <span class="keyword">this</span>.def = def</span><br><span class="line">    <span class="keyword">this</span>.atk = atk</span><br><span class="line">    <span class="keyword">this</span>.hp = hp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`当前状态 ===&gt; <span class="subst">$&#123;tony&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// 输出：当前状态 ===&gt; 防御力:102,攻击力:53,血量:3(技能加成:飞行能力)</span></span><br></pre></td></tr></table></figure><p>作用在方法上的decorator接收第一个参数(target)是类的prototype；如果把一个decorator作用到类上，则它的第一个参数target是类本身</p><h2 id="经典实现-Logger"><a href="#经典实现-Logger" class="headerlink" title="经典实现 Logger"></a>经典实现 Logger</h2><p>有了上面的基础，下面我们来写一个简易版<code>日志系统</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> log = <span class="function"><span class="params">type</span> =&gt;</span> (target, name, descriptor) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> method = descriptor.value</span><br><span class="line">  descriptor.value = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">`(<span class="subst">$&#123;type&#125;</span> 正在执行：<span class="subst">$&#123;name&#125;</span>(<span class="subst">$&#123;args&#125;</span>) = ?`</span>)</span><br><span class="line">    <span class="keyword">let</span> ret</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ret = method.apply(target, args)</span><br><span class="line">      <span class="built_in">console</span>.info(<span class="string">`(<span class="subst">$&#123;tytpe&#125;</span> 成功：<span class="subst">$&#123;name&#125;</span>(<span class="subst">$&#123;args&#125;</span>) =&gt; <span class="subst">$&#123;ret&#125;</span>)`</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">`(<span class="subst">$&#123;tytpe&#125;</span> 失败：<span class="subst">$&#123;name&#125;</span>(<span class="subst">$&#123;args&#125;</span>) =&gt; <span class="subst">$&#123;error&#125;</span>)`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IronMan</span> </span>&#123;</span><br><span class="line">  @log(<span class="string">'IronMan 自检阶段'</span>)</span><br><span class="line">  check() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'检查完毕'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @log(<span class="string">'IronMan 攻击阶段'</span>)</span><br><span class="line">  attack() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'击倒敌人'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @log(<span class="string">'IronMan 机体报错'</span>)</span><br><span class="line">  error() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">'something is wrong!'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tony = <span class="keyword">new</span> IronMan()</span><br><span class="line">tony.check();</span><br><span class="line">tony.attack();</span><br><span class="line">tony.error();</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// (IronMan 自检阶段) 正在执行: check() = ?</span></span><br><span class="line"><span class="comment">// (IronMan 自检阶段) 成功 : check() =&gt; 检查完毕</span></span><br><span class="line"><span class="comment">// (IronMan 攻击阶段) 正在执行: attack() = ?</span></span><br><span class="line"><span class="comment">// (IronMan 攻击阶段) 成功 : attack() =&gt; 击倒敌人</span></span><br><span class="line"><span class="comment">// (IronMan 机体报错) 正在执行: error() = ?</span></span><br><span class="line"><span class="comment">// (IronMan 机体报错) 失败: error() =&gt; Something is wrong!</span></span><br></pre></td></tr></table></figure><p>Logger方法的关键在于：</p><ul><li>首先使用 <code>const method = descriptor.value</code> 将原有的方法提取出来，保障原有方法的纯净</li><li>在<code>try catch</code>语句是调用 <code>ret = method.apply(target, args)</code> 在调用之前之后分别进行日志汇报</li><li>最后返回 <code>return ret</code> 原始的调用结果</li></ul><h3 id="vue-property-decorator"><a href="#vue-property-decorator" class="headerlink" title="vue-property-decorator"></a>vue-property-decorator</h3><p>vue-property-decorator 是在 vue-class-component 上增强了更多的结合 Vue 特性的装饰器，新增了这 7 个装饰器：</p><ul><li>@Emit</li><li>@Inject</li><li>@Model</li><li>@Prop</li><li>@Provide</li><li>@Watch</li><li>@Component (从 vue-class-component 继承)</li></ul><p>我们来读读源码上是怎样来实现的吧：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue, &#123;PropOptions, WatchOptions&#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Component, &#123;createDecorator&#125; <span class="keyword">from</span> <span class="string">'vue-class-component'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'reflect-metadata'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Constructor = &#123;</span><br><span class="line">  <span class="keyword">new</span>(...args: <span class="built_in">any</span>[]): <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们在 vue-property-decorator 可调用 Vue 和 Component 是这样继承下来的</span></span><br><span class="line"><span class="keyword">export</span> &#123; Component, Vue &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of an inject</span></span><br><span class="line"><span class="comment"> * @param key key</span></span><br><span class="line"><span class="comment"> * @return PropertyDecorator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Inject</span>(<span class="params">key?: <span class="built_in">string</span> | symbol</span>): <span class="title">PropertyDecorator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createDecorator(<span class="function">(<span class="params">componentOptions, k</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> componentOptions.inject === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      <span class="comment">// inject默认为 空对象</span></span><br><span class="line">      componentOptions.inject = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(componentOptions.inject)) &#123;</span><br><span class="line">      <span class="comment">// 第二个参数 就是我们对 inject的注入</span></span><br><span class="line">      componentOptions.inject[k] = key || k</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of an provide</span></span><br><span class="line"><span class="comment"> * @param key key</span></span><br><span class="line"><span class="comment"> * @return PropertyDecorator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Provide</span>(<span class="params">key?: <span class="built_in">string</span> | symbol</span>): <span class="title">PropertyDecorator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createDecorator(<span class="function">(<span class="params">componentOptions, k</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> provide: <span class="built_in">any</span> = componentOptions.provide</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> provide !== <span class="string">'function'</span> || !provide.managed) &#123;</span><br><span class="line">      <span class="keyword">const</span> original = componentOptions.provide</span><br><span class="line">      provide = componentOptions.provide = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> rv = <span class="built_in">Object</span>.create((<span class="keyword">typeof</span> original === <span class="string">'function'</span> ? original.call(<span class="keyword">this</span>) : original) || <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> provide.managed) rv[provide.managed[i]] = <span class="keyword">this</span>[i]</span><br><span class="line">        <span class="keyword">return</span> rv</span><br><span class="line">      &#125;</span><br><span class="line">      provide.managed = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    provide.managed[k] = key || k</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of model</span></span><br><span class="line"><span class="comment"> * @param  event event name</span></span><br><span class="line"><span class="comment"> * @return PropertyDecorator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">export function Model(event?: string, options: (PropOptions | Constructor[] | Constructor) = &#123;&#125;): PropertyDecorator &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: Vue, key: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(options) &amp;&amp; <span class="keyword">typeof</span> (options <span class="keyword">as</span> PropOptions).type === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      (options <span class="keyword">as</span> PropOptions).type = Reflect.getMetadata(<span class="string">'design:type'</span>, target, key)</span><br><span class="line">    &#125;</span><br><span class="line">    createDecorator(<span class="function">(<span class="params">componentOptions, k</span>) =&gt;</span> &#123;</span><br><span class="line">      (componentOptions.props || (componentOptions.props = &#123;&#125;) <span class="keyword">as</span> <span class="built_in">any</span>)[k] = options</span><br><span class="line">      componentOptions.model = &#123; prop: k, event: event || k &#125;</span><br><span class="line">    &#125;)(target, key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of a prop</span></span><br><span class="line"><span class="comment"> * @param  options the options for the prop</span></span><br><span class="line"><span class="comment"> * @return PropertyDecorator | void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">export function Prop(options: (PropOptions | Constructor[] | Constructor) = &#123;&#125;): PropertyDecorator &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: Vue, key: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(options) &amp;&amp; <span class="keyword">typeof</span> (options <span class="keyword">as</span> PropOptions).type === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      (options <span class="keyword">as</span> PropOptions).type = Reflect.getMetadata(<span class="string">'design:type'</span>, target, key)</span><br><span class="line">    &#125;</span><br><span class="line">    createDecorator(<span class="function">(<span class="params">componentOptions, k</span>) =&gt;</span> &#123;</span><br><span class="line">      (componentOptions.props || (componentOptions.props = &#123;&#125;) <span class="keyword">as</span> <span class="built_in">any</span>)[k] = options</span><br><span class="line">    &#125;)(target, key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of a watch function</span></span><br><span class="line"><span class="comment"> * @param  path the path or the expression to observe</span></span><br><span class="line"><span class="comment"> * @param  WatchOption</span></span><br><span class="line"><span class="comment"> * @return MethodDecorator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Watch</span>(<span class="params">path: <span class="built_in">string</span>, options: WatchOptions = &#123;&#125;</span>): <span class="title">MethodDecorator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; deep = <span class="literal">false</span>, immediate = <span class="literal">false</span> &#125; = options</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> createDecorator(<span class="function">(<span class="params">componentOptions, handler</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> componentOptions.watch !== <span class="string">'object'</span>) &#123;</span><br><span class="line">      componentOptions.watch = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    (componentOptions.watch <span class="keyword">as</span> <span class="built_in">any</span>)[path] = &#123; handler, deep, immediate &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Code copied from Vue/src/shared/util.js</span></span><br><span class="line"><span class="keyword">const</span> hyphenateRE = <span class="regexp">/\B([A-Z])/g</span></span><br><span class="line"><span class="keyword">const</span> hyphenate = <span class="function">(<span class="params">str: <span class="built_in">string</span></span>) =&gt;</span> str.replace(hyphenateRE, <span class="string">'-$1'</span>).toLowerCase()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of an event-emitter function</span></span><br><span class="line"><span class="comment"> * @param  event The name of the event</span></span><br><span class="line"><span class="comment"> * @return MethodDecorator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Emit</span>(<span class="params">event?: <span class="built_in">string</span></span>): <span class="title">MethodDecorator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: Vue, key: <span class="built_in">string</span>, descriptor: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    key = hyphenate(key)</span><br><span class="line">    <span class="keyword">const</span> original = descriptor.value</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span> <span class="title">emitter</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (original.apply(<span class="keyword">this</span>, args) !== <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">this</span>.$emit(event || key, ...args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of $off</span></span><br><span class="line"><span class="comment"> * @param event The name of the event</span></span><br><span class="line"><span class="comment"> * @param method The name of the method</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Off</span>(<span class="params">event?: <span class="built_in">string</span>, method?: <span class="built_in">string</span></span>): <span class="title">MethodDecorator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: Vue, key: <span class="built_in">string</span>, descriptor: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    key = hyphenate(key)</span><br><span class="line">    <span class="keyword">const</span> original = descriptor.value</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span> <span class="title">offer</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (original.apply(<span class="keyword">this</span>, args) !== <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (method) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>[method] === <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.$off(event || key, <span class="keyword">this</span>[method])</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'must be a method name'</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event) &#123;</span><br><span class="line">          <span class="keyword">this</span>.$off(event || key)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.$off()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of $on</span></span><br><span class="line"><span class="comment"> * @param event The name of the event</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">On</span>(<span class="params">event?: <span class="built_in">string</span></span>): <span class="title">MethodDecorator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createDecorator(<span class="function">(<span class="params">componentOptions, k</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> key = hyphenate(k)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> componentOptions.created !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      componentOptions.created = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> original = componentOptions.created</span><br><span class="line">    componentOptions.created = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      original()</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> componentOptions.methods !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$on(event || key, componentOptions.methods[k])</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of $once</span></span><br><span class="line"><span class="comment"> * @param event The name of the event</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Once</span>(<span class="params">event?: <span class="built_in">string</span></span>): <span class="title">MethodDecorator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createDecorator(<span class="function">(<span class="params">componentOptions, k</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> key = hyphenate(k)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> componentOptions.created !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      componentOptions.created = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> original = componentOptions.created</span><br><span class="line">    componentOptions.created = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      original()</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> componentOptions.methods !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$once(event || key, componentOptions.methods[k]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of $nextTick</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @export</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; method</span></span><br><span class="line"><span class="comment"> * @returns &#123;MethodDecorator&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">NextTick</span>(<span class="params">method: <span class="built_in">string</span></span>): <span class="title">MethodDecorator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: Vue, key: <span class="built_in">string</span>, descriptor: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> original = descriptor.value</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span> <span class="title">emitter</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (original.apply(<span class="keyword">this</span>, args) !== <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>[method] === <span class="string">'function'</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.$nextTick(<span class="keyword">this</span>[method])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'must be a method name'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> ts </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【TS】vue与typescript集成</title>
      <link href="/2018/04/25/%E3%80%90TS%E3%80%91vue%E4%B8%8Etypescript%E9%9B%86%E6%88%90/"/>
      <url>/2018/04/25/%E3%80%90TS%E3%80%91vue%E4%B8%8Etypescript%E9%9B%86%E6%88%90/</url>
      <content type="html"><![CDATA[<blockquote><p>一直想找个机会试试typescript，正好看到一个小项目练手，于是直接开始吧</p></blockquote><p>正文分两部分：</p><ul><li>vue与ts集成 </li><li>项目实战</li></ul><p>转自<a href="https://segmentfault.com/a/1190000012486378" target="_blank" rel="noopener">Vue-TypeScript-DpApp-Demo</a><br><a href="https://juejin.im/post/59f29d28518825549f7260b6" target="_blank" rel="noopener">Vue + TypeScript 新项目起手式</a></p><a id="more"></a><h2 id="Vue与TypeScript集成相关配置"><a href="#Vue与TypeScript集成相关配置" class="headerlink" title="Vue与TypeScript集成相关配置"></a>Vue与TypeScript集成相关配置</h2><p>此demo就是用了 typescript 改的~~ <a href="https://github.com/Fridolph/colorful-gallery.git" target="_blank" rel="noopener">https://github.com/Fridolph/colorful-gallery.git</a></p><p><code>vue init SimonZhangITer/vue-typescript-template &lt;project-name&gt;</code></p><p>npm i ts-loader -D</p><p>使用别人造好轮子就好。当然，我们还是要看看前人踩了哪些坑</p><h3 id="配置rules"><a href="#配置rules" class="headerlink" title="配置rules"></a>配置rules</h3><p>接着在Webpack的module.rules里面添加对ts的支持</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">  loader: <span class="string">'vue-loader'</span>,</span><br><span class="line">  options: vueLoaderConfig</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">  exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">  enforce: <span class="string">'pre'</span>,</span><br><span class="line">  loader: <span class="string">'tslint-loader'</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">  loader: <span class="string">'ts-loader'</span>,</span><br><span class="line">  exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">  options: &#123;</span><br><span class="line">    appendTsSuffixTo: [<span class="regexp">/\.vue$/</span>],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ts-loader</code>会检索当前目录下的 <code>tsconfig.json</code>文件，根据里面定义的规则来解析<code>.ts</code>文件，就跟<code>.babelrc的作用一样</code></p><blockquote><p>tslint-loader 作用等同于 eslint-loader</p></blockquote><h3 id="配置extensions"><a href="#配置extensions" class="headerlink" title="配置extensions"></a>配置extensions</h3><p>添加可识别文件后缀对ts的支持，如：</p><p><code>extensions: [&#39;.js&#39;, &#39;.vue&#39;, &#39;.json&#39;, &#39;.ts&#39;]</code></p><h3 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h3><p>创建tsconfig.json文件，放在根目录下，和package.json同级</p><p>配置内容主要也看个人需求，具体可以去typescript的官网查看，但是有一点需要注意：</p><blockquote><p>在Vue中，你需要引入 strict: true (或者至少 noImplicitThis: true，这是 strict 模式的一部分) 以利用组件方法中 this 的类型检查，否则它会始终被看作 any 类型。</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"include"</span>: [// 只对src下面的文件生效</span><br><span class="line">    <span class="string">"src/*"</span>,</span><br><span class="line">    <span class="string">"src/**/*"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"exclude"</span>: [</span><br><span class="line">    <span class="string">"node_modules"</span> // 排除node_modules 加快速度</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    // 类型选项之前已经配置好了</span><br><span class="line">    "types": [</span><br><span class="line">      // 添加Node作为选项</span><br><span class="line">      <span class="string">"node"</span></span><br><span class="line">    ],</span><br><span class="line">    // typeRoots选项之前已经配置好了</span><br><span class="line">    "typeRoots": [</span><br><span class="line">      <span class="string">"node_modules/@types"</span></span><br><span class="line">    ],</span><br><span class="line">    // 以严格模式解析</span><br><span class="line">    "strict": true,</span><br><span class="line">    // 在.tsx文件里支持JSX</span><br><span class="line">    "jsx": "preserve",</span><br><span class="line">    // 使用的JSX工厂函数 createElement</span><br><span class="line">    "jsxFactory": "h",</span><br><span class="line">    // 允许从没有设置默认导出的模块中默认导入</span><br><span class="line">    "allowSyntheticDefaultImports": true,</span><br><span class="line">    // 启用装饰器</span><br><span class="line">    "experimentalDecorators": true,</span><br><span class="line">    "strictFunctionTypes": false,</span><br><span class="line">    // 允许编译javascript文件</span><br><span class="line">    "allowJs": true,</span><br><span class="line">    // 采用的模块系统</span><br><span class="line">    "module": "esnext",</span><br><span class="line">    // 编译输出目标 ES 版本</span><br><span class="line">    "target": "es5",</span><br><span class="line">    // 如何处理模块</span><br><span class="line">    "moduleResolution": "node",</span><br><span class="line">    // 在表达式和声明上有隐含的any类型时报错</span><br><span class="line">    "noImplicitAny": true,</span><br><span class="line">    "lib": [</span><br><span class="line">      "dom",</span><br><span class="line">      "es5",</span><br><span class="line">      "es6",</span><br><span class="line">      "es7",</span><br><span class="line">      <span class="string">"es2015.promise"</span></span><br><span class="line">    ],</span><br><span class="line">    "sourceMap": true,</span><br><span class="line">    "pretty": true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改main-js"><a href="#修改main-js" class="headerlink" title="修改main.js"></a>修改main.js</h3><p>把项目主文件main.js修改成main.ts，里面的写法基本不变，但是有一点需要注意：</p><p>引入Vue文件的时候需要加上.vue后缀,否则编辑器识别不到</p><p>把webpack的entry文件也修改成<code>main.ts</code></p><h3 id="vue-shims-d-ts"><a href="#vue-shims-d-ts" class="headerlink" title="vue-shims.d.ts"></a>vue-shims.d.ts</h3><p>TypeScript并不支持Vue文件，所以需要告诉TypeScript*.vue文件交给vue编辑器来处理。解决方案就是在创建一个vue-shims.d.ts文件，建议放在src目录下再创建一个typings文件夹，把这个声明文件放进去，如：src/typings/vue-shims.d.ts，文件内容：</p><blockquote><p>*.d.ts类型文件不需要手动引入，TypeScript会自动加载</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="built_in">module</span> <span class="string">'*.vue'</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意思是告诉 TypeScript <code>*.vue</code>后缀的文件可以交给vue模块来处理</p><p>而在代码中导入<code>*.vue</code>文件时，需要写上.vue后缀，原因还是因为TypeScript默认只识别 <em>.ts 文件，不识别 </em>.vue 文件</p><p>到这里TypeScript在Vue中配置就完成了，可以愉快的撸代码了~</p><h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><p>引入第三方库需要额外声明文件</p><p>比如说我想引入vue-lazyload,虽然已经在本地安装，但是typescript还是提示找不到模块。原因是typescript是从node_modules/@types目录下去找模块声明，有些库并没有提供typescript的声明文件，所以就需要自己去添加</p><blockquote><p>解决办法： 在src/typings目前下建一个tools.d.ts文件，声明这个模块即可</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="built_in">module</span> <span class="string">'vue-awesome-swiper'</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> swiper: any</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> swiperSlide: any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare <span class="built_in">module</span> <span class="string">'vue-lazyload'</span></span><br></pre></td></tr></table></figure><h3 id="改造-vue-文件"><a href="#改造-vue-文件" class="headerlink" title="改造 .vue 文件"></a>改造 .vue 文件</h3><h4 id="vue-class-component"><a href="#vue-class-component" class="headerlink" title="vue-class-component"></a>vue-class-component</h4><p>vue-class-component是官方维护的TypeScript装饰器，写法比较扁平化。Vue对其做到完美兼容，如果你在声明组件时更喜欢基于类的 API，这个库一定不要错过</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"msg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>msg: &#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>computed msg: &#123;&#123;computedMsg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"greet"</span>&gt;</span>Greet<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">"ts"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">'vue-class-component'</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">@Component</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 初始化数据 不用写 data return 了</span></span></span><br><span class="line"><span class="undefined">  msg = 123</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 计算属性</span></span></span><br><span class="line"><span class="undefined">  get computedMsg() &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="string">`computed <span class="subst">$&#123;<span class="keyword">this</span>.msg&#125;</span>`</span></span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 相同于 methods 里写 方法</span></span></span><br><span class="line"><span class="javascript">  greet(): <span class="keyword">void</span> &#123;</span></span><br><span class="line"><span class="javascript">    alert(<span class="string">`greeting <span class="subst">$&#123;<span class="keyword">this</span>.msg&#125;</span>`</span>)</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 生命周期钩子 - 像普通函数一样写就好</span></span></span><br><span class="line"><span class="undefined">  mounted() &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.greet()</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="vuex-class"><a href="#vuex-class" class="headerlink" title="vuex-class"></a>vuex-class</h4><p>vuex-class是基于基于vue-class-component对Vuex提供的装饰器。它的作者同时也是vue-class-component的主要贡献者，质量还是有保证的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">'vue-class-component'</span></span><br><span class="line"><span class="keyword">import</span> &#123;State, Action, Getter&#125; <span class="keyword">from</span> <span class="string">'vuex-class'</span></span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  name: string = <span class="string">'fu yinsheng'</span></span><br><span class="line"></span><br><span class="line">  @State login: boolean</span><br><span class="line">  @Action initAjax: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span></span><br><span class="line">  @Getter load: boolean</span><br><span class="line"></span><br><span class="line">  get isLogin(): boolean &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.login</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="keyword">this</span>.initAjax()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vue-property-decorator"><a href="#vue-property-decorator" class="headerlink" title="vue-property-decorator"></a>vue-property-decorator</h4><p>这是在<code>vue-class-component</code>上增强了更多结合vue特性的装饰器，新增了7个装饰器</p><ul><li>@Emit</li><li>@Inject</li><li>@Model</li><li>@Prop</li><li>@Provide</li><li>@Watch</li><li>@Component (从vue-class-component中继承)</li></ul><p>这里列举几个常用的 <code>@Prop、@Watch、@Component</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Component, Emit, Inject, Model, Prop, Provide, Vue, Watch&#125; <span class="keyword">from</span> <span class="string">'vue-property-decorator'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyComponent <span class="keyword">extends</span> Vue &#123;</span><br><span class="line">  <span class="meta">@Prop</span>()</span><br><span class="line">  propA: <span class="built_in">number</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Prop</span>(&#123;<span class="keyword">default</span>: <span class="string">'default value'</span>&#125;)</span><br><span class="line">  propB: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Prop</span>([<span class="built_in">String</span>, <span class="built_in">Boolean</span>])</span><br><span class="line">  PropC: <span class="built_in">string</span> | <span class="built_in">boolean</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Prop</span>(&#123;<span class="keyword">type</span>: <span class="literal">null</span>&#125;)</span><br><span class="line">  propD: <span class="built_in">any</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Watch</span>(<span class="string">'child'</span>)</span><br><span class="line">  onChildChanged(val: <span class="built_in">string</span>, oldVal: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码相当于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    propA: <span class="built_in">Number</span>,</span><br><span class="line">    propB: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">'default value'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    propC: [<span class="built_in">String</span>, <span class="built_in">Boolean</span>],</span><br><span class="line">    propD: &#123;<span class="attr">type</span>: <span class="literal">null</span>&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    child: &#123;</span><br><span class="line">      handler: <span class="string">'onChildChanged'</span>,</span><br><span class="line">      immediate: <span class="literal">false</span>,</span><br><span class="line">      deep: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onChildChanged(val, oldVal) &#123;</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> ts </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【Next】一次掌握ES6到ES8新增功能</title>
      <link href="/2018/04/22/%E3%80%90Next%E3%80%91%E4%B8%80%E6%AC%A1%E6%8E%8C%E6%8F%A1ES6%E5%88%B0ES8%E6%96%B0%E5%A2%9E%E5%8A%9F%E8%83%BD/"/>
      <url>/2018/04/22/%E3%80%90Next%E3%80%91%E4%B8%80%E6%AC%A1%E6%8E%8C%E6%8F%A1ES6%E5%88%B0ES8%E6%96%B0%E5%A2%9E%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<blockquote><p>转自 <a href="https://medium.freecodecamp.org/here-are-examples-of-everything-new-in-ecmascript-2016-2017-and-2018-d52fa3b5a70e" target="_blank" rel="noopener">https://medium.freecodecamp.org/here-are-examples-of-everything-new-in-ecmascript-2016-2017-and-2018-d52fa3b5a70e</a><br>作者 rajaraodv<br>感觉挺好的，就搬过来了，很多代码值得敲一遍多多回顾理解</p></blockquote><a id="more"></a><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><h3 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes"></a>Array.prototype.includes</h3><p>找到数组中是否包含某项，直接返回布尔值（能找到NaN）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="literal">NaN</span>]</span><br><span class="line"><span class="comment">// 之前</span></span><br><span class="line"><span class="keyword">if</span> (arr.indexOf(<span class="number">3</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">if</span> (arr.includes(<span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ps: includes还可以用来判断是否包含NaN</span></span><br><span class="line">arr.includes(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line">arr.indexOf(<span class="literal">NaN</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="1-Object-values"><a href="#1-Object-values" class="headerlink" title="1. Object.values()"></a>1. Object.values()</h3><p>这个还好，我们已经在使用了，原来还是es7的。Object.values()是一个类似于Object.keys()的新函数，但是它返回了对象自身属性的所有值，不包括原型链中的任何值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cars = &#123;<span class="attr">BMW</span>: <span class="number">3</span>, <span class="attr">Tesla</span>: <span class="number">2</span>, <span class="attr">Toyota</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="keyword">const</span> vals = <span class="built_in">Object</span>.keys(cars).map(<span class="function"><span class="params">key</span> =&gt;</span> cars[key])</span><br><span class="line"><span class="built_in">console</span>.log(vals) <span class="comment">// [3,2,1]</span></span><br><span class="line"><span class="comment">// use</span></span><br><span class="line"><span class="keyword">const</span> values = <span class="built_in">Object</span>.values(cars) <span class="comment">// [3,2,1]</span></span><br></pre></td></tr></table></figure><h3 id="2-Object-entries"><a href="#2-Object-entries" class="headerlink" title="2. Object.entries()"></a>2. Object.entries()</h3><p>同上，返回的是 由键值对组成的数组的数组集合~ 好像解释得绕了，我们还是看代码吧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cars = &#123;<span class="attr">BMW</span>: <span class="number">3</span>, <span class="attr">Tesla</span>: <span class="number">2</span>, <span class="attr">Toyota</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">const</span> ret = <span class="built_in">Object</span>.entries(cars) <span class="comment">// [ [BWM, 3], [Tesla, 2], [Toyota, 1] ]</span></span><br><span class="line"><span class="comment">// 场景1 - 利用解构赋值，直接拿到 k v </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, val] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(cars)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`key: <span class="subst">$&#123;key&#125;</span>, value: <span class="subst">$&#123;val&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 场景2 - 将拿到的 kv对存到 Map中</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(cars))</span><br><span class="line"><span class="built_in">console</span>.log(map) <span class="comment">// Map(3) &#123;"BMW" =&gt; 3, "Tesla" =&gt; 2, "Toyota" =&gt; 1&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-Object-getOwnPropertyDescriptors"><a href="#3-Object-getOwnPropertyDescriptors" class="headerlink" title="3. Object.getOwnPropertyDescriptors"></a>3. Object.getOwnPropertyDescriptors</h3><p>该方法返回给定对象的所有属性的所有细节(包括getter getand setter set方法)。<br>添加这一功能的主要动机是允许浅层复制/克隆一个对象到另一个对象，该对象也复制getter和setter函数。</p><p>而`Object.assign 浅复制原始源对象的getter和setter函数外的所有细节。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Car = &#123;</span><br><span class="line">  name: <span class="string">'BWM'</span>,</span><br><span class="line">  price: <span class="number">10000</span>,</span><br><span class="line">  set discount(x) &#123;</span><br><span class="line">    <span class="keyword">this</span>.d = x</span><br><span class="line">  &#125;,</span><br><span class="line">  get discount() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.d</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(Car, <span class="string">'discount'</span>)) <span class="comment">// 返回某一属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(Car) <span class="comment">// 返回所有属性</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oCar = <span class="built_in">Object</span>.assign(&#123;&#125;, Car)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(oCar)) <span class="comment">// 没有了discount的 getter setter</span></span><br></pre></td></tr></table></figure><h3 id="4-剩余对象属性"><a href="#4-剩余对象属性" class="headerlink" title="4. 剩余对象属性"></a>4. 剩余对象属性</h3><p>点点点的扩展，- - 其实用得很多了，比如写redux里经常~~</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;firstName, age, ...remaining &#125; = &#123;</span><br><span class="line">  firstName: <span class="string">'hello'</span>,</span><br><span class="line">  lastName: <span class="string">'world'</span>,</span><br><span class="line">  age: <span class="number">24</span>,</span><br><span class="line">  height: <span class="number">170</span>,</span><br><span class="line">  hoby: <span class="string">'coding'</span></span><br><span class="line">&#125;</span><br><span class="line">firstName <span class="comment">// hello</span></span><br><span class="line">age <span class="comment">// 24</span></span><br><span class="line">remaining <span class="comment">// &#123; lastName: 'world', height: 170, hoby: 'coding' &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>可以用这一点，删除对象中不需要的属性</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;SSN, ...cleanObj&#125; = &#123;</span><br><span class="line">  SSN: <span class="string">'xxx'</span>,</span><br><span class="line">  name: <span class="string">'fri'</span>,</span><br><span class="line">  age: <span class="number">24</span></span><br><span class="line">&#125;</span><br><span class="line">cleanObj <span class="comment">// &#123;name: 'fri', age: 24&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>当然，还可以利用这一点扩展对象属性</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = &#123;<span class="attr">name</span>: <span class="string">'fri'</span>, <span class="attr">age</span>: <span class="number">24</span>&#125;</span><br><span class="line"><span class="keyword">let</span> p2 = &#123;<span class="attr">name</span>: <span class="string">'yk'</span>, <span class="attr">hobby</span>: <span class="string">'coding'</span>&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;...p1, ...p2&#125; <span class="comment">// &#123;name: "yk", age: 24, hobby: "coding"&#125; 有同名key后面的会覆盖前面的</span></span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="1-String-padding-字符串填充"><a href="#1-String-padding-字符串填充" class="headerlink" title="1. String padding 字符串填充"></a>1. String padding 字符串填充</h3><p>允许将空字符串或其他字符串添加到原始字符串的开头或结尾。直接上代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'5'</span>.padStart(<span class="number">10</span>)  <span class="comment">// "         5" 不传第二个参数默认填充空格</span></span><br><span class="line"><span class="string">'5'</span>.padStart(<span class="number">10</span>, <span class="string">'=*'</span>)  <span class="comment">// "=*=*=*=*=5" 第一个参数决定返回字符串的length，第二个参数用于填充，但会保留初始字符串</span></span><br><span class="line"></span><br><span class="line"><span class="string">'fri'</span>.padEnd(<span class="number">10</span>)  <span class="comment">// "fri       "  和padStart类似，不过是在末尾加</span></span><br><span class="line"><span class="string">'fri'</span>.padEnd(<span class="number">10</span>, <span class="string">'|--|'</span>)  <span class="comment">// "fri|--||--" 字符串最大长度为10，所以最终成这样</span></span><br></pre></td></tr></table></figure><p>我们来看一个高级点的用法，用于游戏，或是渲染字符串图片等很有用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> formatted = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">123</span>, <span class="number">1234</span>, <span class="number">12345</span>].map(<span class="function"><span class="params">num</span> =&gt;</span> (</span><br><span class="line">  num.toString().padStart(<span class="number">10</span>, <span class="string">'0'</span>)</span><br><span class="line">))</span><br><span class="line"><span class="built_in">console</span>.log(formateed)</span><br><span class="line"><span class="comment">/* [</span></span><br><span class="line"><span class="comment">  "0000000000", </span></span><br><span class="line"><span class="comment">  "0000000001", </span></span><br><span class="line"><span class="comment">  "0000000012", </span></span><br><span class="line"><span class="comment">  "0000000123", </span></span><br><span class="line"><span class="comment">  "0000001234", </span></span><br><span class="line"><span class="comment">  "0000012345"</span></span><br><span class="line"><span class="comment">] */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cars = &#123;</span><br><span class="line">  <span class="string">'😀BWM'</span>: <span class="string">'10'</span></span><br><span class="line">  <span class="string">'😎Tesla'</span>: <span class="string">'5'</span>,</span><br><span class="line">  <span class="string">'😝Lamborghini'</span>: <span class="string">'0'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.entries(cars).map(<span class="function">(<span class="params">[name, count]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;name.padEnd(<span class="number">20</span>, <span class="string">' -'</span>)&#125;</span> Count: <span class="subst">$&#123;padStart(<span class="number">3</span>, <span class="string">'0'</span>)&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 😀BWM - - - - - - - Count: 010</span></span><br><span class="line"><span class="comment">// 😎Tesla - - - - - - Count: 010</span></span><br><span class="line"><span class="comment">// 😝Lamborghini - - - Count: 010</span></span><br></pre></td></tr></table></figure><blockquote><p>注：在Emojis和其他双字节字符上使用padStart和padEnd，一个emoji表情是2个字符</p></blockquote><h2 id="正则扩展"><a href="#正则扩展" class="headerlink" title="正则扩展"></a>正则扩展</h2><h3 id="1-s-模式"><a href="#1-s-模式" class="headerlink" title="1. s 模式"></a>1. <code>s</code> 模式</h3><p>这种增强使得点操作符可以匹配任何单个字符。为了确保这不会破坏任何东西，我们需要使用\s标志，当我们创建RegEx来工作时。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/first.second/s.test(<span class="string">'first\nsecond'</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="2-RegExp命名组捕获"><a href="#2-RegExp命名组捕获" class="headerlink" title="2. RegExp命名组捕获"></a>2. RegExp命名组捕获</h3><p>在下面的例子中，我们使用<code>(?&lt;year&gt;) (?&lt;month&gt;) (?&lt;day&gt;)</code>名称来分组日期RegEx的不同部分。产生的对象现在将包含具有属性年、月、日和相应值的组属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line"><span class="keyword">let</span> re1 = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span></span><br><span class="line"><span class="keyword">let</span> ret1 = re1.exec(<span class="string">'2015-01-02'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(ret1) <span class="comment">// ["2015-01-02", "2015", "01", "02", index: 0, input: "2015-01-02", groups: undefined]</span></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line"><span class="keyword">let</span> re2 = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span></span><br><span class="line"><span class="keyword">let</span> ret2 = re2.exec(<span class="string">'2015-01-02'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(ret2.goups) <span class="comment">// &#123;year: "2015", month: "01", day: "02"&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-使用命名组"><a href="#3-使用命名组" class="headerlink" title="3. 使用命名组"></a>3. 使用命名组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sameWords = <span class="regexp">/(?&lt;fruit&gt;apple|orange)==\k&lt;fruit&gt;/u</span>;</span><br><span class="line">sameWords.test(<span class="string">'apple==apple'</span>)   <span class="comment">// true</span></span><br><span class="line">sameWords.test(<span class="string">'orange==orange'</span>) <span class="comment">// true</span></span><br><span class="line">sameWords.test(<span class="string">'apple==orange'</span>)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="4-在字符串中使用命名组"><a href="#4-在字符串中使用命名组" class="headerlink" title="4. 在字符串中使用命名组"></a>4. 在字符串中使用命名组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;firstName&gt;[A-Za-z]+) (?&lt;lastName&gt;[A-Za-z]+$)/u</span>;</span><br><span class="line"><span class="string">'Raja Rao'</span>.replace(re, <span class="string">'$&lt;lastName&gt;, $&lt;firstName&gt;'</span>) <span class="comment">// 'Rao Raja'</span></span><br></pre></td></tr></table></figure><h3 id="5-正则向后插入断言"><a href="#5-正则向后插入断言" class="headerlink" title="5. 正则向后插入断言"></a>5. 正则向后插入断言</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(?<span class="xml"><span class="tag">&lt;<span class="name">=#).*</span>/<span class="attr">.test</span>('<span class="attr">winning</span>') // <span class="attr">false</span></span></span></span><br><span class="line"><span class="xml">/(?<span class="tag">&lt;<span class="name">=#).*</span>/<span class="attr">.test</span>('#<span class="attr">winning</span>') // <span class="attr">true</span></span></span></span><br></pre></td></tr></table></figure><p>之前我们写(?=) 这类匹配到的一般从[1]开始，这样写从[0]就可以匹配到，习惯了用之前的也行，毕竟这样会增加学习成本。</p><h3 id="6-正则匹配unicode"><a href="#6-正则匹配unicode" class="headerlink" title="6. 正则匹配unicode"></a>6. 正则匹配unicode</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//The following matches multiple hindi character</span></span><br><span class="line">/^\p&#123;Script=Devanagari&#125;+$/u.test(<span class="string">'हिन्दी'</span>); <span class="comment">//true  </span></span><br><span class="line"><span class="comment">//PS:there are 3 hindi characters h</span></span><br></pre></td></tr></table></figure><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="1-用来替代-Math-pow"><a href="#1-用来替代-Math-pow" class="headerlink" title="1. ** 用来替代 Math.pow"></a>1. <code>**</code> 用来替代 <code>Math.pow</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">7</span>, <span class="number">2</span>) <span class="comment">// 49  7的2次方</span></span><br><span class="line"><span class="comment">// use</span></span><br><span class="line"><span class="number">7</span>**<span class="number">2</span> <span class="comment">// 49</span></span><br></pre></td></tr></table></figure><h3 id="2-在函数参数中添加尾随逗号，现在不会报错了"><a href="#2-在函数参数中添加尾随逗号，现在不会报错了" class="headerlink" title="2. 在函数参数中添加尾随逗号，现在不会报错了"></a>2. 在函数参数中添加尾随逗号，现在不会报错了</h3><h3 id="3-async-await"><a href="#3-async-await" class="headerlink" title="3. async/await"></a>3. async/await</h3><p>这个用得也挺多了，同步写法的异步函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doubleAndAdd</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  a = <span class="keyword">await</span> doubleAfterSec(a)</span><br><span class="line">  b = <span class="keyword">await</span> doubleAfterSec(b)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line">doubleAndAdd(<span class="number">1</span>, <span class="number">2</span>).then(<span class="built_in">console</span>.log)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doubleAfterSec</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve(param * <span class="number">2</span>), <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看一个高级用法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doubleAndAdd</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    [a, b] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([doubleAfterSel(a), doubleAfterSec(b)])</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(e)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line">doubleAndAdd(<span class="number">1</span>, <span class="number">2</span>).then(<span class="built_in">console</span>.log)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doubleAfterSec</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve(param * <span class="number">2</span>), <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Promise-prototype-finally"><a href="#4-Promise-prototype-finally" class="headerlink" title="4. Promise.prototype.finally()"></a>4. Promise.prototype.finally()</h3><p>主要的想法是允许在解决或拒绝帮助清理问题之后运行回调。最后回调被调用，没有任何值，无论如何都要执行。可以理解为增加了一个生命周期钩子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> started = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'all good'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val) <span class="comment">// 'all good'</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'finally'</span>)</span><br><span class="line">  started = <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="5-异步迭代器"><a href="#5-异步迭代器" class="headerlink" title="5. 异步迭代器"></a>5. 异步迭代器</h3><p>这是一个非常有用的特性。基本上，它允许我们轻松地创建异步代码的循环！<br>这个特性添加了一个新的“for-awaof”循环，它允许我们调用async函数，它在循环中返回承诺（或带有一堆承诺的数组）。<br>很酷的一点是，循环等待每个承诺在执行下一个循环之前解决。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="number">1</span>)),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="number">2</span>)),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="number">3</span>))</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 之前这么用</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> obj <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj) <span class="comment">// 打印3个promise</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 现在可以</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> obj <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj) <span class="comment">// 直接打印结果 1 2 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>Array方法</p><ol><li>Array.prototype.includes 是否包含某项，返回Boolean</li></ol></li><li><p>Object方法</p><ol><li>Object.values() 迭代器 返回value组成的对象</li><li>Object.entries() 迭代器，返回 k v组成的数组</li><li>Object.getOwnPropertyDescriptors? 取某个属性能拿到getter setter</li><li>对象扩展 … 点点点</li></ol></li><li><p>String方法</p><ol><li>padStart</li><li>padEnd</li></ol></li><li><p>正则扩展</p><ol><li>s模式 匹配换行等而不破坏字符串</li><li>命名组捕获</li><li>插入断言</li><li>匹配unicode</li></ol></li><li><p>函数扩展</p><ol><li>async/await</li><li>Promise.finally 钩子</li><li>async函数里 for 可以使用 await</li><li>原生方法扩展 Math.pow -&gt; <code>**</code></li></ol></li></ul>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> ES标准 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【Vue】服务端渲染框架Nuxt入门</title>
      <link href="/2018/04/17/%E3%80%90Vue%E3%80%91%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E6%A1%86%E6%9E%B6Nuxt%E5%85%A5%E9%97%A8/"/>
      <url>/2018/04/17/%E3%80%90Vue%E3%80%91%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E6%A1%86%E6%9E%B6Nuxt%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<blockquote><p>对着官方文档一顿敲= = 看官方文档就好，很简单，相比Vue和React那坑爹的服务端渲染配置，Nuxt简直是良心多了，配置灵活，最重要的是简单！！！于是近期会把 我的个人站首页用nuxt重（折腾）构一番，敬请期待~</p></blockquote><a id="more"></a><h1 id="Nuxt"><a href="#Nuxt" class="headerlink" title="Nuxt"></a>Nuxt</h1><p>Nuxt.js（后文Nuxt）是基于Vue.js的通用应用框架</p><p>通过对客户端/服务端基础架构的抽象组织，Nuxt主要关注的是应用的UI渲染。其预设了利用Vue开发服务端渲染的应用所需要的各种配置。<br>作为框架，Nuxt.js 为 客户端/服务端 这种典型的应用架构模式提供了许多有用的特性，例如异步数据加载、中间件支持、布局支持等。</p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><h3 id="如何运作"><a href="#如何运作" class="headerlink" title="如何运作"></a>如何运作</h3><p>vue2+ vue-router vuex vue-meta<br>以及webpack、vue-loader、babel-loader来处理代码的自动化构建工作</p><p><strong>特性</strong></p><ul><li>基于Vue</li><li>自动代码分层</li><li>服务端渲染</li><li>强大的路由功能，支持异步数据</li><li>静态服务文件</li><li>ES6+语法支持</li><li>打包和压缩JS/CSS</li><li>HTML头部标签管理</li><li>本地开发支持热加载</li><li>集成ESLint</li><li>支持样式预处理</li></ul><p>下图阐述了 Nuxt.js 应用一个完整的服务器请求到渲染（或用户通过 <code>&lt;nuxt-link&gt;</code> 切换路由渲染页面）的流程：</p><p><img src="https://zh.nuxtjs.org/nuxt-schema.png"></p><p>请求到来 -&gt; nuxt server拦截处理(事件派发store action) -&gt; middleware处理中间件 (先配置，后布局，再页面) -&gt; 验证 -&gt; 获取异步数据 -&gt; render渲染(通过Navigate作路由跳转)</p><h3 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h3><p>使用nuxt作UI渲染框架。当运行<code>nuxt</code>命令时会启动一个支持<code>热加载</code>和<code>服务端渲染</code>（基于Vue的vue-server-renderer模块）的开发服务器。</p><h3 id="静态化"><a href="#静态化" class="headerlink" title="静态化"></a>静态化</h3><p>nuxt generate </p><p>通过CDN缓存静态页面，进行全球CDN节点布局。相对传统的动态网站，静态化分散了对服务器的请求，降低服务器压力。</p><p>简而言之，页面静态文件CDN，数据通过API，前后端分离.</p><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>vue init nuxt-community/starter-template nuxt-demo</code></pre><p>要注意，<code>服务端渲染</code>是前台服务端用相同组件，一份代码，我们跑的其实是静态文件，所以需要打包出来一份bundle</p><p>npm run build </p><p>npm run dev </p><p>现在浏览器打开 localhost:3000 就可以访问nuxt-demo了</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ul><li><p>assets 组织静态资源 css js等</p></li><li><p>components 放公共组件。注：nuxt不会扩展该目录下的组件，所以不会有asyncData特性</p></li><li><p>layouts 用于组织布局，除配置外这个优先级很高</p></li><li><p>middleware 存放中间件</p></li><li><p>pages 组织页面及路由，在layouts后读取，配置这个就不用写routes了. 后面介绍很爽</p></li><li><p>plugins 插件，用于组织需要在根vue.js实例化之前运行的JS插件</p></li><li><p>static 静态文件目录，不会被nuxt调用构建。服务启动，该目录下文件会被映射到根路径下</p></li><li><p>store Vuex状态文件</p></li><li><p>nuxt.config.js nuxt配置，优先级最高，用于覆盖默认配置</p></li></ul><p>更多请参考官方文档 <a href="https://zh.nuxtjs.org" target="_blank" rel="noopener">https://zh.nuxtjs.org</a> ~ </p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>Nuxt根据<code>pages</code>目录结构自动生成vue-router模块路由配置，就问你叼不叼~</p><p>在pages下新建一个user文件夹，新建index.vue one.vue</p><p>访问 localhost:3000/user  localhost:3000/user/one 就能显示了，简直不要太爽</p><p><strong>动态路由</strong></p><p>以前path里配置 <code>/:id</code> 这样的，在pages/user 里新建 _id.vue即可</p><p><strong>路由参数校验</strong></p><p>pages/users/_id.vue</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  validate(&#123;params&#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^\d+$/</span>.test(params.id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>嵌套路由</strong></p><p>pages/<br>–| users/<br>—–| _id.vue<br>—–| index.vue<br>–| users.vue</p><h3 id="过渡动效"><a href="#过渡动效" class="headerlink" title="过渡动效"></a>过渡动效</h3><p>参考文档 - - 我没跑成功，回头再看看</p><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>允许定义一个自定义函数运行在一个页面或一组页面渲染之前。放在middleware目录下，一个中间件接收<code>context</code>作为第一个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context.userAgent = context.isServer </span><br><span class="line">    ? context.req.headers[<span class="string">'user-agent'</span>]</span><br><span class="line">    : navigator.userAgent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中间件执行顺序：</p><ol><li>nuxt.config.js</li><li>匹配布局</li><li>匹配页面</li></ol><p>中间件可异步执行，只需返回一个<code>Promise</code>或使用第二个callback作为第一个参数：</p><p>middleware/stats.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">&#123;route&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.post(<span class="string">'http://xx.com'</span>, &#123;</span><br><span class="line">    url: route.fullPath</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 上面3个任意地方使用中间件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  router: &#123;</span><br><span class="line">    middleware: <span class="string">'stats'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stats中间件将在每个路由改变时被调用。</p><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p><strong>默认页面</strong></p><p>layouts/default.vue </p><p><strong>错误页面</strong></p><p>layouts/error.vue</p><p><strong>个性化布局</strong></p><p>在layouts里添加一个dark.vue文件，然后在pages里的组件写. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  layout: <span class="string">'dark'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h3><p>页面的一些api</p><table><thead><tr><th style="text-align:center">属性名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">asyncData</td><td style="text-align:left">最重要的一个键, 支持 异步数据处理，另外该方法的第一个参数为当前页面组件的 上下文对象</td></tr><tr><td style="text-align:center">fetch</td><td style="text-align:left">与 asyncData 方法类似，用于在渲染页面之前获取数据填充应用的状态树（store）。不同的是 fetch 方法不会设置组件的数据。详情请参考 关于fetch方法的文档</td></tr><tr><td style="text-align:center">head</td><td style="text-align:left">配置当前页面的 Meta 标签, 详情参考 页面头部配置API</td></tr><tr><td style="text-align:center">layout</td><td style="text-align:left">指定当前页面使用的布局（layouts 根目录下的布局文件）。详情请参考 关于 布局 的文档</td></tr><tr><td style="text-align:center">transition</td><td style="text-align:left">指定当前页面使用的布局（layouts 根目录下的布局文件）。详情请参考 关于 布局 的文档</td></tr><tr><td style="text-align:center">scrollToTop</td><td style="text-align:left">布尔值，默认: false。 用于判定渲染页面前是否需要将当前页面滚动至顶部。这个配置用于 嵌套路由的应用场景</td></tr><tr><td style="text-align:center">middleware</td><td style="text-align:left">指定页面的中间件，中间件会在页面渲染之前被调用， 请参考 路由中间件</td></tr></tbody></table><h3 id="HTML头部"><a href="#HTML头部" class="headerlink" title="HTML头部"></a>HTML头部</h3><p>nuxt使用<code>vue-meta</code>更新应用头部标签和html属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  keyName: <span class="string">'head'</span>, <span class="comment">// 设置meta信息的组件对象的字段，vue-meta会根据key值获取meta信息</span></span><br><span class="line">  attribute: <span class="string">'n-head'</span>, <span class="comment">// vue-meta在监听标签时所添加的属性名</span></span><br><span class="line">  ssrAttribute: <span class="string">'n-head-ssr'</span>, <span class="comment">// 让vue-meta获知meta信息已完成服务端渲染的属性名</span></span><br><span class="line">  tagIDKeyName: <span class="string">'hid'</span> <span class="comment">// 让vue-meta用来决定是否覆盖还是追加tag的属性名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步数据"><a href="#异步数据" class="headerlink" title="异步数据"></a>异步数据</h3><p>Nuxt扩展了Vue增加一个asyncData方法，使得我们可以在设置组件数据前异步获取处理数据</p><p><strong>asyncData</strong></p><p>该方法会在组件（限于页面组件）每次加载前被调用。它可以在服务端或路由更新之前被调用。在该方法被调用时，第一个参数被设定为<code>当前页面的上下文对象</code>，可利用<code>asyncData</code>方法来获取数据，Nuxt会将asyncData返回的数据融合组件<code>data</code>方法返回的数据一并返回给当前组件。</p><blockquote><p>由于asyncData方法是在组件初始化前被调用的，所以在方法内是无法通过this来引用组件实例对象的。</p></blockquote><p>使用：</p><ol><li>返回Promise</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">asyncData(&#123;params, error&#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">`/api/<span class="subst">$&#123;params.id&#125;</span>`</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">title</span>: res.data.title&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      error(&#123; <span class="attr">statusCode</span>: <span class="number">404</span>, <span class="attr">message</span>: <span class="string">'not found'</span> &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用async/await</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">asyncData(&#123;params, error&#125;) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;data&#125; = <span class="keyword">await</span> axios.get(<span class="string">`/api/<span class="subst">$&#123;params.id&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">title</span>: data.title&#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    error(&#123; <span class="attr">statusCode</span>: <span class="number">404</span>, <span class="attr">message</span>: <span class="string">'not found'</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h3><p>默认Nuxt使用vue-loader、file-loader及url-loader来处理文件的加载和引用。对于不需要通过webpack处理的静态资源文件，可以放置在static目录中</p><p><strong>webpack构建</strong></p><p>默认情况下, vue-loader自动使用 css-loader 和Vue模板编译器来编译处理vue文件中的样式和模板。在此编译过程中，所有的资源URL例如 <code>&lt;img src=&quot;...&quot;&gt;</code>、 <code>background: url(...)</code> 和 CSS中的 <code>@import</code> 均会被解析成模块通过 require 引用。</p><p><strong>静态文件</strong></p><p>如果你的静态资源文件需要 Webpack 做构建编译处理，可以放到 assets 目录，否则可以放到 static 目录中去。</p><p>Nuxt 服务器启动的时候，该目录下的文件会映射至应用的根路径 / 下，像 robots.txt 或 sitemap.xml 这种类型的文件就很适合放到 static 目录中。</p><p>你可以在代码中使用根路径 / 结合资源相对路径来引用静态资源：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引用 static 目录下的图片 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/my-image.png"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 引用 assets 目录下经过 webpack 构建处理后的图片 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/assets/my-image-2.png"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p><strong>使用第三方模块</strong></p><p>在页面内直接 import。但是，如果在另一页面也import相同第三方模块，在打包时该模块会被重复打包，而实际上我们只需要打包一次。该问题可以通过在<code>nuxt.config.js</code>里配置<code>build.vendor</code>来解决：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  build: &#123;</span><br><span class="line">    vendor: [<span class="string">'axios'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用Vue插件</strong></p><p>plugins里增加相应插件的js文件，如xxx.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// '~/plugins/xxx',</span></span><br><span class="line">    &#123;</span><br><span class="line">      src: <span class="string">'~/plugins/xxx'</span>,</span><br><span class="line">      ssr: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有些插件可能只是在浏览器里使用，所以你可以用 ssr: false </span></span><br><span class="line">    <span class="comment">// 来配置插件只从客户端还是服务端运行</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Vuex"><a href="#使用Vuex" class="headerlink" title="使用Vuex"></a>使用Vuex</h3><p>Nuxt已内置了Vuex，所以不需额外安装和use了。</p><p><strong>模块方式</strong></p><p>状态树还可以拆分成为模块，store 目录下的每个 .js 文件会被转换成为状态树指定命名的子模块</p><p>使用状态树模块化的方式，store/index.js 不需要返回 Vuex.Store 实例，而应该直接将 state、mutations 和 actions 暴露出来：</p><p><strong>fetch方法</strong></p><p>fetch 方法会在渲染页面前被调用，作用是填充状态树 (store) 数据，与 asyncData 方法类似，不同的是它不会设置组件的数据。</p><p><strong>nuxtServerInit方法</strong></p><p>如果在状态树中指定了<code>nuxtServerInit</code>方法，Nuxt调用它时会将页面的上下文对象作为第2个参数传给它（仅在服务端调用时）。当我们想将服务端数据传到客户端时，就可用此方法。</p><p>如，服务端会话状态树可以通过 <code>req.session.user</code> 来访问当前登录用户。将该登录用户信息传给客户端的状态树，只需要更新 <code>store/index.js</code>，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  nuxtServerInit(&#123;commit&#125;, &#123;req&#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (req.session.user) &#123;</span><br><span class="line">      commit(<span class="string">'user'</span>, req.session.user)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果你使用状态树模块化的模式，只有主模块（即 store/index.js）适用设置该方法（其他模块设置了也不会被调用）。nuxtServerInit 方法接收的上下文对象和 fetch 的一样，但不包括 context.redirect() 和 context.error()。</p></blockquote><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">nuxt</td><td style="text-align:left">启动一个热加载的Web服务器（开发模式） localhost:3000</td></tr><tr><td style="text-align:center">nuxt build</td><td style="text-align:left">利用webpack编译应用，压缩JS和CSS资源（发布用）</td></tr><tr><td style="text-align:center">nuxt start</td><td style="text-align:left">以生成模式启动一个Web服务器 (nuxt build 会先被执行)</td></tr><tr><td style="text-align:center">nuxt generate</td><td style="text-align:left">编译应用，并依据路由配置生成对应的HTML文件 (用于静态站点的部署)</td></tr></tbody></table><hr><p>大致就这样了，试着自己折腾一下吧。对了，正好可以把个人网站首页用nuxt重构静态发布~~</p><p>生命不息，折腾不止！~</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> nuxt </tag>
            
            <tag> 服务端渲染 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【JS】函数柯里化[转载]</title>
      <link href="/2018/04/15/%E3%80%90JS%E3%80%91%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%5B%E8%BD%AC%E8%BD%BD%5D/"/>
      <url>/2018/04/15/%E3%80%90JS%E3%80%91%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%5B%E8%BD%AC%E8%BD%BD%5D/</url>
      <content type="html"><![CDATA[<blockquote><p>转自前端早读课 葉河英。好文就转了，更重要的目的是代码量多，敲一遍慢慢吸收</p></blockquote><p>柯里化 curring 是把接收多个参数的函数变换成接收一个单一参数（最初函数的第一个参数）的函数，并且返回接收余下参数并且返回结果的新函数的技术。</p><a id="more"></a><p>柯里化 -&gt; 部分求值，返回接收剩余参数且返回结果的新函数。</p><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><ul><li>参数复用 - 复用最初函数的第一个参数</li><li>提前返回 - 返回接收余下的参数且返回结果的新函数</li><li>延迟执行 - 返回新函数，等待执行</li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>兼容浏览器事件监听方法</li><li>性能优化：防抖和节流</li><li>兼容低版本IE bind方法等</li></ul><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addEvent = <span class="function"><span class="keyword">function</span>(<span class="params">elm, type, fn, isCapture</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">    elm.addEventListner(type, fn, isCapture)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent) &#123;</span><br><span class="line">    elm.attachEvent(<span class="string">'on'</span> + type, fn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们调用addEvent方法时，都会执行if else-if 进行一次兼容判断，其实这个判断是无必要的，用柯里化优化后如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addEvent = <span class="function"><span class="keyword">function</span>(<span class="params">elm, type, fn, isCapture</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">elm, type, fn, isCapture</span>) </span>&#123;</span><br><span class="line">      elm.addEventListen(type, fn, isCapture)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">elm, type, fn</span>) </span>&#123;</span><br><span class="line">      elm.attachEvent(<span class="string">'on'</span> + type, fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该例就利用了柯里化提前返回和执行的特点：</p><ul><li>提前返回 - 使用函数立即调用进行一次兼容判断，返回兼容的事件绑定方法</li><li>延迟执行 - 返回新函数，在新函数调用兼容的事件方法。等待addEvent新函数调用，延迟执行</li></ul><h3 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h3><p>web开发中，事件<code>resize, scroll, mousemove</code>等属于高频事件。浏览器页面渲染帧率为60fps，大约16.67ms刷新一帧。 若事件触发频率大于显示帧率，则会发生掉帧、卡顿等现象，更坏地浏览器直接崩溃。</p><p>要解决高频事件的问题，其根本在于：</p><ul><li>高频事件处理函数，不应该含有复杂操作，如DOM操作和复杂计算（DOM操作一般会造成页面回流和重绘，使浏览器不断重新渲染页面）</li><li>控制高频事件的触发频率</li></ul><p>其中防抖和节流对高频事件进行优化的原理就是通过延迟执行，将多个间隔接近的函数执行合并成一次函数执行。</p><h4 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖 debounce"></a>防抖 debounce</h4><p>针对高频事件，防抖就是讲多个触发间隔接近的事件函数执行，合并成一次函数执行</p><p>实现防抖的关键点有两个：</p><ul><li><p>使用setTimeout延时器，传入延迟时间，将事件处理函数延迟执行，并且通过事件触发频率与延迟事件值比较，控制处理函数是否执行</p></li><li><p>使用柯里化函数结合闭包思想，将执行状态保存在闭包中，返回新函数，在新函数中通过执行状态控制是否在滚动时执行处理函数</p></li></ul><p>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param    fn              Function    事件处理函数</span></span><br><span class="line"><span class="comment"> * @param    delay           Number      延迟时间</span></span><br><span class="line"><span class="comment"> * @param    isImmediate     Boolean     是否滚动时立刻执行</span></span><br><span class="line"><span class="comment"> * @return   Function                    事件处理函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> debound = <span class="function"><span class="keyword">function</span>(<span class="params">fn, delay, isImmediate</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用闭包，保存执行状态，控制函数调用顺序</span></span><br><span class="line">  <span class="keyword">var</span> timer</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _args = [].slice.call(<span class="built_in">arguments</span>),</span><br><span class="line">      context = <span class="keyword">this</span></span><br><span class="line">    </span><br><span class="line">    clearTimeout(timer)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      timer = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">if</span> (!isImmediate) fn.apply(context, _args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否滚动时立即执行</span></span><br><span class="line">    <span class="keyword">var</span> callNow = !timer &amp;&amp; isImmediate</span><br><span class="line"></span><br><span class="line">    timer = setTimeout(_fn, delay)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callNow) fn.apply(context, _args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 防抖使用如下：</span></span><br><span class="line"><span class="keyword">var</span> debounceScroll = debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 事件处理函数，滚动时进行的处理</span></span><br><span class="line">&#125;, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, debounceScroll)</span><br></pre></td></tr></table></figure><p>防抖技术仅靠传入延迟时间值的大小控制高频事件的触发频率。如果传入的延迟事件较大，则可能导致不触发事件处理函数，这时节流就派上用场了</p><h4 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流 throttle"></a>节流 throttle</h4><p>节流也是将多个触发间隔接近的事件函数执行，合并成一次函数执行，并且在指定时间内执行执行一次事件处理函数。</p><p>节流实现原理跟防抖类似，但是比防抖多了一次实函数执行判断，实现的关键点是：</p><ul><li>利用闭包存储了当前和上一次执行的时间戳，通过两次函数执行的时间差跟指定的延迟事件的比较，控制函数是否执行</li></ul><p>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @param    fn          Function    事件处理函数</span></span><br><span class="line"><span class="comment">* @param    wait        Number      延迟时间</span></span><br><span class="line"><span class="comment">* @return   Function                事件处理函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer, previous, now, diff</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _args = [].slice.call(<span class="built_in">arguments</span>),</span><br><span class="line">      context = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 存储当前时间戳</span></span><br><span class="line">    now = <span class="built_in">Date</span>.now()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 存储上一次执行的时间戳</span></span><br><span class="line">      previous = <span class="built_in">Date</span>.now()</span><br><span class="line">      timer = <span class="literal">null</span></span><br><span class="line">      fn.apply(context, _args)</span><br><span class="line">    &#125;</span><br><span class="line">    clearTimeout(timer)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (previous !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="comment">// 时间差</span></span><br><span class="line">      diff = now - previous</span><br><span class="line">      <span class="keyword">if</span> (diff &gt;= wait) &#123;</span><br><span class="line">        fn.apply(context, _args)</span><br><span class="line">        previous = now</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        timer = setTimeout(_fn, wait)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _fn()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>拓展：节流和防抖都是用setTimeout实现的，改用window.requestAnimationFrame</strong></p><p>实现起来更简单，性能更好，但不支持低版本IE</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解决requestAnimationFrame兼容</span></span><br><span class="line"><span class="keyword">var</span> reFrame = <span class="built_in">window</span>.requestAnimationFrame ||</span><br><span class="line">  <span class="built_in">window</span>.webkitRequestAnimationFrame ||</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.setTimeout(callback, <span class="number">1000</span> / <span class="number">60</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化封装</span></span><br><span class="line"><span class="keyword">var</span> refThrottle = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> isLocked</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">var</span> _args = <span class="built_in">arguments</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isLocked) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    isLocked = <span class="literal">true</span></span><br><span class="line">    reFrame(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      isLocked = <span class="literal">false</span></span><br><span class="line">      fn.apply(context, _args)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bind柯里化函数"><a href="#bind柯里化函数" class="headerlink" title="bind柯里化函数"></a>bind柯里化函数</h3><p>函数的bind方法我们不陌生，但在低版本IE不兼容，若要实现兼容其关键点在于：</p><ul><li>bind方法改变this指向，却不会执行原函数，那么我们可以利用柯里化延迟执行，参数复用和提前返回的特点，返回新函数，在新函数是用apply方法执行原函数</li></ul><p>我们这里将bind方法封装为两种情况：</p><ol><li>简单的bind方法封装，不考虑构造函数等，实现如下：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context.toString() !== <span class="string">'[object Object]'</span> &amp;&amp; context.toString() !== <span class="string">'[object Window]'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">'context is not a Object'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> _args = [].slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">      _this.apply(context, _args.concat(args))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>复杂情况，考虑bind的任何用法，这里直接是用MDN的bind兼容方法：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">oThis</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Function.prototype.bind - what is trying to be bound is not callable'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> aArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>),</span><br><span class="line">      fToBind = <span class="keyword">this</span>,</span><br><span class="line">      fNOP = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">      fBound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fToBind.apply(</span><br><span class="line">          <span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP ? <span class="keyword">this</span> : oThis,</span><br><span class="line">          <span class="comment">// 获取调用时 fBound 的传参 .bind返回的函数入参往往是这么传递的</span></span><br><span class="line">          aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>))</span><br><span class="line">        ) </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 维护原型关系</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.prototype) &#123;</span><br><span class="line">        <span class="comment">// Function.prototype doesn't have a prototype property</span></span><br><span class="line">        fNOP.prototype = <span class="keyword">this</span>.prototype</span><br><span class="line">      &#125;</span><br><span class="line">      fBound.prototype = <span class="keyword">new</span> fNOP()</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> fBound</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要理解复杂的bind兼容方法，必须彻底理解以下四个基础知识</p><ul><li>JS原型对象</li><li>构造函数是用new操作符的过程</li><li>this的指向问题</li><li>熟悉bind方法的是用场景</li></ul><h3 id="柯里化函数的封装"><a href="#柯里化函数的封装" class="headerlink" title="柯里化函数的封装"></a>柯里化函数的封装</h3><p>分析了柯里化的各种是用场景，我们来尝试一下封装一个简单的柯里化函数，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCurry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">'fn is not a function'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 复用第一个参数</span></span><br><span class="line">  <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 返回新函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 收集剩余参数</span></span><br><span class="line">    <span class="keyword">var</span> _args = [].slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args.concat(_args))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>柯里化函数的特点如上注释所示：</p><ul><li>复用第一个参数</li><li>返回新函数</li><li>收集剩余参数</li><li>返回结果</li></ul>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> curry </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【Vue】理解Vue生命周期</title>
      <link href="/2018/04/14/%E3%80%90Vue%E3%80%91%E7%90%86%E8%A7%A3Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2018/04/14/%E3%80%90Vue%E3%80%91%E7%90%86%E8%A7%A3Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="html"><![CDATA[<p>早上刷手机在思否上看到 闰土大叔的这篇<a href="https://segmentfault.com/a/1190000014376915?_ea=3615607" target="_blank" rel="noopener">如何解释vue的生命周期才能令XXX满意？</a>，觉得挺好就老套路了。当然，看别人的文章，在此基础上注释，添加自己的东西，才有写博客的价值，希望能站在大佬的肩膀上往前走得更快吧！</p><a id="more"></a><p>这张图肯定是必上的，说得相当详尽和清楚了。</p><p><img src="https://segmentfault.com/img/bV4xju?w=1200&h=3039"></p><p>在理解上，一直觉得Vue生命周期就是四个阶段 创建 -&gt; 挂载 -&gt; 更新 -&gt; 销毁，每个阶段对应2个钩子函数 <code>beforeCreate</code> <code>created</code> ， 带 before 和 ed 的，同时也写过demo，无非就是以下： <a href="https://jsfiddle.net/0dzvcf4d/10495/" target="_blank" rel="noopener">https://jsfiddle.net/0dzvcf4d/10495/</a> 可看下官网的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#editor'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    input: <span class="string">'# hello'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    compiledMarkdown: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> marked(<span class="keyword">this</span>.input, &#123; <span class="attr">sanitize</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    update: _.debounce(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.input = e.target.value</span><br><span class="line">    &#125;, <span class="number">300</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeCreate() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'beforeCreate'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'created'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'beforeMount'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'mounted'</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.input = <span class="string">'vue lifecycle'</span></span><br><span class="line">    &#125;, <span class="number">2000</span>)    </span><br><span class="line">  &#125;,</span><br><span class="line">  beforeUpdate() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'beforeUpdate'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  updated() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'updated'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestory() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'beforeDestory'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  destroyed() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'destroyed'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>控制台会依次输出 </p><p>beforeCreate<br>created<br>beforeMount<br>render<br>mounted</p><p>过了两秒后，再打印<br>beforeUpdate<br>updated</p><p>那么，信息量还是挺多的，Vue的生命周期描述不是说8个钩子函数，这显然也不是问题的本质。</p><hr><p>那么我们来理一理这个过程吧，请关注随时对比大图：</p><p>在一开始，我们创建了一个Vue的实例对象 vm，在控制台打印 beforeCreate 之前，首先执行了 <code>_init</code> 方法  （正好之前写了篇 【Vue】实现原生双向绑定 可参考一下） <code>_init</code> 就是将我们所传入的 el、data、methods等等各种属性绑定到Vue原型对象上。 而在init的过程中首先调用<code>beforeCreate</code>钩子。然后在<code>injections</code>[注射]和<code>reactivity</code>[反应作用]时，它会再去调用<code>created</code>钩子。</p><p>也就是说在init时，事件已经被调用了。所以，我们在<code>beforeCreate</code>时千万别去修改data里面的赋值，最早也要放在<code>created</code>里去做。</p><p>在created完成后，它会去判断<code>instance</code>实例里是否含有 <code>el</code> 属性 ，若没有 就会调用 vm.$mount(el)这个方法，然后继续执行后续逻辑；</p><p>若有el属性，则会判断是否有 <code>template</code>属性，并将template解析成一个 <code>render function</code></p><hr><p>这里插播一下 render function 相关的科普</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render(createElement) &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * param &#123;String&#125; tagName</span></span><br><span class="line"><span class="comment">   * param &#123;Object&#125; element properties</span></span><br><span class="line"><span class="comment">   * param &#123;String&#125; text node content</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> createElement(<span class="string">'div'</span>, &#123;&#125;, <span class="keyword">this</span>.text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们经常看到的 h 的写法，其实就是代表 createElement 的一个实参而已。 可传入三个参数， 参考代码方法注释。其中，如果要渲染更多子节点的话，可在 properties 中继续传入 createElement。</p><p>最终我们的template将被解析为 render 函数所返回的内容，也就是 Virtial DOM。关于Virtial DOM相关的下次会在了解后再写。</p><hr><p>回到生命周期的话题中，render 函数发生在 <code>beforeMount</code> 和 <code>mounted</code>之间的，这也侧面说明在<code>beforeMount</code>时，$el还只是我们在HTML里面写的节点。（可自行 在生命周期函数中添加 console.log(this.$el) ） <code>beforeMount</code> 和 <code>render</code>都打印了节点内容，到<code>mounted</code>时已被渲染出来并将之挂载到了DOM节点上。在此间经历的过程其实是执行了 render funcion的内容。</p><p>在使用.vue文件开发的过程当中，我们在里面写了template模板，在经过了vue-loader的处理之后，就变成了render function，最终放到了vue-loader解析过的文件里面。这样做有什么好处呢？原因是由于在解析template变成render function的过程，是一个非常耗时的过程，vue-loader帮我们处理了这些内容之后，当我们在页面上执行vue代码的时候，效率会变得更高。</p><p><code>beforeMount</code>在有了render function的时候才会执行，当执行完render function之后，就会调用<code>mounted</code>这个钩子，在<code>mounted</code>挂载完毕之后，这个实例就算是走完流程了。</p><p>后续的钩子函数执行的过程都是需要外部的触发才会执行。比如说有数据的变化，会调用beforeUpdate，然后经过Virtual DOM，最后updated更新完毕。当组件被销毁的时候，它会调用beforeDestory，以及destoryed。</p><p><strong>这就是vue实例从新建到销毁的一个完整流程</strong></p><hr><p>说点题外话：</p><p>钩子函数是什么意思？ 特别是在学习 React生命周期，Vue生命周期这一词频繁出现。那么，看到此相信你大致有感觉了。<br>没错，钩子函数可理解为回调函数，当代码执行到某处时，检查是否有回调，简单代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gouzi1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'g1'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gouzi2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'g2'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">10</span>) &#123;</span><br><span class="line">    gouzi1()    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">100</span> &amp;&amp; i &lt; <span class="number">105</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">1000</span>) &#123;</span><br><span class="line">    gouzi2()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(i === <span class="number">9999</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// g1</span></span><br><span class="line"><span class="comment">// 101</span></span><br><span class="line"><span class="comment">// 102</span></span><br><span class="line"><span class="comment">// 103</span></span><br><span class="line"><span class="comment">// 104</span></span><br><span class="line"><span class="comment">// g2</span></span><br><span class="line"><span class="comment">// end</span></span><br></pre></td></tr></table></figure><p>当然JS的执行环境不是这么简单的。这里大致了解一下就好，最后的最后，再简单总结收个尾吧</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Vue的完整生命周期流程：</p><ol><li>new Vue(options) 时执行 init初始化将options的值绑到Vue原型中</li><li>从init起，生命周期已开始，beforeCreate 调用后通过注入等方式拿到值后走到created钩子，data重赋值等操作最早在该钩子中进行</li><li>检查实例是否传入el来解析template或是执行vm.$mount，其实质是一个render function，将template写的节点，变成Virtial DOM</li><li>beforeMount较早于render，一旦进入mounted钩子，虚拟节点将生成真正的DOM节点并被挂载</li><li>之后的数据改变 会触发 beforeUpdate 和 updated 钩子</li><li>通过路由移入移出组件等可触发 destroy destroyed 钩子</li></ol><p>这就是Vue实例的完整声明周期流程！ 完~</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> mvvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【Vue】实现原生类Vue的双向绑定</title>
      <link href="/2018/04/11/%E3%80%90Vue%E3%80%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%94%9F%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
      <url>/2018/04/11/%E3%80%90Vue%E3%80%91%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%94%9F%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
      <content type="html"><![CDATA[<p>逛掘金看到篇讲<a href="https://juejin.im/post/5acc17cb51882555745a03f8" target="_blank" rel="noopener">Vue双向绑定的文章</a>，很不错，就拿过来了，里面的代码抄了一遍，当然不是初抄啦，加入我自己的理解和总结。虽然看了几次这类文章，但真不嫌多，温故而知新嘛。</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Vue的双向绑定通过 Object对象的defineProperty属性，重写data的set和get函数来实现。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/10/162ad3d5be3e5105?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>简单实现</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>  <span class="attr">v-model</span>=<span class="string">"number"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">v-click</span>=<span class="string">"increment"</span>&gt;</span>增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span> <span class="attr">v-bind</span>=<span class="string">"number"</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>一个input，使用v-model指令</li><li>一个button，使用v-click指令</li><li>一个h3，使用v-bind指令。</li></ol><p>通过类似于vue的方式来使用我们的双向数据绑定，结合我们的数据结构添加注释</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> MyVue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    number: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      <span class="keyword">this</span>.number++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>首先定义一个MyVue构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyVue</span>(<span class="params">options</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>为了初始化这个构造函数，给它添加一 个_init属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyVue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._init(options)</span><br><span class="line">&#125;</span><br><span class="line">MyVue.prototype._init = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$options = options <span class="comment">// options为上面使用时传入的结构体，包括el data methods</span></span><br><span class="line">  <span class="keyword">this</span>.$el = <span class="built_in">document</span>.querySelector(options.el) <span class="comment">// this.$el 即 id为app的 dom元素</span></span><br><span class="line">  <span class="keyword">this</span>.$data = options.data <span class="comment">// this.$data = &#123;number: 0&#125;</span></span><br><span class="line">  <span class="keyword">this</span>.$methods = options.methods <span class="comment">// &#123; increment() &#123;this.number++&#125; &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来实现_observe函数，对data进行处理，重写data的set和get函数，并改造 _init函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">MyVue.prototype._observe = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123; <span class="comment">// 将要实现监听的对象 obj = &#123;number: 0&#125;</span></span><br><span class="line">  <span class="keyword">var</span> value</span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      value = obj[key]</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'object'</span>) &#123; <span class="comment">// 若值还是 object类型，则继续遍历</span></span><br><span class="line">        <span class="keyword">this</span>._observe(value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>.$data, key, &#123; <span class="comment">// 关键</span></span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`获取<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">          <span class="keyword">return</span> value</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`更新<span class="subst">$&#123;newVal&#125;</span>`</span>)</span><br><span class="line">          <span class="keyword">if</span> (value !== newValue) &#123;</span><br><span class="line">            value = newVal</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyVue.prototype._init = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$options = options</span><br><span class="line">  <span class="keyword">this</span>.$el = <span class="built_in">document</span>.querySelector(options.el)</span><br><span class="line">  <span class="keyword">this</span>.$data = options.data</span><br><span class="line">  <span class="keyword">this</span>.$methods = options.methods</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>._observe(<span class="keyword">this</span>.$data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们写一个指令类 Watcher 用来绑定更新函数，实现对DOM元素的更新</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">name, el, vm, exp, attr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name  <span class="comment">// 指令名称，例如文件节点，该值设为 text</span></span><br><span class="line">  <span class="keyword">this</span>.el = el      <span class="comment">// 指令对应的DOM元素</span></span><br><span class="line">  <span class="keyword">this</span>.vm = vm      <span class="comment">// 指令所属的MyVue实例</span></span><br><span class="line">  <span class="keyword">this</span>.exp = exp    <span class="comment">// 指令对应的值，本例为 number</span></span><br><span class="line">  <span class="keyword">this</span>.attr = attr  <span class="comment">// 绑定的属性值，本例为 innerHTML</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>._update()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Watcher.prototype._update = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.el[<span class="keyword">this</span>.attr] = <span class="keyword">this</span>.vm.$data[<span class="keyword">this</span>.exp]</span><br><span class="line">  <span class="comment">// 比如 h3.innerHTML = this.data.number</span></span><br><span class="line">  <span class="comment">// 当number改变时，会触发_update函数，保证对应的DOM进行更新</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">更新_init函数以及observe函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">MyVue.ptototype._init = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* 省略 */</span></span><br><span class="line">  <span class="keyword">this</span>._binding = &#123;&#125;</span><br><span class="line">  <span class="comment">// _binding保存着model与view的映射关系, 也就是我们前面定义的Watcher的实例</span></span><br><span class="line">  <span class="comment">// 当model改变时，我们会触发其中的指令类更新，保证view也能实时更新</span></span><br><span class="line">  <span class="comment">/* ... */</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyVue.prototype._observe = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* 省略 */</span></span><br><span class="line">  <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">    <span class="keyword">this</span>._binding[key] = &#123;</span><br><span class="line">      _directives: []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">var</span> binding = <span class="keyword">this</span>._binding[key]</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>.$data, key, &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`更新<span class="subst">$&#123;newVal&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">if</span> (value !== newVal) &#123;</span><br><span class="line">          value = newVal</span><br><span class="line">          binding._directives.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 当number改变时，触发_binding[number]._directives 中绑定的Watcher类的更新</span></span><br><span class="line">            item._update()</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如何将 view 与 model进行绑定呢？ 接下来我们定义一个_compiler函数，用来解析我们的指令（v-bind, v-model, v-click）等，并在这个过程中与view与model进行绑定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">MyVue.prototype._init = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 省略</span></span><br><span class="line">  <span class="keyword">this</span>._compile(<span class="keyword">this</span>.$el)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyVue.prototype._compile = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123; <span class="comment">// root为 id为app的element，即根元素</span></span><br><span class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">var</span> nodes = root.children</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nodes.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> node = nodes[i]</span><br><span class="line">    <span class="keyword">if</span> (node.chilren.length) &#123; <span class="comment">// 若存在子元素则进行递归处理</span></span><br><span class="line">      <span class="keyword">this</span>._compile(node)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有v-click属性，我们监听它的onclick事件，触发increment事件，即number++</span></span><br><span class="line">    <span class="keyword">if</span> (node.hasAttribute(<span class="string">'v-click'</span>)) &#123;</span><br><span class="line">      node.onclick = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> attrVal = nodes[i].getAttribute(<span class="string">'v-click'</span>)</span><br><span class="line">        <span class="keyword">return</span> _this.$methods[attrVal].bind(_this.$data)</span><br><span class="line">        <span class="comment">// bind是使data的作用域与method函数的作用域保持一致</span></span><br><span class="line">      &#125;)()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有v-model属性，且元素是input或textarea，就监听它的input事件</span></span><br><span class="line">    <span class="keyword">if</span> (node.hasAttribute(<span class="string">'v-model'</span>) &amp;&amp; (node.tagName === <span class="string">'input'</span> || node.target === <span class="string">'textarea'</span>)) &#123;</span><br><span class="line">      node.addEventListener(<span class="string">'input'</span>, (<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> attrVal = node.getAttribute(<span class="string">'v-model'</span>)</span><br><span class="line">        <span class="comment">// _this._binding[number]._directives = [一个Watcher的实例]</span></span><br><span class="line">        <span class="comment">// 其中Watcher.prototype.update = functoin() &#123;</span></span><br><span class="line">        <span class="comment">//   node['value'] = _this.$data['number']</span></span><br><span class="line">        <span class="comment">//   这就将node的值保持与number一致了</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        _this._bniding[attrVal]._directives.push(<span class="keyword">new</span> Watcher(</span><br><span class="line">          <span class="string">'input'</span>,  <span class="comment">// 结合上面的 Watcher构造函数来看 </span></span><br><span class="line">          node,     <span class="comment">// 分别传参 指令名, dom</span></span><br><span class="line">          _this,    <span class="comment">// Vue绑定的实例</span></span><br><span class="line">          attrVal,  <span class="comment">// 指令对应值</span></span><br><span class="line">          <span class="string">'value'</span>   <span class="comment">// 绑定的对应属性</span></span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          _this.$data[attrVal] = nodes[key].value</span><br><span class="line">          <span class="comment">// 使number的值与node的value保持一致，这就实现了双向绑定</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)(i))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有v-bind属性，我们只要使node的值及时更新为data中的number值即可</span></span><br><span class="line">    <span class="keyword">if</span> (node.hasAttribute(<span class="string">'v-bind'</span>)) &#123;</span><br><span class="line">      <span class="keyword">var</span> attrVal = node.getAttribute(<span class="string">'v-bind'</span>)</span><br><span class="line">      _this._binding[attrVal]._directives.push(<span class="keyword">new</span> Watcher(</span><br><span class="line">        <span class="string">'text'</span>,</span><br><span class="line">        node,</span><br><span class="line">        _this,</span><br><span class="line">        attrVal,</span><br><span class="line">        <span class="string">'innerHTML'</span></span><br><span class="line">      ))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附上完整代码"><a href="#附上完整代码" class="headerlink" title="附上完整代码"></a>附上完整代码</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>  <span class="attr">v-model</span>=<span class="string">"number"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">v-click</span>=<span class="string">"increment"</span>&gt;</span>增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span> <span class="attr">v-bind</span>=<span class="string">"number"</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">MyVue</span>(<span class="params">options</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>._init(options)</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  MyVue.prototype._init = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.$options = options</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.$el = <span class="built_in">document</span>.querySelector(options.el)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.$data = options.data</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.$methods = options.methods</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>._binding = &#123;&#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>._observe(<span class="keyword">this</span>.$data)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>._compile(<span class="keyword">this</span>.$el)</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  MyVue.prototype._observe = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> value</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (key <span class="keyword">in</span> obj) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (obj.hasOwnproperty(key)) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>._binding[key] = &#123;</span></span><br><span class="line"><span class="undefined">          _directives: []</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        value = obj[key]</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'object'</span>) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>._observe(value)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> binding = <span class="keyword">this</span>._binding[key]</span></span><br><span class="line"><span class="javascript">        <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>.$data, key, &#123;</span></span><br><span class="line"><span class="javascript">          enumerable: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">          configurable: <span class="literal">true</span>,</span></span><br><span class="line"><span class="undefined">          get() &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">`获取<span class="subst">$&#123;value&#125;</span>`</span>)</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> value</span></span><br><span class="line"><span class="undefined">          &#125;,</span></span><br><span class="line"><span class="undefined">          set(newVal) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">`更新<span class="subst">$&#123;newVal&#125;</span>`</span>)</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (value !== newVal) &#123;</span></span><br><span class="line"><span class="undefined">              value = newVal</span></span><br><span class="line"><span class="javascript">              binding._directives.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">                item.update()</span></span><br><span class="line"><span class="undefined">              &#125;)</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">          &#125;</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  MyVue.prototype._compile = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> _this = <span class="keyword">this</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> nodes = root.children</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nodes.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> node = nodes[i]</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (node.children.length) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>._compile(node)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (node.hasAttribute(<span class="string">'v-click'</span>)) &#123;</span></span><br><span class="line"><span class="javascript">        node.onclick = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> attrVal = nodes[i].getAttribute(<span class="string">'v-click'</span>)</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> _this.$methods[attrVal].bind(_this.$data)</span></span><br><span class="line"><span class="undefined">        &#125;)()</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (node.hasAttribute(<span class="string">'v-model'</span>) &amp;&amp; (node.tagName === <span class="string">'input'</span> || node.tagName === <span class="string">'textarea'</span>)) &#123;</span></span><br><span class="line"><span class="javascript">        node.addEventListener(<span class="string">'input'</span>, (<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> attrVal = node.getAttribute(<span class="string">'v-model'</span>)</span></span><br><span class="line"><span class="javascript">          _this._binding[attrVal]._directives.push(<span class="keyword">new</span> Watcher(</span></span><br><span class="line"><span class="javascript">            <span class="string">'input'</span>,</span></span><br><span class="line"><span class="undefined">            node,</span></span><br><span class="line"><span class="undefined">            _this,</span></span><br><span class="line"><span class="undefined">            attrVal,</span></span><br><span class="line"><span class="javascript">            <span class="string">'value'</span></span></span><br><span class="line"><span class="undefined">          ))</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">            _this.$data[attrVal] = nodes[key].value</span></span><br><span class="line"><span class="undefined">          &#125;</span></span><br><span class="line"><span class="undefined">        &#125;)(i))</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (node.hasAttribute(<span class="string">'v-bind'</span>)) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> attrVal = node.getAttribute(<span class="string">'v-bind'</span>)</span></span><br><span class="line"><span class="javascript">        _this._binding[attrVal]._directives.push(<span class="keyword">new</span> Watcher(</span></span><br><span class="line"><span class="javascript">          <span class="string">'text'</span>,</span></span><br><span class="line"><span class="undefined">          node,</span></span><br><span class="line"><span class="undefined">          _this,</span></span><br><span class="line"><span class="undefined">          attrVal,</span></span><br><span class="line"><span class="javascript">          <span class="string">'innerHTML'</span></span></span><br><span class="line"><span class="undefined">        ))</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">name, el, vm, exp, attr</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.name = name    <span class="comment">//指令名称，例如文本节点，该值设为"text"</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.el = el        <span class="comment">//指令对应的DOM元素</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.vm = vm        <span class="comment">//指令所属myVue实例</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.exp = exp      <span class="comment">//指令对应的值，本例如"number"</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.attr = attr    <span class="comment">//绑定的属性值，本例为"innerHTML"</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.update()</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  Wathcer.prototype.update = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.el[<span class="keyword">this</span>.attr] = <span class="keyword">this</span>.vm.$data[<span class="keyword">this</span>.exp]</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> MyVue(&#123;</span></span><br><span class="line"><span class="javascript">      el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">      data: &#123;</span></span><br><span class="line"><span class="undefined">        number: 0</span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">      methods: &#123;</span></span><br><span class="line"><span class="javascript">        increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.number++</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后来梳理一下逻辑：</p><ol><li>写一个构造函数 MyVue 可传入一个options参数，实例化时执行其 _init方法</li><li>_init 其核心是将 options的各种属性 放到其实例上，并执行 _observe 和 _compile 方法</li><li>_observe 作为一个代理方法，监听传入的options.data属性的改变，（这里会将data里的每个key放入 _bingding 对象中，然后用Object.defineProperty对每一个key进行监听, 若属性值改变了，就实时改变）</li><li>上面说的实时改变就是 update 方法，那观察的对象从哪来？ 指令上对应的值？ 这一过程其实就是 _compile做的. 让 MyVue能知道 el 上的指令代表什么</li><li>_compile让我们知道了指令是干嘛的，具体触发改变就是由Watcher来做的了，我们传入name(指令名), el(对应dom), vm(MyVue实例), exp(指令对应值), attr(绑定的属性)，然后调用其原型上的update方法。 触发了 _observe其最终是执行 update方法来更改值</li></ol><p>说得好像很啰嗦，但这就是双向绑定的过程了，知根知底，这样又往前进了一小步咯。以上就实现了文本与input的双向绑定</p><hr><p>4.17更新~ 添加完整可运行的 es6版</p><p>理下思路：</p><ol><li>MyVue实例时将传入的options的给实例，完成初始化</li><li>_binding 进行依赖收集，每次设置会触发 Watcher 实例的update</li><li>_observe 监听data数据，实现数据响应式化</li><li>_compile 将模版编译为抽象语法树AST</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$options = options</span><br><span class="line">    <span class="keyword">this</span>.$el = <span class="built_in">document</span>.querySelector(options.el)</span><br><span class="line">    <span class="keyword">this</span>.$data = options.data</span><br><span class="line">    <span class="keyword">this</span>.$methods = options.methods</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._binding = &#123;&#125;           <span class="comment">// 依赖收集</span></span><br><span class="line">    <span class="keyword">this</span>._observe(<span class="keyword">this</span>.$data)    <span class="comment">// 观察data数据添加到Watcher中</span></span><br><span class="line">    <span class="keyword">this</span>._compile(<span class="keyword">this</span>.$el)      <span class="comment">// 编译为抽象语法树AST 这里要简单得多</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _observe(obj) &#123;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span>(obj.hasOwnProperty(key)) &#123;</span><br><span class="line">        <span class="keyword">this</span>._binding[key] = &#123;</span><br><span class="line">          _directives: []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'this._binding[key]'</span>, <span class="keyword">this</span>._binding[key])</span><br><span class="line">        <span class="keyword">let</span> value = obj[key]</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'object'</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>._observe(value)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> binding = <span class="keyword">this</span>._binding[key]</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>.$data, key, &#123;</span><br><span class="line">          enumerable: <span class="literal">true</span>,</span><br><span class="line">          configurable: <span class="literal">true</span>,</span><br><span class="line">          get() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>获取<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">          &#125;,</span><br><span class="line">          set(newVal) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>设置<span class="subst">$&#123;newVal&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">if</span> (value !== newVal) &#123;</span><br><span class="line">              value = newVal</span><br><span class="line">              binding._directives.forEach(<span class="function"><span class="params">item</span> =&gt;</span> item.update())</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _compile(root) &#123;</span><br><span class="line">    <span class="comment">// root为根节点，传入的el</span></span><br><span class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> nodes = root.children</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nodes.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> node = nodes[i]</span><br><span class="line">      <span class="keyword">if</span> (node.children.length) &#123;</span><br><span class="line">        <span class="keyword">this</span>._compile(node)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (node.hasAttribute(<span class="string">'v-click'</span>)) &#123;</span><br><span class="line">        node.onclick = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">let</span> attrVal = nodes[i].getAttribute(<span class="string">'v-click'</span>)</span><br><span class="line">          <span class="keyword">return</span> _this.$methods[attrVal].bind(_this.$data)</span><br><span class="line">        &#125;)()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (node.hasAttribute(<span class="string">'v-model'</span>) &amp;&amp; (node.tagName === <span class="string">'INPUT'</span> || node.tagName === <span class="string">'TEXTAREA'</span>)) &#123;</span><br><span class="line">        node.addEventListener(<span class="string">'input'</span>, (<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">let</span> attrVal = nodes[i].getAttribute(<span class="string">'v-model'</span>)</span><br><span class="line">          _this._binding[attrVal]._directives.push(<span class="keyword">new</span> Watcher(</span><br><span class="line">            <span class="string">'input'</span>,</span><br><span class="line">            node,</span><br><span class="line">            _this,</span><br><span class="line">            attrVal,</span><br><span class="line">            <span class="string">'value'</span></span><br><span class="line">          ))</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            _this.$data[attrVal] = nodes[key].value</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)(i))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (node.hasAttribute(<span class="string">'v-bind'</span>)) &#123;</span><br><span class="line">        <span class="keyword">let</span> attrVal = nodes[i].getAttribute(<span class="string">'v-bind'</span>)</span><br><span class="line">        _this._binding[attrVal]._directives.push(<span class="keyword">new</span> Watcher(</span><br><span class="line">          <span class="string">'text'</span>,</span><br><span class="line">          node,</span><br><span class="line">          _this,</span><br><span class="line">          attrVal,</span><br><span class="line">          <span class="string">'innerHTML'</span></span><br><span class="line">        ))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, el, vm, exp, attr) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name    <span class="comment">// 指令名</span></span><br><span class="line">    <span class="keyword">this</span>.el = el        <span class="comment">// 指令对应dom</span></span><br><span class="line">    <span class="keyword">this</span>.vm = vm        <span class="comment">// 指令所属实例</span></span><br><span class="line">    <span class="keyword">this</span>.exp = exp      <span class="comment">// 指令对应值</span></span><br><span class="line">    <span class="keyword">this</span>.attr = attr    <span class="comment">// 绑定属性值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.update()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="keyword">this</span>.el[<span class="keyword">this</span>.attr] = <span class="keyword">this</span>.vm.$data[<span class="keyword">this</span>.exp]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> mvvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【构建】webpack4.5升级踩坑</title>
      <link href="/2018/04/10/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%8C%96%E3%80%91webpack4.5%E5%8D%87%E7%BA%A7%E8%B8%A9%E5%9D%91/"/>
      <url>/2018/04/10/%E3%80%90%E5%B7%A5%E7%A8%8B%E5%8C%96%E3%80%91webpack4.5%E5%8D%87%E7%BA%A7%E8%B8%A9%E5%9D%91/</url>
      <content type="html"><![CDATA[<blockquote><p>正好离webpack4的升级也过了一个多月了，大佬们已经踩完第一波雷，官方也强推现在的稳定版本4.5，加上最近在看服务端渲染，正好弄个demo升级玩玩。内容大部分转自 webpack4升级完全指南 <a href="https://segmentfault.com/a/1190000014247030" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014247030</a></p></blockquote><a id="more"></a><h2 id="相关依赖调整"><a href="#相关依赖调整" class="headerlink" title="相关依赖调整"></a>相关依赖调整</h2><p>node 版本 8.9.4 + 为佳，之前8.9.0升级了好久也没见什么问题，node版本升级比飞还快，能升就跟着升吧</p><p>webpack命令优化， 要装上<br>各种loader跟着升级到最新先- - 不然报错有点头疼，这个放后面说</p><p>“webpack”: “^4.5.0”,<br>“webpack-cli”: “^2.0.14”,<br>“webpack-dev-server”: “^3.1.2”,<br>“webpack-merge”: “^4.1.2”</p><p>html-webpack-plugin file-loader url-loader style-loader 各种loader该升级的都升级吧，要相信社区的实力和效率</p><h2 id="webpack相关更新"><a href="#webpack相关更新" class="headerlink" title="webpack相关更新"></a>webpack相关更新</h2><h3 id="mode模式"><a href="#mode模式" class="headerlink" title="mode模式"></a>mode模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> isDev = process.env.NODE_ENV === <span class="string">'development'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  config: &#123;</span><br><span class="line">    <span class="comment">// 省略大部分代码</span></span><br><span class="line">    mode: isDev ? <span class="string">'development'</span> : <span class="string">'production'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可以这么写。以前 dev 和 prd 环境分开设置的一些东西，在webpack 4官方已经为我们做好了预配置，不用麻烦些一堆东向了（感谢parcel）</p><p><strong>development模式下，将侧重于功能调试和优化开发体验：</strong></p><ol><li>浏览器调试工具</li><li>开发阶段的详细错误日志和提示</li><li>快速和优化的增量构建机制</li></ol><p><strong>production模式下，将侧重于模块体积优化和线上部署</strong></p><ol><li>开启所有的优化代码</li><li>更小的bundle大小</li><li>去除掉只在开发阶段运行的代码</li><li>Scope hoisting和Tree-shaking</li><li>自动启用uglifyjs对代码进行压缩</li></ol><h3 id="移除commonChunk-改为-optimization"><a href="#移除commonChunk-改为-optimization" class="headerlink" title="移除commonChunk 改为 optimization"></a>移除commonChunk 改为 optimization</h3><p>之前为了将公共代码提取出来，我们会将入口中配置相关依赖 vendor。webpack打包时，会给每一个模块单独加上一个ID， 在有新的模块加入时，模块插入的顺序在中间，导致后面的模块顺序发生变化，后面的chunk就是为解决这一问题的，这样顺序不会变动，前面部分不会重复打包了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: <span class="string">'vendor'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: <span class="string">'runtime'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p>下面的代码即是optimize.splitChunks 中的一些配置参考，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    runtimeChunk: &#123;</span><br><span class="line">      name: <span class="string">'manifest'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    minimizer: <span class="literal">true</span>, <span class="comment">// [new UglifyJsPlugin(&#123;...&#125;)]</span></span><br><span class="line">    splitChunks:&#123;</span><br><span class="line">      chunks: <span class="string">'async'</span>,</span><br><span class="line">      minSize: <span class="number">30000</span>,</span><br><span class="line">      minChunks: <span class="number">1</span>,</span><br><span class="line">      maxAsyncRequests: <span class="number">5</span>,</span><br><span class="line">      maxInitialRequests: <span class="number">3</span>,</span><br><span class="line">      name: <span class="literal">false</span>,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendor: &#123;</span><br><span class="line">          name: <span class="string">'vendor'</span>,</span><br><span class="line">          chunks: <span class="string">'initial'</span>,</span><br><span class="line">          priority: <span class="number">-10</span>,</span><br><span class="line">          reuseExistingChunk: <span class="literal">false</span>,</span><br><span class="line">          test: <span class="regexp">/node_modules\/(.*)\.js/</span></span><br><span class="line">        &#125;,</span><br><span class="line">        styles: &#123;</span><br><span class="line">          name: <span class="string">'styles'</span>,</span><br><span class="line">          test: <span class="regexp">/\.(scss|css)$/</span>,</span><br><span class="line">          chunks: <span class="string">'all'</span>,</span><br><span class="line">          minChunks: <span class="number">1</span>,</span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span>,</span><br><span class="line">          enforce: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从webpack4开始官方移除了commonchunk插件，改用了optimization属性进行更加灵活的配置，这也应该是从V3升级到V4的代码修改过程中最为复杂的一部分。其中变化有如下几方面：</p><ul><li><p>commonchunk配置项被彻底去掉，之前需要通过配置两次new webpack.optimize.CommonsChunkPlugin来分别获取vendor和manifest的通用chunk方式已经做了整合， 直接在optimization中配置runtimeChunk和splitChunks即可 ，提取功能也更为强大，具体配置见：splitChunks</p></li><li><p>runtimeChunk可以配置成true，single或者对象，用自动计算当前构建的一些基础chunk信息，类似之前版本中的manifest信息获取方式。</p></li><li><p>webpack.optimize.UglifyJsPlugin现在也不需要了，只需要使用optimization.minimize为true就行，production mode下面自动为true，当然如果想使用第三方的压缩插件也可以在optimization.minimizer的数组列表中进行配置</p></li></ul><h3 id="ExtractTextWebpackPlugin调整"><a href="#ExtractTextWebpackPlugin调整" class="headerlink" title="ExtractTextWebpackPlugin调整"></a>ExtractTextWebpackPlugin调整</h3><p>如果升级到 最新的 extract-text-webpack-plugin”: “^4.0.0-beta.0” 也没问题，如果遇到了下面的错误，你懂的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> (node:<span class="number">4728</span>) DeprecationWarning: Tapable.plugin is deprecated. Use <span class="keyword">new</span> API on <span class="string">`.hooks`</span> instead</span><br><span class="line">(node:<span class="number">4728</span>) DeprecationWarning: Tapable.apply is deprecated. Call apply on the plugin directly instead</span><br><span class="line">/Users/x-kxem/myWorkSpace/vue-ssr-tech/node_modules/webpack/lib/Chunk.js:<span class="number">460</span></span><br></pre></td></tr></table></figure><p>建议选用新的CSS文件提取插件mini-css-extract-plugin，配置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">"mini-css-extract-plugin"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'[name].css'</span>,</span><br><span class="line">      chunkFilename: <span class="string">'[id].css'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生产环境下的配置优化"><a href="#生产环境下的配置优化" class="headerlink" title="生产环境下的配置优化"></a>生产环境下的配置优化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">"uglifyjs-webpack-plugin"</span>)</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">"mini-css-extract-plugin"</span>)</span><br><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">"optimize-css-assets-webpack-plugin"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">      <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">        cache: <span class="literal">true</span>,</span><br><span class="line">        parallel: <span class="literal">true</span>,</span><br><span class="line">        sourceMap: <span class="literal">true</span></span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;</span><br><span class="line">        <span class="comment">// use OptimizeCSSAssetsPlugin</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'css/app.[name].css'</span>,</span><br><span class="line">      <span class="comment">// use contenthash *</span></span><br><span class="line">      chunkFilename: <span class="string">'css/app.[contenthash:12].css'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将多个-css-chunk-合并成一个-css文件"><a href="#将多个-css-chunk-合并成一个-css文件" class="headerlink" title="将多个 css chunk 合并成一个 css文件"></a>将多个 css chunk 合并成一个 css文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">"mini-css-extract-plugin"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        styles: &#123;</span><br><span class="line">          name: <span class="string">'styles'</span>,</span><br><span class="line">          test: <span class="regexp">/\.scss|css$/</span>,</span><br><span class="line">          <span class="comment">// 下面的设置就是将 css chunk合并为一个文件的</span></span><br><span class="line">          chunks: <span class="string">'all'</span>,</span><br><span class="line">          enforce: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他调整"><a href="#其他调整" class="headerlink" title="其他调整"></a>其他调整</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  config: &#123;</span><br><span class="line">    <span class="comment">// plugins: [</span></span><br><span class="line">    <span class="comment">//   new webpack.NoEmitOnErrorsPlugin()</span></span><br><span class="line">    <span class="comment">//   new webpack.NamedChunksPlugin()</span></span><br><span class="line">    <span class="comment">// ]</span></span><br><span class="line">    optimization: &#123;</span><br><span class="line">      <span class="comment">// noEmitOnErrors</span></span><br><span class="line">      <span class="comment">// namedModules</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>webpack4更新日志 <a href="https://github.com/webpack/webpack/releases/tag/v4.0.0" target="_blank" rel="noopener">https://github.com/webpack/webpack/releases/tag/v4.0.0</a></p><p>《webpack 4: mode and optimization》 <a href="https://medium.com/webpack/webpack-4-mode-and-optimization-5423a6bc597a" target="_blank" rel="noopener">https://medium.com/webpack/webpack-4-mode-and-optimization-5423a6bc597a</a></p><p>splitChunks  <a href="https://webpack.js.org/plugins/split-chunks-plugin/#optimization-splitchunks" target="_blank" rel="noopener">https://webpack.js.org/plugins/split-chunks-plugin/#optimization-splitchunks</a></p><p>mini-css-extract-plugin  <a href="https://github.com/webpack-contrib/mini-css-extract-plugin" target="_blank" rel="noopener">https://github.com/webpack-contrib/mini-css-extract-plugin</a></p><p>webpack4配置工程实例  <a href="https://github.com/taikongfeizhu/react-mobx-react-router4-boilerplate" target="_blank" rel="noopener">https://github.com/taikongfeizhu/react-mobx-react-router4-boilerplate</a></p><hr><p>重点参考资料</p><p>webpack4 <a href="https://blog.csdn.net/qq_20334295/article/details/79401231" target="_blank" rel="noopener">https://blog.csdn.net/qq_20334295/article/details/79401231</a></p><p>webpack4发布概览 <a href="https://zhuanlan.zhihu.com/p/34028750" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34028750</a></p><p>webpack 4: mode and optimization <a href="https://medium.com/webpack/webpack-4-mode-and-optimization-5423a6bc597a" target="_blank" rel="noopener">https://medium.com/webpack/webpack-4-mode-and-optimization-5423a6bc597a</a></p><p>webpack4新特性介绍 <a href="https://segmentfault.com/a/1190000013970017" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013970017</a></p><p>webpack4升级指北 <a href="https://segmentfault.com/a/1190000013420383" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013420383</a></p><p>webpack4升级指南以及从webpack3.x迁移 <a href="https://blog.csdn.net/qq_26733915/article/details/79446460" target="_blank" rel="noopener">https://blog.csdn.net/qq_26733915/article/details/79446460</a></p>]]></content>
      
      <categories>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【学习】Reveal.js一个Web演示文稿框架</title>
      <link href="/2018/04/03/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91Reveal.js%E4%B8%80%E4%B8%AAWeb%E6%BC%94%E7%A4%BA%E6%96%87%E7%A8%BF%E6%A1%86%E6%9E%B6/"/>
      <url>/2018/04/03/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91Reveal.js%E4%B8%80%E4%B8%AAWeb%E6%BC%94%E7%A4%BA%E6%96%87%E7%A8%BF%E6%A1%86%E6%9E%B6/</url>
      <content type="html"><![CDATA[<blockquote><p>A framework for easily creating beautiful presentations using HTML. Check out the live demo.</p></blockquote><blockquote><p>首先安利一波 <a href="https://molunerfinn.com/hexo-theme-melody-doc/#/" target="_blank" rel="noopener">melody</a> 一个漂亮的hexo主题，集合了N多主题的优点于一身，可配置性强、简洁、美观，在知乎刷到后马上就动手把主题换了，读了读文档，有很多好玩的东西，这就算其中之一吧，遂有了这篇博客。</p></blockquote><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>A framework for easily creating beautiful presentations using HTML. Check out the live demo.<br>reveal.js comes with a broad range of features including nested slides, Markdown contents, PDF export, speaker notes and a JavaScript API. There’s also a fully featured visual editor and platform for sharing reveal.js presentations at slides.com.</p></blockquote><p>reveal.js是一个能够帮助我们很轻易地使用HTML来创建漂亮的演示效果，也就是我们常见的PPT幻灯片。reveal.js不依赖其他任何javascript库，是一个独立的javascript插件库。它提供了多种幻灯片过渡效果，是一个非常棒的在线演示库。</p><h3 id="在html里使用"><a href="#在html里使用" class="headerlink" title="在html里使用"></a>在html里使用</h3><p>我们先引入主要的CSS文件以及js文件。CSS文件要在head内就载入，而reveal.js可以在<code>&lt;/body&gt;</code>前载入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/reveal.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/theme/moon.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/reveal.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>HTML标记的层次结构需要是 <code>.reveal &gt; .slides &gt; section</code> 这样的，<code>&lt;section&gt;</code> 代表一个幻灯片并且能够被无限地重复。如果我们将多个 <code>&lt;section&gt;</code> 放到另一个 <code>&lt;section&gt;</code> 的内部，它们将会以垂直幻灯片的方式显示。<code>&lt;section&gt;</code> 内部可以是文本、图片、多媒体等任意HTML内容。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"reveal"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"slides"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span>slide1<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span>slide2<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在页面最后，我们需要运行下面的代码来初始化幻灯片。注意，所有的配置的值都是可选的，下面展示的都是默认值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">Reveal.initialize(&#123;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 是否在右下角展示控制条</span></span></span><br><span class="line"><span class="javascript">controls: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript"><span class="comment">// 是否显示演示的进度条</span></span></span><br><span class="line"><span class="javascript">  progress: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 是否显示当前幻灯片的页数</span></span></span><br><span class="line"><span class="javascript">  slideNumber: <span class="string">'c/t'</span></span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在melody主题中，作者大大已经为我们封装好了，在 <code>_config.yml</code> 里的 slide 选项下直接配置就好</p><h3 id="hexo主题"><a href="#hexo主题" class="headerlink" title="hexo主题"></a>hexo主题</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">slide:</span></span><br><span class="line"><span class="attr">  separator:</span> <span class="meta">---</span></span><br><span class="line"><span class="attr">  separator_vertical:</span> <span class="bullet">--</span></span><br><span class="line"><span class="attr">  charset:</span> <span class="string">utf-8</span></span><br><span class="line"><span class="attr">  theme:</span> <span class="string">black</span></span><br><span class="line">  <span class="comment"># optional</span></span><br><span class="line"><span class="attr">  mouseWheel:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  transition:</span> <span class="string">slide</span></span><br><span class="line"><span class="attr">  transitionSpeed:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  parallaxBackgroundImage:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">  parallaxBackgroundSize:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">  parallaxBackgroundHorizontal:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">  parallaxBackgroundVertical:</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure><h2 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h2><p>下面介绍一下可选配置：（对应上面的api，可自行添加、修改）</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:left">描述</th><th style="text-align:center">默认值</th></tr></thead><tbody><tr><td style="text-align:center">controls</td><td style="text-align:left">是否在右下角展示控制条</td><td style="text-align:center">true</td></tr><tr><td style="text-align:center">progress</td><td style="text-align:left">是否显示演示的进度条</td><td style="text-align:center">true</td></tr><tr><td style="text-align:center">slideNumber</td><td style="text-align:left">是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: ‘c / t’ ，表示当前页/总页数</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">history</td><td style="text-align:left">是否将每个幻灯片改变加入到浏览器的历史记录中去</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">keyboard</td><td style="text-align:left">是否启用键盘快捷键来导航</td><td style="text-align:center">true</td></tr><tr><td style="text-align:center">overview</td><td style="text-align:left">是否启用幻灯片的概览模式，可使用”Esc”或”o”键来切换概览模式</td><td style="text-align:center">true</td></tr><tr><td style="text-align:center">center</td><td style="text-align:left">是否将幻灯片垂直居中</td><td style="text-align:center">true</td></tr><tr><td style="text-align:center">touch</td><td style="text-align:left">是否在触屏设备上启用触摸滑动切换</td><td style="text-align:center">true</td></tr><tr><td style="text-align:center">loop</td><td style="text-align:left">是否循环演示</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">rtl</td><td style="text-align:left">是否将演示的方向变成RTL，即从右往左</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">fragments</td><td style="text-align:left">全局开启和关闭碎片</td><td style="text-align:center">true</td></tr><tr><td style="text-align:center">autoSlide</td><td style="text-align:left">两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 <code>data-autoslide</code> 属性覆盖</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">transition</td><td style="text-align:left">切换过渡效果，有none/fade/slide/convex/concave/zoom</td><td style="text-align:center">‘default’</td></tr><tr><td style="text-align:center">transitionSpeed</td><td style="text-align:left">过渡速度，default/fast/slow</td><td style="text-align:center">‘default’</td></tr><tr><td style="text-align:center">mouseWheel</td><td style="text-align:left">是否启用通过鼠标滚轮来切换幻灯片</td><td style="text-align:center">true</td></tr></tbody></table><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>reveal.js还有一个片段概念，片段被用来在一个幻灯片中来突出显示单独的一个元素。每一个带有 fragment 样式的元素将会在切换到下一个幻灯片之前被走过。默认的片段样式是开始不可见，然后淡入，我们可以将同一张幻灯片里的多个段落分作多个片段，并给他们加上.fragment样式即可，就像DEMO演示中的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>幻灯片切换方式<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"fragment"</span>&gt;</span>右下角控制条控制切换<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"fragment"</span>&gt;</span>可以使用键盘方向键操作<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"fragment"</span>&gt;</span>可以设置使用鼠标滚轮切换<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"fragment"</span>&gt;</span>移动端滑动切换<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关于幻灯片切换效果，是通过transition配置值来设定的。我们也可以通过指定data-transition属性来重写全局配置。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">data-transition</span>=<span class="string">"zoom"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>This slide will override the presentation transition and zoom!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><p>光说不练，怎么也搞不明白，遂请看下一篇，直接拿reveal写篇博客就好。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>更多请参考官方文档 <a href="https://github.com/hakimel/reveal.js#configuration" target="_blank" rel="noopener">https://github.com/hakimel/reveal.js#configuration</a></p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reveal.js </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【调研】移动端布局解决hotcss</title>
      <link href="/2018/03/29/%E3%80%90%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%91%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80%E8%A7%A3%E5%86%B3hotcss/"/>
      <url>/2018/03/29/%E3%80%90%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%91%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80%E8%A7%A3%E5%86%B3hotcss/</url>
      <content type="html"><![CDATA[<blockquote><p>号称移动端布局终极解决方案。其实现非常简洁，但功能却不是盖的。在最近准备做的一个项目中会用到该解决方案，知根知底最好的办法便是学习官方文档和敲源码了。嗯，感觉这法还好，于是废话不多说，开始正文吧</p></blockquote><a id="more"></a><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><a href="http://imochen.github.io/hotcss/" target="_blank" rel="noopener">hotcss</a> 官网称这是一个移动端布局开发的解决方案，使用动态HTML根字体大小和动态viewport scale。之前有一篇很火的讲述移动端布局的，介绍了淘宝、网易几家大厂的实现方式，这里的不同也就是在这个动态viewport scale上了吧。</p><p>其优势在于：</p><ul><li>保证不同设备下的统一视觉体验。</li><li>不需要你再手动设置viewport，根据当前环境计算出最适合的viewport。</li><li>支持任意尺寸的设计图，不局限于特定尺寸的设计图。</li><li>支持单一项目，多种设计图尺寸，专为解决大型，长周期项目。</li><li>提供px2rem转换方法，CSS布局，零成本转换，原始值不丢失。</li><li>有效解决移动端真实1像素问题。</li></ul><p><strong>用法</strong></p><p>直接引入</p><pre><code>&lt;script src=&quot;/path/to/hotcss.js&quot;&gt;&lt;/script&gt;</code></pre><h3 id="css写法"><a href="#css写法" class="headerlink" title="css写法"></a>css写法</h3><p>推荐使用scss来编写css，在scss文件的头部使用import将px2rem导入</p><pre><code>@import &apos;/path/to/px2rem.scss&apos;;</code></pre><p>如果项目是单一尺寸设计图，那么你需要去px2rem.scss中定义全局的designWidth。</p><pre><code>@function px2rem( $px ){  @return $px*320/$designWidth/20 + rem;}$designWidth : 750; //如设计图是750</code></pre><p>如果你的项目是多尺寸设计图，那么就不能定义全局的designWidth了。需要在你的业务scss中单独定义。如以下是style.scss</p><pre><code>@import &apos;/path/to/px2rem.scss&apos;;$designWidth : 750; //如设计图是750</code></pre><p>$designWidth必须要在使用px2rem前定义。否则scss编译会出错。</p><h2 id="hotcss-源码学习"><a href="#hotcss-源码学习" class="headerlink" title="hotcss 源码学习"></a>hotcss 源码学习</h2><p>上面的是用来初（凑）步（字）认（数）识的，果断还是要从源码着手，才能拨云见雾。</p><p>项目目录</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── example<span class="comment">//所有的示例都在这个目录下</span></span><br><span class="line">│   ├── duang</span><br><span class="line">│   ├── normal</span><br><span class="line">│   └── wolf</span><br><span class="line">│</span><br><span class="line">└── src<span class="comment">//主要文件在这里</span></span><br><span class="line">    ├── hotcss.js</span><br><span class="line">    ├── px2rem.less</span><br><span class="line">    ├── px2rem.scss</span><br><span class="line">    └── px2rem.styl</span><br></pre></td></tr></table></figure><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">widnow, document</span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="comment">// 给hotcss开辟个命名空间，暴露给外部访问</span></span><br><span class="line">  <span class="keyword">var</span> hotcss = &#123;&#125;</span><br><span class="line">  ;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 根据devicePixelRatio自定计算scale</span></span><br><span class="line">    <span class="comment">// 可以有效解决移动端1px问题</span></span><br><span class="line">    <span class="keyword">var</span> viewportEl = <span class="built_in">document</span>.querySelector(<span class="string">'meta[name="viewport"]'</span>),</span><br><span class="line">      hotcssEl = <span class="built_in">document</span>.querySelector(<span class="string">'meta[name="hotcss"]'</span>),</span><br><span class="line">      dpr = <span class="built_in">window</span>.devicePixelRatio || <span class="number">1</span>, <span class="comment">// 默认给1</span></span><br><span class="line">      maxWidth = <span class="number">540</span>,  <span class="comment">// 这个最大宽度是可以手动调整的，表示我们支持的最大宽度</span></span><br><span class="line">      designWidth = <span class="number">0</span>  <span class="comment">// 该值最终为设计稿宽度 比如 ip5 320 实际计算得 640    </span></span><br><span class="line">    <span class="comment">// 这里有点绕，一句话说就是，dpr超过3的按3算，2-3之间按2算，1-2之间按1算</span></span><br><span class="line">    dpr = dpr &gt;= <span class="number">3</span> ? <span class="number">3</span> : (dpr &gt;= <span class="number">2</span> ? <span class="number">2</span> : <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 允许通过自定义name为hotcss的meta头，通过initial-dpr来强制页面缩放</span></span><br><span class="line">    <span class="keyword">if</span> (hotcssEl) &#123;</span><br><span class="line">      <span class="keyword">var</span> hotcssCon = hotcssEl.getAttribute(<span class="string">'content'</span>) <span class="comment">// 拿meta的content</span></span><br><span class="line">      <span class="keyword">if</span> (hotcssCon) &#123;</span><br><span class="line">        <span class="comment">// 搞不清楚运行一下就好， 'initial-dpr=2.333'.match(/initial\-dpr=([\d\.]+)/)</span></span><br><span class="line">        <span class="comment">// 返回数组 ['initial-dpr=2.333', '2.333'] </span></span><br><span class="line">        <span class="keyword">var</span> initialDprMatch = hotcssCon.match(<span class="regexp">/initial\-dpr=([\d\.]+)/</span>)</span><br><span class="line">        <span class="keyword">if</span> (initialDprMatch) &#123;</span><br><span class="line">          <span class="comment">// 实际上取 上数组的第1项 即具体数值</span></span><br><span class="line">          dpr = <span class="built_in">parseFloat</span>(initialDprMatch[<span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> maxWidthMatch = hotcssCon.match(<span class="regexp">/max\-width=(\d\.)+/</span>)</span><br><span class="line">        <span class="keyword">if</span> (maxWidthMatch) &#123;</span><br><span class="line">          <span class="comment">// 同上，拿到了最大宽度</span></span><br><span class="line">          maxWidth = <span class="built_in">parseFloat</span>(maxWidthMatch[<span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> designWidthMatch = hotcssCon.match(<span class="regexp">/degisn\-width=([\d\.]+)/</span>)</span><br><span class="line">        <span class="keyword">if</span> (designWidthMatch) &#123;</span><br><span class="line">          <span class="comment">// 这个设计宽度很重要，下面会将到</span></span><br><span class="line">          designWidth = <span class="built_in">parseFloat</span>(designWidthMatch[<span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给html设置 data-dpr属性</span></span><br><span class="line">    <span class="built_in">document</span>.documentElement.setAttribute(<span class="string">'data-dpr'</span>, dpr)</span><br><span class="line">    <span class="comment">// 同时为hotcss对象 添加属性 dpr</span></span><br><span class="line">    hotcss.dpr = dpr</span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">    <span class="built_in">document</span>.documentElement.setAttribute(<span class="string">'max-width'</span>, maxWidth)</span><br><span class="line">    hotcss.maxWidth = maxWidth</span><br><span class="line">    <span class="keyword">if</span> (designWidth) &#123;</span><br><span class="line">      <span class="built_in">document</span>.documentElement.setAttribute(<span class="string">'design-width'</span>, designWidth)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保证 px2rem 和 rem2px 不传第二个参数时，获取 hotcss.desgnWidth 是 undefined导致的NaN</span></span><br><span class="line">    hotcss.designWidth = designWidth</span><br><span class="line">    <span class="keyword">var</span> scale = <span class="number">1</span> / dpr,</span><br><span class="line">      <span class="comment">// 注：我觉得麻烦就改成es6写法了，作者为兼容性用的 + 来拼接，这段大家写viewport都很熟悉吧</span></span><br><span class="line">      content = <span class="string">`width=device-width, initial-scale=<span class="subst">$&#123;scale&#125;</span>, minimum-scale=<span class="subst">$&#123;scale&#125;</span>, maximum-scale=<span class="subst">$&#123;scale&#125;</span>, user-scalable=no`</span></span><br><span class="line">    <span class="comment">// 容错处理，如果没写viewport作者大大很和善地帮加上了</span></span><br><span class="line">    <span class="keyword">if</span> (viewportEl) &#123;</span><br><span class="line">      viewportEl.setAttribute(<span class="string">'content'</span>, content)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      viewportEl = <span class="built_in">document</span>.createElement(<span class="string">'meta'</span>)</span><br><span class="line">      viewportEl.setAttribute(<span class="string">'name'</span>, <span class="string">'viewport'</span>)</span><br><span class="line">      viewportEl.setAttribute(<span class="string">'content'</span>, <span class="string">'content'</span>)</span><br><span class="line">      <span class="built_in">document</span>.head.appendChild(viewportEl)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)()</span><br><span class="line">  <span class="comment">// 其实到这里为止还没开始重头戏，前戏为，我们将 html文档设置了需要的前置属性</span></span><br><span class="line">  <span class="comment">// meta-dpr max-width design-width 通过这3个值就能进行以下的适配工作了</span></span><br><span class="line">  hotcss.px2rem = <span class="function"><span class="keyword">function</span>(<span class="params">px, designWidth</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 预判你将会在JS中用到尺寸，特提供一个方法助你在JS中将px转为rem</span></span><br><span class="line">    <span class="keyword">if</span> (!designWidth) &#123;</span><br><span class="line">      <span class="comment">// 如果在JS中大量用到此方法，建议直接定义 hotcss.designWidth 来定义设计图尺寸</span></span><br><span class="line">      <span class="comment">// 否则可以在第二个参数告诉设计图是多大</span></span><br><span class="line">      designWidth = <span class="built_in">parseInt</span>(hotcss.designWidth, <span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按320宽 与 设计图比例 进行 20份等比分配</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(px, <span class="number">10</span>) * <span class="number">320</span> / designWidth / <span class="number">20</span></span><br><span class="line">  &#125;</span><br><span class="line">  hotcss.rem2px = <span class="function"><span class="keyword">function</span>(<span class="params">rem, designWidth</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 新增一个rem2px的方法，用法和 px2rem 一致</span></span><br><span class="line">    <span class="keyword">if</span> (!designWidth) &#123;</span><br><span class="line">      designWidth = <span class="built_in">parseInt</span>(hotcss.designWidth, <span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// rem可能为小数，这里暂不作处理</span></span><br><span class="line">    <span class="comment">// rem是 以320标准和设计图尺寸比 除以20份 得到的，这里反过来求得 px</span></span><br><span class="line">    <span class="keyword">return</span> rem * <span class="number">20</span> * designWidth / <span class="number">320</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 核心方法，给html 设置 font-size, 因为 rem是基于 根元素的fontsize</span></span><br><span class="line">  hotcss.mresize = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// getBoundingClientRect()有少数兼容性问题</span></span><br><span class="line">    <span class="keyword">var</span> innerWidth = <span class="built_in">document</span>.documentElement.getBoundingClientRect().width || <span class="built_in">window</span>.innerWidth;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 我们之前给hotcss设了最大宽度，这是一个处理边界</span></span><br><span class="line">    <span class="comment">// 假设 苹果xxx 宽度是 2560 / 3 = 853，我们处理的最大宽为 600， 则说明走以下逻辑， 反之则重设innerWidth</span></span><br><span class="line">    <span class="keyword">if</span> (hotcss.maxWidth &amp;&amp; (innerWidth / hotcss.dpr &gt; hotcss.maxWidth)) &#123;</span><br><span class="line">      innerWidth = hotcss.maxWidth * hotcss.dpr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!innerWidth) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 还记得我们将设计图尺寸切分成20份吗。dpr已用于innerWidth计算了。这里按320宽还原回去</span></span><br><span class="line">    <span class="built_in">document</span>.documentElement.style.fontSize = (innerWidth * <span class="number">20</span> / <span class="number">320</span>) + <span class="string">'px'</span></span><br><span class="line">    <span class="comment">// 有回调则执行回调</span></span><br><span class="line">    hotcss.callback &amp;&amp; hotcss.callback()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 先直接调用一次，调用后， html根元素被设置了：</span></span><br><span class="line">  <span class="comment">// data-dpr、max-width、design-width、font-size</span></span><br><span class="line">  hotcss.mresize() </span><br><span class="line">  <span class="comment">// 接下来的 即函数节流了，用于性能优化</span></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(hotcss.tid)</span><br><span class="line">    <span class="comment">// 这个时间可按实际需求更改</span></span><br><span class="line">    hotcss.tid = setTimeout(hotcss.mresize, <span class="number">33</span>)</span><br><span class="line">  &#125;, <span class="literal">false</span>)</span><br><span class="line">  <span class="comment">// 这里可理解为初始化，load后先执行一次</span></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, hotcss.mresize, <span class="literal">false</span>) </span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    hotcss.mresize()</span><br><span class="line">    <span class="comment">// 这里作者为保险又调用了一次，真是小心谨慎啊</span></span><br><span class="line">  &#125;, <span class="number">333</span>)</span><br><span class="line">  <span class="built_in">window</span>.hotcss = hotcss</span><br><span class="line">  <span class="comment">// 命名空间暴露出来，控制权也暴露了，需要时可手动调用以处理某些特别需求</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>, <span class="built_in">document</span>)</span><br></pre></td></tr></table></figure><p>还不错，加上注释也没多少行代码，为以后读大段源码打下了基础…… 误。。。 看到这里，其实和之前淘宝 rem 解决方案差不多，这里只是进行整合。<br>我们可以简单回顾一下，脚本执行后 为window添加全局变量hotcss。在其中可以调用 hotcss.mresize方法，设置几大重要值，随着屏幕尺寸的改变，font-size也会跟着变，从而让我们写在代码中的rem值也随之调整，这样就实现了移动端的适配。</p><h3 id="接口说明"><a href="#接口说明" class="headerlink" title="接口说明"></a>接口说明</h3><p><strong>initial-dpr</strong></p><p>可以通过强制设置dpr。来关闭响应的viewport scale。使得viewport scale始终为固定值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"hotcss"</span> <span class="attr">content</span>=<span class="string">"initial-dpr=1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/path/to/hotcss.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">如iphone微信强设dpr=1，则可以长按识别二维码。</span></span><br><span class="line"><span class="comment">注意，强制设置dpr=1后，css中的1px在2x，3x屏上则不再是真实的1px。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><p><strong>max-width</strong><br>通过设置该值来优化平板/PC访问体验，注意该值默认值为540。设置为0则该功能关闭。 为了配合使用该设置，请给body增加样式width:16rem;margin:0 auto;。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"hotcss"</span> <span class="attr">content</span>=<span class="string">"max-width=640"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/path/to/hotcss.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">默认为540，可根据具体需求自己定义</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">body&#123;</span></span><br><span class="line"><span class="undefined">    width: 16rem;</span></span><br><span class="line"><span class="undefined">    margin: 0 auto;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>design-width</strong><br>通过对design-width的设置可以在本页运行的JS中直接使用hotcss.px2rem/hotcss.rem2px方法，无需再传递第二个值。</p><p><meta name="hotcss" content="design-width=750"></p><script src="/path/to/hotcss.js"></script><p><strong>hotcss.mresize</strong><br>用于重新计算布局，一般不需要你手动调用。</p><pre><code>hotcss.mresize();</code></pre><p><strong>hotcss.callback</strong><br>触发mresize的时候会执行该方法。</p><pre><code>hotcss.callback = function(){  //your code here}</code></pre><p>单位转换 <code>hotcss.px2rem</code> / <code>hotcss.rem2px</code><br>hotcss.px2rem 和 hotcss.rem2px。你可以预先设定hotcss.designWidth可以在meta中设置design-width，则之后使用这两个方法不需要再传递第二个参数。</p><p>迭代后仍然支持在js中设置hotcss.designWidth，推荐使用meta去设置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [px2rem px值转换为rem值]</span></span><br><span class="line"><span class="comment"> * @param  &#123;[number]&#125; px          [需要转换的值]</span></span><br><span class="line"><span class="comment"> * @param  &#123;[number]&#125; designWidth [设计图的宽度尺寸]</span></span><br><span class="line"><span class="comment"> * @return &#123;[number]&#125;             [返回转换后的结果]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">hotcss.px2rem( px , designWidth );</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同上。</span></span><br><span class="line"><span class="comment"> * 注意：因为rem可能为小数，转换后的px值有可能不是整数，需要自己手动处理。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">hotcss.rem2px( rem , designWidth );</span><br><span class="line"><span class="comment">//你可以在meta中定义design-width，此后使用px2rem/rem2px，就不需要传递designWidth值了。同时也支持旧的设置方式，直接在JS中设置hotcss.designWidth</span></span><br><span class="line">hotcss.px2rem(<span class="number">200</span>);</span><br><span class="line">hotcss.rem2px(<span class="number">350</span>);</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>官方文档 <a href="http://imochen.github.io/hotcss/" target="_blank" rel="noopener">http://imochen.github.io/hotcss/</a></p><p>github <a href="https://github.com/imochen/hotcss/blob/master/src/hotcss.js" target="_blank" rel="noopener">https://github.com/imochen/hotcss/blob/master/src/hotcss.js</a></p>]]></content>
      
      <categories>
          
          <category> 调研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动端 </tag>
            
            <tag> rem </tag>
            
            <tag> 自适应 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【项目总结】vue-jd-finance</title>
      <link href="/2018/03/15/%E3%80%90%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E3%80%91vue-jd-finance/"/>
      <url>/2018/03/15/%E3%80%90%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%E3%80%91vue-jd-finance/</url>
      <content type="html"><![CDATA[<blockquote><p>今年3月做的一个小项目，虽然不难，但有很多值得思考和回味的地方，加上自己写东西一向不勤快，趁着小项目完工，思路方法热情都还历历在目，赶紧开篇记录下这些点点滴滴。</p></blockquote><a id="more"></a><h2 id="项目开始"><a href="#项目开始" class="headerlink" title="项目开始"></a>项目开始</h2><p>这是在慕课实战的一个小项目，我觉得自己最大的进步在于，以前做黄老师的Vue是手把手跟着视频敲代码，而现在是看了两节知道了整体思路后，模块、目录、结构都是由自己进行了拆分和重构，自己折腾出来了，再对比视频，更多的是看老师实现的思路，当然，因项目不复杂才有了上述操作吧。</p><p>在实战过程中，提出了很多问题，这个也是我想写博客的原因，问题的回答也是自己慢慢摸索进行了总结</p><p><img src="/2018/03/15/【项目总结】vue-jd-finance/1.png" alt=""></p><p><img src="/2018/03/15/【项目总结】vue-jd-finance/2.png" alt=""></p><p><img src="/2018/03/15/【项目总结】vue-jd-finance/3.png" alt=""></p><p><img src="/2018/03/15/【项目总结】vue-jd-finance/4.png" alt=""></p><p><img src="/2018/03/15/【项目总结】vue-jd-finance/5.png" alt=""></p><p><img src="/2018/03/15/【项目总结】vue-jd-finance/6.png" alt=""></p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>头部<br>轮播图<br>新手特权<br>极速借贷<br>理财精选<br>精品推荐<br>生活服务<br>在线客服<br>公司介绍<br>导航条</p><p><strong>项目目录</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- src</span><br><span class="line">  - assets            <span class="comment">// 静态资源</span></span><br><span class="line">  - components        <span class="comment">// 可拆分的组件</span></span><br><span class="line">  - layout            <span class="comment">// 布局相关组件</span></span><br><span class="line">  - lib               <span class="comment">// 公共方法等，请求，计算等</span></span><br><span class="line">  - routes            <span class="comment">// 路由相关</span></span><br><span class="line">  - views             <span class="comment">// container 页面容器 其相关子组件也放到对应文件夹中</span></span><br><span class="line">  - App.vue           <span class="comment">// 起始文件</span></span><br><span class="line">  - main.js           <span class="comment">// 入口</span></span><br></pre></td></tr></table></figure><h3 id="CSS模块化设计"><a href="#CSS模块化设计" class="headerlink" title="CSS模块化设计"></a>CSS模块化设计</h3><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><ul><li>可复用、能继承、要完整</li><li>周期性迭代</li></ul><h4 id="设计方法"><a href="#设计方法" class="headerlink" title="设计方法"></a>设计方法</h4><ul><li>先整体再后部再颗粒化</li></ul><p>布局 -&gt; 页面 -&gt; 功能 -&gt; 业务</p><ul><li>先抽象再具体</li></ul><h3 id="JS组件设计原则"><a href="#JS组件设计原则" class="headerlink" title="JS组件设计原则"></a>JS组件设计原则</h3><ul><li>高内聚、低耦合</li><li>尽可能抽象</li><li>周期性迭代</li></ul><h3 id="自适应"><a href="#自适应" class="headerlink" title="自适应"></a>自适应</h3><ol><li>基本概念</li></ol><ul><li>CSS像素、设备像素、逻辑像素、设备像素比</li><li>viewport</li><li>rem</li></ul><p>css里的 1px px就是css像素了，和逻辑单位一致。<br>设备像素比：css像素和物理像素的比值</p><ol><li>原理</li></ol><ul><li>利用viewport和设备像素比调整基准像素</li><li>利用px2rem自动转换CSS单位</li></ul><h3 id="SPA设计"><a href="#SPA设计" class="headerlink" title="SPA设计"></a>SPA设计</h3><h4 id="设计意义"><a href="#设计意义" class="headerlink" title="设计意义"></a>设计意义</h4><ul><li>前后端分离</li><li>减轻服务器压力</li><li>增强用户体验</li><li>Prerender预渲染优化SEO</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>History API</li><li>Hash</li></ul><h3 id="生产构建"><a href="#生产构建" class="headerlink" title="生产构建"></a>生产构建</h3><ul><li>合并 style javascript</li><li>抽取 样式要从 javascript中抽取出来</li><li>压缩 js、css、图片等</li><li>调试 开启sourceMap</li></ul><h3 id="发布部署"><a href="#发布部署" class="headerlink" title="发布部署"></a>发布部署</h3><ul><li>提交 使用git提交代码 管理线上版本</li><li>部署 从git仓库拉取代码，通过小流量、跨机房、全量部署</li><li>开启Gzip 开启gzip压缩</li><li>更新CDN</li></ul><h3 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h3><ul><li>babel</li><li>webpack</li><li>dev-server</li></ul><h3 id="代码校验-eslint"><a href="#代码校验-eslint" class="headerlink" title="代码校验 eslint"></a>代码校验 eslint</h3><ul><li>eslint-plugin-vue</li><li>mystaticatea.github.op/vue-eslint-demo</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>windows <a href="https://github.com/coreybutler/nvm-windows" target="_blank" rel="noopener">https://github.com/coreybutler/nvm-windows</a><br>mac <a href="https://github.com/creationix/nvm#install-script" target="_blank" rel="noopener">https://github.com/creationix/nvm#install-script</a></p><p><strong>构建环境相关</strong></p><p>webpack 4.10.0<br><a href="https://doc.webpack-china.org" target="_blank" rel="noopener">https://doc.webpack-china.org</a></p><p>npm scripts<br><a href="http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html</a></p><p>babel<br><a href="https://babeljs.cn/docs/usage/polyfill" target="_blank" rel="noopener">https://babeljs.cn/docs/usage/polyfill</a><br><a href="https://www.imooc.com/article/21866" target="_blank" rel="noopener">https://www.imooc.com/article/21866</a></p>]]></content>
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【JS】应用正则表达式（一）</title>
      <link href="/2018/02/26/%E3%80%90JS%E3%80%91%E5%BA%94%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2018/02/26/%E3%80%90JS%E3%80%91%E5%BA%94%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote><p>之前也写过正则学习相关的，取这标题只是因为最近读忍者秘籍第2版又讲到这个话题，作为学习、回顾把一些重要的知识点和方法记录下来。正则表达式需要长时间的积累及不断实践才能提高，虽然工作中碰不到太多正则使用场景，简单的记录也算作一种学习、应用吧</p></blockquote><a id="more"></a><h2 id="我们可以使用正则解决各种任务"><a href="#我们可以使用正则解决各种任务" class="headerlink" title="我们可以使用正则解决各种任务"></a>我们可以使用正则解决各种任务</h2><ul><li>操作HTML节点中的字符串</li><li>使用CSS选择器表达式定位部分选择器</li><li>判断一个元素是否具有指定的类名</li><li>输入校验</li><li>其他任务</li></ul><hr><h2 id="带着问题学习"><a href="#带着问题学习" class="headerlink" title="带着问题学习"></a>带着问题学习</h2><ol><li>什么时候使用正则字面量，而不是使用正则对象</li><li>什么是粘连匹配，如何开启粘连匹配</li><li>使用全局和非全局正则表达式的区别是什么</li></ol><hr><h2 id="正则相关"><a href="#正则相关" class="headerlink" title="正则相关"></a>正则相关</h2><p>创建正则的方式：</p><ul><li>使用正则字面量</li><li>通过创建 RegExp 对象的实例</li></ul><p>回答1： 当正则表达式在开发环境是明确的，推荐优先使用字面量语法；当需要在运行时动态创建字符串来构建正则表达式时，则使用构造函数的方式。</p><p>正则修饰符：</p><ul><li>i 对大小写不敏感</li><li>g 查找所有匹配项</li><li>m 多行匹配</li><li>y 开启粘连匹配</li><li>u 允许使用 Unicode点转义符</li></ul><h3 id="术语和操作符"><a href="#术语和操作符" class="headerlink" title="术语和操作符"></a>术语和操作符</h3><p><strong>精确匹配</strong></p><p>/test/ 这类，/^test$/</p><p><strong>匹配字符集</strong></p><p>[abc] 我们匹配的是 a b 或 c，只是abc其中一个字符</p><p>[^abc] 字符集里的 ^ 表示除了abc意外的任意字符，这要和 ^ 以开始作区别</p><p><strong>转义</strong></p><p>$ . ^ [ / ] \ { } ‘ 这些特殊字符都是需要 添加 <code>\</code> 来进行转义的</p><p><strong>起止符号</strong></p><p>尖括号()用于匹配字符串的开始，如 /^test/就是匹配test出现在字符串的开头。（注，这只是字符的重载，^还可以表示非）</p><p>美元符号$表示字符串的结束，如/test$/ 就是匹配 test出现在字符串的末尾</p><p><strong>重复出现</strong></p><ul><li>? 0次或1次</li><li><ul><li>1次或多次</li></ul></li><li><ul><li>0次或多次</li></ul></li><li>{n} 表重复次数</li><li>{2, 4} 重复范围 出现2到4次</li><li>{4, } 匹配4次或更多</li></ul><p>这些字符串都可以是贪婪的或非贪婪的。默认是贪婪模式，可以匹配所有可能的字符。在运算符后添加?，例如 a+?，使得运算符为非贪婪模式，只进行最小限度的匹配。<br>例如，对于字符串aaa，正则表达式/a+/会匹配全部3个字符，而非贪婪模式/a+?/则匹配一个字符a，因为一个字符a足以满足a+术语。</p><p><strong>预定义字符集</strong>只列常用的</p><ul><li>\t 水平制表符</li><li>\r 回车</li><li>\h 换行符</li><li>. 匹配除换行意外的任意字符</li><li>\d 匹配十进制数字 [0-9]</li><li>\D 匹配非十进制数字外任意字符 [^0-9]</li><li>\w 匹配任何数字、字母、下划线 [0-9a-zA-Z_]</li><li>\W 匹配除了数字、字母、下划线以外的任意字符 [^0-9a-zA-Z_]</li><li>\s 匹配任意空白字符 空格、制表符、换行等</li><li>\S 匹配除空白符以外的任意字符</li><li>\b 匹配单词边界</li><li>\B 匹配非单词边界</li></ul><p><strong>分组</strong></p><p>操作符，如 + 和 * 只影响其前面的术语。如果对一组术语使用操作符，可以使用<strong>圆括号</strong>()进行分组，这与数学表达式类似。例如，/(ab)+/匹配一个或多个连续的ab</p><p><strong>或操作符</strong></p><p>使用竖线 | 表示或。例如， /a|b/表示可以匹配a或者b，/(ab+)|(cd+)/表示可以匹配一个或多个ab或cd</p><p><strong>反向引用</strong></p><p>反向引用可引用正则中定义的捕获。稍后会详细介绍。</p><p>现在只需要把捕获看作待匹配的字符串，也就是前面匹配的字符串。反向引用分组中捕获的内容，使用反斜线加上数字表示引用，该数字从1开始。<br>例如 /^([dtn]a)\1/ 匹配任意从d t或n开始的连续有a的字符串，连续匹配第一个分组中捕获的内容。</p><h3 id="编译正则表达式"><a href="#编译正则表达式" class="headerlink" title="编译正则表达式"></a>编译正则表达式</h3><p>处理正则经历多个阶段，其中两个主要的阶段是编译和执行。<br>编译阶段发生在正则表达式被创建的时期。执行发生在使用编译之后的正则表达式进行匹配字符串的时期。</p><p>在编译过程中，表达式经过JS引擎的解析，转换为内部代码。解析和转换的过程发生砸死正则表达式创建时期（浏览器会进行内部优化处理）。通常的，浏览器会判断使用哪条正则并缓存表达式的编译结果。但对于复杂表达式，我们通过预编译正则，使得性能得到明显提升。</p><p>编译正则并将其保存在变量是个很重要的优化过程。<br>每个正则都有以个独特的对象表示，每次创建一个正则都会创建一个新的正则表达式对象。这与原始类型不同，因为每个正则都是独一无二的。使用构造函数创建正则可以在运行时使用字符串创建正则。对于构建可以重复使用的复杂正则很有用。</p><p>在运行时编译一个稍后使用的正则，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"samurai ninja"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ninja samurai"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"samurai ninja ronin"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">findClassInElements</span>(<span class="params">className, type</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 根据标签类型查找元素</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> elems = <span class="built_in">document</span>.getElementsByTagName(type || <span class="string">'*'</span>)</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 使用传入的class编译正则</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`(^|\\s)<span class="subst">$&#123;className&#125;</span>(\\s|$)`</span>)</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 储存最终结果</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> results = []</span></span><br><span class="line"><span class="javascript">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = elems.length; i &lt; length; i++) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 检测是否与正则匹配</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (reg.test(elems[i].className)) &#123;</span></span><br><span class="line"><span class="undefined">      results.push(elems[i])</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">return</span> results</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种方式可以大大提高性能。一旦正则被编译后，就可以通过该正则的test方法收集匹配的元素。<br>推荐使用预创建和预编译的正则表达式，这对性能有很大提升。在正则表达式中使用圆括号，不仅可以用于术语，还可以创建捕获。</p><h3 id="捕获匹配的片段"><a href="#捕获匹配的片段" class="headerlink" title="捕获匹配的片段"></a>捕获匹配的片段</h3><p>执行简单捕获，代码示例如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"square"</span> <span class="attr">style</span>=<span class="string">"transform:translateY(15px);"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">getTranslate</span>(<span class="params">elem</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> transformValue = elem.style.transform</span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span> (transformValue) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> match = transformValue.match(<span class="regexp">/translate[x|y|z|3d]\(([^\)]+)\)/</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(match)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> match ? match[<span class="number">1</span>] : <span class="string">''</span></span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">return</span> <span class="string">''</span></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> square = <span class="built_in">document</span>.getElementById(<span class="string">'square'</span>)</span></span><br><span class="line"><span class="undefined">getTranslate(square)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>match方法匹配结果通过第一个索引返回，然后每次捕获结果索引递增。所以第0个匹配的是整个字符串translateY(15px)，第二个位置是15px。<br>在正则表达式中使用圆括号定义捕获。因为我们在正则表达式中仅定义了一个捕获，因此当匹配变换值时，其值存储在[1]中。</p><h3 id="使用全局表达式进行匹配"><a href="#使用全局表达式进行匹配" class="headerlink" title="使用全局表达式进行匹配"></a>使用全局表达式进行匹配</h3><p>使用局部正则表示可以返回数组，该数组中包含全部匹配的内容以及操作中的全部匹配结果。<br>但当使用全局正则表达式g返回全部的匹配结果，但不会返回捕获结果。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> html = <span class="string">`&lt;div class="test"&gt;&lt;b&gt;hello&lt;/b&gt; &lt;i&gt;world!&lt;/i&gt;&lt;/div&gt;`</span></span><br><span class="line"><span class="keyword">const</span> reg1 = <span class="regexp">/&lt;(\/?)(\w+)([^&gt;]*?)&gt;/</span></span><br><span class="line"><span class="keyword">const</span> reg2 = <span class="regexp">/&lt;(\/?)(\w+)([^&gt;]*?)&gt;/g</span></span><br><span class="line"><span class="keyword">const</span> result = html.match(reg1)</span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// ["&lt;div class="test"&gt;", "", "div", " class="test"", index: 0, input: "&lt;div class="test"&gt;&lt;b&gt;hello&lt;/b&gt; &lt;i&gt;world!&lt;/i&gt;&lt;/div&gt;"]</span></span><br><span class="line"><span class="keyword">const</span> all = html.match(reg2)</span><br><span class="line"><span class="built_in">console</span>.log(all) <span class="comment">// ["&lt;div class="test"&gt;", "&lt;b&gt;", "&lt;/b&gt;", "&lt;i&gt;", "&lt;/i&gt;", "&lt;/div&gt;"]</span></span><br></pre></td></tr></table></figure><p>当局部匹配时只有一个实例被匹配，并返回匹配中的捕获结果。但当使用全局匹配时，返回的是匹配的全部内容列表。<br>若捕获结果重要，可以在全局匹配中使用正则的exec方法，可多次对一个正则调用exec方法，每次调用都可以返回下一个匹配的结果，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> html = <span class="string">`&lt;div class="test"&gt;&lt;b&gt;hello&lt;/b&gt; &lt;i&gt;world!&lt;/i&gt;&lt;/div&gt;`</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/&lt;(\/?)(\w+)([^&gt;]*?)&gt;/g</span></span><br><span class="line"><span class="keyword">let</span> match, num = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (match = reg.exec(html) !== <span class="literal">null</span>) &#123;</span><br><span class="line">  num++</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="捕获的引用"><a href="#捕获的引用" class="headerlink" title="捕获的引用"></a>捕获的引用</h3><p>对捕获结果进行引用有两种方式：</p><ol><li>在自身匹配</li><li>字符串替换</li></ol><p>下示例为使用反向匹配html标记的内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> html = <span class="string">`&lt;b class="hello"&gt;hello&lt;/b&gt; &lt;i&gt;world!&lt;/i&gt;`</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/&lt;(\w+)([^&gt;]*)&gt;(.*?)&lt;\/\1&gt;/g</span> <span class="comment">//使用反向引用</span></span><br><span class="line"><span class="keyword">let</span> match = reg.exec(html)</span><br><span class="line"><span class="built_in">console</span>.log(match) <span class="comment">// ["&lt;b class="hello"&gt;hello&lt;/b&gt;", "b", " class="hello"", "hello"]</span></span><br><span class="line">match = reg.exec(html)</span><br><span class="line"><span class="built_in">console</span>.log(match) <span class="comment">// ["&lt;i&gt;world!&lt;/i&gt;", "i", "", "world!"]</span></span><br></pre></td></tr></table></figure><p>使用 \1 指向表达式中的第一个捕获，在本例中捕获的是标记的名称。使用第一个捕获的内容匹配对应的结束标记。<br>此外，可以调用字符串的replace方法，对替换字符串内获取捕获。不使用反向引用，可以用$1、$2、$3等标记捕获序号，如下：</p><pre><code>&apos;fontFamily&apos;.replace(/([A-Z])/g, &apos;-$1&apos;).toLowerCase()</code></pre><p>上述代码中，第一个捕获值 F 通过替代字符$1进行引用，从而替换。由于捕获和分组都可以使用圆括号表示，对于正则处理器来说，无法区别所添加的是捕获还是分组。对于这种情况我们继续介绍</p><h3 id="未捕获的分组"><a href="#未捕获的分组" class="headerlink" title="未捕获的分组"></a>未捕获的分组</h3><p>圆括号有两项职责：</p><ol><li>定义分组</li><li>指定捕获</li></ol><p>对于存在大量分组的正则表达式来说，可能会产生太多不必要的捕获，这会导致处理捕获变得频繁</p><pre><code>const pattern = /((ninja-+))sword/</code></pre><p>创建正则时，允许前缀 ninja-单词在sword之前出现1次或多次，并捕获整个前缀。该正则使用了两个括号：</p><ol><li>定义捕获的圆括号，字符串sword之前的全部内容</li><li>定义ninja-和+操作符分组的操作符</li></ol><p>返回结果中不止一个捕获，因为含有用于分组的圆括号。说明有一组括号不应该产生捕获，正则表达式语法可以在起始圆括号之后使用符号 ?: ，这就是所谓的<code>被动子表达式</code>。</p><pre><code>const pattern = /((?:ninja-)+)sword/</code></pre><p>只有外层括号会创建捕获，内层括号会变成一个被动子表达式，我们来看以个具体的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reg1 = <span class="regexp">/((ninja-+))sword/</span></span><br><span class="line"><span class="keyword">const</span> reg2 = <span class="regexp">/((?:ninja-+))sword/</span></span><br><span class="line"><span class="keyword">const</span> ninjas1 = <span class="string">'ninja-ninja-sword'</span>.match(reg1) <span class="comment">// ["ninja-sword", "ninja-", "ninja-"]</span></span><br><span class="line"><span class="keyword">const</span> ninjas2 = <span class="string">'ninja-ninja-sword'</span>.match(reg2) <span class="comment">// ["ninja-sword", "ninja-"]</span></span><br></pre></td></tr></table></figure><p>在不需要捕获情况下，尽量使用非捕获分组代替捕获，表达式引擎不需要记忆和返回捕获结果，这利于提高性能。</p><h3 id="利用函数进行替换"><a href="#利用函数进行替换" class="headerlink" title="利用函数进行替换"></a>利用函数进行替换</h3><p>replace最重要的特征不仅支持替换值，而且支持替换函数作用参数：</p><ul><li>全文匹配</li><li>匹配时的捕获</li><li>在原始字符串匹配的索引</li><li>源字符串</li><li>从函数返回的值作为替换值</li></ul><p>下面来看示例，将短横线连接的字符串转换为驼峰式字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upper</span>(<span class="params">all, letter</span>) </span>&#123;<span class="keyword">return</span> letter.toUpperCase()&#125; <span class="comment">// 转换为大写的函数</span></span><br><span class="line"><span class="string">'border-bottom-width'</span>.replace(<span class="regexp">/-(\w)/g</span>, upper) <span class="comment">// borderBottomWidth</span></span><br></pre></td></tr></table></figure><p>由于全局匹配，对每一个匹配的字符串都会执行替换函数。我们再来看一个实例加深印象</p><p>假设需要将查询字符串换为符合我们所需格式的字符串，需将 foo=1&amp;foo=2&amp;blah=a&amp;blah=b&amp;foo=3转换为 foo=1,2,3&amp;blah=a,b</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compress</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> keys = &#123;&#125;</span><br><span class="line">  source.replace(</span><br><span class="line">    /([^=&amp;]+)=([^&amp;]*)/g,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">full, key, value</span>) </span>&#123; <span class="comment">// 提取键值对信息</span></span><br><span class="line">      keys[key] = (keys[key] ? keys[key] + <span class="string">','</span> : <span class="string">''</span>) + value</span><br><span class="line">      <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> keys) &#123;</span><br><span class="line">    <span class="keyword">if</span> (keys.hasOwnProperty(key)) &#123;</span><br><span class="line">      result.push(key + <span class="string">'='</span> + keys[key])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.join(<span class="string">'&amp;'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="几个实例"><a href="#几个实例" class="headerlink" title="几个实例"></a>几个实例</h3><p>匹配所有字符，包括换行符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> html = <span class="string">'&lt;b class="hello"&gt;hello&lt;/b&gt; \n&lt;i&gt;world!&lt;/i&gt;'</span></span><br><span class="line"><span class="comment">// 不匹配换行</span></span><br><span class="line">/.*<span class="regexp">/.exec(html) /</span><span class="regexp">/ ["&lt;b class="hello"&gt;hello&lt;/b&gt;"]</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 使用空白符匹配所有字符</span></span><br><span class="line"><span class="regexp">/</span>[\S\s]*<span class="regexp">/.exec(html) /</span><span class="regexp">/["&lt;b class="hello"&gt;hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;"]</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 第二种匹配所有字符的方法</span></span><br><span class="line"><span class="regexp">/</span>(?:.|\s)*<span class="regexp">/.exec(html)</span></span><br></pre></td></tr></table></figure><p>在css选择器中匹配转义字符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该正则允许任意字符序列组成的单词，包括一个反斜线紧跟任意字符</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/^((\w+)|(\\.))+$/</span></span><br><span class="line"><span class="keyword">const</span> tests = [</span><br><span class="line">  <span class="string">'formUpdate'</span>,</span><br><span class="line">  <span class="string">'form\\.update\\.whatever'</span>,</span><br><span class="line">  <span class="string">'form\\:update'</span>,</span><br><span class="line">  <span class="string">'\\f\\o\\r\\m\\u\\p\\d\\a\\t\\e'</span>,</span><br><span class="line">  <span class="string">'form:update'</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tests.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reg.test(tests[i]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>创建正则可以使用正则字面量 /test/ 或正则构造函数 new RegExp(‘test’)。对于在开发环境明确的推荐使用正则字面量，在运行时则推荐使用构造函数</li><li>使用section指定一组待匹配的字符</li><li>理解掌握5种模式gimyu，各种术语和操作符：匹配字符集[] 转义\ 起止^ 结束$ 重复 预定义字符等</li><li>使用圆括号对多个术语进行分组，使用竖线 | 表示或</li><li>通过反斜线加数字 \1 \2 可以对匹配的字符串进行反向引用</li><li>字符串的正则方法，match test replace</li></ul>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【Mock】搭建部署自己的easy-mock服务</title>
      <link href="/2018/02/04/%E3%80%90Mock%E3%80%91%E6%90%AD%E5%BB%BA%E9%83%A8%E7%BD%B2%E8%87%AA%E5%B7%B1%E7%9A%84easy-mock%E6%9C%8D%E5%8A%A1/"/>
      <url>/2018/02/04/%E3%80%90Mock%E3%80%91%E6%90%AD%E5%BB%BA%E9%83%A8%E7%BD%B2%E8%87%AA%E5%B7%B1%E7%9A%84easy-mock%E6%9C%8D%E5%8A%A1/</url>
      <content type="html"><![CDATA[<blockquote><p>Easy Mock 是一个可视化，并且能快速生成 模拟数据 的持久化服务。 真是超级好用啊，顺便还学习了mock.js语法，对于mock数据友好高效，在官网用了很久发现人数越来越多，偶尔会出现卡顿，遂决定搭建自己的easy-mock服务</p></blockquote><p>更多参考<a href="https://www.easy-mock.com/" target="_blank" rel="noopener">官方文档</a></p><a id="more"></a><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>支持接口代理</li><li>支持快捷键操作</li><li>支持协同编辑</li><li>支持团队项目</li><li>支持 RESTful</li><li>支持 Swagger | OpenAPI Specification (1.2 &amp; 2.0 &amp; 3.0)</li><li>基于 Swagger 快速创建项目</li><li>支持显示接口入参与返回值</li><li>支持显示实体类</li><li>支持灵活性与扩展性更高的响应式数据开发</li><li>支持自定义响应配置（例：status/headers/cookies）</li><li>支持 Mock.js 语法</li><li>支持 restc 方式的接口预览</li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>准备一台服务器和域名，做好相关备案工作。这些就省略了，接下来安装</p><pre><code>$ git clone https://github.com/easy-mock/easy-mock.git$ cd easy-mock$ export NODE_ENV=production # 很重要$ npm install$ npm run build</code></pre><p>接下来找到 config/default.json，或者创建一个 config/local.json 文件，将如下需要替换的字段换成自己的配置即可。</p><p>这里有踩坑，如果要以production方式成功部署，需要将 default.json 拷贝一份，命名为 <code>production.json</code>,</p><p>先说下，大部分保持默认配置就好，具体的可根据实际服务器情况做相应修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"port"</span>: <span class="number">7300</span>, <span class="comment">// 默认是7300端口，根据实际情况修改</span></span><br><span class="line">  <span class="string">"host"</span>: <span class="string">"0.0.0.0"</span>, <span class="comment">// 我改成了localhost 应该没影响</span></span><br><span class="line">  <span class="string">"pageSize"</span>: <span class="number">30</span>, <span class="comment">// 一页显示多少条接口列表， 可改成 20</span></span><br><span class="line">  <span class="string">"proxy"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">"db"</span>: <span class="string">"mongodb://localhost/easy-mock"</span>, <span class="comment">// 添加下mongodb的端口</span></span><br><span class="line">  <span class="string">"unsplashClientId"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"redis"</span>: &#123;</span><br><span class="line">    <span class="string">"port"</span>: <span class="number">6379</span>,</span><br><span class="line">    <span class="string">"host"</span>: <span class="string">"localhost"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"blackList"</span>: &#123;</span><br><span class="line">    <span class="string">"projects"</span>: [], <span class="comment">// projectId，例："5a4495e16ef711102113e500"</span></span><br><span class="line">    <span class="string">"ips"</span>: [] <span class="comment">// ip，例："127.0.0.1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"rateLimit"</span>: &#123; <span class="comment">// https://github.com/koajs/ratelimit</span></span><br><span class="line">    <span class="string">"max"</span>: <span class="number">1000</span>,</span><br><span class="line">    <span class="string">"duration"</span>: <span class="number">1000</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"jwt"</span>: &#123;</span><br><span class="line">    <span class="string">"expire"</span>: <span class="string">"14 days"</span>,</span><br><span class="line">    <span class="string">"secret"</span>: <span class="string">"shared-secret"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"upload"</span>: &#123;</span><br><span class="line">    <span class="string">"types"</span>: [<span class="string">".jpg"</span>, <span class="string">".jpeg"</span>, <span class="string">".png"</span>, <span class="string">".gif"</span>, <span class="string">".json"</span>, <span class="string">".yml"</span>, <span class="string">".yaml"</span>],</span><br><span class="line">    <span class="string">"size"</span>: <span class="number">5242880</span>,</span><br><span class="line">    <span class="string">"dir"</span>: <span class="string">"../public/upload"</span>,</span><br><span class="line">    <span class="string">"expire"</span>: &#123;</span><br><span class="line">      <span class="string">"types"</span>: [<span class="string">".json"</span>, <span class="string">".yml"</span>, <span class="string">".yaml"</span>],</span><br><span class="line">      <span class="string">"day"</span>: <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"fe"</span>: &#123;</span><br><span class="line">    <span class="string">"copyright"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="string">"storageNamespace"</span>: <span class="string">"easy-mock_"</span>,</span><br><span class="line">    <span class="string">"timeout"</span>: <span class="number">25000</span>,</span><br><span class="line">    <span class="string">"publicPath"</span>: <span class="string">"/dist/"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mongodb配置"><a href="#mongodb配置" class="headerlink" title="mongodb配置"></a>mongodb配置</h3><p>既然提到了mongoDB和redis这里做个备份，一起记录下吧。</p><p>网上下载好最新的 mongoDB 和 redis传到 服务器，我放到了 /usr/local/mongodb  /usr/local/redis</p><p>启动mongo 只需进去 mongodb/bin 中 ～ 可以写个 mongodb.conf 也可以直接带上参数命令行的形式执行</p><p>我们先将mongodb添加到环境变量中，这里就可以直接输命令行启动了：</p><pre><code>cd ~export PATH=${PATH}:/usr/local/mongodb/bin</code></pre><p>如果不能运行可以 写到 根目录到 .bash_profile下 source ./bash_profile后 在尝试</p><p>然后启动 mongodb</p><h3 id="redis安装"><a href="#redis安装" class="headerlink" title="redis安装"></a>redis安装</h3><p>将下载好的文件解压</p><pre><code>tar zxvf redis.tar.gz</code></pre><p>然后进入我们解压好的redis文件夹中， make一下 然后进入src后再 <code>make install</code>进行redis的安装</p><p>安装完后，和上面mongodb差不多，需要进行后端启动，这样不用每次启动服务器后再启动redis</p><p>a)创建bin和redis.conf文件</p><p>复制代码代码如下:</p><pre><code>mkdir -p/usr/local/redis/binmkdir -p/usr/local/redis/ect</code></pre><p>b)执行Linux文件移动命令：</p><p>复制代码代码如下:</p><pre><code>mv /lamp/redis-3.0.7/redis.conf /usr/local/redis/etccd /lamp/redis-3.0.7/srcmv mkreleasdhdr.sh redis-benchmark redis-check-aof redis-check-dump redis-cli redis-server /usr/local/redis/bin</code></pre><p>这里执行 ./redis-serve 就可以启动redis了，不过我们换成后台启动的方式</p><p>c)首先编辑conf文件，将daemonize属性改为yes（表明需要在后台运行）</p><pre><code>cd etc/Vi redis.conf</code></pre><p>d)再次启动redis服务，并指定启动服务配置文件</p><pre><code>redis-server /usr/local/redis/etc/redis.conf</code></pre><p>更多参考 <a href="https://www.cnblogs.com/rainowl-ymj/p/7403638.html" target="_blank" rel="noopener">https://www.cnblogs.com/rainowl-ymj/p/7403638.html</a></p><hr><p>于是继续我们的easy-mock部署</p><p>接上面，easy-mock需要以 production的方式安装和run build，这里也是群里大佬告诉我的，这样的上产环境部署才不会出现各种bug。</p><p>服务，数据库各种没问题后，自己配置nginx吧，由于有隐私内容这里就省略了</p><p>回到 easy-mock根目录下</p><pre><code>NODE_ENV=production pm2 start app.js --name=easy-mockpm2 list</code></pre><p>看看我们的easy-mock服务有没有启动好吧～～</p><hr><p>等项目完工了，回头再添加一点自己对mock.js 和 自行mock 请求的一些笔记和理解吧</p>]]></content>
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mock </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【React】进阶React的重要知识点</title>
      <link href="/2017/12/28/%E3%80%90React%E3%80%91%E8%BF%9B%E9%98%B6React%E7%9A%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2017/12/28/%E3%80%90React%E3%80%91%E8%BF%9B%E9%98%B6React%E7%9A%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<blockquote><p>这里只是React的相关知识点整理，也算是老生常谈了吧，通过这样的整理让自己温故知新。说是进阶，其实也算是基础的重要知识点。好了，于是我们一起来看看吧：</p></blockquote><ul><li>组件<ul><li>组件与state</li><li>几种组件通信</li><li>ref</li></ul></li><li>虚拟DOM相关</li><li>性能优化</li><li>高阶组件</li></ul><a id="more"></a><h2 id="组件间的通信"><a href="#组件间的通信" class="headerlink" title="组件间的通信"></a>组件间的通信</h2><p>React里的组件通信方式大致有以下几种情况：</p><h3 id="父子组件的通信通过props"><a href="#父子组件的通信通过props" class="headerlink" title="父子组件的通信通过props"></a>父子组件的通信通过props</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserList.jsx</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ul className=<span class="string">"user-list"</span>&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.props.users.map(<span class="function"><span class="params">user</span> =&gt;</span> (</span><br><span class="line">            &lt;li key=&#123;user.id&#125;&gt;</span><br><span class="line">              &lt;span&gt;&#123;user.name&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>li&gt;</span><br><span class="line">          ))&#125;</span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserListContainer.jsx</span></span><br><span class="line"><span class="keyword">import</span> UserList <span class="keyword">from</span> <span class="string">'./UserList'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserListContainer</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      users: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &#123;<span class="comment">/* 通过props传递users */</span>&#125;</span><br><span class="line">      &lt;UserList users=&#123;<span class="keyword">this</span>.state.users&#125; /&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    fetch(<span class="string">'/path/api'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      res.json().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          users: data</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子向父组件通信"><a href="#子向父组件通信" class="headerlink" title="子向父组件通信"></a>子向父组件通信</h3><p>父组件可以通过子组件的props传递给子组件一个回调函数，子组件在需要改变父组件数据时，调用该回调即可。下面为UserList增加一个添加新用户功能：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      newUser: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  handleChange = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      newUser: e.target.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.newUser &amp;&amp; <span class="keyword">this</span>.state.newUser.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.props.onAddUser(<span class="keyword">this</span>.state.newUser)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ul className=<span class="string">"user-list"</span>&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.props.users.map(<span class="function"><span class="params">user</span> =&gt;</span> (</span><br><span class="line">            &lt;li key=&#123;user.id&#125;&gt;</span><br><span class="line">              &lt;span&gt;&#123;user.name&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>li&gt;</span><br><span class="line">          ))&#125;</span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.newUser&#125; /</span>&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;add uesr&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h3><p>兄弟组件不能直接相互传送数据，需要通过状态提升的方式实现兄弟组件的通信：即把组件之间需要共享的state保存到距离它们最近的共同父组件内，任意一个兄弟组件都可以通过父组件传递的回调修改共享状态。</p><p>组件从服务器上获取数据，不包含组件向服务器提交数据的情况。</p><h3 id="组件挂载阶段通信"><a href="#组件挂载阶段通信" class="headerlink" title="组件挂载阶段通信"></a>组件挂载阶段通信</h3><p>React组件的正常运转本质上是组件不同生命周期方法的有序执行，因此组件与服务器的通信也必定依赖组件的声明周期方法。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">UserListContainer</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 省略无关代码</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;UserListContainer&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    fetch(<span class="string">'/path/api'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      res.json().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          users: data</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>componentDidMount是官方推荐的通信周期，当然componentWillMount也是可以的。</p><ol><li><p>componentDidMount中执行服务器通信可以保证获取数据时，组件已经处于挂载状态，即便操作DOM也是安全的，而componentWillMount无法保证</p></li><li><p>当组件在服务端渲染时，componentWillMount会被调用两次，一次是服务端，一次是浏览器端，而componentDidMount能保证在任何情况下只调用一次，从而不会发送多余的请求</p></li></ol><h3 id="组件更新阶段通信"><a href="#组件更新阶段通信" class="headerlink" title="组件更新阶段通信"></a>组件更新阶段通信</h3><p>componentWillReceiveProps非常适合做更新阶段的服务器通信。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserListContainer</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 省略</span></span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextProps.category !== <span class="keyword">this</span>.props.category) &#123;</span><br><span class="line">      fetch(<span class="string">`/path/api?category=<span class="subst">$&#123;nextProps.category&#125;</span>`</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        res.json().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            users: data</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需注意：在执行fetch请求时，要先对新老props中的category作比较，有不一致才进行更新。componentWillReceiveProps并不能保证props一定发生了修改</p><h2 id="深入理解组件"><a href="#深入理解组件" class="headerlink" title="深入理解组件"></a>深入理解组件</h2><p>state所代表的一个组件UI呈现的完整状态又可以分成两类数据：用作渲染组件时使用到的数据的来源以及用作组件UI展现形式的判断依据。</p><hr><h3 id="如何定义state"><a href="#如何定义state" class="headerlink" title="如何定义state"></a>如何定义state</h3><p>在组件中需要用到一个变量，且与组件的渲染无关时，就应该把这个变量定义为组件的普通属性，直接挂载到this下，而不是作为组件的state。还有就是看render方法有无用到该变量，没有就同样挂载到this下</p><p>state和props都直接和组件的UI渲染有关，它们的变化会触发组件的重新渲染，但props对于使用它的组件来说是只读的，是通过父组件传递过来的，想要修改props，只能在父组件中修改，而state是组件内部自己维护的状态，是可变的</p><p>总结一下，组件中用到一个变量是不是应该作为state可通过下面4条依据进行判断：</p><ol><li>该变量是否通过props从父组件中获取？若是，则不是state</li><li>该变量是否在组件的整个生命周期中保持不变？若是，则不是state</li><li>该变量是否可通过其他state或props计算得到？若是，则不是state</li><li>该变量是否在render方法中使用？若是，则为state，反之则不是，该情况下，变量更适合定义为组件的一个普通属性</li></ol><hr><ul><li>不能直接修改state，需要用setState</li><li>state的更新是异步的</li></ul><p>调用setState时，组件的state不会立即改变，setState只是把要修改的状态放入一个队列中，React会优化真正的执行时机，出于性能考虑，可能会将多次setState状态修改合并成一次状态修改。所以不要依赖当前state去计算下一个state。当真正执行修改时，依赖的this.state并不能保证是最新的state。同样不能依赖当前props计算下一状态，因为props的更新也是异步的。</p><hr><h3 id="state-与不可变对象"><a href="#state-与不可变对象" class="headerlink" title="state 与不可变对象"></a>state 与不可变对象</h3><ol><li>state类型是不可变类型（数字、字符串、布尔值、null、undefined）</li></ol><p>因state是不可变类型，所以直接给要修改的状态赋一个新值即可</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  count: <span class="number">1</span>,</span><br><span class="line">  title: <span class="string">'React'</span>,</span><br><span class="line">  success: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>state类型是数组</li></ol><p>法一：使用preState、concat创建新数组</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</span><br><span class="line">  books: preState.books.concat([<span class="string">'React Guide'</span>])</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>法二：ES6 spread syntax</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</span><br><span class="line">  books: [...preState.books, <span class="string">'React Guide'</span>]</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>当从books中截取部分元素作为新状态时，可使用数组的slice方法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</span><br><span class="line">  books: preState.books.slice(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>当从books中过滤部分元素后作为新状态，可使用数组的filter方法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</span><br><span class="line">  books: preState.books.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item !== <span class="string">'React'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>注意，不要使用push、pop、shift、unshift、splice等方法修改数组类型的状态，因为这些方法都是在原数组的基础上修改的，而concat、slice、filter会返回一个新的数组</p><h3 id="state的类型是普通对象-不包含字符串、数组"><a href="#state的类型是普通对象-不包含字符串、数组" class="headerlink" title="state的类型是普通对象(不包含字符串、数组)"></a>state的类型是普通对象(不包含字符串、数组)</h3><ol><li>使用ES6的Object.assign</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</span><br><span class="line">  owner: <span class="built_in">Object</span>.assign(&#123;&#125;, preState.owner, &#123;<span class="attr">name</span>: <span class="string">'Jason'</span>&#125;)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><ol><li>使用对象扩展语法 Object spread properties</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</span><br><span class="line">  owner: &#123;...preState.owner, <span class="attr">name</span>: <span class="string">'Jason'</span>&#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>总结下，创建新的state的关键是，避免使用会直接修改原对象的方法，而是使用可以返回一个新对象的方法。当然也可以使用一些Immutable的JS库来实现</p><p><code>React状态为什么要是不可变对象呢？</code> 一方面是因为不可变对象的修改会返回一个新对象，不用担心原有对象在不小心情况下被修改导致的错误，方便程序管理与调试。另一方面是出于性能考虑，当对象组件状态都是不可变对象时，在组件的shouldComponentUpdate方法中仅需要比较前后两次状态引用就可以判断状态是否真的改变，从而避免不必要的render调用。</p><p>React之所以执行效率高，其重要原因是虚拟DOM机制。React应用常用的性能优化也与虚拟DOM机制有关。</p><h2 id="虚拟DOM相关"><a href="#虚拟DOM相关" class="headerlink" title="虚拟DOM相关"></a>虚拟DOM相关</h2><p>在Web环境中，DOM也就是对HTML文本的一种抽象描述。在传统开发中，通过调用浏览器提供API对DOM执行增删查改操作。这些操作看似只执行了一条JS语法，但其效率要慢得多。因为对DOM的修改会引起页面的重布局和重渲染，这过程很耗时，这也是前端性能优化的一条原则，尽量减少DOM操作。</p><p>虚拟DOM是一层抽象（对真实DOM），建立在真实的DOM上。（虚拟DOM是一项独立的技术）</p><pre><code>&lt;div class=&quot;foo&quot;&gt;  &lt;h1&gt;Hello React&lt;/h1&gt;&lt;/div&gt;</code></pre><p>可以用JS对象来描述</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: <span class="string">'div'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: <span class="string">'foo'</span>,</span><br><span class="line">    children: &#123;</span><br><span class="line">      type: <span class="string">'h1'</span>,</span><br><span class="line">      props: &#123;</span><br><span class="line">        children: <span class="string">'Hello React'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了虚拟DOM这一层，当我们需要操作DOM时，就可以操作虚拟DOM而不是操作真实DOM。</p><h3 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h3><p>React采用声明式地API描述UI结构，每次组件的状态或属性更新，组件的render方法都会返回一个新的虚拟DOM对象，用来表述新的UI结构。如果每次render都直接使用新的虚拟DOM来生成真实DOM结构，那么会带来大量对真实DOM的操作，影响执行效率。</p><p>事实上，React通过比较两次虚拟DOM的变化找出差异部分，更新到真实DOM上，从而减少最终要在真实DOM上执行的操作，提高程序执行效率。这一过程就是React的调和过程Reconcliliation，其中的关键就是比较两个树型结构的diff算法。</p><blockquote><p>在diff算法中，比较的两方是新的虚拟DOM和旧的虚拟DOM，而表示虚拟DOM和真实DOM，只不过Diff的结果会更新到真实的DOM上。</p></blockquote><p>正常情况下，比较两个树形结构差异的算法时间复杂度是O(N^3)。React通过总结DOM的实际使用场景提出了两个在绝大多数实践场景下都成立的假设，基于这两个假设，React实现了O(N)时间复杂度内完整两棵虚拟DOM树的比较：</p><ol><li>如果两个元素的类型不同，那么它们将生成两棵不同的树</li><li>为列表中的元素设置key，用key标识对应的元素在多次render过程中是否发生变化</li></ol><h3 id="当根节点是不同类型时"><a href="#当根节点是不同类型时" class="headerlink" title="当根节点是不同类型时"></a>当根节点是不同类型时</h3><p>从div变成p，ComponentA变成ComponentB，或者从ComponentA变成div这些都是节点类型发生变化的情况。</p><p>根节点类型变化，React会认为新的树和旧的树完全不同，不会再继续比较其他属性和子节点，而是把整棵树拆掉重建（包括虚拟DOM树和真实DOM树）。需要注意的是，虚拟DOM节点类型分为两类：一类是DOM元素类型，一类是React组件类型。</p><p>在旧的虚拟DOM树被拆除过程中，旧的DOM元素类型的节点会被销毁，旧的React组件的实例componentWillUnmount会被调用，在重建过程中，新的DOM元素会被插入到DOM树中，新的组件实例的componentWillMount和componentDidMount方法会被调用。重建后的新的虚拟DOM树会被整体更新到真实DOM树中，这种情况需要大量DOM操作，更新效率最低。</p><h3 id="当根节点是相同的DOM元素类型时"><a href="#当根节点是相同的DOM元素类型时" class="headerlink" title="当根节点是相同的DOM元素类型时"></a>当根节点是相同的DOM元素类型时</h3><p>React会保留根节点，而比较根节点的属性，然后只更新那些变化了的属性。</p><h3 id="当根节点是相同的组件类型时"><a href="#当根节点是相同的组件类型时" class="headerlink" title="当根节点是相同的组件类型时"></a>当根节点是相同的组件类型时</h3><p>对应的组件实例不会被销毁，只是会执行更新操作，同步变化的属性到虚拟DOM树上，这一过程组件实例的componentWillReceiveProps和componentWillUpdate会被调用。注意，对于组件类型的节点，React是无法直接知道如何更新真实DOM树的，需要在组件更新并且render方法执行完成后，根据render返回的虚拟DOM结构决定如何更新真实DOM树。</p><p>比较完根节点后，React会以同样的原则继续递归比较子节点，每一个子节点相对于其层级以下的节点来说又是一个根节点。如此递归比较，直到比较完两棵树上的所有节点，计算得到最终差异，更新到DOM树中。</p><h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><p>高阶组件是React中一个重要而复杂的概念。主要用来实现组件逻辑的抽象和复用，在很多第三方库被使用到。合理使用高阶组件也能显著提高代码质量。</p><p><strong>基本概念</strong> 高阶函数是函数作为参数，并且返回值也是函数的函数。类似地，高阶组件简称（HOC）接受React组件作为参数，并且返回一个新的React组件。高阶组件本质上也是一个函数，并不是一个组件，高阶组件的函数形式如下：</p><pre><code>const EnhancedComponent = higherOrderComponent(WrappedComponent)</code></pre><p>从例子来看。MyComponent组件需要从LocalStorage中读取数据然后渲染到界面，一般来说：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;&#123;<span class="keyword">this</span>.state.data&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  componentWillMount() &#123;</span></span><br><span class="line"><span class="regexp">    let data = localStorage.getItem('data')</span></span><br><span class="line"><span class="regexp">    this.setState(&#123; data &#125;)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>但当其他组件也需要从LocalStorage中获取同样的数据展示时，每个组件都需要重写一次componentWillMount中的代码，这是很冗余的。于是用高阶组件来改写这部分：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withPersistentData</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentWillMount() &#123;</span><br><span class="line">      <span class="keyword">let</span> data = localStorage.getItem(<span class="string">'data'</span>)</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; data &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="comment">// 通过 &#123;...this.props&#125;把传递给当前组件的属性传递给被包装的组件</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">data</span>=<span class="string">&#123;this.state.data&#125;</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">class MyComponent extends Component &#123;</span></span><br><span class="line"><span class="xml">  render() &#123;</span></span><br><span class="line"><span class="xml">    return <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">const MyComponentWithPersistenData = withPersistentData(MyComponent)</span></span><br></pre></td></tr></table></figure><p>withPersistenData就是一个高阶组件，它返回一个新的组件，在新组件的componentWillMount中统一处理从localStorage中获取数据的逻辑，然后将获取到的数据通过props传递给被包装的租金啊WrappedComponent。这样在WrappedComponent中就可以直接使用this.props.data获取需要展示的数据。</p><p>高阶组件的主要功能是封装被分离组件的通用逻辑，让通用逻辑在组件间更好地被复用。高阶组件的这种实现方式的本质其实就是装饰者设计模式。</p><hr><p><strong>使用场景</strong></p><ol><li>操作props</li><li>通过ref访问组件实例</li><li>组件状态提升</li><li>从其他元素包装组件</li></ol><h3 id="操作props"><a href="#操作props" class="headerlink" title="操作props"></a>操作props</h3><p>在被包装组件接受props前，高阶组件可以先拦截props，对props执行增、删、改等操作，然后将处理后的props再传递给被包装组件。</p><h3 id="通过ref访问组件实例"><a href="#通过ref访问组件实例" class="headerlink" title="通过ref访问组件实例"></a>通过ref访问组件实例</h3><p>高阶组件通过ref获取被包装组件实例的引用，然后高阶组件就具备了直接操作被包装组件的属性或方法的能力。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withRef</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    someMehod = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.wrappedInstance = <span class="keyword">this</span>.someMethodInWrappedComponent()</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="comment">// 为被包装组件添加ref ， 从而获取该组件实例并赋值给this.wrappedInstance</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">ref</span>=<span class="string">&#123;instance</span> =&gt;</span> this.wrappedInstance = instance&#125; &#123;...this.props&#125; /&gt;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>当WrappedComponent被渲染时，执行ref的回调函数，高阶组件通过this.wrappedInstance保存WrappedComponent实例的引用，在someMethod方法中，通过this.wrappedInstance调用WrappedComponent实例中的方法。</p><h3 id="组件状态提升"><a href="#组件状态提升" class="headerlink" title="组件状态提升"></a>组件状态提升</h3><p>无状态组件更容易被复用。高阶组件可以通过将被包装组件的状态及相应的状态处理方法提升到高阶组件自身内部实现被包装组件的无状态化。一个典型场景是，利用高阶组件将原本受控组件需要自己维护的状态统一提升到高阶组件中：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withControlledState</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">      <span class="keyword">super</span>()</span><br><span class="line">      <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        value: <span class="string">''</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleValueChange = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        value: e.target.value</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="comment">// newProps保存受控组件需要使用的属性和事件处理函数</span></span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        controlledProps: &#123;</span><br><span class="line">          value: <span class="keyword">this</span>.state.value,</span><br><span class="line">          onChange: <span class="keyword">this</span>.handleValueChange</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...newProps</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>这个例子把受控组件的value属性用到的状态和处理value变化的回调都提升到了高阶组件中，当我们再使用受控组件时，可以这么使用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleControlledComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 此时的SimpleControlledComponent 为无状态组件，状态由高阶组件维护</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">nmae</span>=<span class="string">"simple"</span> &#123;<span class="attr">...this.props.controlledProps</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">const ComponentWithControlledState = withControlledState(SimpleControlledComponent)</span></span><br></pre></td></tr></table></figure><h3 id="用其他元素包装组件"><a href="#用其他元素包装组件" class="headerlink" title="用其他元素包装组件"></a>用其他元素包装组件</h3><p>我们还可以在高阶组件渲染 WrappedComponent时添加额外的元素，这种情况通常用于为 WrappedCompoent增加布局或修改样式</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withRedBackground</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div style=&#123;&#123;<span class="attr">backgroundColor</span>: <span class="string">'red'</span>&#125;&#125;&gt;</span><br><span class="line">          &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>高阶组件的参数并非只是一个组件，它还可以接受其他参数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withPersistentData</span>(<span class="params">WrappedComponent, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentWillMount() &#123;</span><br><span class="line">      <span class="keyword">let</span> data = localStorage.getItem(key)</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        [<span class="string">`local/<span class="subst">$&#123;key&#125;</span>`</span>]: data</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="comment">// 通过&#123;...this.props&#125;把传递给当前组件的属性继续传递给被包装的组件</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">data</span>=<span class="string">&#123;this.state.data&#125;</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><hr><p><code>HOC(...params)</code>返回值是一个高阶组件，高阶组件需要的参数是先传递给HOC函数的。用这种形式改写withPersistentData如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> withPersistentData = <span class="function"><span class="params">key</span> =&gt;</span> WrappedCompnent =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentWillMount() &#123;</span><br><span class="line">      <span class="keyword">let</span> data = localStorage.getItem(key)</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; data &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="comment">// 通过 &#123;...this.props&#125; 把传递给当前组件的属性继续传递给被包装的组件</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">data</span>=<span class="string">&#123;this.state.data&#125;</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">class MyComponent extends Component &#123;</span></span><br><span class="line"><span class="xml">  render() &#123;</span></span><br><span class="line"><span class="xml">    return <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">// 获取key='data'的数据</span></span><br><span class="line"><span class="xml">const MyComponentPersistentData = withPersistentData('data')(MyCompoent)</span></span><br></pre></td></tr></table></figure><p>实际上，这种形式的高阶组件大量出现在第三方库中，如react-redux的connect函数就是一个典型的例子。connect的简化定义如下：</p><pre><code>connect(mapStateToProps, mapDispatchToProps)(WrappedComponent)</code></pre><p>这个函数会将一个React组件连接到Redux的store上，在连接的过程中，connect通过函数参数mapStateToProps从全局store中取出当前组件需要的state，并把state转化成当前组件的props，传递给当前组件。 connect并不会修改传递进去的组件的定义，而是会返回一个新的组件。</p><blockquote><p>connect的参数mapStateToProps、mapDispatchToProps是函数类型，说明高阶组件的参数也可以是函数类型。</p></blockquote><pre><code>const connectedComponentA = connect(mapStateToProps, mapDispatchToProps)(ComponentA)</code></pre><p>我们可以把它拆分来看</p><pre><code>// connect是一个函数，返回值 enhance也是一个函数const enhance = connect(mapState, mapDispatch)// enhance是一个高阶组件const ConnectedComponentA = enhance(ComponentA)</code></pre><p>这种形式的高阶组件易组合使用。因为当多个函数的输出和它的输入类型相同时，这些函数易组合到一起。</p><pre><code>// connect的参数是可选参数，这里省略了mapDispatch参数const ConnectedComponentA = connect(mapStateToProps)(withLog(ComponentA))</code></pre><p>我们还可以定义一个工具函数 compose(…funcs)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...fns</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fns.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">  <span class="keyword">if</span> (fns.length === <span class="number">1</span>) <span class="keyword">return</span> fns[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">return</span> fns.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> (...args) =&gt; acc(cur(args)))</span><br></pre></td></tr></table></figure><p>调用<code>compose(f, g, h)</code> 等价于 <code>(...args) =&gt; f(g(h(...args)))</code></p><p>用compose函数可以把高阶组件嵌套的写法打平：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> enhance = compose(</span><br><span class="line">  connect(mapState),</span><br><span class="line">  withLog()</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> ConnectedComponentA = enhance(ComponentA)</span><br></pre></td></tr></table></figure><p>像Redux等第三方库都提供了compose的实现，compose结合高阶组件使用可以显著提高代码的可读性和逻辑的清晰度</p><hr><h3 id="继承方式实现高阶组件"><a href="#继承方式实现高阶组件" class="headerlink" title="继承方式实现高阶组件"></a>继承方式实现高阶组件</h3><p>上面这类由高阶组件处理通用逻辑，然后再将相关属性传递给被包装组件，我们称这种实现方式为<code>属性代理</code>。</p><p>除此外，还可以通过继承方式实现高阶组件，通过继承被包装组件实现逻辑的复用。继承方式实现的高阶组件常用于渲染劫持。例如：当用户处于登录状态，允许组件渲染，否则渲染一个空组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withAuth</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.props.loggedIn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.render()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据WrappedComponent的<code>this.props.loggedIn</code>判断用户是否已经登录，若登录就通过super.render()调用WrappedComponent的render方法正常渲染，否则返回null。</p><p>继承方式实现的高阶组件对被包装组件具有侵入性，当组合多个高阶组件使用时，很容易因为子类组件忘记通过super调用父类组件方法而导致逻辑丢失。因此，在使用高阶组件时，应尽量通过代理方式实现高阶组件。</p><hr><p><strong>注意事项</strong></p><h3 id="1-为了在开发和调试阶段更好地区别包装了不同组件的高阶组件，需要对高阶组件的显示名称做自定义处理。"><a href="#1-为了在开发和调试阶段更好地区别包装了不同组件的高阶组件，需要对高阶组件的显示名称做自定义处理。" class="headerlink" title="1. 为了在开发和调试阶段更好地区别包装了不同组件的高阶组件，需要对高阶组件的显示名称做自定义处理。"></a>1. 为了在开发和调试阶段更好地区别包装了不同组件的高阶组件，需要对高阶组件的显示名称做自定义处理。</h3><p>常用的处理方式是，把被包装组件的显示名称也包到高阶组件的显示名称中：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withPersistentData</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结合被包装组件的名称，自定义高阶组件的名称</span></span><br><span class="line">    <span class="keyword">static</span> displayName = <span class="string">`HOC(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span>  <span class="comment">// 省略</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDisplayName</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> WrappedComponent.displayName || WrappedComponent.name || <span class="string">'Component'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-不要在组件的render方法中使用高阶组件，尽量也不要在组件的其他生命周期方法中使用高阶组件。"><a href="#2-不要在组件的render方法中使用高阶组件，尽量也不要在组件的其他生命周期方法中使用高阶组件。" class="headerlink" title="2. 不要在组件的render方法中使用高阶组件，尽量也不要在组件的其他生命周期方法中使用高阶组件。"></a>2. 不要在组件的render方法中使用高阶组件，尽量也不要在组件的其他生命周期方法中使用高阶组件。</h3><p>因为调用高阶组件，每次都会返回一个新的组件，于是每次render前一次高阶组件创建的组件都会被卸载unmount，然后重新挂载(mount)本次创建的新组件，影响效率又丢失子组件状态，如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="comment">// 每次render, enhance都会创建一个新租金啊，尽管被包装的组件没有变</span></span><br><span class="line">  <span class="keyword">const</span> EnhancedComponent = enhance(MyComponent)</span><br><span class="line">  <span class="comment">// 因为是新的组件，所以会经历旧组件的卸载和新组件的重新挂载</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">EnhancedComopnent</span> /&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>所以高阶组件最适合的地方是在组件定义的外部，这样就不会收到组件生命周期的影响。</p><h3 id="3-如果需要使用被包装组件的静态方法，那么必须手动复制这些静态方法。"><a href="#3-如果需要使用被包装组件的静态方法，那么必须手动复制这些静态方法。" class="headerlink" title="3. 如果需要使用被包装组件的静态方法，那么必须手动复制这些静态方法。"></a>3. 如果需要使用被包装组件的静态方法，那么必须手动复制这些静态方法。</h3><p>因为高阶组件返回的新组件不包含被包装组件的静态方法，如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WrappedComponent组件定义了一个静态方法staticMethod</span></span><br><span class="line">WrappedComponent.staticMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Enhance</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 手动复制静态方法到Enhance上</span></span><br><span class="line">  Enhance.staticMethod = WrappedComponent.staticMethod</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-refs不会被传递给被包装组件"><a href="#4-refs不会被传递给被包装组件" class="headerlink" title="4. refs不会被传递给被包装组件"></a>4. refs不会被传递给被包装组件</h3><p>尽管在定义高阶组件时，我们会把所有的属性都传递给被包装组件，但是ref并不会传递给被包装组件。如果在高阶组件的返回数组中定义了ref，那么它指向的是这个返回的新组件，而不是内部被包装的组件。如果希望获取被包装组件的引用，那么可以自定义一个属性，属性的值是一个函数，传递给被包装的ref。下面的例子就是用inputRef这个属性名替代常规的ref命名：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FocusInput</span>(<span class="params">&#123;inputRef, ...rest&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用高阶组件传递的inputRef作为ref的值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> &#123;<span class="attr">...rest</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">// enhance是一个高阶组件</span></span><br><span class="line"><span class="xml">const EnhanceInput = enhance(FocusInput)</span></span><br><span class="line"><span class="xml">// 在一个组件的render方法中，自定义属性inputRef代替ref</span></span><br><span class="line"><span class="xml">// 保证inputRef可以传递给被包装组件</span></span><br><span class="line"><span class="xml">return (</span></span><br><span class="line">  &lt;EnhanceInput</span><br><span class="line">    inputRef=&#123;input =&gt; this.input = input&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">)</span><br><span class="line">// 组件内 让FocusInput自动获取焦点</span><br><span class="line">this.input.focus()</span><br></pre></td></tr></table></figure><h3 id="5-与父组件的区别"><a href="#5-与父组件的区别" class="headerlink" title="5. 与父组件的区别"></a>5. 与父组件的区别</h3><p>高阶组件在一些方面与父组件类似。我们可以把高阶组件中的逻辑放到一个父组件中执行，执行完成的结果再传递给子组件，但是高阶组件强调的是逻辑的抽象。</p><p>高阶组件是一个函数，函数关注的是逻辑；父组件是一个组件，组件主要关注的是UI/DOM。如果逻辑是与DOM直接相关的，那么这部分逻辑适合放到父组件中实现；如果逻辑是与DOM不直接相关的，那么这部分逻辑使用用高阶组件抽象，如数据校验、请求发送等。</p><hr><p>高阶组件用于封装组件的通用逻辑，常用在操作组件props、通过ref访问组件实例、组件状态提升和用其他元素包装组件等场景中。</p><p>高阶组件可以接受被包装组件以外的其他参数，多个高阶组件还可以组合使用。高阶组件一般通过代理实现，少量场景中也会使用继承等方式实现。灵活地使用高阶组件可以显著提高代码质量和效率。</p>]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【React】从基础开始再来温习React，相关学习整理</title>
      <link href="/2017/12/20/%E3%80%90React%E3%80%91%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%BC%80%E5%A7%8B%E5%86%8D%E6%9D%A5%E6%B8%A9%E4%B9%A0React%EF%BC%8C%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/"/>
      <url>/2017/12/20/%E3%80%90React%E3%80%91%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%BC%80%E5%A7%8B%E5%86%8D%E6%9D%A5%E6%B8%A9%E4%B9%A0React%EF%BC%8C%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<blockquote><p>React虽然从14版就在学习使用了，- - 换公司之后一直在用Vue，以前用Redux，服务端渲染总是觉得很坑，虽然跟着前辈写似懂非懂的，业务逻辑也能做，但Redux那块始终用得不好。也算是曲线救国，Vue、Vuex的使用让我慢慢理解了React的核心和优美之处。正好现在新版发布了，再来重学一次吧</p></blockquote><a id="more"></a><h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><p>前端UI本质问题是： 如何将来源于服务器的动态数据和用户的交互行为高效地反映复杂的用户界面上。React通过引入虚拟DOM、状态、单向数据流等设计理念，形成以组件为核心，用组件搭建UI的开发模式，完美地将数据、组件状态和UI映射到一起，极大提高了开发大型Web应用的效率。</p><p>React的特点：</p><ol><li>声明式的视图层</li></ol><p>使用React不用担心数据、状态和视图交错。</p><ol><li>简单的更新流程</li></ol><p>定义UI状态，React框架会复杂把它渲染成最终的UI。当状态数据发生变化时，React也会根据最新的状态渲染出最新的UI</p><ol><li>灵活地渲染实现</li></ol><p>先渲染成虚拟DOM，简单的JS对象然后渲染成对应UI</p><ol><li>高效的DOM操作</li></ol><p>操作JS对象比起操作真实DOM在效率上有了巨大提升。基于Diff算法，React可以尽量减少虚拟DOM到真实DOM的渲染次数</p><p>尽管如此，React并不是MVC框架，从分层上看，React属于V层，关注如何根据状态创建可复用UI组件。当应用复杂时，需结合Redux等才能最大发挥</p><h2 id="React新特性相关"><a href="#React新特性相关" class="headerlink" title="React新特性相关"></a>React新特性相关</h2><p>这里介绍了16的新特性，包括render方法新支持的返回类型、新的错误处理机制和Error Boundary组件，可以将组件挂载到任意DOM树的Portals特性以及自定义DOM属性的支持。</p><p>基于新的fiber架构。还有如 setState传入null不触发组件更新，更加高效的服务端渲染等方式等。</p><h3 id="render新的返回类型"><a href="#render新的返回类型" class="headerlink" title="render新的返回类型"></a>render新的返回类型</h3><p>返回数组</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      &lt;li key=<span class="string">"a"</span>&gt;a&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      &lt;li key="b"&gt;b&lt;/</span>li&gt;</span><br><span class="line">      &lt;li key=<span class="string">"c"</span>&gt;c&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    ]</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>返回字符串</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Just a strings</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>App 组件的render方法渲染 ListComponent 和 StringComponent</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &lt;ListComponent /&gt;</span><br><span class="line">      &lt;<span class="regexp">/ul&gt;,</span></span><br><span class="line"><span class="regexp">      &lt;StringComponent /</span>&gt;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>16版本前，组件运行期间执行错误会阻塞应用渲染。16引入新的错误处理机制，组件抛错时，会就爱你个组件从组件树中卸载，从而避免整个应用的崩溃。</p><p>16还提供了一种更友好的错误处理方式——错误边界。错误边界是能够捕获子组件的错误并对其优雅处理的组件，输出错误日志、显示出错提示等这比卸载组件更友好</p><p>定义了 componentDidCatch(error, info) 方法的组件将成为一个错误边界，现在我们创建一个组件ErrorBoundary</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">hasError</span>: <span class="literal">false</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidCatch(error, info) &#123;</span><br><span class="line">    <span class="comment">// 显示错误UI</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    <span class="comment">// 同时输出错误日志</span></span><br><span class="line">    <span class="built_in">console</span>.log(error, info)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.hasError) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Oopts, something went wrong.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在App中使用ErrorBoundary</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      user: &#123; <span class="attr">name</span>: <span class="string">'react'</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将user置为null，模拟异常</span></span><br><span class="line">  onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">user</span>: <span class="literal">null</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ErrorBoundary&gt;</span><br><span class="line">          &lt;Profile user=&#123;<span class="keyword">this</span>.state.user&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/ErrorBoundary&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.onClick&#125;&gt;更新&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const Profile = (&#123;user&#125;) =&gt; &lt;div&gt;name: &#123;user.name&#125;&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><p>点击更新按钮后，Profile接受的属性user为null，程序会抛错TypeError，这个错误被ErrorBoundary捕获，并在界面上显示出错提示</p><h3 id="Portals"><a href="#Portals" class="headerlink" title="Portals"></a>Portals</h3><p>Portals特性让我们可以把组件渲染到当前组件树以外的DOM节点上。该特性的典型应用场景是，渲染应用的全局弹框，使用Portals后，任意组件都可以将弹框组件渲染到根节点上，以方便弹框的显示。Portals的实现依赖于ReactDOM的一个新API</p><pre><code>ReactDOM.createPortal(child, container)</code></pre><p>第一个参数child是可以被渲染的React节点，例如React元素、由React元素组成的数组、字符串等。<br>container是一个DOM元素，child将被挂载到这个DOM节点</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modal</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="comment">// 根节点下创建一个div节点</span></span><br><span class="line">    <span class="keyword">this</span>.container = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(<span class="keyword">this</span>.container)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> ReactDOM.createPortal(</span><br><span class="line">      &lt;div className=<span class="string">"modal"</span>&gt;</span><br><span class="line">        &lt;span className=<span class="string">"close"</span> onClick=&#123;<span class="keyword">this</span>.props.onClose&#125;&gt;&amp;times;<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">        &lt;div className=<span class="string">"content"</span>&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;,</span><br><span class="line">      <span class="keyword">this</span>.container</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(<span class="keyword">this</span>.container)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在App中使用Modal</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">showModal</span>: <span class="literal">true</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  closeModal = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">showModal</span>: <span class="literal">false</span>&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;Dashboard&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">        &#123;this.state.showModal &amp;&amp; (</span></span><br><span class="line"><span class="regexp">          &lt;Modal onClose=&#123;this.closeModal&#125;&gt;Modal Dialog&lt;/</span>Modal&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="自定义DOM属性"><a href="#自定义DOM属性" class="headerlink" title="自定义DOM属性"></a>自定义DOM属性</h3><p>16版 React会把不识别的属性传递给DOM元素。例如， 在16前，下面的React元素</p><pre><code>&lt;div custom-attribute=&quot;something&quot; /&gt;</code></pre><p>在浏览器中渲染出的DOM节点为：</p><pre><code>&lt;div /&gt;</code></pre><p>而React16版渲染出的DOM节点为：</p><pre><code>&lt;div custom-attribute=&quot;something&quot; /&gt;</code></pre><hr><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>组件从创建到被销毁的过程称为组件的生命周期。通常，有以下三个阶段：</p><h3 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h3><ul><li><p>constructor</p></li><li><p>componentWillMount 用得较少，因为此阶段的都可移到constructor里，该方法调用this.setState不会引起重渲</p></li><li><p>render 根据组件的props和state返回一个React元素。需注意，render并不负责组件的实际渲染，它只是返回一个UI描述，真正渲染DOM由React本身负责，该阶段不能执行有副作用的操作</p></li><li><p>componentDidMount 组件被挂载后只调用一次，依赖DOM节点操作可放该阶段中，还有服务端请求等操作，this.setState会引起重渲</p></li></ul><h3 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h3><ul><li>componentWillReceiveProps(nextProps) 引起组件更新过程调用。state引起组件更新不会触发该方法的执行。nextProps是父组件传递给当前组件的新props. 因此往往需比较nextProps和this.props来决定是否执行props发生变化后的逻辑</li></ul><blockquote><p>(1)在componentWillReceiveProps中调用setState，只有在组件render及其之后的方法中，this.setState指向的才是更新后的state。在render之前的方法shouldComponentUpdate、componentWillUpdate中，this.setState依然指向的是更新前的state</p></blockquote><blockquote><p>(2)通过调用setState更新组件状态并不会触发componentWillReceiveProps的调用，否则会进入一个死循环 componentWillReceiveProps -&gt; this.setState -&gt; componentWillReceiveProps …</p></blockquote><ul><li><p>shouldComponentUpdate(nextProps, nextState) 该方法决定组件是否继续执行更新过程。当方法返回true时(默认)，组件会继续更新过程。当返回false，组件的更新过程停止，后续的componentWillUpdate、render、componentDidUpdate也不会被调用，这是优化性能的一个重要钩子</p></li><li><p>componentWillUpdate(nextProps, nextState) 在组件render前调用，可作为组件更新前执行某些工作的地方</p></li></ul><blockquote><p>shouldComponentUpdate和componentWillUpdate中都不能调用setState，否则会引起循环调用问题</p></blockquote><ul><li><p>render 同上，省略了</p></li><li><p>componentDidUpdate(prevProps, prevState) 组件更新后被调用，可作为更新后操作DOM的地方，其参数prevProps, prevState代表组件更新前的props和state</p></li></ul><h3 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h3><p>组件从DOM中被卸载的过程，只有一个声明周期方法</p><ul><li>componentWillUnmount 在组件卸载前调用，可在这里执行一些清理工作。如定时器或手动创建的DOM元素等，以避免内存泄漏</li></ul><blockquote><p>只有类才具有生命周期方法，函数组件是没有生命周期钩子的。</p></blockquote><h2 id="ref相关"><a href="#ref相关" class="headerlink" title="ref相关"></a>ref相关</h2><p>绝大部分场景应避免使用ref，因为它破坏了React中以props为数据传递介质的典型数据流。</p><p>下面介绍下ref的常用使用场景</p><h2 id="在DOM上使用ref"><a href="#在DOM上使用ref" class="headerlink" title="在DOM上使用ref"></a>在DOM上使用ref</h2><p>ref接受一个回调函数作为值，在组件被挂载或卸载时，回调函数会被调用，在组件被挂载时，回调函数会接受当前DOM元素作为参数；组件被卸载时回调函数会接受null作为参数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoFocusTextInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> ref=&#123;input =&gt; <span class="keyword">this</span>.textInput = input&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  componentDidMount() &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 通过ref让input自动获取焦点</span></span><br><span class="line"><span class="regexp">    this.textInput.focus()</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>AutoFocusTextInput中为input定义ref，在组件挂载后，通过ref获取input元素，让其自动获取焦点，否则就很难实现该功能</p><h3 id="在组件上使用ref"><a href="#在组件上使用ref" class="headerlink" title="在组件上使用ref"></a>在组件上使用ref</h3><p>例，在使用AutoFocusTextInput组件的外部组件Containter中控制：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoFocusTextInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  blur = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.textInput.blur()</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> ref=&#123;input =&gt; <span class="keyword">this</span>.textInput = input&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ AutoFocusTextInputContainer.jsx</span></span><br><span class="line"><span class="regexp">class AutoFocusTextInputContainer extends Component &#123;</span></span><br><span class="line"><span class="regexp">  handleClick = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 通过ref调用 组件的方法</span></span><br><span class="line"><span class="regexp">    this.inputInstance.blur()</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;AutoFocusTextInput ref=&#123;this.inputInstance = input&#125; /</span>&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;失去焦点&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过ref获取到了AutoFocusTextInput组件的实例对象，并把它赋值给Container的inputInstance属性，这样就可以通过inputInstance调用AutoFocusTextInput中的blur方法，让已经处于获取焦点状态的input失去焦点。</p><h3 id="父组件访问子组件的DOM节点"><a href="#父组件访问子组件的DOM节点" class="headerlink" title="父组件访问子组件的DOM节点"></a>父组件访问子组件的DOM节点</h3><p>某些场景可能会需要。例如父组件需知道这个DOM元素的尺寸或位置信息，直接使用ref是无法实现的。</p><p>这时，可在子组件的DOM元素上定义ref，ref的值是父组件传递给子组件的一个回调函数，回调函数可以通过一个自定义的属性传递，例如inputRef, 这样父组件的回调函数中就能获取到这个DOM元素</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Children</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 子组件使用父组件传递的inputRef, 为input的ref赋值</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input ref=&#123;props.inputRef&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Parent extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 自定义一个属性inputRef，值是一个函数</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;Children inputRef=&#123;el =&gt; this.inputElement = el&#125; /</span>&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从该例中还可发现，即时子组件是函数组件，这种方式同样有效。</p><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><ul><li>React的事件命名采用驼峰命名</li><li>处理事件的响应函数要以对象形式赋值给事件属性</li></ul><hr><p>React事件是合成事件，并不是原生DOM事件。在React事件中必须显式调用事件对象的preventDefault方法来阻止事件的默认行为。</p><p>在 React组件中处理事件最容易出错的是事件处理函数中this指向问题，因为ES6 Class不会为方法自动绑定到当前对象。</p><ol><li>使用箭头函数</li></ol><p>箭头函数的this指向的是函数定义时的对象，可保证this总是指向当前组件的实例对象。<br>直接在render方法为元素事件定义事件处理函数，最大问题是每次render调用时都会重新创建一个新的事件处理函数，带来额外的性能开销，组件所处层级越低，开销就越大</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;e =&gt; <span class="keyword">this</span>.handleClick(e)&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><ol><li>使用组件方法</li></ol><p>直接将组件的方法赋值给元素的事件属性，同时在类的构造函数中，将这个方法的this绑定当当前对象</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick(e)&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>好处是每次render不会重新创建一个回调函数，没有额外的性能损失。但模版较为繁琐，还有下一种改良：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>)&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>使用bind会创建一个新函数，因此该写法毅然存在每次render都会创建一个新函数问题</p><p><strong>3. 属性初始化语法</strong> property initializer syntax</p><p>使用ES7的property initializers会自动为class中定义的方法绑定this：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ES7的属性初始化方法，实际上也是使用了箭头函数</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> num = ++<span class="keyword">this</span>.state.num</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      num</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;<span class="keyword">this</span>.state.num&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.handleClick&#125;&gt;click&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这种方式既不需要在构造函数中手动绑定this，也不需要担心组件重复渲染导致的函数重复创建问题。</p>]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【JS】【设计模式】初识IOC</title>
      <link href="/2017/12/13/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E5%88%9D%E8%AF%86IOC/"/>
      <url>/2017/12/13/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E5%88%9D%E8%AF%86IOC/</url>
      <content type="html"><![CDATA[<blockquote><p>看到群里的大佬们在讨论着，冒出了好多“生词”，竟然完全不知，惭愧惭愧，于是各种谷歌百度后将之整理一下。近几年，前端应用（WebApp）正朝着大规模方向发展，在这个过程中我们会对项目拆解成多个模块/组件来组合使用，以此提高我们代码的复用性，最终提高研发效率。在编写一个复杂组件的时候，总会依赖其他组件来协同完成某个逻辑功能。组件越复杂，依赖越多，可复用性就越差，我们可以借助软件工程中优秀的编程理念来提高复杂组件的可复用性，以下将详述其中之一的依赖倒置理念。</p></blockquote><a id="more"></a><p>之前自学React，看到了高阶组件这么一个概念。那么理解之前，我们首先要理解高阶函数这个概念</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>)</span><br><span class="line">&#125;</span><br><span class="line">hello() <span class="comment">// 'Hello World'</span></span><br><span class="line"><span class="comment">// hello()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WrapperHello</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'before ------ say hello'</span>)</span><br><span class="line">    fn()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'after ------- say hello'</span>)</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line">hello = WrapperHello(hello)</span><br><span class="line">hello()</span><br><span class="line"><span class="comment">// 'before ------ say hello'</span></span><br><span class="line"><span class="comment">// 'Hello World'</span></span><br><span class="line"><span class="comment">// 'after ------- say hello'</span></span><br></pre></td></tr></table></figure><p>函数既可以当参数，也可以当返回值</p><h3 id="属性代理"><a href="#属性代理" class="headerlink" title="属性代理"></a>属性代理</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WrapHello</span>(<span class="params">Comp</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">WrapComp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;p&gt;高阶组件 - 属性代理&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Comp &#123;...this.props&#125; /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  return WrapComp</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">Hello = WrapHello(Hello)</span></span><br><span class="line"><span class="regexp">&lt;Hello /</span>&gt;</span><br><span class="line"><span class="comment">// 这个Hello 组件 已经有p标签了</span></span><br></pre></td></tr></table></figure><p>上面的 WrapComponent 就是属性代理<br>可以在其添加更多的属性或组件等</p><h3 id="反向继承"><a href="#反向继承" class="headerlink" title="反向继承"></a>反向继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WrapComponent</span>(<span class="params">Comp</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Wrap</span> <span class="keyword">extends</span> <span class="title">Comp</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Comp</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    componentDidMount() &#123;</span></span><br><span class="line"><span class="xml">      console.log('高阶函数 - 反向继承')</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  return Wrap</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">Hello = WrapComponent(Hello)</span></span><br></pre></td></tr></table></figure><p>### </p><h2 id="依赖反转-Inversion-of-Control"><a href="#依赖反转-Inversion-of-Control" class="headerlink" title="依赖反转 Inversion of Control"></a>依赖反转 Inversion of Control</h2><p>其实这词好像经常听到过，很高端的样子。我们先来百科的解释： 控制反转把创建对象的权利交给框架，是框架的重要特征，并非面向对象编程的专业术语。<br>它包括依赖注入<code>Dependency Injection</code>和依赖查找<code>Dependency Lookup</code></p><p>它包含两个准则：</p><ol><li>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象</li><li>抽象不应该依赖于具体实现，具体实现应该依赖于抽象</li></ol><p>其背后的核心思想是：面向接口编程</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>IoC最大的好处是什么？因为把对象生成放在了XML里定义，所以当我们需要换一个实现子类将会变成很简单（一般这样的对象都是实现于某种接口的），只要修改XML就可以了，这样我们甚至可以实现对象的热插拔（有点像USB接口和SCSI硬盘了）。</p><p>IoC最大的缺点是什么？（1）生成一个对象的步骤变复杂了（事实上操作上还是挺简单的），对于不习惯这种方式的人，会觉得有些别扭和不直观。（2）对象生成因为是使用反射编程，在效率上有些损耗。但相对于IoC提高的维护性和灵活性来说，这点损耗是微不足道的，除非某对象的生成对效率要求特别高。（3）缺少IDE重构操作的支持，如果在Eclipse要对类改名，那么你还需要去XML文件里手工去改了，这似乎是所有XML方式的缺陷所在。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p><strong>实现数据访问层</strong></p><p>数据访问层有两个目标。第一是将数据库引擎从应用中抽象出来，这样就可以随时改变数据库—比方说，从微软SQL变成Oracle。不过在实践上很少会这么做，也没有足够的理由未来使用实现数据访问层而进行重构现有应用的努力。[3]<br>第二个目标是将数据模型从数据库实现中抽象出来。这使得数据库或代码开源根据需要改变，同时只会影响主应用的一小部分——数据访问层。这一目标是值得的，为了在现有系统中实现它进行必要的重构。</p><p><strong>模块与接口重构</strong></p><p>依赖注入背后的一个核心思想是单一功能原则（single responsibility principle）。该原则指出，每一个对象应该有一个特定的目的，而应用需要利用这一目的的不同部分应当使用合适的对象。这意味着这些对象在系统的任何地方都可以重用。但在现有系统里面很多时候都不是这样的。[3] </p><p><strong>随时增加单元测试</strong></p><p>把功能封装到整个对象里面会导致自动测试困难或者不可能。将模块和接口与特定对象隔离，以这种方式重构可以执行更先进的单元测试。按照后面再增加测试的想法继续重构模块是诱惑力的，但这是错误的。</p><p><strong>使用服务定位器而不是构造注入</strong></p><p>实现控制反转不止一种方法。最常见的办法是使用构造注入，这需要在对象首次被创建是提供所有的软件依赖。然而，构造注入要假设整个系统都使用这一模式，这意味着整个系统必须同时进行重构。这很困难、有风险，且耗时。</p><hr><p>我们还是由例子来看：要实现一个列表 A，能够加载一系列的信息并展示<br>于是很自然地我们遵守单一职责功能，将展示和加载两个逻辑分成两个类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loading.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Loader</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(url) &#123;</span><br><span class="line">    <span class="keyword">this</span>.url = url</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> load() &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> fetch(<span class="keyword">this</span>.url)</span><br><span class="line">    <span class="keyword">return</span> result.text()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****************************/</span></span><br><span class="line"><span class="comment">// list.js</span></span><br><span class="line"><span class="keyword">import</span> Loader <span class="keyword">from</span> <span class="string">'./Loader</span></span><br><span class="line"><span class="string">export default class List &#123;</span></span><br><span class="line"><span class="string">  constructor(container) &#123;</span></span><br><span class="line"><span class="string">    this.container = container</span></span><br><span class="line"><span class="string">    this.loader = new Loader('</span>list.json<span class="string">')</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  async render() &#123;</span></span><br><span class="line"><span class="string">    let items = await this.loader.load()</span></span><br><span class="line"><span class="string">    this.container.textContent = items</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">/*****************************/</span></span><br><span class="line"><span class="string">// main.js</span></span><br><span class="line"><span class="string">import List from '</span>./List<span class="string">'</span></span><br><span class="line"><span class="string">let list = new List(document.getElementById('</span>elem<span class="string">'))</span></span><br><span class="line"><span class="string">List.render()</span></span><br></pre></td></tr></table></figure><p>列表A很快开发完毕，于是继续开发下一个列表 B，B 的功能和 A 类似，也是加载数据展示数据，区别在于 B 的数据来源是一个第三方的服务，他们提供一个 js sdk 给你调用能够返回数据信息。<br>很自然的我们想到 A 的展示逻辑是可以复用的，对于数据加载这个逻辑我们重新实现一个 ThirdLoader 来专门加载第三方服务就是了，但回到 List 模块，我们发现在其构造函数中写死了对 Loader 的依赖：</p><pre><code>this.loader = new Loader(&apos;/list&apos;); </code></pre><p>导致无法对 List 设置第三方数据加载逻辑。这个问题就在于 List 依赖了具体的实现而不是依赖一个 Loader 接口。</p><p>IOC正是解决这类问题的最佳良药，我们再回顾IOC的两条准则，再看看如何利用IOC理念解决这类问题：</p><p><code>1. 高层次的模块不应该依赖于低层次的模块，它们都应该依赖于抽象</code></p><p>上述代码中，列表模块是高层次的模块，Loader是低层次的模块。高层次的List依赖了低层次的Loader，违背了该准则。好在准备也提供了解决方案：<strong>应该依赖于抽象</strong>。<br>那什么是抽象？即<code>接口</code>，放在JS语言中，接口则是隐式的。</p><p>我们正好实践下该准则：</p><ol><li>我们定义一个隐式的接口ILoader,ILoader声明了一个load方法，该方法签名是返回一个包含请求结果的Promise</li><li>将List模块对Loader模块的依赖调整为对ILoader接口的依赖：我们在List模块中移除对Loader模块的依赖（即移除import语句），同时构造函数中增加一个参数，该参数是一个实现了ILoader接口的实例</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span>() </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(container, loader) &#123;</span><br><span class="line">    <span class="keyword">this</span>.container = container</span><br><span class="line">    <span class="keyword">this</span>.loader = loader</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> render() &#123;</span><br><span class="line">    <span class="keyword">this</span>.container.textContent = <span class="keyword">await</span> <span class="keyword">this</span>.loader.load()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>为了完成列表A的功能，我们还要改造main.js，将实现了ILoader的Loader模块实例化传给List模块：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">'./List'</span></span><br><span class="line"><span class="keyword">import</span> Loader <span class="keyword">from</span> <span class="string">'./Loader'</span></span><br><span class="line"><span class="keyword">let</span> list = <span class="keyword">new</span> List(<span class="built_in">document</span>.getElementById(<span class="string">'elem'</span>), <span class="keyword">new</span> Loader(<span class="string">'list.json'</span>))</span><br><span class="line">list.render()</span><br></pre></td></tr></table></figure><p>至此，我们完成了对List模块的一次改造，List从对具体实现Loader的依赖变成了对抽象接口ILoader的依赖，而List模块中对Loader模块的导入和实例化过程转移到了main.js，这一过程就是我们的<code>依赖倒置</code>。依赖创建的控制权交给了外部main.js，而在main.js中查找创建依赖并将依赖传递给List模块的这一过程我们称之为依赖注入<code>Dependency injection</code></p><p>我们再来看看IOC的第二个准则：<code>2. 抽象不应该依赖于具体实现，具体实现应该依赖于抽象</code>，我们的ILoader接口显然不会依赖于任何具体实现，而Loader这个具体实现依赖于ILoader接口，完全符合了IOC的第二准则。</p><p>原有系统的依赖关系图结果如下：</p><p><img src="/2017/12/13/【设计模式】初识IOC/原有关系依赖图.jpg"></p><p>基于新的依赖架构，List模块具备了设置不同数据加载逻辑的能力，现在我们可以复用List模块再实现列表B的数据加载逻辑并在main中组装即可完成列表B的功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThirdLoader.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">'../third/sdk'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ThirdServiceLoader</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> load() &#123;</span><br><span class="line">    <span class="keyword">return</span> request()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> List <span class="keyword">from</span> <span class="string">'./List'</span></span><br><span class="line"><span class="keyword">import</span> Loader <span class="keyword">from</span> <span class="string">'./Loader'</span></span><br><span class="line"><span class="keyword">import</span> ThirdLoader <span class="keyword">from</span> <span class="string">'./ThirdLoader'</span></span><br><span class="line"><span class="keyword">let</span> listA = <span class="keyword">new</span> List(<span class="built_in">document</span>.getElementById(<span class="string">'a'</span>), <span class="keyword">new</span> Loader(<span class="string">'list.json'</span>))</span><br><span class="line">listA.render()</span><br><span class="line"><span class="keyword">let</span> listB = <span class="keyword">new</span> List(<span class="built_in">document</span>.getElementById(<span class="string">'b'</span>), <span class="keyword">new</span> ThirdLoader())</span><br><span class="line">listB.render()</span><br></pre></td></tr></table></figure><p>最终的一个依赖关系图如下：</p><p><img src="/2017/12/13/【设计模式】初识IOC/最终依赖关系图.jpg"></p><p>至此我们上面演示了应用 IoC 理念对高层模块的一个依赖架构改造，提高了高层模块的可复用性。</p><h2 id="IOC小结"><a href="#IOC小结" class="headerlink" title="IOC小结"></a>IOC小结</h2><p>总结我们最开始遇到的问题：类 A 直接依赖类 B，假如要将类 A 改为依赖类 C，则必须通过修改类 A 的代码来达成。这种场景下，类 A 一般是高层模块，负责复杂的业务逻辑；类 B 和类 C 是低层模块，负责基本的原子操作；假如修改类 A，会给程序带来不必要的风险。</p><p>IOC 解决方案：将类 A 修改为依赖接口 I，类 B 和类 C 各自实现接口 I，类 A 通过接口 I 间接与类 B 或者类 C 发生联系，则会大大降低修改类 A 的几率。</p>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【JS】面向对象相关设计模式</title>
      <link href="/2017/11/01/%E3%80%90JS%E3%80%91%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/11/01/%E3%80%90JS%E3%80%91%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<blockquote><p>面向对象应该是一种思想，而不是代码的组织形式。</p></blockquote><p>面向对象的特点：</p><ul><li>封装</li><li>继承</li><li>多态</li></ul><p>子类继承了父类的函数，同时覆盖实现了父类的某些行为。上面的setProgress函数即体现了多态又体现了继承</p><a id="more"></a><h3 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h3><p>集成商为了实现复用，组合其实也是为了实现复用。继承是is-a的关系，而组合是has-a的关系。</p><p>可以把上面的ProgressBar改成组合的方式。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProgressBar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>($container) &#123;</span><br><span class="line">    <span class="keyword">this</span>.fullWidth = $container.width()</span><br><span class="line">    <span class="keyword">this</span>.$bar = <span class="literal">null</span></span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">// 设置宽度</span></span><br><span class="line">  setProgress(percentage) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$bar.animate(&#123;</span><br><span class="line">      width: <span class="keyword">this</span>.fullWidth * percentage + <span class="string">'px'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 完成</span></span><br><span class="line">  finished() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$bar.hide()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 失败</span></span><br><span class="line">  failed() &#123;</span><br><span class="line">    <span class="keyword">this</span>.addFailedText()</span><br><span class="line">  &#125;</span><br><span class="line">  addFailedText() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProgressBarWithNumber</span> <span class="keyword">extends</span> <span class="title">ProgressBar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>($container) &#123;</span><br><span class="line">    <span class="keyword">super</span>($container)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 多态</span></span><br><span class="line">  setProgress(percentage) &#123;</span><br><span class="line">    <span class="comment">// 先借助继承父类的函数</span></span><br><span class="line">    <span class="keyword">super</span>.setProgress(percentage)</span><br><span class="line">    <span class="keyword">this</span>.showPercentageText(percentage)</span><br><span class="line">  &#125;</span><br><span class="line">  showPercentageText(percentage) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造函数里面组合了一个progressBar的实例，然后在setProgress函数里面利用这个实例去设置进度条的百分比。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProgressBarWithNumber</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>($container) &#123;</span><br><span class="line">    <span class="keyword">this</span>.progressBar = <span class="keyword">new</span> ProgressBar($container)</span><br><span class="line">  &#125;</span><br><span class="line">  setProgress(percentage) &#123;</span><br><span class="line">    <span class="keyword">this</span>.progressBar.setProgress(percentage)</span><br><span class="line">    <span class="keyword">this</span>.showPercentageText(percentage)</span><br><span class="line">  &#125;</span><br><span class="line">  showPercentageText(percentage) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>偏向于使用组合而非继承</strong></p><p>因为继承的耦合性要大于组合，组合更加灵活。继承是编译阶段就决定了关系，而组合是运行阶段才决定关系。</p><h3 id="面向对象编程原则和设计模式"><a href="#面向对象编程原则和设计模式" class="headerlink" title="面向对象编程原则和设计模式"></a>面向对象编程原则和设计模式</h3><ol><li>单例模式</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> taskWorker = &#123;</span><br><span class="line">  tasks: [],</span><br><span class="line">  draw() &#123;&#125;,</span><br><span class="line">  addTask(task) &#123;</span><br><span class="line">    Task.tasks.push(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> mapTask = &#123;</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span>(<span class="params">task</span>) </span>&#123;</span><br><span class="line">    taskWorker.addTask(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次get的时候先判断mapTask有没有Task的新实例，如果没有则为第一次。先去实例化一个，并做些初始化工作，如果有则直接返回。然后执行mapTask.get()的时候就能够保证获取到的是一个单例。</p><ul><li><p>破坏单例</p><pre><code>mapTask.aTask = null</code></pre></li></ul><ol><li>策略模式</li></ol><p>场景：注册弹框，不同的弹框文字。把文案当做一个个的策略，使用时根据不同类型，映射到不同的策略。<br>这样比写if-else或者switch的好处在于：如果以后要增加或删除某种类型，只需要增删一个type就可以了，而不用去改动if-else逻辑。这就叫做开放封闭原则——对修改是封闭的，而对扩展是开放的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> popType = &#123;</span><br><span class="line">  userReg: &#123;</span><br><span class="line">    title: <span class="string">'Create your account'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  favHouse: &#123;</span><br><span class="line">    title: <span class="string">'Add home to favorite'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  saveSearch: &#123;</span><br><span class="line">    title: <span class="string">'Save this search'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tpl = <span class="string">`&lt;section&gt;&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;/section&gt;`</span></span><br><span class="line"></span><br><span class="line">Mustache.render(tpl, popType[<span class="string">'userReg'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把回调操作封装成一个策略</span></span><br><span class="line"><span class="keyword">var</span> popCallback = &#123;</span><br><span class="line">  userReg: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  favHouse: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  saveSearch: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">util.ajax(<span class="string">'/register'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> popType = <span class="string">'favHouse'</span> <span class="comment">// 获取popType</span></span><br><span class="line">  popCallback[popType]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>观察者模式</li></ol><p>观察者向消息的接受者订阅消息，一旦接受者收到消息后就把消息下发给它的观察者们。在一个回执搜索的应用里面，单击最后一个点关闭路径，要触发搜索。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Input</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(inputDom) &#123;</span><br><span class="line">    <span class="keyword">this</span>.inputDom = inputDom</span><br><span class="line">    <span class="keyword">this</span>.visitors = &#123;</span><br><span class="line">      click: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加访问者</span></span><br><span class="line">  on(eventType, visitor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.visitors.push(visitor)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 收到消息，把消息分发给访问者</span></span><br><span class="line">  trigger(type, event) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.visitors[type]) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.visitors[type]; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.visitors[type]()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>适配器模式</li></ol><p>在一个响应式的页面里，假设小屏和大屏显示的分页样式不同，它们初始化和更新状态的函数都不同，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小屏</span></span><br><span class="line"><span class="keyword">var</span> pagination = <span class="keyword">new</span> jqPagination(&#123;</span><br><span class="line">&#125;)</span><br><span class="line">pagination.showPage = <span class="function"><span class="keyword">function</span>(<span class="params">curPage, totalPage</span>) </span>&#123;</span><br><span class="line">  pagination.setPage(curPage, totalPage)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 大屏</span></span><br><span class="line"><span class="keyword">var</span> pagination = <span class="keyword">new</span> Pagination(&#123;</span><br><span class="line">&#125;)</span><br><span class="line">pagination.showPage = <span class="function"><span class="keyword">function</span>(<span class="params">curPage, totalPage</span>) </span>&#123;</span><br><span class="line">  pagination.showItem(curPage, totalPage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果每次调用都得判断一下不同的屏幕大小然后调用不同函数就很麻烦，所以用一个适配器，对外提供统一的接口：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> screen = $(<span class="built_in">window</span>).width() &lt; <span class="number">800</span> ? <span class="string">'small'</span> : <span class="string">'large'</span></span><br><span class="line"><span class="keyword">var</span> paginationAdapter = &#123;</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.pagination = screen === <span class="string">'small'</span> ? <span class="keyword">new</span> jqPagination() : <span class="keyword">new</span> Pagination()</span><br><span class="line">    <span class="keyword">if</span> (screen === <span class="string">'large'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.pagination.showItem = <span class="keyword">this</span>.pagination.setPage</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  showPage: <span class="function"><span class="keyword">function</span>(<span class="params">curPage, totalPage</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.pagination.showItem(curPage, totalPage)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用者只要调用 <code>paginationAdapter.showPage</code> 就可以更新分页状态，它不需要去关心当前是大屏还是小屏，由适配器去处理这些细节</p><ol><li>工厂模式</li></ol><p>工厂模式是把创建交给一个工厂，使用者无需要关心创建细节，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> taskCreator = &#123;</span><br><span class="line">  createTask: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'map'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MapTask()</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'search'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SearchTask()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> mapTask = taskCreator.createTask(<span class="string">'map'</span>)</span><br></pre></td></tr></table></figure><p>需要哪种类型的Task时就传一个类型或者name给以个工厂，工厂根据名字去生产相应的产品，不用关心它是怎么创建的，要不要单例之类。</p><ol><li>外观/门面模式</li></ol><p>在一个搜索逻辑里，为了显示搜索结果需要执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hideNoResult() <span class="comment">// 隐藏没有结果的显示</span></span><br><span class="line">removeOldResult() <span class="comment">// 删除老的结果</span></span><br><span class="line">showNewResult() <span class="comment">// 显示新结果</span></span><br><span class="line">showPageItem() <span class="comment">// 更新分页</span></span><br><span class="line">resizePhoto() <span class="comment">// 结果图片大小重置</span></span><br></pre></td></tr></table></figure><p>于是考虑用一个模块把它包起来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showResult</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  hideNoResult() <span class="comment">// 隐藏没有结果的显示</span></span><br><span class="line">  removeOldResult() <span class="comment">// 删除老的结果</span></span><br><span class="line">  showNewResult() <span class="comment">// 显示新结果</span></span><br><span class="line">  showPageItem() <span class="comment">// 更新分页</span></span><br><span class="line">  resizePhoto() <span class="comment">// 结果图片大小重置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 需要时调用 showResult()</span></span><br></pre></td></tr></table></figure><p>把多个操作封装成一个模块，对外只提供一个门面叫showResult，使用者只要调一下该函数即可</p><ol><li>状态模式</li></ol><p>实现一个类似微博的消息框，要求是当数字为0或者超过140时，发推按钮可单击，且剩余数字会跟着变</p><p>可用一个state来保存当前的状态，然后当用户输入时，这个state的数据会跟着变，同时更新按钮状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tweetBox = &#123;</span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="comment">// 初始化一个state</span></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;&#125;</span><br><span class="line">    tweetBox.bindEvent()</span><br><span class="line">  &#125;,</span><br><span class="line">  setState(key, val) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state[key] = val</span><br><span class="line">  &#125;,</span><br><span class="line">  changeSubmit() &#123;</span><br><span class="line">    <span class="comment">// 通过获取当前的state</span></span><br><span class="line">    $(<span class="string">'#submit'</span>)[<span class="number">0</span>].disabled = tweeetBox.state.text.length === <span class="number">0</span></span><br><span class="line">      || tweetBox.state.text.length &gt; <span class="number">140</span></span><br><span class="line">  &#125;,</span><br><span class="line">  showLeftTextCount() &#123;</span><br><span class="line">    $(<span class="string">'#text-count'</span>).text(<span class="number">140</span> - <span class="keyword">this</span>.state.text.length)</span><br><span class="line">  &#125;,</span><br><span class="line">  bindEvent() &#123;</span><br><span class="line">    $(<span class="string">'.tweet-textarea'</span>).on(<span class="string">'input'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 改变当前的state</span></span><br><span class="line">      tweetBox.setState(<span class="string">'text'</span>, <span class="keyword">this</span>.value)</span><br><span class="line">      tweetBox.changeSubmit()</span><br><span class="line">      tweetBox.showLeftTextCount()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用一个state保存当前状态，通过获取当前state进行下一步操作。</p><p>当然，上面的还有优化空间，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tweetBox = &#123;</span><br><span class="line">  setState(key, val) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state[key] = val</span><br><span class="line">    renderDom($(<span class="string">'.tweet'</span>))</span><br><span class="line">  &#125;,</span><br><span class="line">  renderDom($currentDom) &#123;</span><br><span class="line">    diffAndChange($currentDom, renderVirtualDom(tweetBox.state))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// `&lt;input type="submit" disabled=&#123;&#123;this.state.text.length === 0 || this.state.text.length &gt; 140&#125;&#125; /&gt;`</span></span><br></pre></td></tr></table></figure><p>这其实就是React的原型，不同的状态有不同的表现行为，所以可以认为是一个状态模式，并且通过状态去驱动DOM更改</p><ol><li>代理模式</li></ol><p>其实React不直接操作DOM，而是把数据给state，然后委托给state和虚拟DOM去操作真实DOM，所以它是一个代理模式</p><p>eventHandler -&gt; state -&gt; renderDom()</p><ol><li>状态模式的另一个例子</li></ol><p>改变一个房源的状态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newState === <span class="string">'sold'</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (currentState === <span class="string">'building'</span> || currentState === <span class="string">'dold'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'error'</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentState === <span class="string">'ready'</span>) &#123;</span><br><span class="line">    currentState = <span class="string">'sold'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'ok'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (newState === <span class="string">'ready'</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (currentState === <span class="string">'building'</span>) &#123;</span><br><span class="line">    currentState = <span class="string">'toBeSold'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'ok'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更改一个房源的状态之前先要判断一下当前的状态，如果当前状态不支持那么不允许修改。对上面的代码我们可以用代理模式重构一下，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stateChange = &#123;</span><br><span class="line">  ready: &#123;</span><br><span class="line">    building: <span class="string">'error'</span>,</span><br><span class="line">    ready: <span class="string">'error'</span>,</span><br><span class="line">    sold: <span class="string">'ok'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  building: &#123;</span><br><span class="line">    building: <span class="string">'error'</span>,</span><br><span class="line">    ready: <span class="string">'ok'</span>,</span><br><span class="line">    sold: <span class="string">'error'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (stateChange[currentState][newState] !== <span class="string">'error'</span>) &#123;</span><br><span class="line">  currentState = newState</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> stateChange[currentState][newState]</span><br></pre></td></tr></table></figure><p>你会发现状态模式和策略模式是孪生兄弟，它们形式相同，只是目的不同。</p><p>策略模式封装成策略，状态模式封装成状态。这样的代码就比写很多个if-else强多了，特别是当切换关系比较复杂的时候</p><ol><li>装饰者模式</li></ol><p>要实现一个贷款的计算器，点计算按钮后，除了要计算结果，还要把结果发给后端做一个埋点。所以写了一个calculateResult函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateResult</span>(<span class="params">form</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = $(form).serializeForm()</span><br><span class="line">  <span class="keyword">var</span> l = data.rate / <span class="number">1200</span></span><br><span class="line">  <span class="keyword">var</span> o = <span class="built_in">Math</span>.pow(<span class="number">1</span> + l, data.term * <span class="number">12</span>)</span><br><span class="line">  <span class="keyword">var</span> e = data.price * (<span class="number">1</span> - data.payment / <span class="number">100</span>)</span><br><span class="line">  <span class="keyword">var</span> result = (e * l * o / (o - <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">var</span> formatResult = util.formatMoney(result).toFixed(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> $calResult = $(<span class="string">'.loan-cal .cal-result-con'</span>)</span><br><span class="line">  $calResult.find(<span class="string">'.pi-result'</span>).text(formatResult)</span><br><span class="line">  <span class="comment">// 这个函数包含了两个功能，一个计算结果，一个改变DOM</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算按钮click回调</span></span><br><span class="line"><span class="keyword">var</span> result = calculateResult(form)</span><br><span class="line"><span class="comment">// 发送一个埋点请求</span></span><br><span class="line">util.ajax(<span class="string">'/cal-load'</span>, &#123;result&#125;)</span><br></pre></td></tr></table></figure><p>因为要把结果返回出来，所以这个函数有两个功能，一个是计算结果，第二个是改变DOM，这样写在一起感觉不太好。<br>于是我们把函数拆了，首先有一个LoanCalculator的类专门负责计算小数结果： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算结果</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoanCalculator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(form) &#123;</span><br><span class="line">    <span class="keyword">this</span>.form = form</span><br><span class="line">  &#125;</span><br><span class="line">  calResult() &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="string">'xxx'</span></span><br><span class="line">    <span class="keyword">this</span>.result = result</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  getResult() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.result) <span class="keyword">this</span>.result = <span class="keyword">this</span>.calResult()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它还提供了一个getResult的函数，如果结果没算过那先算一下保存起来，如果已经计算过了那就直接用算好的结果。<br>然后再写一个<code>NumberFormater</code>，它负责把小数结果格式化成带逗号的形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberFormater</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(calculator) &#123;</span><br><span class="line">    <span class="keyword">this</span>.calculator = calculator</span><br><span class="line">  &#125;</span><br><span class="line">  calResult() &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">this</span>.calculator.calResult()</span><br><span class="line">    <span class="keyword">this</span>.result = result</span><br><span class="line">    <span class="keyword">return</span> util.formatMoney(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在它的构造函数里传一个calculator给它，这个calculator可以是上面的LoanCalculator，获取到它的计算结果然后格式化。<br>接着写一个DOMRenderer的类，它负责把结果下显示出来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示结果</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DOMRenderer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(calculator) &#123;</span><br><span class="line">    <span class="keyword">this</span>.calculator = calculator</span><br><span class="line">  &#125;</span><br><span class="line">  calResult() &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">this</span>.calculator.calResult()</span><br><span class="line">    $(<span class="string">'.pi-result'</span>).text(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后代码调用如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> loadCalculator = <span class="keyword">new</span> LoanCalculator(form)</span><br><span class="line"><span class="keyword">let</span> numberFormator = <span class="keyword">new</span> NumberFormator(loadCalculator)</span><br><span class="line"><span class="keyword">let</span> domRenderer = <span class="keyword">new</span> DOMRenderer(numberFormator)</span><br><span class="line">domRenderer.calResult()</span><br><span class="line">util.ajax(<span class="string">'/cal-loan'</span>, &#123;<span class="attr">result</span>: loadCalculator.getResult()&#125;)</span><br></pre></td></tr></table></figure><p>可以看到它就是一个装饰的过程，一层一层地装饰：</p><p>DOMRenderer -&gt; NumberFormator -&gt; LoanCalculator</p><p>下一个装饰者调用上一个calResult函数，对它的结果进一步地装饰。如果这些装饰者的返回结果类型比较平行时，可以一层层地装饰下去。</p><p>使用装饰者模式，逻辑是清晰了，但是系统的复杂性增加了，有时候能用简单方式实现还是用简单方式。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下上文提到的面向对象的编程原则：</p><ol><li>把共性和特性或者会变和不变的部分分离出来</li><li>少用继承，多用组合</li><li>低耦合高聚合</li><li>开放封闭原则（对修改封闭，对扩展开放）</li><li>单一职责原则</li></ol>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oop </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【Vue】iview按需引入相关配置</title>
      <link href="/2017/10/14/%E3%80%90Vue%E3%80%91iview%E6%8C%89%E9%9C%80%E5%BC%95%E5%85%A5%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"/>
      <url>/2017/10/14/%E3%80%90Vue%E3%80%91iview%E6%8C%89%E9%9C%80%E5%BC%95%E5%85%A5%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<blockquote><p>iview 是一套基于 Vue.js 的高质量 UI 组件库。在项目中使用虽然直接引入整个包挺好的，但打包出来 vendor 非常大，并没必要。所以加入了 iview 按需引入的相关配置，减小包的体积从而提升点性能。</p></blockquote><a id="more"></a><p>首先通过 npm 安装 iview-loader</p><pre><code>npm install iview-loader --save-dev</code></pre><p>配置 webpack，改写平时 vue-loader 的配置，之前是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">      loader: <span class="string">'vue-loader'</span>,</span><br><span class="line">      options: vueLoaderConfig</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/iview.src.*?js$/</span>,</span><br><span class="line">      loader: <span class="string">'babel-loader'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">'vue-loader'</span>,</span><br><span class="line">          options: vueLoaderConfig</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">'iview-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            prefix: <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      loader: <span class="string">'babel-loader'</span>, <span class="comment">// 注：wepback 3等高版本 loader名称必须写完整</span></span><br><span class="line">      include: [</span><br><span class="line">        resolve(<span class="string">'src'</span>),</span><br><span class="line">        resolve(<span class="string">'test'</span>),</span><br><span class="line">        resolve(<span class="string">'/node_modules/iview/src'</span>)</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 更多</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助插件 babel-plugin-import可以实现按需加载组件，减少文件体积。首先安装，并在文件 .babelrc 中配置：</p><pre><code>npm install babel-plugin-import --save-dev</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"plugins"</span>: [[<span class="string">"import"</span>, &#123;</span><br><span class="line">    <span class="string">"libraryName"</span>: <span class="string">"iview"</span>,</span><br><span class="line">    <span class="string">"libraryDirectory"</span>: <span class="string">"src/components"</span></span><br><span class="line">  &#125;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这样按需引入组件，就可以减小体积了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Button, Table &#125; <span class="keyword">from</span> <span class="string">'iview'</span>;</span><br><span class="line">Vue.component(<span class="string">'Button'</span>, Button);</span><br><span class="line">Vue.component(<span class="string">'Table'</span>, Table);</span><br></pre></td></tr></table></figure><p>可以直接写 <switch> 和 <circle></circle> 这两个标签；<br>参数 prefix 设置为 true 后，所有 iView 组件标签名都可以使用前缀 i-，例如 <i-row>、<i-select></i-select></i-row></switch></p><p>注： 按需引用仍然需要导入样式，即在 main.js 或根组件执行 <code>import &#39;iview/dist/styles/iview.css&#39;</code>;</p><hr><p><strong>routes 里同样可以异步加载组件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    redirect: <span class="string">'/home'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/home'</span>,</span><br><span class="line">    name: <span class="string">'home'</span>,</span><br><span class="line">    <span class="comment">// component: Situation,</span></span><br><span class="line">    component: <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">'@/views/home'</span>], resolve),</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件 template 中 <code>import {Button} from &#39;iview&#39;</code>， 然后在 components 里注册相应组件即可使用了</p><p>使用 :prop传递数据格式为 数字、布尔值或函数时，必须带:(兼容String除外，具体看组件文档)</p><p>在非 template/render 模式下（例如使用 CDN 引用时），组件名要分隔，例如 DatePicker 必须要写成 date-picker</p><p>注：</p><p>locale，Message，Modal 等全局组件需要在主入口文件中引入或声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueI18n <span class="keyword">from</span> <span class="string">'vue-i18n'</span></span><br><span class="line"><span class="keyword">import</span> ZH <span class="keyword">from</span> <span class="string">'locale/local/zh_CN'</span></span><br><span class="line"><span class="keyword">import</span> EN <span class="keyword">from</span> <span class="string">'locale/local/en_US'</span></span><br><span class="line"><span class="keyword">import</span> zhLocale <span class="keyword">from</span> <span class="string">'iview/dist/locale/zh-CN'</span></span><br><span class="line"><span class="keyword">import</span> enLocale <span class="keyword">from</span> <span class="string">'iview/dist/locale/en-US'</span></span><br><span class="line"><span class="comment">// 依赖包</span></span><br><span class="line"><span class="keyword">import</span> &#123; locale, Modal, Message &#125; <span class="keyword">from</span> <span class="string">'iview'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'iview/dist/styles/iview.css'</span></span><br><span class="line"><span class="keyword">let</span> lang = localStorage.getItem(<span class="string">'language'</span>)</span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line">Vue.config.lang = lang</span><br><span class="line">Vue.use(VueI18n)</span><br><span class="line"><span class="comment">// 这里的locale国际化组件引入后，需将其声明为方法</span></span><br><span class="line">Vue.locale = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> messages = &#123;</span><br><span class="line">  zh: <span class="built_in">Object</span>.assign(ZH, zhLocale),</span><br><span class="line">  en: <span class="built_in">Object</span>.assign(EN, enLocale)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> i18n = <span class="keyword">new</span> VueI18n(&#123;</span><br><span class="line">  locale: Vue.config.lang,</span><br><span class="line">  messages</span><br><span class="line">&#125;)</span><br><span class="line">Vue.use(locale, &#123;</span><br><span class="line">  i18n(path, options) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = i18n.t(path, options)</span><br><span class="line">    <span class="keyword">if</span> (value !== <span class="literal">null</span> &amp;&amp; value !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">Vue.prototype.$Modal = Modal</span><br><span class="line">Vue.prototype.$Message = Message</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> webpack </tag>
            
            <tag> iview </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【JS】导出图片和导出html</title>
      <link href="/2017/09/11/%E3%80%90JS%E3%80%91%E5%AF%BC%E5%87%BA%E5%9B%BE%E7%89%87%E5%92%8C%E5%AF%BC%E5%87%BAhtml/"/>
      <url>/2017/09/11/%E3%80%90JS%E3%80%91%E5%AF%BC%E5%87%BA%E5%9B%BE%E7%89%87%E5%92%8C%E5%AF%BC%E5%87%BAhtml/</url>
      <content type="html"><![CDATA[<blockquote><p>最近的项目中最过的一个需求，之前没遇到过，正好记录下来方便以后参考，实现方式并不是最好，不过暂时能完成需求，性能方便还未做过优化，先看着吧</p></blockquote><a id="more"></a><p>由于是公司项目- -截图啥的我就不发了，这里说下核心功能实现</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"exportToImage"</span>&gt;</span>导出为图片<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"html2canvas"</span> <span class="attr">ref</span>=<span class="string">"html2canvas"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 代码 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 导入html2canvas</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">require</span>(<span class="string">'html2canvas/html2canvas.min'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">  data() &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;&#125;</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">  methods: &#123;</span></span><br><span class="line"><span class="undefined">    clickToImage() &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 拿到当前的this执行环境</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 将html转为图片</span></span></span><br><span class="line"><span class="javascript">      html2canvas(<span class="keyword">this</span>.refs.html2canvas)</span></span><br><span class="line"><span class="javascript">        .then(<span class="function"><span class="params">canvas</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">let</span> imgUri = canvas.toDataURL(<span class="string">'image/png'</span>).replace(<span class="string">'image/png'</span>, <span class="string">'image/octet-stream'</span>);</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 下载图片</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">let</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span></span><br><span class="line"><span class="javascript">          <span class="keyword">let</span> $el = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span></span><br><span class="line"><span class="undefined">          $el.href = imgUri;</span></span><br><span class="line"><span class="javascript">          $el.target = <span class="string">'_blank'</span>;</span></span><br><span class="line"><span class="javascript">          $el.download = <span class="string">`下载名_<span class="subst">$&#123;time&#125;</span>.jpg`</span>;</span></span><br><span class="line"><span class="undefined">          $el.click();</span></span><br><span class="line"><span class="javascript">          <span class="built_in">window</span>.location.href = imgUri;</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p>下面再说另一种导出为html的方式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"exportToHTML"</span>&gt;</span>导出为HTML<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"html2canvas"</span> <span class="attr">ref</span>=<span class="string">"html2canvas"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 代码 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 使用前需要 npm install file-saver --save-dev</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> fileSaver <span class="keyword">from</span> <span class="string">'file-saver'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">  data() &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;&#125;</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">  methods: &#123;</span></span><br><span class="line"><span class="undefined">    exportToHTML() &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 获取当前页面内容</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> record = <span class="built_in">document</span>.getElementById(<span class="string">'html2canvas'</span>).innerHTML;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> title = <span class="string">'我是title'</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> style = <span class="string">'这里是style我把需要的样式拼了过去，虽然手动麻烦了些，但导出内容一般样式都是一份，所以这样能节省导出文件大小'</span>;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 这里需要注意的是模版里的 / 需要转义~~ 第一次这里踩了坑弄半天没编译通过</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> head = <span class="string">`</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">title</span>&gt;</span>$&#123;title&#125;<span class="tag">&lt;<span class="name">\</span>/<span class="attr">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="undefined">            $&#123;style&#125;</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">\</span>/<span class="attr">style</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">\</span>/<span class="attr">head</span>&gt;</span></span></span><br><span class="line"><span class="undefined">      `;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> script = <span class="string">'同上，把需要的业务逻辑拼在了这里'</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> html = <span class="string">`</span></span></span><br><span class="line"><span class="xml">        <span class="meta">&lt;!DOCTYPE html&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="undefined">        $&#123;head&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="undefined">          $&#123;record&#125;</span></span><br><span class="line"><span class="undefined">          $&#123;script&#125;            </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">\</span>/<span class="attr">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">\</span>/<span class="attr">html</span>&gt;</span></span></span><br><span class="line"><span class="undefined">      `;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 最后保存文件</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> blob = <span class="keyword">new</span> Blob([html], &#123;<span class="attr">type</span>: <span class="string">'text/html; charset=utf-8'</span>&#125;);</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 这个文件会自动下载到浏览器设定的下载目录下</span></span></span><br><span class="line"><span class="javascript">      fileSaver.saveAs(blob, <span class="string">`<span class="subst">$&#123;title&#125;</span>_<span class="subst">$&#123;time&#125;</span>.html`</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里再额外说一下，因为我导出的html是带有echarts图表的，图片不方便查看一些细节，所以需求里加了html，这里导出script时需要注意下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// echarts相关字符串拼接</span></span><br><span class="line"><span class="keyword">let</span> dataString = <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.echartsData);</span><br><span class="line"><span class="keyword">const</span> script = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;script&gt;</span></span><br><span class="line"><span class="string">    // 这里把echarts.min.js的内容写入即可，或者也可根据用到的组件按需加载，这样体积小些    </span></span><br><span class="line"><span class="string">  &lt;\/script&gt;</span></span><br><span class="line"><span class="string">  &lt;script&gt;</span></span><br><span class="line"><span class="string">    var charts = echarts.init(document.getElementById('charts'));</span></span><br><span class="line"><span class="string">    var data = <span class="subst">$&#123;dataString&#125;</span></span></span><br><span class="line"><span class="string">    let options = &#123;</span></span><br><span class="line"><span class="string">      tooltip: &#123;</span></span><br><span class="line"><span class="string">        trigger: 'item',</span></span><br><span class="line"><span class="string">        formatter: "&#123;a&#125; &lt;br/&gt;&#123;b&#125;: &#123;c&#125; (&#123;d&#125;%)"</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      legend: &#123;</span></span><br><span class="line"><span class="string">        orient: 'horizontal',</span></span><br><span class="line"><span class="string">        x: 'center',</span></span><br><span class="line"><span class="string">        y: 520,</span></span><br><span class="line"><span class="string">        data: data.levels</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      series: [&#123;                  </span></span><br><span class="line"><span class="string">          name: '名称',</span></span><br><span class="line"><span class="string">          type: 'pie',</span></span><br><span class="line"><span class="string">          selectedMode: 'single',</span></span><br><span class="line"><span class="string">          radius: [0, '30%'],</span></span><br><span class="line"><span class="string">          label: &#123;</span></span><br><span class="line"><span class="string">            normal: &#123;</span></span><br><span class="line"><span class="string">              position: 'inner'</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">          &#125;,</span></span><br><span class="line"><span class="string">          labelLine: &#123;</span></span><br><span class="line"><span class="string">            normal: &#123;</span></span><br><span class="line"><span class="string">              show: false</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">          &#125;,</span></span><br><span class="line"><span class="string">          data: data.levels                 </span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          name: '名称',</span></span><br><span class="line"><span class="string">          type: 'pie',</span></span><br><span class="line"><span class="string">          radius: ['40%', '55%'],</span></span><br><span class="line"><span class="string">          data: data.seriesData</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      ]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    charts.setOption(options);</span></span><br><span class="line"><span class="string">    if (null != charts) &#123;</span></span><br><span class="line"><span class="string">      charts.resize();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    window.onresize = function() &#123;</span></span><br><span class="line"><span class="string">      throttle(charts.resize)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    function throttle(method, context) &#123;</span></span><br><span class="line"><span class="string">      clearTimeout(method.tId);</span></span><br><span class="line"><span class="string">      method.tId = setTimeout(function () &#123;</span></span><br><span class="line"><span class="string">        method.call(context);</span></span><br><span class="line"><span class="string">      &#125;, 200);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &lt;\/script&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>这样导出图片和html的功能就实现了</p>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【Vue】vue-i18n踩坑记录</title>
      <link href="/2017/09/05/%E3%80%90Vue%E3%80%91vue-i18n%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
      <url>/2017/09/05/%E3%80%90Vue%E3%80%91vue-i18n%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<blockquote><p>跟着官网来看着并不难，放项目里，这出错那不行的… 慢慢看文档一边整理一边尝试，最终得到了我想要的效果。暂时记下来写成博客，可能不是最好的，但目前先把问题解决了来后面再谈细节和优化的事儿吧</p></blockquote><a id="more"></a><p>折腾了一上午，犯了很多错… 最终捣鼓出来，算是完成了需求。这里说下自己的理解。Vue里的国际化，其实只是把 所谓的静态内容，标题，文字段落，提示说明等等用vue的响应式data来存储，再根据我们的配置，动态改变这些data，从而实现无刷新语言切换，这和vue自身的响应式数据是一个道理。</p><h2 id="渲染原理"><a href="#渲染原理" class="headerlink" title="渲染原理"></a>渲染原理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">VueI18n.prototype._t = <span class="function"><span class="keyword">function</span> <span class="title">_t</span> (<span class="params">key, _locale, messages, host</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> values = [], len = <span class="built_in">arguments</span>.length - <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">while</span> ( len-- &gt; <span class="number">0</span> ) values[ len ] = <span class="built_in">arguments</span>[ len + <span class="number">4</span> ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!key) &#123; <span class="keyword">return</span> <span class="string">''</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> parsedArgs = parseArgs.apply(<span class="keyword">void</span> <span class="number">0</span>, values);</span><br><span class="line">  <span class="keyword">var</span> locale = parsedArgs.locale || _locale;</span><br><span class="line">  <span class="keyword">var</span> ret = <span class="keyword">this</span>._translate(</span><br><span class="line">    messages, locale, <span class="keyword">this</span>.fallbackLocale, key,</span><br><span class="line">    host, <span class="string">'string'</span>, parsedArgs.params</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._isFallbackRoot(ret)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"development"</span> !== <span class="string">'production'</span> &amp;&amp; !<span class="keyword">this</span>._silentTranslationWarn) &#123;</span><br><span class="line">      warn((<span class="string">"Fall back to translate the keypath '"</span> + key + <span class="string">"' with root locale."</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._root) &#123; <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'unexpected error'</span>) &#125;</span><br><span class="line">    <span class="keyword">return</span> (ref = <span class="keyword">this</span>._root).t.apply(ref, [ key ].concat( values ))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._warnDefault(locale, key, ret, host)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> ref;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$t = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> values = [], len = <span class="built_in">arguments</span>.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ( len-- &gt; <span class="number">0</span> ) values[ len ] = <span class="built_in">arguments</span>[ len + <span class="number">1</span> ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> i18n = <span class="keyword">this</span>.$i18n;</span><br><span class="line">  <span class="keyword">return</span> i18n._t.apply(i18n, [ key, i18n.locale, i18n._getMessages(), <span class="keyword">this</span> ].concat( values ))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是目前用到的一个重要函数，从源码里复制出来。这里Vue原型里添加了一个$t方法，它可传入一个key参数，最后连同信息一起返回。</p><p>我们使用的$t即将想要的key 拿到写好的 locale目录下的data中查询，返回对应value这样一个过程，理解了这个思路后后面的就要好办多了。</p><hr><h2 id="项目运用"><a href="#项目运用" class="headerlink" title="项目运用"></a>项目运用</h2><p>首先安装依赖 npm install vue-i18n -D</p><p>先贴一下我的配置，然后慢慢说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> VueI18n <span class="keyword">from</span> <span class="string">'vue-i18n'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./index'</span>;</span><br><span class="line"><span class="comment">// import router from '../../router/edrPage';</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'../../store/index'</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'../../router/edrPage/index'</span>;</span><br><span class="line"><span class="comment">// 依赖包</span></span><br><span class="line"><span class="keyword">import</span> iView <span class="keyword">from</span> <span class="string">'iview'</span>;</span><br><span class="line"><span class="keyword">import</span> en <span class="keyword">from</span> <span class="string">'locale/local/en_US'</span>;</span><br><span class="line"><span class="keyword">import</span> zh <span class="keyword">from</span> <span class="string">'locale/local/zh_CN'</span>;</span><br><span class="line"><span class="keyword">import</span> zhLocale <span class="keyword">from</span> <span class="string">'locale/iviewLocale/zh-CN'</span>;</span><br><span class="line"><span class="keyword">import</span> enLocale <span class="keyword">from</span> <span class="string">'locale/iviewLocale/en-US'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'iview/dist/styles/iview.css'</span>;</span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span>;</span><br><span class="line">Vue.config.lang = <span class="string">'en'</span>;  <span class="comment">// 语言控制的开关</span></span><br><span class="line">Vue.use(VueI18n);        <span class="comment">// Vue实例中注册</span></span><br><span class="line"><span class="comment">// 定义数据</span></span><br><span class="line"><span class="keyword">const</span> messages = &#123;</span><br><span class="line">    en: <span class="built_in">Object</span>.assign(&#123;&#125;, en, enLocale),  <span class="comment">// 这里浅拷贝也可</span></span><br><span class="line">    zh: <span class="built_in">Object</span>.assign(&#123;&#125;, zh, zhLocale)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新生成i18n实例，并写入相应配置</span></span><br><span class="line"><span class="keyword">const</span> i18n = <span class="keyword">new</span> VueI18n(&#123;</span><br><span class="line">    locale: Vue.config.lang, <span class="comment">// 语言</span></span><br><span class="line">    fallbackLocale: <span class="string">'en'</span>,    <span class="comment">// 这是iView用到的</span></span><br><span class="line">    messages                 <span class="comment">// 把上面定义好的数据传入i18n</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 注册iView的同时，把i18n的配置一同传入</span></span><br><span class="line"><span class="comment">// 这样就可以在vue中无缝使用i18n和iView的国际化组件了, element同理</span></span><br><span class="line">Vue.use(iView, &#123;</span><br><span class="line">    i18n(path, options) &#123;</span><br><span class="line">      <span class="keyword">let</span> value = i18n.t(path, options);</span><br><span class="line">      <span class="keyword">if</span> (value !== <span class="literal">null</span> &amp;&amp; value !== <span class="literal">undefined</span>) <span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  <span class="comment">// i18n已有上面定义的messages了，这里在Vue实例中注入</span></span><br><span class="line">  <span class="comment">// 就可以在组件中 this.$i18n 这样来用了(这一步是i18n已帮我们做的)</span></span><br><span class="line">  i18n,</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span>,</span><br><span class="line">  components: &#123; App &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我用的iView 2.2版本i18n版本只支持到5.0+明显不成，各种问了之后看到了一个解决方案挺不错，就是上面这个。思路很简单，就是本地创建自己的语言包，然后与iView提供的包合并，其他流程走i18n自己的流程即可</p><hr><p>在单文件组件的模版中:  (用来测试的随便写了)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"login"</span> <span class="attr">class</span>=<span class="string">"bg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"switchLang"</span>&gt;</span>切换语言<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;$t('edr.footer.copyright')&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">'page-login'</span>,</span></span><br><span class="line"><span class="undefined">    data() &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        locale: <span class="string">'en'</span>,</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    mounted() &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.locale = <span class="keyword">this</span>.$i18n.locale = localStorage.getItem(<span class="string">'language'</span>) <span class="comment">// 从 localStorage 中获取语言状态</span></span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    methods: &#123;</span></span><br><span class="line"><span class="undefined">      switchLang() &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="keyword">this</span>.locale === <span class="string">'en'</span>) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.locale = <span class="keyword">this</span>.$i18n.locale = <span class="string">'zh'</span></span></span><br><span class="line"><span class="javascript">          localStorage.setItem(<span class="string">'language'</span>, <span class="string">'zh'</span>)</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.locale = <span class="keyword">this</span>.$i18n.locale = <span class="string">'en'</span></span></span><br><span class="line"><span class="javascript">          localStorage.setItem(<span class="string">'language'</span>, <span class="string">'en'</span>)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在，点击切换按钮，语言就可实时更改了~ </p><p>好了，其他的同理，在locale目录下，把我们需要切换的中英文数据管理好即可~ 如果内容多拆开来管理更好</p><hr><p>但感觉很麻烦的是，以后写静态数据都不能直接写在模版里了… 也算是长姿势了<br>至于后端返回的数据…… 暂时不知道，让后端自己先折腾吧</p><p>还有一个问题…  整个template里， 全是$t()这样的…  也不知道写了什么，占位符谁是谁… 于是，之前写好的最好还是来一层注释，或者利用良好的class命名来避免开发时的尴尬… 不然拿到同事手中只有两眼懵比了…</p>]]></content>
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> vue-i18n </tag>
            
            <tag> 国际化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【Vue】vue-cli改多页配置及踩坑笔记</title>
      <link href="/2017/08/24/%E3%80%90Vue%E3%80%91vue-cli%E6%94%B9%E5%A4%9A%E9%A1%B5%E9%85%8D%E7%BD%AE%E5%8F%8A%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/08/24/%E3%80%90Vue%E3%80%91vue-cli%E6%94%B9%E5%A4%9A%E9%A1%B5%E9%85%8D%E7%BD%AE%E5%8F%8A%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<blockquote><p>vue写起项目来很爽，效率也着实高，加上官方的vue-cli脚手架也是各种爽。不过直接搭出来是单页，在最近的项目实践上加上网上的参考。弄了套demo出来，可以参考我的项目，要是感兴趣记得start+fork下，谢谢</p></blockquote><a id="more"></a><p>那么还是一步步来来吧，也算是记下笔记，方便以后搭建新项目。</p><p>npm install vue-cli -g</p><p>vue init webpack my-project</p><p>注意，<code>node</code>和<code>npm</code>的版本，越高越好。vue-cli的配置就跳过不说了，根据需要选择ESLint，在这里单元测试就先去掉了，router记得选上</p><p>npm install<br>npm run dev</p><p>然后可以看到Hello Vue</p><p>怎么写我们知道了，这是一个单页组件。那么接下来，我们开始正式配置我们的多页路由项目吧</p><h2 id="开始配置我们的多页路由项目吧"><a href="#开始配置我们的多页路由项目吧" class="headerlink" title="开始配置我们的多页路由项目吧"></a>开始配置我们的多页路由项目吧</h2><h3 id="第一步-调整项目结构"><a href="#第一步-调整项目结构" class="headerlink" title="第一步 调整项目结构"></a>第一步 调整项目结构</h3><p>|– build<br>|– config<br>|– node_modules<br>|– src<br>|– static<br>|– … 省略了<br>|– … index.html</p><p>既然是多页，我们把 index.html 换个地方吧。这是我目前的vue项目架构（不够好，但慢慢提升学习吧，以后会更改）</p><p>你们参考下图片吧… 大致是这样</p><h3 id="第二步-修改webpack配置："><a href="#第二步-修改webpack配置：" class="headerlink" title="第二步 修改webpack配置："></a>第二步 修改webpack配置：</h3><p>需要安装一个很重要的包</p><pre><code>npm install glob --save-dev</code></pre><p>接着配置config下面的index.js文件：(增加的地方我下面标注了)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>)  <span class="comment">// - add -</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> build = &#123;</span><br><span class="line">  env: <span class="built_in">require</span>(<span class="string">'./prod.env'</span>),</span><br><span class="line">  <span class="comment">// - remove - index: path.resolve(__dirname, '../dist/index.html'),</span></span><br><span class="line">  assetsRoot: path.resolve(__dirname, <span class="string">'../dist'</span>),</span><br><span class="line">  assetsSubDirectory: <span class="string">'static'</span>,</span><br><span class="line">  assetsPublicPath: <span class="string">'/'</span>,</span><br><span class="line">  productionSourceMap: <span class="literal">true</span>,</span><br><span class="line">  productionGzip: <span class="literal">false</span>,</span><br><span class="line">  productionGzipExtensions: [<span class="string">'js'</span>, <span class="string">'css'</span>],</span><br><span class="line">  bundleAnalyzerReport: process.env.npm_config_report</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据getEntry获取所有入口主页面</span></span><br><span class="line"><span class="keyword">var</span> pages = getEntry(<span class="string">'src/pages/**/*.html'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个入口页面生成一个入口添加到build中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> pathname <span class="keyword">in</span> pages) &#123;</span><br><span class="line">  build[pathname] = path.resolve(__dirname, <span class="string">'../dist/'</span> + pathname + <span class="string">'.html'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  build: build,<span class="comment">//生成的配置build</span></span><br><span class="line">  dev: &#123;</span><br><span class="line">    env: <span class="built_in">require</span>(<span class="string">'./dev.env'</span>),</span><br><span class="line">    port: <span class="number">8080</span>,</span><br><span class="line">    autoOpenBrowser: <span class="literal">false</span>,</span><br><span class="line">    assetsSubDirectory: <span class="string">'static'</span>,</span><br><span class="line">    assetsPublicPath: <span class="string">'/'</span>,</span><br><span class="line">    proxyTable: &#123;</span><br><span class="line">      <span class="comment">// 设置代理跨域 - 根据需要来就好</span></span><br><span class="line">      <span class="string">'/api'</span>: &#123;</span><br><span class="line">        <span class="comment">// 我用了 easy-mock 意思为 项目/api 的请求实际上 会转发到 target的地址上</span></span><br><span class="line">        target: <span class="string">'https://www.easy-mock.com/mock/597a9bf0a1d30433d8401855/api/edr3/api'</span>,</span><br><span class="line">        changeOrigin: <span class="literal">true</span>,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          <span class="string">'^/api'</span>: <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    cssSourceMap: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取所有入口文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getEntry</span>(<span class="params">globPath</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> entries = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> basename;</span><br><span class="line"></span><br><span class="line">  glob.sync(globPath).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">    basename = path.basename(entry, path.extname(entry));</span><br><span class="line">    entries[basename] = entry;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> entries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就配置完了index.js了。然后是配置 <code>build/webpack.base.conf.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>) <span class="comment">//  - add -</span></span><br><span class="line"><span class="keyword">var</span> utils = <span class="built_in">require</span>(<span class="string">'./utils'</span>)</span><br><span class="line"><span class="keyword">var</span> config = <span class="built_in">require</span>(<span class="string">'../config'</span>)</span><br><span class="line"><span class="keyword">var</span> vueLoaderConfig = <span class="built_in">require</span>(<span class="string">'./vue-loader.conf'</span>)</span><br><span class="line"><span class="keyword">var</span> entries = getEntry(<span class="string">'./src/pages/**/*.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> path.join(__dirname, <span class="string">'..'</span>, dir)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// entry: &#123;</span></span><br><span class="line">  <span class="comment">//  app: './src/main.js'</span></span><br><span class="line">  <span class="comment">// &#125;,</span></span><br><span class="line">  entry: entries,  <span class="comment">// 改成这样</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: config.build.assetsRoot,</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    publicPath: process.env.NODE_ENV === <span class="string">'production'</span> ? config.build.assetsPublicPath : config.dev.assetsPublicPath</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">'.js'</span>, <span class="string">'.vue'</span>, <span class="string">'.json'</span>],</span><br><span class="line">    modules: [</span><br><span class="line">      resolve(<span class="string">'src'</span>),</span><br><span class="line">      resolve(<span class="string">'node_modules'</span>)</span><br><span class="line">    ],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'vue$'</span>: <span class="string">'vue/dist/vue.common.js'</span>,</span><br><span class="line">      <span class="string">'@'</span>: resolve(<span class="string">'src'</span>)</span><br><span class="line">      <span class="comment">// 可自行来配， 比如若配了src的alias话， vue里 写 地址可 'src/*.js' 就是 /src/*.js了</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">      loader: <span class="string">'vue-loader'</span>,</span><br><span class="line">      options: vueLoaderConfig</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">      include: [resolve(<span class="string">'src'</span>), resolve(<span class="string">'test'</span>)]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">      loader: <span class="string">'url-loader'</span>,</span><br><span class="line">      query: &#123;</span><br><span class="line">        limit: <span class="number">10000</span>,</span><br><span class="line">        name: utils.assetsPath(<span class="string">'img/[name].[hash:7].[ext]'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.(woff2?|eot|ttf|otf)(\?.*)?$/</span>,</span><br><span class="line">      loader: <span class="string">'url-loader'</span>,</span><br><span class="line">      query: &#123;</span><br><span class="line">        limit: <span class="number">10000</span>,</span><br><span class="line">        name: utils.assetsPath(<span class="string">'fonts/[name].[hash:7].[ext]'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取入口js文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getEntry</span>(<span class="params">globPath</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> entries = &#123;&#125;,</span><br><span class="line">    basename, tmp, pathname;</span><br><span class="line"></span><br><span class="line">  glob.sync(globPath).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">    basename = path.basename(entry, path.extname(entry));</span><br><span class="line">    pathname = basename.split(<span class="string">"_"</span>)[<span class="number">0</span>];</span><br><span class="line">    entries[pathname] = entry;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> entries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个文件主要是配置entry: entries入口，剩下的两个配置文件类似。直接复制了，参考以下代码：</p><p>build/webpack.dev.conf.js文件的配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> utils = <span class="built_in">require</span>(<span class="string">'./utils'</span>)</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">var</span> config = <span class="built_in">require</span>(<span class="string">'../config'</span>)</span><br><span class="line"><span class="keyword">var</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="keyword">var</span> baseWebpackConfig = <span class="built_in">require</span>(<span class="string">'./webpack.base.conf'</span>)</span><br><span class="line"><span class="keyword">var</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">var</span> FriendlyErrorsPlugin = <span class="built_in">require</span>(<span class="string">'friendly-errors-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">var</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>) <span class="comment">// 新增这两行</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(baseWebpackConfig.entry).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  baseWebpackConfig.entry[name] = [<span class="string">'./build/dev-client'</span>].concat(baseWebpackConfig.entry[name])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(baseWebpackConfig, &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: utils.styleLoaders(&#123; <span class="attr">sourceMap</span>: config.dev.cssSourceMap &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">'#cheap-module-eval-source-map'</span>,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">'process.env'</span>: config.dev.env</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">    <span class="keyword">new</span> webpack.NoEmitOnErrorsPlugin(),</span><br><span class="line">    <span class="keyword">new</span> FriendlyErrorsPlugin(),</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getEntry</span>(<span class="params">globPath</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> entries = &#123;&#125;,</span><br><span class="line">    basename;</span><br><span class="line"></span><br><span class="line">  glob.sync(globPath).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    basename = path.basename(entry, path.extname(entry));</span><br><span class="line">    entries[basename] = entry;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> entries;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pages = getEntry(<span class="string">'src/pages/**/*.html'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> pathname <span class="keyword">in</span> pages) &#123;</span><br><span class="line">  <span class="comment">// 配置生成的html文件，定义路径等</span></span><br><span class="line">  <span class="keyword">var</span> conf = &#123;</span><br><span class="line">    filename: pathname + <span class="string">'.html'</span>,</span><br><span class="line">    template: pages[pathname], <span class="comment">// 模板路径</span></span><br><span class="line">    inject: <span class="literal">true</span>, <span class="comment">// js插入位置</span></span><br><span class="line">    chunks: [pathname]</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">module</span>.exports.plugins.push(<span class="keyword">new</span> HtmlWebpackPlugin(conf));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack.prod.conf.js文件的配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>) <span class="comment">// - add - </span></span><br><span class="line"><span class="keyword">var</span> utils = <span class="built_in">require</span>(<span class="string">'./utils'</span>)</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">var</span> config = <span class="built_in">require</span>(<span class="string">'../config'</span>)</span><br><span class="line"><span class="keyword">var</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="keyword">var</span> baseWebpackConfig = <span class="built_in">require</span>(<span class="string">'./webpack.base.conf'</span>)</span><br><span class="line"><span class="keyword">var</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">'copy-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">var</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">var</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">var</span> OptimizeCSSPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">var</span> env = config.build.env</span><br><span class="line"><span class="comment">// 增加的</span></span><br><span class="line"><span class="keyword">var</span> plugins = [</span><br><span class="line">  <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">    <span class="string">'process.env'</span>: env</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">    compress: &#123;</span><br><span class="line">      warnings: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    sourceMap: <span class="literal">true</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> ExtractTextPlugin(&#123;</span><br><span class="line">    filename: utils.assetsPath(<span class="string">'css/[name].[contenthash].css'</span>)</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> OptimizeCSSPlugin(&#123;</span><br><span class="line">    cssProcessorOptions: &#123;</span><br><span class="line">      safe: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">    name: <span class="string">'vendor'</span>,</span><br><span class="line">    minChunks: <span class="function"><span class="keyword">function</span> (<span class="params">module, count</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="built_in">module</span>.resource &amp;&amp;</span><br><span class="line">        /\.js$/.test(<span class="built_in">module</span>.resource) &amp;&amp;</span><br><span class="line">        <span class="built_in">module</span>.resource.indexOf(</span><br><span class="line">          path.join(__dirname, <span class="string">'../node_modules'</span>)</span><br><span class="line">        ) === <span class="number">0</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">    name: <span class="string">'manifest'</span>,</span><br><span class="line">    chunks: [<span class="string">'vendor'</span>]</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> CopyWebpackPlugin([</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">from</span>: path.resolve(__dirname, <span class="string">'../static'</span>),</span><br><span class="line">      to: config.build.assetsSubDirectory,</span><br><span class="line">      ignore: [<span class="string">'.*'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ])</span><br><span class="line">];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getEntry</span>(<span class="params">globPath</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> entries = &#123;&#125;,</span><br><span class="line">    basename;</span><br><span class="line"></span><br><span class="line">  glob.sync(globPath).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    basename = path.basename(entry, path.extname(entry));</span><br><span class="line">    entries[basename] = entry;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> entries;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> pages = getEntry(<span class="string">'src/pages/**/*.html'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> pathname <span class="keyword">in</span> pages) &#123;</span><br><span class="line">  <span class="keyword">var</span> conf = &#123;</span><br><span class="line">    filename: process.env.NODE_ENV === <span class="string">'testing'</span> ? pathname + <span class="string">'.html'</span> : config.build[pathname],</span><br><span class="line">    template: pages[pathname],</span><br><span class="line">    inject: <span class="literal">true</span>,</span><br><span class="line">    minify: &#123;</span><br><span class="line">      removeComments: <span class="literal">true</span>,</span><br><span class="line">      collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">      removeAttributeQuotes: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 关键一行 加上，不错到时会报 webpackJsonp not defin的错</span></span><br><span class="line">    chunks: [<span class="string">'manifest'</span>, <span class="string">'vendor'</span>, pathname]</span><br><span class="line">  &#125;</span><br><span class="line">  plugins.push(<span class="keyword">new</span> HtmlWebpackPlugin(conf));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ----------增加的--</span></span><br><span class="line"><span class="keyword">var</span> webpackConfig = merge(baseWebpackConfig, &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: utils.styleLoaders(&#123;</span><br><span class="line">      sourceMap: config.build.productionSourceMap,</span><br><span class="line">      extract: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: config.build.productionSourceMap ? <span class="string">'#source-map'</span> : <span class="literal">false</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: config.build.assetsRoot,</span><br><span class="line">    filename: utils.assetsPath(<span class="string">'js/[name].[chunkhash].js'</span>),</span><br><span class="line">    chunkFilename: utils.assetsPath(<span class="string">'js/[id].[chunkhash].js'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: plugins</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> (config.build.productionGzip) &#123;</span><br><span class="line">  <span class="keyword">var</span> CompressionWebpackPlugin = <span class="built_in">require</span>(<span class="string">'compression-webpack-plugin'</span>)</span><br><span class="line">  webpackConfig.plugins.push(</span><br><span class="line">    <span class="keyword">new</span> CompressionWebpackPlugin(&#123;</span><br><span class="line">      asset: <span class="string">'[path].gz[query]'</span>,</span><br><span class="line">      algorithm: <span class="string">'gzip'</span>,</span><br><span class="line">      test: <span class="keyword">new</span> <span class="built_in">RegExp</span>(</span><br><span class="line">        <span class="string">'\\.('</span> +</span><br><span class="line">        config.build.productionGzipExtensions.join(<span class="string">'|'</span>) +</span><br><span class="line">        <span class="string">')$'</span></span><br><span class="line">      ),</span><br><span class="line">      threshold: <span class="number">10240</span>,</span><br><span class="line">      minRatio: <span class="number">0.8</span></span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (config.build.bundleAnalyzerReport) &#123;</span><br><span class="line">  <span class="keyword">var</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin</span><br><span class="line">  webpackConfig.plugins.push(<span class="keyword">new</span> BundleAnalyzerPlugin())</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig</span><br></pre></td></tr></table></figure><p>好了，所有配置文件写完。但现在还跑不起来，我们再把 <code>src/pages</code> <code>src/router</code> 目录下的文件改一改，具体参考我的项目</p><p>就可以跑起来我们的vue多页项目了</p>]]></content>
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> webpack </tag>
            
            <tag> vue-cli </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【JS】深入理解ES6——Promise与异步编程</title>
      <link href="/2017/08/12/%E3%80%90JS%E3%80%91%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E2%80%94%E2%80%94Promise%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
      <url>/2017/08/12/%E3%80%90JS%E3%80%91%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E2%80%94%E2%80%94Promise%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<blockquote><p>Promise可以实现其他语言类似Future和Deferred一样的功能，是另一种异步编程的选择。它既可以像事件和回调函数一样指定稍后执行的代码，也可以明确指示代码是否成功执行。本文重在讨论Promise是如何运转的，所以实践和代码依然是我们的重点，要完全理解其原理，了解构建Promise的一些基本概念尤为重要。</p></blockquote><a id="more"></a><h2 id="异步编程相关知识点"><a href="#异步编程相关知识点" class="headerlink" title="异步编程相关知识点"></a>异步编程相关知识点</h2><p>我们知道的JS是单线程，具体来说：JavaScritp引擎同一时刻只允许执行一个代码块。那么就需要跟踪即将运行的代码块，那些代码块将被添加到任务队列。每当JavaScript引擎中的一段代码结束执行，事件循环会执行队列中的下一个任务，它（事件循环）是JS引擎中的一段程序，负责监控代码执行并管理任务队列。</p><h3 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h3><p>我们先来看一段代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'#btn'</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'clicked!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单击btn会打印出 clicked 来，这个过程是先赋值给onclick的函数被添加到任务队列中，只有前面的任务都完成后它才会被执行</p><h3 id="回调模式"><a href="#回调模式" class="headerlink" title="回调模式"></a>回调模式</h3><p>回调模式与事件模型类似，异步代码都会在未来的某个时间点执行，二者区别是回调函数中被调用的函数是作为参数传入的，示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">readFile(<span class="string">'example.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(contents);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br></pre></td></tr></table></figure><p>readFile执行，但当去读取文件时就会暂停，转而执行后面的程序，打印出了hi，当readFile()结束执行时，会向任务队列的末尾添加一个新任务，该任务包含回调函数及相应的参数，当队列前面所有的任务完成才执行该任务，并最终执行<code>console.log(contents)</code></p><p>现在来看还是很方便的，但如果执行的回调任务多了…… 那么头皮发麻是一定的…… 所以 -&gt; 才有了后面的Promise ~ 只有生成器、Async啥的放后面来说了，扎扎实实打基础先。</p><h2 id="Promise基础"><a href="#Promise基础" class="headerlink" title="Promise基础"></a>Promise基础</h2><p>Promise相当于异步操作结果的占位符，它既不订阅也不传回调，而是让函数返回一个Promise<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// readFile承诺将在未来的某个时刻完成</span></span><br><span class="line"><span class="keyword">let</span> promise = readFile(<span class="string">'exm.txt'</span>);</span><br></pre></td></tr></table></figure></p><p>这段代码，readFile()并不会立即开始读取文件，函数会先返回一个表示异步读取操作的Promise对象，未来对这个对象的操作完全取决于Promise的生命周期。</p><h3 id="Promise的生命周期"><a href="#Promise的生命周期" class="headerlink" title="Promise的生命周期"></a>Promise的生命周期</h3><ul><li>Fulfilled Promise异步操作成功完成</li><li>Rejected  Promise异步操作未能成功完成</li></ul><p>内部属性[[PromiseState]]被用来表示Promise的三种状态：<code>pending</code>、<code>fulfilled</code>及<code>rejected</code>。只有当Promise的状态改变时，通过then()方法来采取特定的行动。<br>Promise具有then方法，它接受两个参数，第一个是当Promise状态转变为fulfilled时要调用的函数；第二个是当Promise状态变为rejected时要调用的函数。</p><blockquote><p>如果一个对象实现了上述的then()方法，那这个对象我们称之为thenable对象。所有的Promise都是thenable对象</p></blockquote><p>每次调用then或catch方法都会创建一个新任务，当Promise被resolved时执行，这些任务最终会被加入到一个为Promise量身定制的队列中</p><h3 id="创建未完成的Promise"><a href="#创建未完成的Promise" class="headerlink" title="创建未完成的Promise"></a>创建未完成的Promise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node.js示例</span></span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 触发异步操作</span></span><br><span class="line">    fs.readFile(filename, &#123;<span class="attr">encoding</span>: <span class="string">'utf8'</span>&#125;, (err, contents) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 检查是否有错</span></span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 成功读取文件</span></span><br><span class="line">      resolve(contents);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> promise = readFile(<span class="string">'example.txt'</span>);</span><br><span class="line"><span class="comment">// 同时监听执行完成和执行被拒</span></span><br><span class="line">promise.then(<span class="function"><span class="params">contents</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 完成</span></span><br><span class="line">  <span class="built_in">console</span>.log(contents);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 拒绝</span></span><br><span class="line">  <span class="built_in">console</span>.log(err.message);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="全局的Promise拒绝处理"><a href="#全局的Promise拒绝处理" class="headerlink" title="全局的Promise拒绝处理"></a>全局的Promise拒绝处理</h2><p>有关Promise的其中一个最具争议的问题是，如果没有拒绝处理程序的情况下拒绝一个Promise，那么不会提示失败信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected = <span class="built_in">Promise</span>.reject(<span class="number">42</span>);</span><br><span class="line"><span class="comment">// 此rejected还没有被处理</span></span><br><span class="line">rejected.catch(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 现在rejected已经被处理了</span></span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="我们来看看在Node-js环境下的拒绝处理"><a href="#我们来看看在Node-js环境下的拒绝处理" class="headerlink" title="我们来看看在Node.js环境下的拒绝处理"></a>我们来看看在Node.js环境下的拒绝处理</h3><ul><li>unhandledRejection 在一个<code>事件循环中</code>，当Promise被拒绝，并且没有提供拒绝处理程序时被调用</li><li>rejectionHandled 在一个<code>事件循环后</code>，当Promise被拒绝，并且没有提供拒绝处理程序时被调用</li></ul><p>我们还是来看一下实际代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected;</span><br><span class="line">process.on(<span class="string">'unhandledRejection'</span>, (reason, promise) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason.message); <span class="comment">// 'explosion'</span></span><br><span class="line">  <span class="built_in">console</span>.log(rejected === promise); <span class="comment">// true</span></span><br><span class="line">&#125;)</span><br><span class="line">rejected = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Explosion'</span>));</span><br></pre></td></tr></table></figure><p>以上代码创建了一个已拒绝的Promise和一个错误对象，并监听了unhandledRejection事件，事件处理程序分别接受错误对象和Promise作为它的两个参数。<br>rejectionHandled事件处理程序只有一个参数——被拒绝的Promise：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected;</span><br><span class="line">process.on(<span class="string">'rejectionHandled'</span>, promise =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(rejected === promise); <span class="comment">// true  </span></span><br><span class="line">&#125;);</span><br><span class="line">rejected = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Explosion'</span>));</span><br><span class="line"><span class="comment">// 等待添加拒绝错误处理</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  rejected.catch(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value.message);  <span class="comment">// 'Explosion'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>这里的rejectionHandled事件在拒绝处理程序最后被调用时触发，如果在创建rejected之后直接添加拒绝处理程序，那么rejectionHandled事件不会被触发，因为rejected创建的过程与拒绝处理程序的调用在同一个事件循环中，此时rejectionHandled事件尚未生效。</p><h3 id="浏览器环境的拒绝处理"><a href="#浏览器环境的拒绝处理" class="headerlink" title="浏览器环境的拒绝处理"></a>浏览器环境的拒绝处理</h3><p>浏览器也是通过触发两个事件来识别未处理的拒绝的，虽然这些事件是在window对象上触发的，但实际上与Node.js中的完全等效</p><ul><li>unhandledrejection 同上Node.js</li><li>rejectionhandled 同上Node.js</li></ul><p>在Node.js的实现中，事件处理程序接受多个独立参数，而在浏览器中，事件处理程序接受一个有以下属性的事件对象作为参数：</p><ul><li>type 事件名称（’unhandledrejection’或’rejectionhandled’）</li><li>promise 被拒绝的Promise对象</li><li>reason 来自Promise的拒绝值</li></ul><p>浏览器实现中固定另一处不同是，在两个事件中都可以使用拒绝值reason，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected;</span><br><span class="line"><span class="built_in">window</span>.onhandledrejection = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.type); <span class="comment">// 'unhandledrejection'</span></span><br><span class="line">  <span class="built_in">console</span>.log(event.reason.message); <span class="comment">// 'Explosion'</span></span><br><span class="line">  <span class="built_in">console</span>.log(rejected === event.promise); <span class="comment">// true</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.onrejectionhandled = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.type); <span class="comment">// 'rejectionhandled'</span></span><br><span class="line">  <span class="built_in">console</span>.log(event.reason.message); <span class="comment">// 'Explosion'</span></span><br><span class="line">  <span class="built_in">console</span>.log(rejected === event.promise); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line">rejected = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Explosion'</span>));</span><br></pre></td></tr></table></figure><p>以上Node.js环境与浏览器环境中的处理差不多，区别在于，事件处理程序中检索信息的位置不同。</p><h2 id="串联Promise"><a href="#串联Promise" class="headerlink" title="串联Promise"></a>串联Promise</h2><p>每次调用then或catch方法时实际上创建并返回了另一个Promise，只有当第一个Promise完成或被拒绝后，第二个才会被解决，示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">42</span>);</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value))</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Finished'</span>))</span><br><span class="line"><span class="comment">// 42</span></span><br><span class="line"><span class="comment">// Finished</span></span><br></pre></td></tr></table></figure><p>调用p1.then后返回第二个Promise，然后又调用then，只有当第一个Promise被解决后才会调用第二个then的完成处理程序，如果将拆开，可写成如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">42</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value));</span><br><span class="line">p2.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Finished'</span>));</span><br></pre></td></tr></table></figure><p>在这个非串联版本的代码中，调用p1.then()的结果被存储在了p2中，然后p2.then()被调用来添加最终的完成处理程序。</p><h3 id="捕捉错误"><a href="#捕捉错误" class="headerlink" title="捕捉错误"></a>捕捉错误</h3><p>在之前的示例中，完成处理程序或拒绝处理程序中可能发生错误，而Promise链可以用来捕获这些错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">42</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Boom'</span>))</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err.message));</span><br></pre></td></tr></table></figure><p>p1完成处理程序，而后抛错，链式调用第二个Promise的catch方法后，可以通过它的拒绝处理程序接收这个错误，如果拒绝处理程序抛出错误，也可以通过相同的方式接收到这个错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Explosion'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error.message); <span class="comment">// 'Explosion'</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Boom'</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err.message); <span class="comment">// 'Boom'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此处的执行器抛出错误并触发Promise p1的拒绝处理程序，这个处理程序又抛出另一个错，并且第二个Promise拒绝处理程序捕获，链式Promise调用可以感知到链中其他Promise错误。</p><p>注：务必在Promise链的末尾留有一个拒绝处理程序以确保能正确处理所有可能发生的错误</p><h3 id="Promise链的返回值"><a href="#Promise链的返回值" class="headerlink" title="Promise链的返回值"></a>Promise链的返回值</h3><p>Promise链可以给下游Promise传递数据。 上面代码很多都已经显示出了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="number">66</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.catch(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// '66'</span></span><br><span class="line">  <span class="keyword">return</span> value + <span class="number">1</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value)); <span class="comment">// '67'</span></span><br></pre></td></tr></table></figure><p>执行器调用reject方法向Promise的拒绝处理程序传入值66，最终返回value+1。拒绝处理程序中返回的值仍可用在下一个Promise的完成处理程序中，在必要时，即使其中一个Promise失败也能恢复整条链的执行。</p><h3 id="Promise链中返回Promise"><a href="#Promise链中返回Promise" class="headerlink" title="Promise链中返回Promise"></a>Promise链中返回Promise</h3><p>同样的还是来看例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">8</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 第一个完成处理程序</span></span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 6</span></span><br><span class="line">  <span class="keyword">return</span> p2;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 第二个完成处理程序</span></span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 8</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>关于这个模式需要注意的是，第二个完成处理程序被添加到了第三个Promise而不是p2。我们来看另一种可能发生的情况</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">66</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="number">88</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 第一个完成处理程序</span></span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 66</span></span><br><span class="line">  <span class="keyword">return</span> p2;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 第二个完成处理程序</span></span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 从未调用</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个示例中由于p2被拒绝了，所以处理程序永不会被调用，所以，无论怎样，我们都应添加一个拒绝处理程序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">66</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="number">88</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 第一个完成处理程序</span></span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 66</span></span><br><span class="line">  <span class="keyword">return</span> p2;</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 拒绝处理程序</span></span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 88</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>p2被拒绝后，拒绝处理程序被调用并传入p2的拒绝值 88.</p><h2 id="响应多个Promise"><a href="#响应多个Promise" class="headerlink" title="响应多个Promise"></a>响应多个Promise</h2><p>在ES6中可以使用Promise.all()和Promise.race()方法来监听多个Promise</p><h3 id="Promise-all-和-Promise-race"><a href="#Promise-all-和-Promise-race" class="headerlink" title="Promise.all() 和 Promise.race()"></a>Promise.all() 和 Promise.race()</h3><p>该方法只接受一个参数并返回一个Promise，该参数是一个含有多个受监视Promise的可迭代对象。只有当可迭代对象中所有Promise都被解决后返回的Promise才会被解决，只有当可迭代对象中所有Promise都被完成后返回的Promise才会被完成，示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">66</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">88</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">99</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br><span class="line">p4.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(value)); <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">console</span>.log(value[<span class="number">0</span>]); <span class="comment">//66</span></span><br><span class="line">  <span class="built_in">console</span>.log(value[<span class="number">1</span>]); <span class="comment">//88</span></span><br><span class="line">  <span class="built_in">console</span>.log(value[<span class="number">2</span>]); <span class="comment">//99</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于所有传入Promise.all()方法的Promise只要有一个被拒绝，那么返回的Promise没等所有Promise都完成就立即被拒绝</p><p><strong>Promise.race()</strong></p><p>该方法监听多个Promise方法，与all稍有不同的是，只要有一个Promise被解决，返回的Promise就被解决，毋须等到所有Promise都被完成。一旦数组中某个Promise被完成，Promise.race()也会像Promise.all()一样返回特定的Promise</p><h2 id="基于Promise的异步任务执行"><a href="#基于Promise的异步任务执行" class="headerlink" title="基于Promise的异步任务执行"></a>基于Promise的异步任务执行</h2><p>来点实战~</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="comment">/* 创建可以在其他地方使用的迭代器 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> task = taskDef();</span><br><span class="line">  <span class="comment">// 开始执行任务</span></span><br><span class="line">  <span class="keyword">let</span> result = task.next();</span><br><span class="line">  <span class="comment">// 不断调用next()的递归函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果有更多任务要做</span></span><br><span class="line">    <span class="keyword">if</span> (!result.done) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> result.value === <span class="string">'function'</span>) &#123;</span><br><span class="line">        result.value(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            result = task.throw(err);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          result = task.next(data);</span><br><span class="line">          step();</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = task.next(result.value);</span><br><span class="line">        step();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 启动递归进程</span></span><br><span class="line">  step();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 定义一个可用于任务执行器的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(filename, callback);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 执行一个任务 */</span></span><br><span class="line">run(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> contents = <span class="keyword">yield</span> readFile(<span class="string">'config.json'</span>);</span><br><span class="line">  doSomethingWith(contents);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Done'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>实现起来多多少少还是有一些问题：</p><ol><li>逻辑让人困惑（在返回值是函数的函数中包裹每一个函数）</li><li>无法区分返回值（用作任务执行器回调函数的返回值和一个不是回调函数的返回值）</li></ol><p>说了这么多，于是用Promise来改写主要逻辑部分吧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建迭代器</span></span><br><span class="line">  <span class="keyword">let</span> task = taskDef();</span><br><span class="line">  <span class="comment">// 开始执行任务</span></span><br><span class="line">  <span class="keyword">let</span> result = task.next();</span><br><span class="line">  <span class="comment">// 递归函数遍历</span></span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果有更多任务要做</span></span><br><span class="line">    <span class="keyword">if</span> (!result.done) &#123;</span><br><span class="line">      <span class="comment">// 用一个Promise来解决会简化问题</span></span><br><span class="line">      <span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(result.value);</span><br><span class="line">      promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        result = task.next(value);</span><br><span class="line">        step();</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        result = task.throw(err);</span><br><span class="line">        step();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个可用于任务执行器的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(filename, (err, contents) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(contents);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行一个任务</span></span><br><span class="line">run(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> contents = <span class="keyword">yield</span> readFile(<span class="string">'config.json'</span>);</span><br><span class="line">  doSomethingWith(contents);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Done'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在该版本中，一个通用的run()函数执行生成器创建一个迭代器，它调用task.next()方法来启动任务并递归调用step()方法直到迭代器完成。</p><p><strong>未来的异步任务执行</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略部分代码</span></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> contents = <span class="keyword">await</span> readFile(<span class="string">'config.json'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Done'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在函数前添加关键字async表示该函数以异步模式运行，await关键字表示调用readFile(‘config.json’)的函数应该返回一个Promise，否则，响应应该被包裹在Promise中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Promise的设计目标是改进JavaScript中的异步编程，它能够更好地掌控并组合多个同步操作，比事件系统和回调更符合我们的逻辑认知。</p><ol><li>执行Promise，会将其内部的任务添加到JS引擎队列并在未来执行</li><li>Promise有3个状态：pending进行中、fulfilled已完成和rejected已拒绝，一旦进入pending只能变成已完成或已拒绝且该过程不可逆</li><li>通过then方法可以添加完成处理程序或拒绝处理程序，通过catch方法智能添加拒绝处理程序</li><li>通过Promise.all()或Promise.race()来处理多个执行任务</li><li>迭代器及Async都是基于Promise实现的，让我们拥抱Promise进行异步编程</li></ol>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> ES6 </tag>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【JS】深入理解ES6——JavaScript中的类</title>
      <link href="/2017/08/02/%E3%80%90JS%E3%80%91%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E2%80%94%E2%80%94JavaScript%E4%B8%AD%E7%9A%84%E7%B1%BB/"/>
      <url>/2017/08/02/%E3%80%90JS%E3%80%91%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E2%80%94%E2%80%94JavaScript%E4%B8%AD%E7%9A%84%E7%B1%BB/</url>
      <content type="html"><![CDATA[<blockquote><p>理解类的基本原理有助于理解ES6中类的特性，在该篇文章里我们先探讨ES5语法是如何实现类似特性的，再对比ES6的语法对比来学习</p></blockquote><p>首先，你要知道的是ES6中的类和Java等其他面向对象编程语言是完全不同的。 当然，这是我说的… 我们可认为这是ES6之前实现类及继承的一些语法糖，实则还是面向对象的形式。</p><a id="more"></a><h2 id="使用ES6的类语法"><a href="#使用ES6的类语法" class="headerlink" title="使用ES6的类语法"></a>使用ES6的类语法</h2><p>首先我们要知道的是，ESMAScript5及早期版本中是没有类的概念的。<br>最相近的思路是创建一个自定义类型，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayname = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'fri'</span>);</span><br><span class="line">person.sayname(); <span class="comment">// 'fri'</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面的代码首先创造一个构造函数，然后定义方法并赋值给构造函数的原型，从而实现继承。</p><h3 id="基本类声明"><a href="#基本类声明" class="headerlink" title="基本类声明"></a>基本类声明</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 等价于上面的Person构造函数</span></span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 等价于Person.prototype.sayname</span></span><br><span class="line">  sayname() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">'fri'</span>);</span><br><span class="line">person.sayname(); <span class="comment">// 'fri'</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person); <span class="comment">// 'function'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person.prototype.sayname); <span class="comment">// 'function'</span></span><br></pre></td></tr></table></figure><p>通过对比，可以看出，这里通过在<code>constructor</code>方法名来定义构造函数，<code>其私有属性是实例中的属性，不会出现在原型上，且只有在类的构造函数或方法中创建</code>，上面的name就是一个私有属性</p><p>类声明仅仅是基于已有自定义类型声明的语法糖。所以，<code>Person</code>声明实际上创建了一个具有构造函数方法行为的函数。</p><hr><h3 id="为何使用类语法"><a href="#为何使用类语法" class="headerlink" title="为何使用类语法"></a>为何使用类语法</h3><p>尽管类与自定义类型之间拥有诸多相似处，但我们更需牢记以下差异性：</p><ul><li>函数声明可以被提升，而类声明与let声明类似，不能被提升；真正执行声明语句之前，它们会一直存在于临时死区中</li><li>类声明中的所有代码将自动运行在严格模式下，而且无法强行让代码脱离严格模式执行</li><li>在自定义类型中，需要通过<code>Object.defineProperty()</code>方法手工制定某个方法为不可枚举；而在类中，所有方法都是不可枚举的</li><li>每个类都有一个名为[[Construct]]的内部方法，通过关键字new调用那些不含[[Construct]]的方法会导致程序抛出错误</li><li>使用除关键字new以外的方式调用类的构造函数会导致程序抛出错误</li><li>在类中修改类名会导致程序报错</li></ul><h3 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h3><p><strong>基本的类表达式语法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Person = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ... 代码省略，和上面的类一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：</p><ol><li>类表达式不需要标识符在类后</li><li>类表达式在功能上等价于类声明</li><li>类声明和类表达式均不会被提升</li></ol><p>接第3点，二者最重要的区别是，name属性不同，匿名类表达式的name属性值是一个空字符串，而类声明的name属性值为类名。</p><p><strong>命名类表达式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Person = <span class="class"><span class="keyword">class</span> <span class="title">Person2</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...代码省略, 同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于标识符 Person2只存在于类定义中，因此它可被用在像sayname()这样的方法中，而在类外部，不存在名为Person2的绑定，因而typeof Person2的值为undefined</p><p>在JS引擎中，类表达试的实现与类声明稍有不同。类声明通过<code>let定义的外部绑定</code>与通过<code>const定义的内部绑定</code>具有相同名称；而<code>命名类表达式通过const定义</code>名称，从而上例的Person2只能在类内部使用。</p><h3 id="作为一等公民的类"><a href="#作为一等公民的类" class="headerlink" title="作为一等公民的类"></a>作为一等公民的类</h3><blockquote><p>在程序中，一等公民是制一个可以传入函数，可从函数返回，且可赋值给变量的值。</p></blockquote><p>那么，JS中的函数自然是一等公民，类其实就是这样一个语法糖所以也是一等公民。JS允许通过多种方式使用类的特性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例，可以将类作为参数传入函数中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject</span>(<span class="params">classDef</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> classDef();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = createObject(<span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hi!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">obj.sayHi(); <span class="comment">// 'Hi'</span></span><br></pre></td></tr></table></figure><p>上例通过调用<code>createObject()</code>函数时传入一个匿名类表达式作为参数，然后通过new实例化这个类并返回其实例赋值给变量obj。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  sayname() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="string">'fri'</span>);</span><br><span class="line">person.sayname(); <span class="comment">// 'fri'</span></span><br></pre></td></tr></table></figure><p>这里创建一个立即执行的匿名类表达式，此模式可以使用类语法创建单例，且不会在作用域中暴露类的引用，后面的小括号表明正在调用函数，所以可给函数传参。</p><h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>尽管应该在类构造函数中创建其属性，但类也支持直接在原型上定义访问器属性。如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHtmlElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element;</span><br><span class="line">  &#125;</span><br><span class="line">  get html() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML;</span><br><span class="line">  &#125;</span><br><span class="line">  set html(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.element.innerHTML = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnpropertyDescriptor(CustomHtmlElement.prototype, <span class="string">'html'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'get'</span> <span class="keyword">in</span> descriptor); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'set'</span> <span class="keyword">in</span> descriptor); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>代码中CustomHtmlElement类是一个针对现有DOM元素的包装器，通过getter和setter方法将元素的innerHTML方法委托给html属性，该属性访问器是在CustomHtmlElement.prototype上创建的，与其他方法相同，创建时声明该属性不可枚举</p><h3 id="可计算成员名称"><a href="#可计算成员名称" class="headerlink" title="可计算成员名称"></a>可计算成员名称</h3><p>类和对象字面量有很多相似处，类方法和访问器属性支持使用可计算名称，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mothodName = <span class="string">'sayName'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过变量来给类定义中的方法命名</span></span><br><span class="line">  [methodName]() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> Person(<span class="string">'fri'</span>);</span><br><span class="line">me.sayName(); <span class="comment">// 'fri'</span></span><br></pre></td></tr></table></figure><p>通过相同方式可以在属性⑦属性中计算可计算名称</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> propertyName = <span class="string">'html'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHtmlElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element;</span><br><span class="line">  &#125;</span><br><span class="line">  get [propertyName]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML;</span><br><span class="line">  &#125;</span><br><span class="line">  set [propertyName](value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.element.innerHTML = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过propertyName变量并使用<code>getter</code>和<code>setter</code>方法为类添加html属性，且可像往常一样通过 <code>.html</code>访问该属性</p><h3 id="生成器方法"><a href="#生成器方法" class="headerlink" title="生成器方法"></a>生成器方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  *createIterator() &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="keyword">let</span> iterator = instance.createIterator();</span><br></pre></td></tr></table></figure><p>以上代码创建了MyClass类，它有一个生成器方法<code>createIterator</code>，其返回值为一个硬编码在生成器中的迭代器。<br>如果想要类是用来表示集合的，那么为它定义一个默认迭代器会更好，例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.items = [];</span><br><span class="line">  &#125;</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">yield</span> *<span class="keyword">this</span>.items.values();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> collection = <span class="keyword">new</span> Collection();</span><br><span class="line">collection.items.push(<span class="number">1</span>);</span><br><span class="line">collection.items.push(<span class="number">2</span>);</span><br><span class="line">collection.items.push(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> collection) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>现在可以将Collection的实例用于for-of循环中，或用展开运算符操作。</p><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>ES5之前我们通常这么来用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line">Person.create = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Person(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例方法</span></span><br><span class="line">Person.prototype.sayname = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = Person.create(<span class="string">'fri'</span>);</span><br></pre></td></tr></table></figure><p>由于工厂方法<code>Person.create()</code>使用的数据不依赖Person的实例，因而其会被认为是一个静态方法。<br>ES6的类语法简化了该过程，下面我们用ES6语法重写上面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 等价于Person构造函数</span></span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 等价于Person.prototype.sayname</span></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 等价于Person.create</span></span><br><span class="line">  <span class="keyword">static</span> create(name) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = Person.create(<span class="string">'fri'</span>);</span><br></pre></td></tr></table></figure><p>Person有一个静态方法<code>create()</code>，它的语法与sayname()的区别只在于是否使用<code>static关键字</code>。<br>类中的所有方法和访问器属性都可以用static关键字来定义，唯一的限制是不能将static用于定义构造函数方法。</p><p>注：不可在实例中访问静态成员，必须要直接在类中访问静态成员</p><h3 id="继承与派生类"><a href="#继承与派生类" class="headerlink" title="继承与派生类"></a>继承与派生类</h3><p>同样的，我们来看看ES5的写法，再对比下ES6写法来学习</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length, width</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.length = length;</span><br><span class="line">  <span class="keyword">this</span>.width = width;</span><br><span class="line">&#125;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">length</span>) </span>&#123;</span><br><span class="line">  Rectangle.call(<span class="keyword">this</span>, length, length);</span><br><span class="line">&#125;</span><br><span class="line">Square.prototype = <span class="built_in">Object</span>.create(Rectangle.prototype, &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: &#123;</span><br><span class="line">    value: Square,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(square.getArea()); <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Square); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Rectangle); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>为了实现继承，必须用一个创建自<code>Rectangle.prototype</code>的新对象重写<code>Square.prototype</code>，并调用Rectangle.call()方法。<br>那么我们看下ES6能做哪些简化，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">  getArea() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="comment">// 等价于Rectangle.call(this, length, length)</span></span><br><span class="line">    <span class="keyword">super</span>(length, length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> square = <span class="keyword">new</span> Square(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(square.getArea()); <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Square); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Rectangle); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Square类通过<code>extends关键字</code>继承Rectangle类，在Square构造函数中通过super()调用Rectangle构造函数并传入相应参数。<br>继承自其他类的类被称作为派生类，如果在派生类中指定了构造函数则必须要调用super()。<br>如果选择不使用构造函数，则当创建新的类实例时会自动调用super()并传入所有参数</p><p><strong>使用super()注意事项</strong></p><ul><li>只可在派生类的构造函数中使用super()</li><li>在构造函数中访问this之前一定要调用super() <code>它负责初始化this</code></li><li>若不想调用super()，唯一方法是让类的构造函数返回一个对象</li></ul><h3 id="类方法遮蔽"><a href="#类方法遮蔽" class="headerlink" title="类方法遮蔽"></a>类方法遮蔽</h3><p>派生类中的方法总会覆盖基类中的同名方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="keyword">super</span>(length, length);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 覆盖并遮蔽Rectangle.prototype.getArea()方法</span></span><br><span class="line">  getArea() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Square里定义了getArea方法，便不能在Square的实例中调用Rectangle.prototype.getArea方法。若想调用，可如下使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="keyword">super</span>(length, length);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 覆盖遮蔽后调用Rectangle.prototype.getArea()</span></span><br><span class="line">  getArea() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getArea();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以这种方法使用super，this的值会被自动正确设置</p><h3 id="静态成员继承"><a href="#静态成员继承" class="headerlink" title="静态成员继承"></a>静态成员继承</h3><p>如果基类有静态成员，那么这些静态成员在派生类中也可用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">  getArea() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> create(length, width) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Rectagnle(length, width);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="comment">// 等价于Rectangle.call(this, length, length)</span></span><br><span class="line">    <span class="keyword">super</span>(length, length)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> rect = Square.create(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> Rectangle); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(rect.getArea()); <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> Square); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>以上代码中，新的静态方法create()被添加到Rectangle类中，继承后的Square.create()与Rectangle.create()的行为相似</p><h3 id="派生自表达式的类"><a href="#派生自表达式的类" class="headerlink" title="派生自表达式的类"></a>派生自表达式的类</h3><p>只要表达式可以被解析为一个函数并且具有[[Construct]]属性和原型，那么就可以用extends进行派生。我们还是由下面的例子来看：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length, width</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.length = length;</span><br><span class="line">  <span class="keyword">this</span>.width = width;</span><br><span class="line">&#125;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="keyword">super</span>(length, width);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Square(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(x.getArea()); <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(x <span class="keyword">instanceof</span> Rectangle); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Rectagnle是ES5风格的构造函数，Square是一个类，由于Rectangle具有[[Construct]]属性和原型，因此Square类可以直接继承它。<br>由于可以动态确定使用哪个基类，因而可以创建不同的继承方法。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> SerializableMixin = &#123;</span><br><span class="line">  serialize() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> AreaMixin = &#123;</span><br><span class="line">  getArea() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">...mixins</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> base = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="built_in">Object</span>.assign(base.prototype, ...mixins);</span><br><span class="line">  <span class="keyword">return</span> base;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">mixin</span>(<span class="title">AreaMixin</span>, <span class="title">SerializableMixin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">this</span>.width = length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Square(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(x.getArea()); <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(x.serialize()); <span class="comment">// "&#123;"length": 3, "width": 3&#125;"</span></span><br></pre></td></tr></table></figure><p>mixin函数会用所有mixin对象的自有属性动态填充新函数的原型，如果多个mixin对象具有相同的属性，那么只有最后一个被添加的属性被保留</p><blockquote><p>在<code>extends</code>后可以使用任意表达式，但不是所有表达式最终都能生成合成的类。如果使用null或生成器函数会导致错误，类在这些情况下没有[[Construct]]属性，尝试为其创建新的实例会导致程序无法调用[[Construct]]而报错</p></blockquote><h3 id="内建对象的继承"><a href="#内建对象的继承" class="headerlink" title="内建对象的继承"></a>内建对象的继承</h3><p>在ES5的传统继承方式中，先由派生类型创建this的值，然后调用基类型的构造函数。this的值开始指向构造函数的实例，但是随后会被来自内建对象的其他属性所修饰。<br>ES6中的类则于之相反，先由基类创建this的值，然后派生类的构造函数再修改这个值，所以一开始可以通过this访问基类的所有内建功能，然后再正确地接受所有与之相关的功能。<br>以下示例是一个基于类生成特殊数组的实践：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> MyArray();</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">'red'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(colors.length); <span class="comment">// 1</span></span><br><span class="line">colors.length = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>]); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="Symbol-species属性"><a href="#Symbol-species属性" class="headerlink" title="Symbol.species属性"></a>Symbol.species属性</h3><p>内建对象继承的一个使用之处是，原本在内建对象中返回实例自身的方法将自动返回派生类的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> items = <span class="keyword">new</span> MyArray(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>),</span><br><span class="line">  subitems = items.slice(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(items <span class="keyword">instanceof</span> MyArray); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(subitems <span class="keyword">instanceof</span> MyArray); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这里slice()方法返回的是MyArray的实例，浏览器引擎背后是通过<code>Symbol.species</code>属性实现这一行为的</p><p>该属性用于定义返回函数的静态访问器属性，每当要在实例的方法中创建类的实例时必须使用这个构造函数。</p><p><strong>以下这些内建类型均已定义Symbol.species属性：</strong></p><ul><li>Array</li><li>ArrayBuffer</li><li>Map</li><li>Promise</li><li>RegExp</li><li>Set</li><li>Typed arrays</li></ul><p>列表中的每个类型都有一个默认的Symbol.species属性，该属性的返回值为this，这也意味着该属性总会返回构造函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">return</span> value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  clone() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.constructor[<span class="built_in">Symbol</span>.species](<span class="keyword">this</span>.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该例中<code>Symbol.species</code>被用来给MyClass赋值静态访问器属性，这里只有getter而没有setter方法，因为在这里不可以改变类的种类。<br>调用<code>this.constructor[Symbol.species]</code>会返回MyClass，clone方法通过这个定义可以返回新的实例，从而允许派生类覆盖这个值</p><h3 id="在类的构造函数中使用new-target"><a href="#在类的构造函数中使用new-target" class="headerlink" title="在类的构造函数中使用new.target"></a>在类的构造函数中使用new.target</h3><p>来类的构造函数中也可以通过new.target来确定类是如何被调用的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// new.target的值是Rectangle</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上例当调用<code>new Rectangle(3,4)</code>时等价于Rectangle的new.target。类构造函数必须通过new关键字调用，所以总是在类的构造函数中定义new.target属性，但是其值有时不同，我们来看另一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="keyword">super</span>(length, length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// new.target的值是Square</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Square(<span class="number">3</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>这里的super调用了Rectangle的构造函数，所以当调用发生时new.target等于Square。每个构造函数可以根据自身被调用的方式改变自己的行为，我们再来看个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === Shape) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'这个类不能直接被实例化'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Shape(); <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(y <span class="keyword">instanceof</span> Shape); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>每当new.target是Shape的构造函数时总会报错，但仍可用Shape作为基类派生其他类。<br>super()调用实行了Shape的构造函数，new.target与Rectangle等价，所以构造函数继续执行不会报错。</p><p>注：类必须通过new关键字才能调用，所以在类的构造函数中，new.target属性永远不会是undefined</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>ES6的类语法作为ES5传统继承模型的语法糖出现，但又降低了其风险</li><li>通过类在原型上定义非静态方法与原型继承协同工作，而静态方法最终放在构造函数上</li><li>类里的静态方法都是不可枚举的，从而可以更好地匹配内建对象的行为</li><li>类构造函数必须通过new关键字调用，以确保不会意外地将类作为函数去调用</li><li>基于类的继承可以通过函数调用确定最终要继承哪一个类，也可通过mixin对象和其他不同组合模式来创建新类</li><li>类构造函数中，可通过new.target随着类被调用的多种方式而做出不同的对应</li></ol><hr><p>以上… 终于耐着性子读完，写完了~~ 总之，对于自己来说还算挺有收获。<br>坚持学习，慢慢成长，欢迎关注，谢谢你的阅读。</p>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【性能】预渲染技术</title>
      <link href="/2017/08/01/%E3%80%90%E6%80%A7%E8%83%BD%E3%80%91%E9%A2%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF/"/>
      <url>/2017/08/01/%E3%80%90%E6%80%A7%E8%83%BD%E3%80%91%E9%A2%84%E6%B8%B2%E6%9F%93%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<h2 id="Prerender-SPA-Plugin"><a href="#Prerender-SPA-Plugin" class="headerlink" title="Prerender SPA Plugin"></a>Prerender SPA Plugin</h2><blockquote><p>一个灵活的静态网站构建框架，让你更好地使用webpack为SPA应用打包</p></blockquote><p>更多请参考官方文档 <a href="https://github.com/chrisvfritz/prerender-spa-plugin" target="_blank" rel="noopener">预渲染技术</a></p><a id="more"></a><p><strong>什么是预渲染？？</strong></p><p>服务端渲染在前端界变得越来越主流。在将网页或应用程序发送给客户之前，在服务器就先呈现了我们想展示的内容。这是一个革命性的想法。</p><p>然而，对于PHP、ASP、JSP（以及这样的）站点来说，同样的批评对于今天的服务器端呈现是有效的。它很慢，很容易被打破，并且很难正确地实现。问题是，尽管每个人可能会告诉你，你可能不需要SSR。您可以通过使用预先设定来获得几乎所有的优点（没有缺点）。</p><p>预渲染的原理是启动一个无头浏览器（如puperteer），加载应用程序的路由，并将结果保存到静态HTML文件中。然后，可使用以前使用的静态文件-文件服务解决方案来服务它。它只适用于HTML5导航和类似的东西。不需要更改代码或添加服务器端渲染工作区。</p><hr><p><strong>使用场景</strong><br>改善少数营销页面，广告页等的SEO，预渲染就能起到很好的效果.</p><p>当然，我们也要承认，在某些场景下，预渲染并不是特别适合：</p><ul><li>大量的网页和跳转 使用预渲染会很慢，虽然这种场景并没那么多，但不代表不会出现</li><li>动态内容 如果网页中有大量的动态内容，Ajax这类，应确保有占位符组件，直到动态内容加载完后才显示出来，否则页面闪动和重绘的开销会得不偿失</li></ul><h3 id="关于-About-prerender-spa-plugin"><a href="#关于-About-prerender-spa-plugin" class="headerlink" title="关于 About prerender-spa-plugin"></a>关于 About prerender-spa-plugin</h3><p>3.x 版本是基于puppeteer的稳定版本。</p><p>该插件的目标是提供一个简单、可扩展的预渲染解决方案，可以用于任何网站或用webpack构建的单页面应用。</p><p>当然，前提是其他任务是已构建好并可运行的</p><h2 id="Examples-示例"><a href="#Examples-示例" class="headerlink" title="Examples 示例"></a>Examples 示例</h2><p>特定框架例子 可以在源码中找到</p><h3 id="Basic-Usage"><a href="#Basic-Usage" class="headerlink" title="Basic Usage"></a>Basic Usage</h3><p>基础用法 webpack.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> PrerenderSPAPlugin = <span class="built_in">require</span>(<span class="string">'prerender-spa-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 省略其他配置</span></span><br><span class="line">    <span class="keyword">new</span> PrerenderSPAPlugin(&#123;</span><br><span class="line">      <span class="comment">// 必填，填写output打包出来的路径</span></span><br><span class="line">      staticDir: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">      <span class="comment">// 必填，需要预渲染的路由</span></span><br><span class="line">      routes: [<span class="string">'/'</span>, <span class="string">'/about'</span>, <span class="string">'/some/deep/nested/route'</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Advanced-Usage"><a href="#Advanced-Usage" class="headerlink" title="Advanced Usage"></a>Advanced Usage</h3><p>高级用法 webpack.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> PrerenderSPAPlugin = <span class="built_in">require</span>(<span class="string">'prerender-spa-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> Renderer = PrerenderSPAPlugin.PuppeteerRenderer</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> PrerenderSPAPlugin(&#123;</span><br><span class="line">      staticDir: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">      <span class="comment">// 可选, 预渲染应该输出到的路径</span></span><br><span class="line">      outputDir: path.join(__dirname, <span class="string">'prerendered'</span>),</span><br><span class="line">      <span class="comment">// 可选，根文档的路径</span></span><br><span class="line">      indexPath: path.join(__dirname, <span class="string">'dist'</span>, <span class="string">'index.html'</span>),</span><br><span class="line">      routes: [<span class="string">'/'</span>, <span class="string">'/about'</span>, <span class="string">'/some/deep/nested/route'</span>],</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 可选 在写入渲染内容到文件之前 允许配置 html和输出路径</span></span><br><span class="line">      <span class="comment">// 可以修改渲染， 也可等待返回。 以下是renderedRoute 的格式：</span></span><br><span class="line">      <span class="comment">// &#123;</span></span><br><span class="line">      <span class="comment">//   route: String, // 输出文件将在何处结束（相对于outputDir)</span></span><br><span class="line">      <span class="comment">//   originalRoute: String, // 在重定向之前，传递给渲染器的路由。.</span></span><br><span class="line">      <span class="comment">//   html: String // 该路由渲染的html</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      postProcess(renderedRoute) &#123;</span><br><span class="line">        <span class="comment">// 忽略任何重定向</span></span><br><span class="line">        renderedRoute.path = renderedRoute.originalPath</span><br><span class="line">        <span class="comment">// 删除空格. (建议别在生产环境中用)</span></span><br><span class="line">        renderedRoute.html = renderedRoute.html.split(<span class="regexp">/&gt;[\s]+&lt;/gmi</span>).join(<span class="string">'&gt;&lt;'</span>)</span><br><span class="line">        <span class="comment">// 返回renderedRoute, 其实就是对 传入的 对象进行了一次处理，返回的还是该对象</span></span><br><span class="line">        <span class="keyword">return</span> renderedRoute</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 可选，使用 html-minifier  它会压缩html， 更多参考官方</span></span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseBooleanAttributes: <span class="literal">true</span>,</span><br><span class="line">        collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">        decodeEntities: <span class="literal">true</span>,</span><br><span class="line">        keepClosingSlash: <span class="literal">true</span>,</span><br><span class="line">        sortAttributes: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 服务端配置选项</span></span><br><span class="line">      server: &#123;</span><br><span class="line">        <span class="comment">// 端口是自动检测的</span></span><br><span class="line">        port: <span class="number">8001</span></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 渲染器 Renderer的实例，可自行编写</span></span><br><span class="line">      renderer: <span class="keyword">new</span> Renderer(&#123;</span><br><span class="line">        <span class="comment">// 注入到window对象 kv对   window.__PRERENDER_INJECTED 就可以访问到了</span></span><br><span class="line">        injectProperty: <span class="string">'__PRERENDER_INJECTED'</span>,</span><br><span class="line">        <span class="comment">// 可选，可配置想通过 window 对象注入的可访问值</span></span><br><span class="line">        inject: &#123;</span><br><span class="line">          foo: <span class="string">'bar'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 默认为 0 没有限制 </span></span><br><span class="line">        <span class="comment">// 由于路由是异步加载的，用该属性限制路由的数量</span></span><br><span class="line">        maxConcurrentRoutes: <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... 更多的看文档吧</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可用的渲染器"><a href="#可用的渲染器" class="headerlink" title="可用的渲染器"></a>可用的渲染器</h3><ul><li>@prerenderer/renderer-puppeteer 已经预先准备好了几百页，并希望得到准确的结果 那就是用它吧</li><li>@prerenderer/renderer-jsdom 你需要提前阅读成千上万页的内容，但是质量并不是那么重要，你愿意为更高级的案例解决问题</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>JS 在 prerender前不运行</li></ul><p>如果您的代码依赖于“body”的存在，那么只需在domcontent重载事件的回调中运行它：（否则会发现在JS运行之前，预编译-spa-plugin将输出页面的内容）</p><pre><code>document.addEventListener(&apos;DOMContentLoaded&apos;, function() {})</code></pre><p>如果使用 Vue，将 <code>&lt;div id=&quot;root&quot;&gt;</code> mounting 到 body标签上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123; <span class="comment">/**/</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  app.$mount(<span class="string">'#root'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>Inline styles 内联样式</strong></p><p>如果您依赖于内联CSS，也就是说，您不会从捆绑包中提取CSS，因此，体验重复的CSS样式标签，可以考虑使用 <code>extract-text-webpack-plugin</code> 将CSS提取到单独的文件中。然后将CSS注入到模板中。使用 <code>html-webpack-plugin</code> 的html文件，或者将其称为外部CSS文件。</p><p>无论哪种方式，JS中都不会有任何不必要的样式。</p><h3 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h3><ul><li><p>出于显而易见的原因，预安装-spa-插件只适用于使用HTML5历史API的spa。索引。不幸的是，html/hash/路由url将无法工作</p></li><li><p>vue2+ 确保你的根组件与它所替换的预先设计的元素具有相同的id。否则，您将得到重复的内容</p></li></ul>]]></content>
      
      <categories>
          
          <category> 调研 </category>
          
          <category> 性能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 预渲染 </tag>
            
            <tag> 性能 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【面试】知识点查缺补漏系列2——从原型到闭包你必知的js知识点</title>
      <link href="/2017/07/23/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F%E7%B3%BB%E5%88%972%E2%80%94%E2%80%94%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0%E9%97%AD%E5%8C%85%E4%BD%A0%E5%BF%85%E7%9F%A5%E7%9A%84js%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2017/07/23/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F%E7%B3%BB%E5%88%972%E2%80%94%E2%80%94%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0%E9%97%AD%E5%8C%85%E4%BD%A0%E5%BF%85%E7%9F%A5%E7%9A%84js%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<p>记得之前知乎有一个问题很火？ 问的大概是一个五年的程序员居然不知道原型链，空口说会vue react什么的巴拉巴拉… 然后大佬们讨论得很激烈</p><p><a href="https://www.zhihu.com/question/60165921" target="_blank" rel="noopener">面试一个5年的前端，却连原型链也搞不清楚，满口都是Vue，React之类的实现，这样的人该用吗？</a>感兴趣可以看看这篇里大牛们的回答</p><a id="more"></a><p>以下只是自我感想… 见笑了……题设是觉得一名5年的前端工程师至少从基本功来说应该掌握这些知识，而不仅仅是业务逻辑熟练，会用各种框架。<br>有一部分认为工作应该服务于需求，拿来主义，满足需求第一，至于细节让他去吧。<br>还有一部分认为知识的不全面并不足以否定面试者其他方面的优秀……<br>总之仁者见仁吧，如果对自己的定位是一名资深前端工程师，或是以技术为核心发展方向，（我现在就以此为目标为之努力）那么就不应该放过这些微小的细节。</p><p>原型为何而来，解决什么样的问题？从中衍生出了哪些更好的解决方案？ jQuery中的原型等等，就像是问css多少种垂直水平居中一样，绝对定位 margin transform flexbox grid很多种解决方案，适合于某些特定的情形，我们了解了各自的差异，才是从众多解决方案中得到<code>最适合的解决方案</code>。与茴字有多少种写法是完全不同的… 于是不多BB了。。。</p><hr><p>那我们说回来，还是从题目入手、思考，寻找知识点最后解答</p><h2 id="引子题目"><a href="#引子题目" class="headerlink" title="引子题目"></a>引子题目</h2><ul><li>如果准确判断一个变量是数组类型</li><li>写一个原型链继承的例子</li><li>描述new一个对象的过程</li><li>zepto或其他框架源码中如何使用原型链</li></ul><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.class = <span class="string">'class-1'</span>;</span><br><span class="line">  <span class="comment">// return this 默认有这行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo(<span class="string">'zhangsan'</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment">// var f1 = new Foo('lisi', 22) // 创建多个对象</span></span><br></pre></td></tr></table></figure><h3 id="构造函数-扩展"><a href="#构造函数-扩展" class="headerlink" title="构造函数 - 扩展"></a>构造函数 - 扩展</h3><ul><li><code>var a = {}</code>其实是<code>var a = new Object()</code>的语法糖</li><li><code>var a = []</code>其实是<code>var a = new Array()</code>的语法糖</li><li><code>function Foo() {...}</code>其实是<code>var Foo = new Function(...)</code></li><li>使用instanceof判断一个函数是否是一个变量的构造函数</li></ul><h3 id="原型规则和示例"><a href="#原型规则和示例" class="headerlink" title="原型规则和示例"></a>原型规则和示例</h3><p>5条原型规则 - 原型规则是学习原型链的基础</p><ul><li>所有的引用类型（对象、数组、函数）都具有对象特性，即可自由扩展属性(除null)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;; obj.a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> arr = []; arr.a = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;&#125;; fn.a = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(arr.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(fn.__proto__);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">console</span>.log(fn.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__ === <span class="built_in">Object</span>.prototype)</span><br></pre></td></tr></table></figure><ul><li><p>所有的引用类型都有一个<code>__proto__</code>(隐式原型)属性，属性值是一个普通的对象</p></li><li><p>所有的函数，都有一个prototype属性，属性值也是一个普通的对象</p></li><li><p>所有的引用类型(数组、对象、函数), <strong>proto</strong>属性值指向它的构造函数的<code>prototype</code>属性</p></li><li><p>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的<strong>proto</strong>（即它的构造函数的prototype）中寻找</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.alertName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo(<span class="string">'zhangsan'</span>)</span><br><span class="line">f.printName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">f.printName()</span><br><span class="line">f.alertName()</span><br></pre></td></tr></table></figure><p><strong>循环对象自身的属性</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> item</span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> f) &#123;</span><br><span class="line">  <span class="comment">// 高级浏览器已经在for in 中屏蔽了来自原型的属性</span></span><br><span class="line">  <span class="comment">// 但是这里还是建议加上这个判断，保证程序健壮性</span></span><br><span class="line">  <span class="keyword">if</span> (f.hasOwnProperty(item)) &#123;</span><br><span class="line">    <span class="comment">// console.log(item)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.alertName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo(<span class="string">'zhangsan'</span>)</span><br><span class="line">f.printName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">f.printName()</span><br><span class="line">f.alertName()</span><br><span class="line">f.toString()  <span class="comment">// 要去 f.__proto__.__proto__ 中去找</span></span><br></pre></td></tr></table></figure><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>用于判断引用类型属于哪个构造函数的方法</p><ul><li><p>f instanceof Foo 的判断逻辑</p></li><li><p>f的<strong>proto</strong>一层一层往上，能否对应到Foo.prototype</p></li><li><p>再试着判断 f instanceof Object</p></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="如果准确判断一个变量是数组类型"><a href="#如果准确判断一个变量是数组类型" class="headerlink" title="如果准确判断一个变量是数组类型"></a>如果准确判断一个变量是数组类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> arr <span class="comment">// object, typeof无法判断是否为数组</span></span><br></pre></td></tr></table></figure><h3 id="写一个原型链继承的例子"><a href="#写一个原型链继承的例子" class="headerlink" title="写一个原型链继承的例子"></a>写一个原型链继承的例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动物</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'animal eat'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 狗</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.bark = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'dog bark'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal()</span><br><span class="line"><span class="comment">// 哈士奇</span></span><br><span class="line"><span class="keyword">var</span> hashiqi = <span class="keyword">new</span> Dog() <span class="comment">// 这不是最好的方式</span></span><br></pre></td></tr></table></figure><h3 id="描述new一个对象的过程"><a href="#描述new一个对象的过程" class="headerlink" title="描述new一个对象的过程"></a>描述new一个对象的过程</h3><ul><li>创建一个新对象</li><li>this指向这个新对象</li><li>执行代码，即对this赋值</li><li>返回this</li></ul><h3 id="zepto或其他框架源码中如何使用原型链"><a href="#zepto或其他框架源码中如何使用原型链" class="headerlink" title="zepto或其他框架源码中如何使用原型链"></a>zepto或其他框架源码中如何使用原型链</h3><p>阅读源码是高效提高技能的方式，但不能“埋头苦钻”，有技巧在其中</p><blockquote><p>可以在慕课网搜索“zepto设计和源码分析”</p></blockquote><p><strong>写一个封装DOM查询的例子</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Elem</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.elem = <span class="built_in">document</span>.getElementById(id)</span><br><span class="line">&#125;</span><br><span class="line">Elem.prototype.html = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> elem = <span class="keyword">this</span>.elem</span><br><span class="line">  <span class="keyword">if</span> (val) &#123;</span><br><span class="line">    elem.innerHTML = val</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> <span class="comment">// return this是为了链式调用</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> elem.innerHTML</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Elem.prototype.on = <span class="function"><span class="keyword">function</span>(<span class="params">type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> elem = <span class="keyword">this</span>.elem</span><br><span class="line">  elem.addEventListener(type, fn)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> div1 = <span class="keyword">new</span> Elem(<span class="string">'div1'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(div1.html())</span><br><span class="line">div1.html(<span class="string">'&lt;h1&gt;Hello world!&lt;/h1&gt;'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'html changed...'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>从题目入手、思考，寻找知识点最后解答</p><ul><li>说一下对变量提升的理解</li><li>说明this几种不同的使用场景</li><li>创建10个<code>&lt;a&gt;</code>标签，点击时弹出对应的序号</li><li>如何理解作用域</li><li>实际开发中闭包的应用</li></ul><hr><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span></span><br><span class="line">fn(<span class="string">'zhangsan'</span>) <span class="comment">// 'zhangsan' 20</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  age = <span class="number">20</span></span><br><span class="line">  <span class="built_in">console</span>.log(name, age)</span><br><span class="line">  <span class="keyword">var</span> age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>范围：一段<code>&lt;script&gt;</code>或者一个函数<br>全局：变量定义、函数声明<br>函数：变量定义、函数声明、this、arguments</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>要在执行时才能确认值，定义时无法确认</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  name: <span class="string">'A'</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.fn()  <span class="comment">// 'A'  this === a</span></span><br><span class="line">a.fn.call(&#123;<span class="attr">name</span>: <span class="string">'B'</span>&#125;)  <span class="comment">// this === &#123;name: 'B'&#125;</span></span><br><span class="line"><span class="keyword">var</span> fn1 = a.fn</span><br><span class="line">fn1() <span class="comment">// undefined  this === window</span></span><br></pre></td></tr></table></figure><ul><li>作为构造函数执行</li><li>作为普通属性执行</li><li>作为普通函数执行</li><li>call apply bind</li><li>es6箭头函数 </li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>es5及以前是没有块级作用域的（所以我们一般用IIFE来模拟）</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 例1 */</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">200</span></span><br><span class="line">  <span class="comment">// 当前作用域没有定义的变量，即“自由变量”</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="comment">/* 例2 */</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">300</span></span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// a是自由变量</span></span><br><span class="line">    <span class="built_in">console</span>.log(b) <span class="comment">// b是自由变量</span></span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br><span class="line">  &#125;</span><br><span class="line">  f2()</span><br><span class="line">&#125;</span><br><span class="line">f1()</span><br></pre></td></tr></table></figure><p>作用域链就是 … （我理解的）这层作用域找不到的向父级找，父级找不到继续往上直到顶层作用域（window或global）</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><strong>闭包的使用场景：</strong></p><ul><li>函数作为返回值</li><li>函数作为参数传递</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1 函数作为返回值 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">100</span></span><br><span class="line">  <span class="comment">// 返回一个函数，函数作为返回值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// 自由变量，父作用域寻找</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// f1得到一个函数</span></span><br><span class="line"><span class="keyword">var</span> f2 = f1()</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">200</span></span><br><span class="line">f1() <span class="comment">// 100</span></span><br><span class="line"><span class="comment">/* 2 函数作为参数传递 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">100</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// 自由变量，父作用域寻找</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn1 = Fn1()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn2</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">200</span></span><br><span class="line">  fn()</span><br><span class="line">&#125;</span><br><span class="line">Fn2(f1) <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><h2 id="解题-1"><a href="#解题-1" class="headerlink" title="解题"></a>解题</h2><ul><li><p>说一下对变量提升的理解 - 见上文</p></li><li><p>说明this几种不同的使用场景 - 见上文</p></li><li><p>创建10个<code>&lt;a&gt;</code>标签，点击时弹出对应的序号</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> el = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">    el.innerHTML = i + <span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">    el.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">      e.preventDefault()</span><br><span class="line">      <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(el);</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如何理解作用域</li></ul><p>自由变量、作用域链（自由变量查找机制）、闭包的使用场景</p><ul><li>实际开发中闭包的应用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 闭包实际应用中主要用于封装变量，收敛权限</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFirstLoad</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// _作为私有变量、方法的前缀，这算是一个约定</span></span><br><span class="line">  <span class="keyword">var</span> _list = []</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_list.indexOf(id) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _list.push(id)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">var</span> firstLoad = isFirstLoad()</span><br><span class="line">firstLoad(<span class="number">10</span>) <span class="comment">// true</span></span><br><span class="line">firstLoad(<span class="number">10</span>) <span class="comment">// false</span></span><br><span class="line">firstLoad(<span class="number">20</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>… 其实杂七杂八说了一堆，只是浅尝辄止但作为迈出的一小步放在这里我觉得够了，明年再看到这篇时不知又是怎样的理解…  前端技术发展日新月异，但万变不离其宗，基本功是一切的根基，抛js基础大谈框架顶层建筑全是耍流氓~<br>坚持自己的路，与其和无聊之人瞎BB不如把时间拿来写写代码看看书提升下自己~</p><p>ps 最后推荐一下 <code>《你不知道的JavaScript》</code>上与中~</p>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【面试】知识点查缺补漏系列1——从几道面试题开始</title>
      <link href="/2017/07/23/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F%E7%B3%BB%E5%88%971%E2%80%94%E2%80%94%E4%BB%8E%E5%87%A0%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BC%80%E5%A7%8B/"/>
      <url>/2017/07/23/%E3%80%90%E9%9D%A2%E8%AF%95%E3%80%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F%E7%B3%BB%E5%88%971%E2%80%94%E2%80%94%E4%BB%8E%E5%87%A0%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BC%80%E5%A7%8B/</url>
      <content type="html"><![CDATA[<blockquote><p>最近整理公司文档，对前段时间的面试经验也算作了些总结，从中也很有多体会，毕竟是人生中的第一次经历嘛（一直都是被面试，现在是面试别人，那感觉还不错…）作为纪念于是就把这些记录下来 … ps 也算为之后作点铺垫… 咳咳你们懂的</p></blockquote><p>系列暂拟了大纲（不确定，随时会改，但最终会统一整理）：</p><p>1——从几道面试题开始<br>2——JS必知(原型相关、作用域、执行环境、闭包等等)<br>3——JS异步相关<br>4——JS 常用API与DOM相关<br>5——JS DOM操作与Event事件<br>6——Ajax、跨域与本地存储<br>7——性能优化与安全相关<br>8——前端自动化相关</p><a id="more"></a><p>好的，欢迎回来，这是本系列的第一篇，作为引子，想先从几道常见的面试题入手由浅入不那么浅。。(误)~</p><h2 id="思考问题的结论"><a href="#思考问题的结论" class="headerlink" title="思考问题的结论"></a>思考问题的结论</h2><p>拿到面试题 -&gt; 看考点</p><p>看不完的题海 -&gt; 以不变应万变</p><p>面对面试题 -&gt; 由题目到知识再回归题目本身</p><h3 id="简单思考"><a href="#简单思考" class="headerlink" title="简单思考"></a>简单思考</h3><ul><li><p>js总使用typeof能得到的变量类型？ 考点：js变量类型</p></li><li><p>何时用 === 何时用 == ？ 考点：强制类型转换</p></li><li><p>window.onload和 DOMContentLoaded 区别？ 考点：浏览器渲染过程</p></li><li><p>用js创建10个<a>标签，点击时弹出对应序号？ 考点：作用域</a></p></li><li><p>实现数组的随机排序？ 考点：JS基础算法</p></li></ul><p>先看几道题:</p><ol><li><p>js总使用typeof能得到的变量类型？ 考点：js变量类型</p></li><li><p>何时用 === 何时用 == ？ 考点：强制类型转换</p></li><li><p>js有哪些内置函数</p></li><li><p>js变量按照存储方式区分为哪些类型，并描述其特点</p></li><li><p>如何理解JSON</p></li></ol><hr><h2 id="变量类型与变量计算"><a href="#变量类型与变量计算" class="headerlink" title="变量类型与变量计算"></a>变量类型与变量计算</h2><p>*值类型</p><p>*引用类型  -  对象、数组、函数</p><h3 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h3><h3 id="变量计算-强制类型转换"><a href="#变量计算-强制类型转换" class="headerlink" title="变量计算 - 强制类型转换"></a>变量计算 - 强制类型转换</h3><ul><li>字符串拼接</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span> + <span class="number">10</span> <span class="comment">// 110</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">100</span> + <span class="string">'10'</span> <span class="comment">// 10010</span></span><br></pre></td></tr></table></figure><ul><li>== 运算符</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span> == <span class="string">'100'</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">''</span>  <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>if语句</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">100</span></span><br><span class="line"><span class="keyword">if</span> (b) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = <span class="string">''</span></span><br><span class="line"><span class="keyword">if</span> (c) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>逻辑运算</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">10</span> &amp;&amp; <span class="number">0</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">''</span> || <span class="string">'abc'</span>) <span class="comment">// 'abc'</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="built_in">window</span>.abc) <span class="comment">// true</span></span><br><span class="line"><span class="comment">//判断一个变量会被当作true还是false</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span></span><br><span class="line"><span class="built_in">console</span>.log(!!a)</span><br></pre></td></tr></table></figure><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><ol><li>typeof类型</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'abc'</span>  <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123</span>  <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;  <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> []  <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log  <span class="comment">// function</span></span><br></pre></td></tr></table></figure><ol><li><p>何时使用 === 和 ==</p><p> if (obj.a == null) {<br>   // …<br> }</p></li></ol><p>这里相当于 <code>obj.a === null || obj.a === undefined</code> 的简写形式<br>这是jQuery源码中推荐的写法</p><ol><li>JS中的内置函数 - 数据封装类对象</li></ol><p>Object<br>Array<br>Boolean<br>Number<br>String<br>Function<br>Date<br>RegExp<br>Error</p><ol><li>js变量按照存储方式区分为哪些类型，并描述其特点</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 值类型 */</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">a = <span class="number">11</span></span><br><span class="line"><span class="built_in">console</span>.log(b)  <span class="comment">// 11</span></span><br><span class="line"><span class="comment">/* 引用类型 */</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">x</span>: <span class="number">100</span> &#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1</span><br><span class="line">obj1.x = <span class="number">200</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.x) <span class="comment">// 200</span></span><br></pre></td></tr></table></figure><ol><li>如何理解JSON</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// - JSON是一个JavaScript对象，有自己的api</span></span><br><span class="line"><span class="comment">// - 数据格式</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123;<span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">`&#123;"a": 10, "b": 20&#125;`</span>)</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们拿到题目，首先阅读仔细要明确考点，懂得面试意图，再来针对性作答。当然，答题不是我们追求的本质，更重要的是通过面试调整好自己的心态，查缺补漏不断完善自己的知识点，如果这次不成，放好心态迎接接下来的挑战就好。</p><p>通过这个引子，我们可以看到JavaScript确实有很多坑，但同时也是一门超级灵活，书写爽快的语言，作为一门很有“统治性的语言”（任何可以用JS写的程序最终都将用JS来实现）与其埋怨，不如深究下去，让我们之后的工作更从容些。</p>]]></content>
      
      <categories>
          
          <category> 面试 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【Axios】学习学习~ 官方readme翻译</title>
      <link href="/2017/07/18/%E3%80%90Axios%E3%80%91%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0~%20%E5%AE%98%E6%96%B9readme%E7%BF%BB%E8%AF%91/"/>
      <url>/2017/07/18/%E3%80%90Axios%E3%80%91%E5%AD%A6%E4%B9%A0%E5%AD%A6%E4%B9%A0~%20%E5%AE%98%E6%96%B9readme%E7%BF%BB%E8%AF%91/</url>
      <content type="html"><![CDATA[<h1 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h1><p><a href="https://github.com/mzabriskie/axios" target="_blank" rel="noopener">Axios的github</a> 看这里</p><a id="more"></a> <p><a href="https://www.npmjs.org/package/axios" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/9f600e10007ac86da6a8b90c16ca1e9504901730/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f6178696f732e7376673f7374796c653d666c61742d737175617265" alt="npm version" data-canonical-src="https://img.shields.io/npm/v/axios.svg?style=flat-square" style="max-width:100%;"></a><br><a href="https://travis-ci.org/mzabriskie/axios" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/5f36e9ec9e05d8160d54f9e2312a1e3059d5e252/68747470733a2f2f696d672e736869656c64732e696f2f7472617669732f6d7a61627269736b69652f6178696f732e7376673f7374796c653d666c61742d737175617265" alt="build status" data-canonical-src="https://img.shields.io/travis/mzabriskie/axios.svg?style=flat-square" style="max-width:100%;"></a><br><a href="https://coveralls.io/r/mzabriskie/axios" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/04dcbd38251ebdea54b541442efb9dd48cfb297b/68747470733a2f2f696d672e736869656c64732e696f2f636f766572616c6c732f6d7a61627269736b69652f6178696f732e7376673f7374796c653d666c61742d737175617265" alt="code coverage" data-canonical-src="https://img.shields.io/coveralls/mzabriskie/axios.svg?style=flat-square" style="max-width:100%;"></a><br><a href="http://npm-stat.com/charts.html?package=axios" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/0466334190cd8c680cfa27ff0ace874fae1157e4/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f646d2f6178696f732e7376673f7374796c653d666c61742d737175617265" alt="npm downloads" data-canonical-src="https://img.shields.io/npm/dm/axios.svg?style=flat-square" style="max-width:100%;"></a><br><a href="https://gitter.im/mzabriskie/axios" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/013650d23d9eb743d6169b87e2b1b9741709f699/68747470733a2f2f696d672e736869656c64732e696f2f6769747465722f726f6f6d2f6d7a61627269736b69652f6178696f732e7376673f7374796c653d666c61742d737175617265" alt="gitter chat" data-canonical-src="https://img.shields.io/gitter/room/mzabriskie/axios.svg?style=flat-square" style="max-width:100%;"></a></p> <p>（真是受不了我蹩脚的英语了- -， 你们还是直接看官方文档吧，让我自high）</p><blockquote><p>一个支持浏览器和Node.js的基于Promise的HTTP客户端</p></blockquote><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>从浏览器发出XMLHttpRequest</li><li>从Node.js发出HTTP请求</li><li>支持Promise API</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>取消请求</li><li>自动转换为JSON数据</li><li>跨站请求伪造的客户端防护</li></ul><h2 id="浏览器支持一览"><a href="#浏览器支持一览" class="headerlink" title="浏览器支持一览"></a>浏览器支持一览</h2> <table><br><thead><br><tr><br><th><a href="https://camo.githubusercontent.com/26846e979600799e9f4273d38bd9e5cb7bb8d6d0/68747470733a2f2f7261772e6769746875622e636f6d2f616c7272612f62726f777365722d6c6f676f732f6d61737465722f7372632f6368726f6d652f6368726f6d655f34387834382e706e67" target="_blank"><img src="https://camo.githubusercontent.com/26846e979600799e9f4273d38bd9e5cb7bb8d6d0/68747470733a2f2f7261772e6769746875622e636f6d2f616c7272612f62726f777365722d6c6f676f732f6d61737465722f7372632f6368726f6d652f6368726f6d655f34387834382e706e67" alt="Chrome" data-canonical-src="https://raw.github.com/alrra/browser-logos/master/src/chrome/chrome_48x48.png" style="max-width:100%;"></a></th><br><th><a href="https://camo.githubusercontent.com/6087557f69ec6585eb7f8d7bd7d9ecb6b7f51ba1/68747470733a2f2f7261772e6769746875622e636f6d2f616c7272612f62726f777365722d6c6f676f732f6d61737465722f7372632f66697265666f782f66697265666f785f34387834382e706e67" target="_blank"><img src="https://camo.githubusercontent.com/6087557f69ec6585eb7f8d7bd7d9ecb6b7f51ba1/68747470733a2f2f7261772e6769746875622e636f6d2f616c7272612f62726f777365722d6c6f676f732f6d61737465722f7372632f66697265666f782f66697265666f785f34387834382e706e67" alt="Firefox" data-canonical-src="https://raw.github.com/alrra/browser-logos/master/src/firefox/firefox_48x48.png" style="max-width:100%;"></a></th><br><th><a href="https://camo.githubusercontent.com/6fbaeb334b99e74ddd89190a42766ea3b4600d2c/68747470733a2f2f7261772e6769746875622e636f6d2f616c7272612f62726f777365722d6c6f676f732f6d61737465722f7372632f7361666172692f7361666172695f34387834382e706e67" target="_blank"><img src="https://camo.githubusercontent.com/6fbaeb334b99e74ddd89190a42766ea3b4600d2c/68747470733a2f2f7261772e6769746875622e636f6d2f616c7272612f62726f777365722d6c6f676f732f6d61737465722f7372632f7361666172692f7361666172695f34387834382e706e67" alt="Safari" data-canonical-src="https://raw.github.com/alrra/browser-logos/master/src/safari/safari_48x48.png" style="max-width:100%;"></a></th><br><th><a href="https://camo.githubusercontent.com/96d2405a936da1fb8988db0c1d304d3db04b8a52/68747470733a2f2f7261772e6769746875622e636f6d2f616c7272612f62726f777365722d6c6f676f732f6d61737465722f7372632f6f706572612f6f706572615f34387834382e706e67" target="_blank"><img src="https://camo.githubusercontent.com/96d2405a936da1fb8988db0c1d304d3db04b8a52/68747470733a2f2f7261772e6769746875622e636f6d2f616c7272612f62726f777365722d6c6f676f732f6d61737465722f7372632f6f706572612f6f706572615f34387834382e706e67" alt="Opera" data-canonical-src="https://raw.github.com/alrra/browser-logos/master/src/opera/opera_48x48.png" style="max-width:100%;"></a></th><br><th><a href="https://camo.githubusercontent.com/826b3030243b09465bf14cf420704344f5eee991/68747470733a2f2f7261772e6769746875622e636f6d2f616c7272612f62726f777365722d6c6f676f732f6d61737465722f7372632f656467652f656467655f34387834382e706e67" target="_blank"><img src="https://camo.githubusercontent.com/826b3030243b09465bf14cf420704344f5eee991/68747470733a2f2f7261772e6769746875622e636f6d2f616c7272612f62726f777365722d6c6f676f732f6d61737465722f7372632f656467652f656467655f34387834382e706e67" alt="Edge" data-canonical-src="https://raw.github.com/alrra/browser-logos/master/src/edge/edge_48x48.png" style="max-width:100%;"></a></th><br><th><a href="https://camo.githubusercontent.com/4b062fb12353b0ef8420a72ddc3debf6b2ee5747/68747470733a2f2f7261772e6769746875622e636f6d2f616c7272612f62726f777365722d6c6f676f732f6d61737465722f7372632f617263686976652f696e7465726e65742d6578706c6f7265725f392d31312f696e7465726e65742d6578706c6f7265725f392d31315f34387834382e706e67" target="_blank"><img src="https://camo.githubusercontent.com/4b062fb12353b0ef8420a72ddc3debf6b2ee5747/68747470733a2f2f7261772e6769746875622e636f6d2f616c7272612f62726f777365722d6c6f676f732f6d61737465722f7372632f617263686976652f696e7465726e65742d6578706c6f7265725f392d31312f696e7465726e65742d6578706c6f7265725f392d31315f34387834382e706e67" alt="IE" data-canonical-src="https://raw.github.com/alrra/browser-logos/master/src/archive/internet-explorer_9-11/internet-explorer_9-11_48x48.png" style="max-width:100%;"></a></th><br></tr><br></thead><br><tbody><br><tr><br><td>Latest ✔</td><br><td>Latest ✔</td><br><td>Latest ✔</td><br><td>Latest ✔</td><br><td>Latest ✔</td><br><td>8+ ✔</td><br></tr></tbody></table><p><a href="https://saucelabs.com/u/axios" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/626c46cfd86214001b4143cda5d0ef27a25bd69f/68747470733a2f2f73617563656c6162732e636f6d2f6f70656e5f73617563652f6275696c645f6d61747269782f6178696f732e737667" alt="Browser Matrix" data-canonical-src="https://saucelabs.com/open_sauce/build_matrix/axios.svg" style="max-width:100%;"></a></p> <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用npm:</p><p><code>$ npm install axios</code></p><p>使用bower:</p><p><code>$ bower install axios</code></p><p>使用cdn:</p><p><code>&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</code></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><strong>执行一个get请求</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发出请求给用户一个ID</span></span><br><span class="line">axios.get(<span class="string">'/user?ID=12345'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的请求也可以用下面的方式</span></span><br><span class="line">axios.get(<span class="string">'/user'</span>, &#123;</span><br><span class="line">  params: &#123;</span><br><span class="line">    ID: <span class="number">12345</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>执行POST请求</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="string">'/user'</span>, &#123;</span><br><span class="line">  firstName: <span class="string">'fys'</span>,</span><br><span class="line">  lastName: <span class="string">'fridolph'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>执行多个并发请求</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserAccount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">'/user/12345'</span>);</span><br><span class="line">&#125;</span><br><span class="line"> 　</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserPermissions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">'/user/12345/permissions'</span>);</span><br><span class="line">&#125;</span><br><span class="line"> 　</span><br><span class="line">axios.all([getUserAccount(), getUserPermissions()])</span><br><span class="line">  .then(axios.spread(acct, perms) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 当两个请求都执行完成后</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h2 id="axios-API"><a href="#axios-API" class="headerlink" title="axios API"></a>axios API</h2><p>请求可以通过相关配置给axios</p><p><strong>axios(config)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送一个POST请求</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  url: <span class="string">'/user/12345'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'fys'</span>,</span><br><span class="line">    lastName: <span class="string">'fridolph'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET请求一个远程图像</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'get'</span>,</span><br><span class="line">  url: <span class="string">'http://bit.ly/2mTM3nY'</span>,</span><br><span class="line">  resonseType: <span class="string">'stream'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  response.data.pipe(fs.createWriteStream(<span class="string">'ada_lovelace.jpg'</span>))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>axios(url[, config])</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Send a GET request (default method)</span></span><br><span class="line">axios(<span class="string">'/user/12345'</span>)</span><br></pre></td></tr></table></figure><h3 id="请求方法别名"><a href="#请求方法别名" class="headerlink" title="请求方法别名"></a>请求方法别名</h3><p>为了方便别名为所有支持的请求提供了方法<br>译者注：类似于jQuery.ajax封装提供的别名，$.get $.post等等</p><ul><li>axios.request(config)</li><li>axios.get(url[, config])</li><li>axios.delete(url[, config])</li><li>axios.head(url[, config])</li><li>axios.options(url[, config])</li><li>axios.post(url[, data[, config]])</li><li>axios.put(url[, data[, config]])</li><li>axios.patch(url[, data[, config]])</li></ul><p><code>注：当使用url别名方法,方法,和数据属性中指定不需要配置</code></p><h3 id="同时请求（并发性）"><a href="#同时请求（并发性）" class="headerlink" title="同时请求（并发性）"></a>同时请求（并发性）</h3><p>以下处理函数用于处理并发请求</p><ul><li>axios.all(iterable)</li><li>axios.spread(callback)</li></ul><h3 id="创建一个实例"><a href="#创建一个实例" class="headerlink" title="创建一个实例"></a>创建一个实例</h3><p>你可以创建一个新的axios实例用于个性化配置</p><p><strong>axios.create([config])</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">'https://some-domain.com/api/'</span>,</span><br><span class="line">  timeout: <span class="number">1000</span>,</span><br><span class="line">  headers: &#123;<span class="string">'X-Custom-Header'</span>: <span class="string">'foobar'</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p>下面列出了可用的实例方法。指定的配置将合并实例配置。</p><ul><li>axios#request(config)</li><li>axios#get(url[, config])</li><li>axios#delete(url[, config])</li><li>axios#head(url[, config])</li><li>axios#options(url[, config])</li><li>axios#post(url[, data[, config]])</li><li>axios#put(url[, data[, config]])</li><li>axios#patch(url[, data[, config]])</li></ul><h2 id="Requese-Config-请求配置"><a href="#Requese-Config-请求配置" class="headerlink" title="Requese Config 请求配置"></a>Requese Config 请求配置</h2><p>下面这些可用的配置选项进行请求，只需要url，若没有指定方法则请求违约。</p><p>ps 写到一半发现朋友发了篇… <a href="https://segmentfault.com/a/1190000008470355?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">axios中文文档翻译</a>过来。。额，我就偷下懒了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// `url`用于请求服务端的url</span></span><br><span class="line">  url: <span class="string">'/user'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `method` 是用来处理请求的请求方法, 默认为get请求</span></span><br><span class="line">  method: <span class="string">'get'</span>, </span><br><span class="line"></span><br><span class="line">  <span class="comment">// `baseUrl`将被处理为url，除非是绝对路径</span></span><br><span class="line">  <span class="comment">// axios通过相对url关联到实例，这便于设置 `baseURL`</span></span><br><span class="line">  baseURL: <span class="string">'https://some-domain.com/api/'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformRequest`允许请求的数组传递给服务器，在这之前进行(转化)处理</span></span><br><span class="line">  <span class="comment">// 不过这是只适用于请求方法 'PUT' 'POST' 'PATCH'</span></span><br><span class="line">  <span class="comment">// 数组中最后一个函数必须返回一个字符串、Buffer实例、ArrayBuffer、FormData或Stream</span></span><br><span class="line">  transformRequest: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理任何你想要转换的数据</span></span><br><span class="line">    <span class="keyword">return</span> data;    </span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformResponse`允许响应的数据传递给 then/catch，在这之前进行处理</span></span><br><span class="line">  transformResponse: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理任何你想要转换的数据</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">//`headers`是自定义的要被发送的头信息</span></span><br><span class="line">    headers:&#123;<span class="string">'X-Requested-with'</span>:<span class="string">'XMLHttpRequest'</span>&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//`params`是请求连接中的请求参数，必须是一个纯对象，或者URLSearchParams对象</span></span><br><span class="line">    params:&#123;</span><br><span class="line">      ID:<span class="number">12345</span></span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//`paramsSerializer`是一个可选的函数，是用来序列化参数</span></span><br><span class="line">    <span class="comment">//例如：（https://ww.npmjs.com/package/qs,http://api.jquery.com/jquery.param/)</span></span><br><span class="line">    paramsSerializer: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Qs.stringify(params,&#123;<span class="attr">arrayFormat</span>:<span class="string">'brackets'</span>&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//`data`是请求提需要设置的数据</span></span><br><span class="line">    <span class="comment">//只适用于应用的'PUT','POST','PATCH'，请求方法</span></span><br><span class="line">    <span class="comment">//当没有设置`transformRequest`时，必须是以下其中之一的类型（不可重复？）：</span></span><br><span class="line">    <span class="comment">//-string,plain object,ArrayBuffer,ArrayBufferView,URLSearchParams</span></span><br><span class="line">    <span class="comment">//-仅浏览器：FormData,File,Blob</span></span><br><span class="line">    <span class="comment">//-仅Node：Stream</span></span><br><span class="line">    data:&#123;</span><br><span class="line">      firstName:<span class="string">'fred'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//`timeout`定义请求的时间，单位是毫秒。</span></span><br><span class="line">    <span class="comment">//如果请求的时间超过这个设定时间，请求将会停止。</span></span><br><span class="line">    timeout:<span class="number">1000</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//`withCredentials`表明是否跨网站访问协议，</span></span><br><span class="line">    <span class="comment">//应该使用证书</span></span><br><span class="line">    withCredentials:<span class="literal">false</span> <span class="comment">//默认值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//`adapter`适配器，允许自定义处理请求，这会使测试更简单。</span></span><br><span class="line">    <span class="comment">//返回一个promise，并且提供验证返回（查看[response docs](#response-api)）</span></span><br><span class="line">    adapter:<span class="function"><span class="keyword">function</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">      <span class="comment">/*...*/</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//`auth`表明HTTP基础的认证应该被使用，并且提供证书。</span></span><br><span class="line">    <span class="comment">//这个会设置一个`authorization` 头（header），并且覆盖你在header设置的Authorization头信息。</span></span><br><span class="line">    auth:&#123;</span><br><span class="line">      username:<span class="string">'janedoe'</span>,</span><br><span class="line">      password:<span class="string">'s00pers3cret'</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//`responsetype`表明服务器返回的数据类型，这些类型的设置应该是</span></span><br><span class="line">    <span class="comment">//'arraybuffer','blob','document','json','text',stream'</span></span><br><span class="line">    responsetype:<span class="string">'json'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//`xsrfHeaderName` 是http头（header）的名字，并且该头携带xsrf的值</span></span><br><span class="line">    xrsfHeadername:<span class="string">'X-XSRF-TOKEN'</span>，<span class="comment">//默认值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//`onUploadProgress`允许处理上传过程的事件</span></span><br><span class="line">    onUploadProgress: <span class="function"><span class="keyword">function</span>(<span class="params">progressEvent</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//本地过程事件发生时想做的事</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//`onDownloadProgress`允许处理下载过程的事件</span></span><br><span class="line">    onDownloadProgress: <span class="function"><span class="keyword">function</span>(<span class="params">progressEvent</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//下载过程中想做的事</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//`maxContentLength` 定义http返回内容的最大容量</span></span><br><span class="line">    maxContentLength: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//`validateStatus` 定义promise的resolve和reject。</span></span><br><span class="line">    <span class="comment">//http返回状态码，如果`validateStatus`返回true（或者设置成null/undefined），promise将会接受；其他的promise将会拒绝。</span></span><br><span class="line">    validateStatus: <span class="function"><span class="keyword">function</span>(<span class="params">status</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> status &gt;= <span class="number">200</span> &amp;&amp; stauts &lt; <span class="number">300</span>;<span class="comment">//默认</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//`httpAgent` 和 `httpsAgent`当产生一个http或者https请求时分别定义一个自定义的代理，在nodejs中。</span></span><br><span class="line">    <span class="comment">//这个允许设置一些选选个，像是`keepAlive`--这个在默认中是没有开启的。</span></span><br><span class="line">    httpAgent: <span class="keyword">new</span> http.Agent(&#123;<span class="attr">keepAlive</span>:treu&#125;),</span><br><span class="line">    httpsAgent: <span class="keyword">new</span> https.Agent(&#123;<span class="attr">keepAlive</span>:<span class="literal">true</span>&#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//`proxy`定义服务器的主机名字和端口号。</span></span><br><span class="line">    <span class="comment">//`auth`表明HTTP基本认证应该跟`proxy`相连接，并且提供证书。</span></span><br><span class="line">    <span class="comment">//这个将设置一个'Proxy-Authorization'头(header)，覆盖原先自定义的。</span></span><br><span class="line">    proxy:&#123;</span><br><span class="line">        host:<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>,</span><br><span class="line">        port:<span class="number">9000</span>,</span><br><span class="line">        auth:&#123;</span><br><span class="line">            username:<span class="string">'cdd'</span>,</span><br><span class="line">            password:<span class="string">'123456'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//`cancelTaken` 定义一个取消，能够用来取消请求</span></span><br><span class="line">    <span class="comment">//（查看 下面的Cancellation 的详细部分）</span></span><br><span class="line">    cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span>(<span class="params">cancel</span>)</span>&#123;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回响应概要-Response-Schema"><a href="#返回响应概要-Response-Schema" class="headerlink" title="返回响应概要 Response Schema"></a>返回响应概要 Response Schema</h2><p><strong>一个请求的返回包含以下信息</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">//`data`是服务器的提供的回复（相对于请求）</span></span><br><span class="line">  data&#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//`status`是服务器返回的http状态码</span></span><br><span class="line">  status:<span class="number">200</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//`statusText`是服务器返回的http状态信息</span></span><br><span class="line">  statusText: <span class="string">'ok'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//`headers`是服务器返回中携带的headers</span></span><br><span class="line">  headers:&#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//`config`是对axios进行的设置，目的是为了请求（request）</span></span><br><span class="line">  config:&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用then，你会接受打下面的信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">'/user/12345'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.data);</span><br><span class="line">    <span class="built_in">console</span>.log(response.status);</span><br><span class="line">    <span class="built_in">console</span>.log(response.statusText);</span><br><span class="line">    <span class="built_in">console</span>.log(response.headers);</span><br><span class="line">    <span class="built_in">console</span>.log(response.config);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>使用catch时，或者传入一个reject callback作为then的第二个参数，那么返回的错误信息将能够被使用。</p><h2 id="默认设置-Config-Default"><a href="#默认设置-Config-Default" class="headerlink" title="默认设置(Config Default)"></a>默认设置(Config Default)</h2><p>你可以设置一个默认的设置，这设置将在所有的请求中有效。</p><h3 id="全局默认设置-Global-axios-defaults"><a href="#全局默认设置-Global-axios-defaults" class="headerlink" title="全局默认设置 Global axios defaults"></a>全局默认设置 Global axios defaults</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.baseURL = <span class="string">'https://api.example.com'</span>;</span><br><span class="line">axios.defaults.headers.common[<span class="string">'Authorization'</span>] = AUTH_TOKEN;</span><br><span class="line">axios.defaults.headers.post[<span class="string">'Content-Type'</span>]=<span class="string">'application/x-www-form-urlencoded'</span>;</span><br></pre></td></tr></table></figure><h3 id="实例中自定义默认值-Custom-instance-default"><a href="#实例中自定义默认值-Custom-instance-default" class="headerlink" title="实例中自定义默认值 Custom instance default"></a>实例中自定义默认值 Custom instance default</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当创建一个实例时进行默认设置</span></span><br><span class="line"><span class="keyword">var</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL:<span class="string">'https://api.example.com'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//在实例创建之后改变默认值</span></span><br><span class="line">instance.defaults.headers.common[<span class="string">'Authorization'</span>] = AUTH_TOKEN;</span><br></pre></td></tr></table></figure><h2 id="设置优先级-Config-order-of-precedence"><a href="#设置优先级-Config-order-of-precedence" class="headerlink" title="设置优先级 Config order of precedence"></a>设置优先级 Config order of precedence</h2><p>设置(config)将按照优先顺序整合起来。首先的是在lib/defaults.js中定义的默认设置，其次是defaults实例属性的设置，最后是请求中config参数的设置。越往后面的等级越高，会覆盖前面的设置。看下面这个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认库的设置创建一个实例，</span></span><br><span class="line"><span class="comment">//这个实例中，使用的是默认库的timeout设置，默认值是0。</span></span><br><span class="line"><span class="keyword">var</span> instance = axios.create();</span><br><span class="line"><span class="comment">//覆盖默认库中timeout的默认值</span></span><br><span class="line"><span class="comment">//此时，所有的请求的timeout时间是2.5秒</span></span><br><span class="line">instance.defaults.timeout = <span class="number">2500</span>;</span><br><span class="line"><span class="comment">//覆盖该次请求中timeout的值，这个值设置的时间更长一些</span></span><br><span class="line">instance.get(<span class="string">'/longRequest'</span>,&#123;</span><br><span class="line">    timeout:<span class="number">5000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="拦截器-interceptors"><a href="#拦截器-interceptors" class="headerlink" title="拦截器 interceptors"></a>拦截器 interceptors</h2><p>你可以在请求或者返回被then或者catch处理之前对他们进行拦截。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加一个请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//在请求发送之前做一些事</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//当出现请求错误是做一些事</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一个返回拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//对返回的数据进行一些处理</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//对返回的错误进行一些处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果你需要在稍后移除拦截器,你可以</p><pre><code>var myInterceptor = axios.interceptors.request.use(function(){/*...*/});axios.interceptors.rquest.eject(myInterceptor);</code></pre><p>你可以在一个axios实例中使用拦截器</p><pre><code>var instance = axios.create();instance.interceptors.request.use(function(){/*...*/});</code></pre><h2 id="错误处理-Handling-Errors"><a href="#错误处理-Handling-Errors" class="headerlink" title="错误处理 Handling Errors"></a>错误处理 Handling Errors</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">'user/12345'</span>)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(error.response)&#123;</span><br><span class="line">      <span class="comment">//存在请求，但是服务器的返回一个状态码</span></span><br><span class="line">      <span class="comment">//他们都在2xx之外</span></span><br><span class="line">      <span class="built_in">console</span>.log(error.response.data);</span><br><span class="line">      <span class="built_in">console</span>.log(error.response.status);</span><br><span class="line">      <span class="built_in">console</span>.log(error.response.headers);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//一些错误是在设置请求时触发的</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Error'</span>,error.message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(error.config);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><strong>你可以使用validateStatus设置选项自定义HTTP状态码的错误范围</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">'user/12345'</span>,&#123;</span><br><span class="line">  validateStatus:<span class="function"><span class="keyword">function</span>(<span class="params">status</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> status &lt; <span class="number">500</span>;<span class="comment">//当返回码小于等于500时视为错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="取消-Cancellation"><a href="#取消-Cancellation" class="headerlink" title="取消 Cancellation"></a>取消 Cancellation</h2><p>你可以使用cancel token取消一个请求</p><p>axios的cancel token API是基于<strong>cnacelable promises proposal</strong>，其目前处于第一阶段。<br>你可以使用CancelToken.source工厂函数创建一个cancel token，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">var</span> source = CancelToken.source();</span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">    cancelToken:source.toke</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">thrown</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(axiso.isCancel(thrown))&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Rquest canceled'</span>, thrown.message);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//handle error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//取消请求(信息参数设可设置的)</span></span><br><span class="line">source.cancel(<span class="string">"操作被用户取消"</span>);</span><br></pre></td></tr></table></figure><p>你可以给CancelToken构造函数传递一个executor function来创建一个cancel token:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">var</span> cancel;</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">    cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//这个executor 函数接受一个cancel function作为参数</span></span><br><span class="line">        cancel = c;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//取消请求</span></span><br><span class="line">cancel();</span><br></pre></td></tr></table></figure><p>注意：你可以使用同一个cancel token取消多个请求。</p><h2 id="使用-application-x-www-form-urlencoded-格式化"><a href="#使用-application-x-www-form-urlencoded-格式化" class="headerlink" title="使用 application/x-www-form-urlencoded 格式化"></a>使用 application/x-www-form-urlencoded 格式化</h2><p>默认情况下，axios串联js对象为JSON格式。为了发送application/x-wwww-form-urlencoded格式数据，你可以使用一下的设置。</p><h3 id="浏览器-Browser"><a href="#浏览器-Browser" class="headerlink" title="浏览器 Browser"></a>浏览器 Browser</h3><p>在浏览器中你可以如下使用URLSearchParams API:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams();</span><br><span class="line">params.append(<span class="string">'param1'</span>,<span class="string">'value1'</span>);</span><br><span class="line">params.append(<span class="string">'param2'</span>,<span class="string">'value2'</span>);</span><br><span class="line">axios.post(<span class="string">'/foo'</span>,params);</span><br></pre></td></tr></table></figure><p>注意：URLSearchParams不支持所有的浏览器，但是这里有个垫片<br>（poly fill）可用（确保垫片在浏览器全局环境中）</p><p>其他方法：你可以使用qs库来格式化数据。</p><pre><code>var qs = require(&apos;qs&apos;);axios.post(&apos;/foo&apos;, qs.stringify({&apos;bar&apos;:123}));</code></pre><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>在nodejs中，你可以如下使用querystring:</p><pre><code>var querystring = require(&apos;querystring&apos;);axios.post(&apos;http://something.com/&apos;, querystring.stringify({foo:&apos;bar&apos;}));</code></pre><p>你同样可以使用qs库。</p><h3 id="promises"><a href="#promises" class="headerlink" title="promises"></a>promises</h3><p>axios 基于原生的ES6 Promise 实现。如果环境不支持请使用垫片.</p><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>axios 包含TypeScript定义</p><pre><code>import axios from &apos;axios&apos;axios.get(&apos;/user?ID=12345&apos;)</code></pre><hr><p>本文完~</p>]]></content>
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【JS】深入理解ES6——块级作用域绑定</title>
      <link href="/2017/07/17/%E3%80%90JS%E3%80%91%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E2%80%94%E2%80%94%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%BB%91%E5%AE%9A/"/>
      <url>/2017/07/17/%E3%80%90JS%E3%80%91%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E2%80%94%E2%80%94%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%BB%91%E5%AE%9A/</url>
      <content type="html"><![CDATA[<p>想了很久还是决定一边看书一边把所记多得用博客的形式记录下来。毕竟好记性不如烂笔头嘛，而且，ES6这么多的内容很适合记博客啊，哈哈~~ 可以产出很多篇不说，还可以顺便练练文笔什么的啦… 额，废话就直接跳过了</p><blockquote><p>ES6的新语法可以让我们更好地控制作用域。这里我们先理解var声明的一些坑，然后从ES6新引入的块级作用域说起，然后到其绑定机制和最佳实践。</p></blockquote><a id="more"></a><h2 id="var声明及变量提升机制"><a href="#var声明及变量提升机制" class="headerlink" title="var声明及变量提升机制"></a>var声明及变量提升机制</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (something) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="string">'hello world'</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    result value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们读着代码，可能会认为只有something为true(存在)时，value才会被声明，但事实上，在<code>预编译</code>阶段，JavaScritp引擎会将上面的getValue函数修成成下面这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是全局作用域 window或global下</span></span><br><span class="line"><span class="comment">// getValue也会有函数声明提升，所以直接调用是能访问并正确执行getValue函数的</span></span><br><span class="line">getValue();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// getValue的函数作用域顶层</span></span><br><span class="line">  <span class="keyword">var</span> value;  </span><br><span class="line">  <span class="keyword">if</span> (something) &#123;</span><br><span class="line">    value = <span class="string">'hello world'</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    result value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 此处可访问变量value，其值为undefined</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 此处可访问变量value，其值为undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量value的声明被提升至顶部。所以在注释处我们都可以在<code>getValue函数内部</code>访问到value。那ES6引入块级作用域就是来强化对变量声明周期的控制的。</p><h2 id="块级声明"><a href="#块级声明" class="headerlink" title="块级声明"></a>块级声明</h2><blockquote><p>块级声明用于声明在指定块的作用域之外无法访问的变量，块级作用域存在于：函数内部和块中（字符<code>{ }</code>之前的区域）</p></blockquote><h3 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h3><p>还是以刚才的代码为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是全局作用域 window或global下</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// getValue的函数作用域顶层  </span></span><br><span class="line">  <span class="keyword">if</span> (something) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="string">'hello world'</span>;</span><br><span class="line">    <span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    result &#123; value, PI &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 变量value，PI在此处不存在</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 变量value，PI在此处不存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用let或const进行的声明不再被提升至函数顶部。执行流离开if块后，value、PI被立即销毁，如果something为false，就永不会声明及初始化变量。</p><p><strong>二者间的相同点</strong> 禁止重声明</p><p><code>在同级的作用域内，若变量用let或const声明过后，再次声明会直接报错</code>。但如果当前作用域嵌另一个作用域便可在内嵌的作用域中用let或const声明同名变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'fri'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 不会报错</span></span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">'fridolph'</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="临时死区-Temporal-Dead-Zone"><a href="#临时死区-Temporal-Dead-Zone" class="headerlink" title="临时死区 (Temporal Dead Zone)"></a>临时死区 (Temporal Dead Zone)</h2><blockquote><p>JavaScript引擎在扫描代码时发现变量声明，要么将它们提升至作用域顶部（遇到var声明），要么将声明放到TDZ中（遇到let或const声明）</p></blockquote><p>访问TDZ中的变量会触发运行时错误。只有执行过变量声明语句后，变量才会从TDZ中移出，然后才可正常访问。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>块级作用域绑定的let和const为JavaScript引入了词法作用域（它们声明的变量不会提升），而且只可以在声明这些变量的代码块中使用。</p></li><li><p>在for-in和for-of循环中，let和const都会为每次迭代时创建新绑定（从而使循环体内创建的函数可以访问到相应迭代的值，而非最后一次迭代后的值）</p></li></ul><p>注：在for循环中使用const声明可能引发错误，要尽量避免</p><ul><li>使用块级作用域绑定的最佳实践是：默认使用const，只有在确实需要改变变量时才使用let</li></ul>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【配置】初始环境搭建 nvm node.js git</title>
      <link href="/2017/07/15/%E3%80%90%E9%85%8D%E7%BD%AE%E3%80%91%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%20nvm%20node.js%20git/"/>
      <url>/2017/07/15/%E3%80%90%E9%85%8D%E7%BD%AE%E3%80%91%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%20nvm%20node.js%20git/</url>
      <content type="html"><![CDATA[<blockquote><p>嗯，家里电脑一直被当作看动漫和打游戏的工具，今天想敲下代码发现什么环境都没搭… 把我恶心惨了，于是出这篇时时铭记，至少以后换台新电脑后可以快速搭建好相关的不影响开发。</p></blockquote><p>ps 我就是单纯在立flag … 陪伴了我好几年的联想，明年该让你退休了。我已经选好了，我要上船2333，windows版</p><a id="more"></a><hr><p>注：强迫症不用太在意，以下排名不分先后啦… 高兴怎么来怎么来</p><h2 id="1-安装-VS-Code"><a href="#1-安装-VS-Code" class="headerlink" title="1. 安装 VS Code"></a>1. 安装 VS Code</h2><p>sublime 对不起，爱过~  2333,  <a href="http://download.csdn.net/search?keywords=vscode" target="_blank" rel="noopener">CSDN里慢慢挑</a>， 另附上 <a href="https://segmentfault.com/a/1190000007688656" target="_blank" rel="noopener">VS Code快捷键一览</a><code>少年，想要更快更高更强吗？</code></p><p>VS Code装了继续把相关插件也装了，嗯，另一篇博客里记载得有。这里就不贴了</p><h2 id="2-Node-js相关环境，nvm安装"><a href="#2-Node-js相关环境，nvm安装" class="headerlink" title="2. Node.js相关环境，nvm安装"></a>2. Node.js相关环境，nvm安装</h2><p>我这里是windows电脑，所以就先贴nvm的相关搭建了~ <code>因为觉得很重要，所以就在这篇下写了</code>。为什么要贴这个，因为怕网上的帖子找不到了，以后要用时不哭死~~嗯，就这样</p><h3 id="nodejs在windows下的安装"><a href="#nodejs在windows下的安装" class="headerlink" title="nodejs在windows下的安装"></a>nodejs在windows下的安装</h3><blockquote><p>nodejs 有很多种的安装方式，下面我用一种nvm的方式，来安装nodejs，nvm(nodejs version manager)是nodejs版本管理工具的意思。详情请点击【官方说明】</p></blockquote><ul><li>下载 nvm 包 地址：<a href="https://github.com/coreybutler/nvm-windows/releases，我们选择第一个：nvm-noinstall.zip" target="_blank" rel="noopener">https://github.com/coreybutler/nvm-windows/releases，我们选择第一个：nvm-noinstall.zip</a> 下载完成后解压到一个地方，比如: C:\dev\nvm 里面的文件列表是这样的：elevate.cmd、elevate.vbs、install.cmd、LICENSE、nvm.exe</li></ul><p>备注：windows下要设置显示文件类型的扩展名，这样才能看到上述文件的后缀</p><ul><li>双击 install.cmd 然后会让你输入”压缩文件解压或拷贝到的一个绝对路径” 先不用管它，直接回车，成功后，会在C盘的根目录生成一个settings.txt的文本文件，把这个文件剪切到C:\dev\nvm目录中，然后我们把它的内容修改成这样：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root: C:\dev\nvm </span><br><span class="line">path: C:\dev\nodejs </span><br><span class="line">arch: <span class="number">64</span> </span><br><span class="line">proxy: none </span><br><span class="line">node_mirror: http:<span class="comment">//npm.taobao.org/mirrors/node/ </span></span><br><span class="line">npm_mirror: https:<span class="comment">//npm.taobao.org/mirrors/npm/</span></span><br></pre></td></tr></table></figure><ul><li><p>然后我们开始配置环境变量了，因为刚刚点击了install.cmd的文件，那么会在环境变量的系统变量中，生成两个环境变量：<code>NVM_HOME</code> 和 <code>NVM_SYMLINK</code> 我们开始修改这两个变量名的变量值：<code>NVM_HOME</code>的变量值为：<code>C:\dev\nvm</code> <code>NVM_SYMLINK</code>的变量值为：<code>C:\dev\nodejs</code></p></li><li><p>我们还会发现，在Path中也会自动添加上<code>C:\dev\nvm;</code>或者是<code>C:\dev\nodejs</code>，如果有的话，把他们删掉，没有的话更好，我们自己来配置，在Path的最前面输入： ;%NVM_HOME%;%NVM_SYMLINK%;</p></li><li><p>打开一个cmd窗口输入命令：nvm v ，那么我们会看到当前nvm的版本信息。然后我们可以安装nodejs了。</p></li><li><p>继续输入命令：<code>nvm install latest</code> 如果网络畅通，我们会看到正在下载的提示，下载完成后 会让你use那个最新的node版本。</p></li><li><p>如果你是第一次下载，在use之前，C:\dev目录下是没有nodejs这个文件夹的，在输入比如： <code>nvm use 6.11.0</code> 之后，你会发现，C:\dev目录下多了一个nodejs文件夹，这个文件夹不是单纯的文件夹，它是一个快捷方式，指向了 C:\dev\nvm 里的 v6.11.0 文件夹。</p></li><li><p>同样的咱们可以下载其他版本的nodejs，这样通过命令:nvm use 版本号 比如：nvm use 6.11.0就可以轻松实现版本切换了。</p></li></ul><p>备注： 如果你的电脑系统是32 位的，那么在下载nodejs版本的时候，一定要指明 32 如： nvm install 6.11.0 32 这样在32位的电脑系统中，才可以使用，默认是64位的。</p><h3 id="npm的安装"><a href="#npm的安装" class="headerlink" title="npm的安装"></a>npm的安装</h3><h4 id="首先-npm是什么？"><a href="#首先-npm是什么？" class="headerlink" title="首先 npm是什么？"></a>首先 npm是什么？</h4><p>npm有两层含义，第一是npm这个开源的模块登记和管理系统，也就是这个站点：<a href="https://www.npmjs.com。" target="_blank" rel="noopener">https://www.npmjs.com。</a><br>第二个指的是 nodejs package manager 也就是nodejs的包管理工具。我们主要说的就是这一个。<br>在每个版本的nodejs中，都会自带npm，为了统一起见，我们安装一个全局的npm工具，这个操作很有必要，因为我们需要安装一些全局的其他包，不会因为切换node版本造成原来下载过的包不可用。<br>首先我们进入命令模式，输入 <code>npm config set prefix &quot;C:\dev\nvm\npm&quot;</code> 回车，这是在配置npm的全局安装路径，然后在用户文件夹下会生成一个.npmrc的文件，用记事本打开后可以看到如下内容：</p><p><code>prefix=C:\dev\nvm\npm</code></p><p>然后继续在命令中输入： <code>npm install npm -g</code> 回车后会发现正在下载npm包，在C:\dev\nvm\npm目录中可以看到下载中的文件，以后我们只要用npm安装包的时候加上 -g 就可以把包安装在我们刚刚配置的全局路径下了。</p><p>我们为这个npm配置环境变量： 变量名为：<code>NPM_HOME</code>，变量值为 ：<code>C:\dev\nvm\npm</code></p><p>在Path的最前面添加<code>;%NPM_HOME%</code>，注意了，这个一定要添加在 <code>%NVM_SYMLINK%</code> 之前，所以我们直接把它放到Path的最前面</p><p>最后我们新打开一个命令窗口，输入npm -v ,此时我们使用的就是我们统一下载的npm包了。</p><p>同样的我们还可以安装cnpm工具，它是中国版的npm镜像库，地址在这里：<a href="https://cnpmjs.org/，也是npm官方的一个拷贝，因为我们和外界有一堵墙隔着，所以用这个国内的比较快，淘宝也弄了一个和npm一样的镜像库，http://npm.taobao.org/，它和官方的npm每隔10分钟同步一次。安装方式：" target="_blank" rel="noopener">https://cnpmjs.org/，也是npm官方的一个拷贝，因为我们和外界有一堵墙隔着，所以用这个国内的比较快，淘宝也弄了一个和npm一样的镜像库，http://npm.taobao.org/，它和官方的npm每隔10分钟同步一次。安装方式：</a></p><pre><code>npm install -g cnpm --registry=http://r.cnpmjs.org</code></pre><p>或者用淘宝的 <code>npm install -g cnpm --registry=https://registry.npm.taoba.org</code><br>安装好了cnpm后，直接执行cnpm install 包名比如：cnpm install bower -g 就可以了。-g只是为了把包安装在全局路径下。如果不全局安装，也可以在当前目录中安装，不用-g就可以了。<br>nrm 的安装</p><h4 id="什么是nrm？"><a href="#什么是nrm？" class="headerlink" title="什么是nrm？"></a>什么是nrm？</h4><p>nrm就是npm registry manager 也就是npm的镜像源管理工具，有时候国外资源太慢，那么我们可以用这个来切换镜像源。<br>我们只要通过这个命令: npm install -g nrm 就可以实现安装。<br>注意-g可以直接放到install的后面，我们以后也最好这样用，因为这样用，我们可以在cmd中上下箭头切换最近命令的时候，容易修改，更方便操作。安装完成后，我们就可以使用了。<br>命令：nrm ls 用于展示所有可切换的镜像地址<br>命令：nrm use cnpm 我们这样就可以直接切换到cnpm上了。当然也可以按照上面罗列的其他内容进行切换。</p><h2 id="3-安装SourceTree"><a href="#3-安装SourceTree" class="headerlink" title="3. 安装SourceTree"></a>3. 安装SourceTree</h2><p><a href="http://download.csdn.net/download/wljk506/9888747" target="_blank" rel="noopener">继续安装sourcetree</a></p><h2 id="4-其他环境搭建"><a href="#4-其他环境搭建" class="headerlink" title="4. 其他环境搭建"></a>4. 其他环境搭建</h2><p>python2.7 python3 PHP MySQL MongoDB 什么的看着来吧，我用到了就往上面贴了…</p>]]></content>
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 装机 </tag>
            
            <tag> nvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【学习】underscore源码学习（三）——Array方法</title>
      <link href="/2017/06/09/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91underscore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94Array%E6%96%B9%E6%B3%95/"/>
      <url>/2017/06/09/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91underscore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94Array%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<blockquote><p>这一篇到了源码488行，主要是<code>underscore</code>对原生Array.prototype的一些扩展，arguments<code>参数</code>对象将在所有数组函数中工作 。然而, <code>_</code> 函数的设计并不只是针对稀疏（”sparse”）数组的。在下面的阅读学习中，我们会慢慢了解到</p></blockquote><a id="more"></a><h2 id="数组函数-488-747行"><a href="#数组函数-488-747行" class="headerlink" title="数组函数 488 - 747行"></a>数组函数 488 - 747行</h2><h3 id="first"><a href="#first" class="headerlink" title="first"></a>first</h3><p><code>first_.first(array, [n])</code> 返回array（数组）的第一个元素。传递 n参数将返回数组中从第一个元素开始的n个元素（返回数组中前 n 个元素）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the first element of an array. Passing **n** will return the first N</span></span><br><span class="line"><span class="comment">// values in the array. Aliased as `head` and `take`. The **guard** check</span></span><br><span class="line"><span class="comment">// allows it to work with `_.map`.</span></span><br><span class="line">_.first = _.head = _.take = <span class="function"><span class="keyword">function</span>(<span class="params">array, n, guard</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (array == <span class="literal">null</span> || array.length &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="literal">null</span> || guard) <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> _.initial(array, array.length - n);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Returns everything but the last entry of the array. Especially useful on</span></span><br><span class="line"><span class="comment">// the arguments object. Passing **n** will return all the values in</span></span><br><span class="line"><span class="comment">// the array, excluding the last N.</span></span><br><span class="line">_.initial = <span class="function"><span class="keyword">function</span>(<span class="params">array, n, guard</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> slice.call(array, <span class="number">0</span>, <span class="built_in">Math</span>.max(<span class="number">0</span>, array.length - (n == <span class="literal">null</span> || guard ? <span class="number">1</span> : n)));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>作用域内有三个同名方法，前两个if判断用于安全检测，若参数参数正确，则返回 _.initial(array, array.length - n)的调用结果，于是我们继续来看看这个initial方法</p><p>这里是slice在之前声明过，为原生数组的slice方法，参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" target="_blank">MDN - Array.prototype.slice</a><br>知道这个后也很简单了——对传递array的一个副本，返回前n个~</p><h3 id="last"><a href="#last" class="headerlink" title="last"></a>last</h3><p><code>_.last(array, n, guard)</code> 返回array（数组）的最后一个元素。传递 n参数将返回数组中从最后一个元素开始的n个元素（愚人码头注：返回数组里的后面的n个元素）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the last element of an array. Passing **n** will return the last N</span></span><br><span class="line"><span class="comment">// values in the array.</span></span><br><span class="line">_.last = <span class="function"><span class="keyword">function</span>(<span class="params">array, n, guard</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (array == <span class="literal">null</span> || array.length &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="literal">null</span> || guard) <span class="keyword">return</span> array[array.length - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">return</span> _.rest(array, <span class="built_in">Math</span>.max(<span class="number">0</span>, array.length - n));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns everything but the first entry of the array. Aliased as `tail` and `drop`.</span></span><br><span class="line"><span class="comment">// Especially useful on the arguments object. Passing an **n** will return</span></span><br><span class="line"><span class="comment">// the rest N values in the array.</span></span><br><span class="line">_.rest = _.tail = _.drop = <span class="function"><span class="keyword">function</span>(<span class="params">array, n, guard</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> slice.call(array, n == <span class="literal">null</span> || guard ? <span class="number">1</span> : n);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>last方法也差不多，只不过这里n是slice的第二个参数，也就是说从n开始，到array剩余的元素</p><h3 id="compact"><a href="#compact" class="headerlink" title="compact"></a>compact</h3><p><code>compact_.compact(array)</code> 返回一个除去所有false值的 array副本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Trim out all falsy values from an array.</span></span><br><span class="line">_.compact = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _.filter(array, <span class="built_in">Boolean</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从传入的数组中过滤掉“错误值”，虽然很短，但很有意思，filter方法我们在之前已经知道了，这里把Boolean作为参数直接传进去，隐式转换为false的值都会被过滤掉，即 null, 0, “”, undefined 和 NaN</p><h3 id="flatten"><a href="#flatten" class="headerlink" title="flatten"></a>flatten</h3><p><code>_.flatten(array, shallow)</code><br>将一个嵌套多层的数组 array（数组） (嵌套可以是任何层数)转换为只有一层的数组。 如果你传递 shallow参数，数组将只减少一维的嵌套。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Internal implementation of a recursive `flatten` function.</span></span><br><span class="line"><span class="keyword">var</span> flatten = <span class="function"><span class="keyword">function</span>(<span class="params">input, shallow, strict, output</span>) </span>&#123;</span><br><span class="line">  output = output || [];</span><br><span class="line">  <span class="keyword">var</span> idx = output.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = getLength(input); i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = input[i];</span><br><span class="line">    <span class="keyword">if</span> (isArrayLike(value) &amp;&amp; (_.isArray(value) || _.isArguments(value))) &#123;</span><br><span class="line">      <span class="comment">// Flatten current level of array or arguments object.</span></span><br><span class="line">      <span class="keyword">if</span> (shallow) &#123;        </span><br><span class="line">        <span class="keyword">var</span> j = <span class="number">0</span>, len = value.length;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; len) output[idx++] = value[j++];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        flatten(value, shallow, strict, output);</span><br><span class="line">        idx = output.length;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strict) &#123;</span><br><span class="line">      output[idx++] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Flatten out an array, either recursively (by default), or just one level.</span></span><br><span class="line">_.flatten = <span class="function"><span class="keyword">function</span>(<span class="params">array, shallow</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> flatten(array, shallow, <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里很有意思，说下我的理解。<code>var flatten = function() {}</code>这里是在作用域里声明了一个私有变量，然后 <code>_.flatten</code>是给 _ 添加属性方法，在函数作用域内，返回的 flatten是在上下文环境中的 var flatten 这个私有变量。</p><p>flatten 接受四个参数：</p><ul><li>input：待展开数组</li><li>shallow：是否是浅展开，反之为深度展开</li><li>strict：是否为严格模式</li><li>output：可以指定输出数组，如果指定了输出数组，则将展开后的数组添加至输出数组尾部</li></ul><p>对传入数组 input 进行遍历，对于遍历到的元素 value：<br>如果 value 为数组，则需要展开，浅展开很简单，只是展开该元素最外一层数组，深度展开则需要递归调用 flatten。<br>如果 value 不为数组，则只有在非严格模式下该 value 才会被赋值到新的数组中。</p><p>如果不是深度展开，只是从value(数组)中不断抽出元素赋值output中，否则进行递归</p><h3 id="without"><a href="#without" class="headerlink" title="without"></a>without</h3><p><code>_.without(array, otherArrays)</code> 返回一个删除所有values值后的 array副本</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a version of the array that does not contain the specified value(s).</span></span><br><span class="line">_.without = restArgs(<span class="function"><span class="keyword">function</span>(<span class="params">array, otherArrays</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _.difference(array, otherArrays);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 这里为了便于观看，我把 _.difference也拿到这里一起说了</span></span><br><span class="line"><span class="comment">// Take the difference between one array and a number of other arrays.</span></span><br><span class="line"><span class="comment">// Only the elements present in just the first array will remain.</span></span><br><span class="line">_.difference = restArgs(<span class="function"><span class="keyword">function</span>(<span class="params">array, rest</span>) </span>&#123;</span><br><span class="line">  rest = flatten(rest, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span> _.filter(array, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !_.contains(rest, value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>至于为什么能返回新的array副本，我们来看看这个方法。<br>之前介绍过了restArgs，就相当于es6的 …args 函数里的展开参数。 rest就是我们的 …args 在函数内部赋值给 rest变量。 这里返回的都是封装好的两个方法的调用，所以在直接代码中的封装为后续节省了很多代码量可读性也更高，所以我们在日常开发中，也应该学习。</p><p>_.contains 返回包含的参数在之前加上<code>!</code>即转为了 Boolean型，布尔型为true才会通过filter方法，所以该方法是这样拿到最后结果的。</p><h3 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h3><p><code>_.uniq(array, isSorted, iteratee, context)</code></p><p>返回 array去重后的副本, 使用 === 做相等测试. 如果您确定 array 已经排序, 那么给 isSorted 参数传递 true值, 此函数将运行的更快的算法. 如果要处理对象元素, 传递 iteratee函数来获取要对比的属性.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Produce a duplicate-free version of the array. If the array has already</span></span><br><span class="line"><span class="comment">// been sorted, you have the option of using a faster algorithm.</span></span><br><span class="line"><span class="comment">// Aliased as `unique`.</span></span><br><span class="line">_.uniq = _.unique = <span class="function"><span class="keyword">function</span>(<span class="params">array, isSorted, iteratee, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!_.isBoolean(isSorted)) &#123;</span><br><span class="line">    context = iteratee;</span><br><span class="line">    iteratee = isSorted;</span><br><span class="line">    isSorted = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (iteratee != <span class="literal">null</span>) iteratee = cb(iteratee, context);</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">var</span> seen = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = getLength(array); i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = array[i],</span><br><span class="line">        computed = iteratee ? iteratee(value, i, array) : value;</span><br><span class="line">    <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!i || seen !== computed) result.push(value);</span><br><span class="line">      seen = computed;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iteratee) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!_.contains(seen, computed)) &#123;</span><br><span class="line">        seen.push(computed);</span><br><span class="line">        result.push(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!_.contains(result, value)) &#123;</span><br><span class="line">      result.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>条件判断我们先略过，从for循环来看。如果排好序了, 直接通过比较操作!== 。<br>如果已经排序, seen 只需要反映最近一次见到的元素；<br>如果尚未排序, 且存在比较函数, 亦即不能直接通过 === 判断；<br>否则直接通过 contains 进行判断</p><h3 id="union"><a href="#union" class="headerlink" title="union"></a>union</h3><p><code>_.union(arrays)</code> 返回传入的 arrays（数组）并集：按顺序返回，返回数组的元素是唯一的，可以传入一个或多个 arrays（数组）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Produce an array that contains the union: each distinct element from all of</span></span><br><span class="line"><span class="comment">// the passed-in arrays.</span></span><br><span class="line">_.union = restArgs(<span class="function"><span class="keyword">function</span>(<span class="params">arrays</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _.uniq(flatten(arrays, <span class="literal">true</span>, <span class="literal">true</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="intersection"><a href="#intersection" class="headerlink" title="intersection"></a>intersection</h3><p><code>_.intersection(arrays)</code> 返回传入 arrays（数组）交集。结果中的每个值是存在于传入的每个arrays（数组）里。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Produce an array that contains every item shared between all the</span></span><br><span class="line"><span class="comment">// passed-in arrays.</span></span><br><span class="line">_.intersection = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">var</span> argsLength = <span class="built_in">arguments</span>.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = getLength(array); i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = array[i];</span><br><span class="line">    <span class="keyword">if</span> (_.contains(result, item)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">var</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argsLength; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!_.contains(<span class="built_in">arguments</span>[j], item)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j === argsLength) result.push(item);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>数组交集的求取思路为：遍历第一个数组的每个元素，在之后的所有数组中找寻是否有该元素，有则放入结果数组。</p><h3 id="difference"><a href="#difference" class="headerlink" title="difference"></a>difference</h3><p><code>_.difference(...array)</code> 求取数组差集</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Take the difference between one array and a number of other arrays.</span></span><br><span class="line"><span class="comment">// Only the elements present in just the first array will remain.</span></span><br><span class="line">_.difference = restArgs(<span class="function"><span class="keyword">function</span>(<span class="params">array, rest</span>) </span>&#123;</span><br><span class="line">  rest = flatten(rest, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span> _.filter(array, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !_.contains(rest, value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>数组差集的求取思路为：令剩余的数组为 rest，flatten方法在之前有提到过，相当于ES6里的…args。然后用filter方法对array进行处理， <code>_.contains</code>返回的是布尔值，再取反，也就是最终返回array中存在的，而 rest 中不存在的值。</p><h3 id="unzip-和-zip"><a href="#unzip-和-zip" class="headerlink" title="unzip 和 zip"></a>unzip 和 zip</h3><p><code>uniq_.uniq(array)</code> 数组解压就是将多个数组的对应位置的元素抽离出来，组成新的数组：</p><pre><code>[[&apos;moe&apos;, 18, &apos;male&apos;], [&apos;larry&apos;, 23, &apos;female&apos;], [&apos;curly&apos;, 30, &apos;male&apos;]]</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Complement of _.zip. Unzip accepts an array of arrays and groups</span></span><br><span class="line"><span class="comment">// each array's elements on shared indices.</span></span><br><span class="line">_.unzip = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> length = array &amp;&amp; _.max(array, getLength).length || <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">Array</span>(length);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">    result[index] = _.pluck(array, index);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>length为array.length，在其中做了安全校验，我们暂时省略。之后又声明了变量result，这是原生数组其长度为length。接下来进行循环，重组result，至于这个_.pluck怎么实现的我们放到后面来说… （还没看到那，说早了怕后面又忘了）</p><p>于是加上例子，更好地说明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">'fri'</span>, <span class="string">'yk'</span>, <span class="string">'wb'</span>];</span><br><span class="line"><span class="keyword">var</span> ages = [<span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>];</span><br><span class="line"><span class="keyword">var</span> hobby = [<span class="string">'LOL'</span>, <span class="string">'Dota2'</span>, [<span class="string">'毒奶粉'</span>, <span class="string">'亡者荣耀'</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> students = _.unzip([names, ages, hobby]);</span><br><span class="line"><span class="comment">// =&gt; students: [['fri', 22, 'LOL'], ['yk', 23, 'dota2'], ['wb', 24, ['毒奶粉', '亡者荣耀']]]</span></span><br></pre></td></tr></table></figure><p>_.zip(array)：压缩 array ~ 同字面意思</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Zip together multiple lists into a single array -- elements that share</span></span><br><span class="line"><span class="comment">// an index go together.</span></span><br><span class="line">_.zip = restArgs(_.unzip);</span><br></pre></td></tr></table></figure><p>就是上面 unzip方法的逆过程</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一章的学习主要是操作Array的相关函数。可发现，其实最主要都是第一章里介绍的主要方法，很多都是方法的封装与实现，可见我们有一个好的封装是多么重要。</p>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> underscore </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【学习】underscore源码学习（二）——集合函数</title>
      <link href="/2017/06/05/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91underscore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%9B%86%E5%90%88%E5%87%BD%E6%95%B0/"/>
      <url>/2017/06/05/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91underscore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%9B%86%E5%90%88%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<blockquote><p>这一篇到了源码170行以后，主要是<code>underscore(下文用下划线代替- -)</code>向外暴露的一些核心API， <code>_</code> 扩展了很多原生JS拥有的方法，有很多优秀地设计思想值得我们学习和探究。我们在用的过程中，了解到底层的实现更有利于我们将来的选择及性能优化</p></blockquote><a id="more"></a><h2 id="集合函数-170-486行"><a href="#集合函数-170-486行" class="headerlink" title="集合函数 170 - 486行"></a>集合函数 170 - 486行</h2><h3 id="each"><a href="#each" class="headerlink" title="each"></a>each</h3><p>_.each(obj, iteratee, [context]) </p><p><code>_</code> 的each方法遍历所传obj（这里可看作一个列表，数组或类数组）中的所有元素，按顺序用遍历输出每个元素。如果传递了context参数，则把iteratee绑定到context对象上。每次调用iteratee都会传递三个参数：(element, index, list)。如果list是个JavaScript对象，iteratee的参数是 (value, key, list))。返回list以方便链式调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_.each = _.forEach = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) </span>&#123;</span><br><span class="line">  iteratee = optimizeCb(iteratee, context);</span><br><span class="line">  <span class="keyword">var</span> i, length;</span><br><span class="line">  <span class="keyword">if</span> (isArrayLike(obj)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, length = obj.length; i &lt; length; i++) &#123;</span><br><span class="line">      iteratee(obj[i], i, obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> keys = _.keys(obj);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, length = keys.length; i &lt; length; i++) &#123;</span><br><span class="line">      iteratee(obj[keys[i]], keys[i], obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_.each([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], i =&gt; <span class="built_in">console</span>.log(i));  </span><br><span class="line">=&gt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  注，返回的是每个迭代对象自身</span><br><span class="line">_.each(&#123;<span class="attr">a</span>: <span class="string">'1'</span>, <span class="attr">b</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="attr">c</span>:&#123;<span class="attr">name</span>: <span class="string">'fri'</span>&#125;&#125;, item =&gt; <span class="built_in">console</span>.log(item))</span><br><span class="line">=&gt; <span class="number">1</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], &#123;<span class="attr">name</span>: <span class="string">'fri'</span>&#125;  注：返回的是迭代对象的每一项，拿到的是value值</span><br></pre></td></tr></table></figure><p><code>iteratee = optimizeCb(iteratee, context)形成一个递归调用</code>，if分支用于控制是迭代数组还是对象，最后返回的是迭代的自身。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>_.map(obj, iteratee, [context]) </p><p>通过转换函数(iteratee迭代器)映射列表中的每个值产生价值的新数组。该方法接收三个参数，循环对象，迭代器和环境参数。后两个参数作为活动对象传到了cb方法中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_.map = _.collect = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) </span>&#123;</span><br><span class="line">  iteratee = cb(iteratee, context);</span><br><span class="line">  <span class="keyword">var</span> keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</span><br><span class="line">      length = (keys || obj).length,</span><br><span class="line">      results = <span class="built_in">Array</span>(length);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentKey = keys ? keys[index] : index;</span><br><span class="line">    results[index] = iteratee(obj[currentKey], currentKey, obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_.map([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], num =&gt; num * <span class="number">2</span>);</span><br><span class="line">=&gt; [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>] 注：返回的是results这是一个数组</span><br><span class="line"></span><br><span class="line">_.map(&#123;<span class="attr">name</span>: <span class="string">'fri'</span>, <span class="attr">age</span>: <span class="number">24</span>&#125;, (k, v) =&gt; <span class="string">`<span class="subst">$&#123;k&#125;</span>: <span class="subst">$&#123;v&#125;</span>`</span>);</span><br><span class="line">=&gt; [<span class="string">"fri: name"</span>, <span class="string">"24: age"</span>] map一个对象，返回的是由key,val组成的数组</span><br></pre></td></tr></table></figure><ul><li>keys, length, results这三个变量的声明很精髓，(后面也有很多地方用到) !有隐式转换变为布尔型，所以keys = <code>布尔</code> &amp;&amp; _.keys(obj) 因为逻辑与，表达式成立的条件是，前面部分会为真，即这句直接拿到了 _.key(obj)。</li><li>数组中才有length这一属性，普通对象中是没有定义的</li><li>Array(length)会创建一个长度为length的数组这么再来看循环体中的results[index]就清楚多了</li></ul><h3 id="reduce-reduceRight"><a href="#reduce-reduceRight" class="headerlink" title="reduce reduceRight"></a>reduce reduceRight</h3><p>_.reduce(list, iteratee, [memo], [context])<br>_.reduceRight(list, iteratee, memo, [context])</p><p>reduce方法把list中元素归结为一个单独的数值。<br>Memo是reduce函数的初始值，reduce的每一步都需要由iteratee返回。这个迭代传递4个参数：memo,value 和 迭代的index（或者 key）和最后一个引用的整个 list。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createReduce = <span class="function"><span class="keyword">function</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> reducer = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, memo, initial</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</span><br><span class="line">        length = (keys || obj).length,</span><br><span class="line">        index = dir &gt; <span class="number">0</span> ? <span class="number">0</span> : length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!initial) &#123;</span><br><span class="line">      memo = obj[keys ? keys[index] : index];</span><br><span class="line">      index += dir;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; index &gt;= <span class="number">0</span> &amp;&amp; index &lt; length; index += dir) &#123;</span><br><span class="line">      <span class="keyword">var</span> currentKey = keys ? keys[index] : index;</span><br><span class="line">      memo = iteratee(memo, obj[currentKey], currentKey, obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, memo, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> initial = <span class="built_in">arguments</span>.length &gt;= <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> reducer(obj, optimizeCb(iteratee, context, <span class="number">4</span>), memo, initial);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_.reduce = _.foldl = _.inject = createReduce(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">_.reduceRight = _.foldr = createReduce(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.reduce([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], (memo, num) =&gt; memo + num)</span><br><span class="line">=&gt; <span class="number">6</span>  这里只传了memo和num, 因为传入的是数组initial默认为<span class="number">0</span></span><br></pre></td></tr></table></figure><p>如果没有memo传递给reduce的初始调用，iteratee不会被列表中的第一个元素调用。第一个元素将取代 传递给列表中下一个元素调用iteratee的memo参数。</p><p>最外层的匿名函数中的dir传到了 <code>index = dir &gt; 0 ? 0 : length - 1</code> 由dir来判断是reduce还是reduceRight，这里高度抽象的思想值得我们学习</p><p>createReduce是 <code>_</code> 作用域中的私有变量，外部访问不到，这里 _.reduce 是向外暴露的接口，我们调用的api 其实是调用craeteReduce()所返回的函数</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>_.find(obj, predicate, [context]) </p><p>keyFinder的结果由传入obj是数组(下标)还是对象(key)决定，这里的key是一个递归调用。在obj中逐项查找，返回第一个通过predicate迭代函数真值检测的元素值，如果没有值传递给测试迭代器将返回undefined。 如果找到匹配的元素，函数将立即返回，不会遍历整个list。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_.find = _.detect = <span class="function"><span class="keyword">function</span>(<span class="params">obj, predicate, context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// _.findIndex() 652行</span></span><br><span class="line">  <span class="comment">// _.findKey() 1093行</span></span><br><span class="line">  <span class="keyword">var</span> keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;</span><br><span class="line">  <span class="keyword">var</span> key = keyFinder(obj, predicate, context);</span><br><span class="line">  <span class="keyword">if</span> (key !== <span class="keyword">void</span> <span class="number">0</span> &amp;&amp; key !== <span class="number">-1</span>) <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.find([<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], num =&gt; num % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">=&gt; <span class="number">5</span>， 找到<span class="number">5</span>就不会继续找<span class="number">7</span>了</span><br></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>_.filter(obj, predicate, [context]) </p><p>遍历所传obj中的每个值，返回包含所有通过predicate真值检测的元素值。（如果存在原生filter方法，则用原生的filter方法。）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_.filter = _.select = <span class="function"><span class="keyword">function</span>(<span class="params">obj, predicate, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> results = [];</span><br><span class="line">  predicate = cb(predicate, context);</span><br><span class="line">  _.each(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, index, list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (predicate(value, index, list)) results.push(value);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_.reject = <span class="function"><span class="keyword">function</span>(<span class="params">obj, predicate, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _.filter(obj, _.negate(cb(predicate)), context);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_.filter([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>], num =&gt; num % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line">=&gt; [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>] <span class="number">3</span>被过滤掉</span><br><span class="line">_.filter([&#123;<span class="attr">name</span>:<span class="string">'fri'</span>&#125;,&#123;<span class="attr">name</span>: <span class="string">'yk'</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">'hhh'</span>&#125;], item =&gt; item[<span class="string">'name'</span>] == <span class="string">'fri'</span>)</span><br><span class="line">=&gt; [&#123;<span class="attr">name</span>: <span class="string">'fri'</span>&#125;]</span><br></pre></td></tr></table></figure><p>这里额外说两句，其实暴露的API写法大同小异，主要是理解核心方法中的 <code>cb</code> <code>optimizeCb</code> 知道 <code>_</code> 是怎么通过高阶函数传参，拿到传入对象（函数）的作用域 <code>func.apply(context, arguments);</code></p><h3 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h3><p>_.reject(list, predicate, [context]) 返回list中没有通过predicate真值检测的元素集合，与filter相反</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_.reject = <span class="function"><span class="keyword">function</span>(<span class="params">obj, predicate, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _.filter(obj, _.negate(cb(predicate)), context);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对<em>.filter的一个封装， `</em>.negate(916行)`可见到，返回的是结果为false的集合</p><h3 id="every"><a href="#every" class="headerlink" title="every"></a>every</h3><p>_.every(obj, [predicate], [context])  如果list中的所有元素都通过predicate的真值检测就返回true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_.every = _.all = <span class="function"><span class="keyword">function</span>(<span class="params">obj, predicate, context</span>) </span>&#123;</span><br><span class="line">  predicate = cb(predicate, context);</span><br><span class="line">  <span class="keyword">var</span> keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</span><br><span class="line">      length = (keys || obj).length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentKey = keys ? keys[index] : index;</span><br><span class="line">    <span class="keyword">if</span> (!predicate(obj[currentKey], currentKey, obj)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.every([<span class="literal">false</span>, <span class="number">0</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="number">1</span>], item =&gt; item != <span class="literal">true</span>) </span><br><span class="line">=&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="some"><a href="#some" class="headerlink" title="some"></a>some</h3><p>_.some(obj, [predicate], [context])  如果obj中有任何一个元素通过 predicate 的真值检测就返回true。一旦找到了符合条件的元素, 就直接中断对obj的遍历. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_.some = _.any = <span class="function"><span class="keyword">function</span>(<span class="params">obj, predicate, context</span>) </span>&#123;</span><br><span class="line">  predicate = cb(predicate, context);</span><br><span class="line">  <span class="keyword">var</span> keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</span><br><span class="line">      length = (keys || obj).length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentKey = keys ? keys[index] : index;</span><br><span class="line">    <span class="keyword">if</span> (predicate(obj[currentKey], currentKey, obj)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.some([<span class="literal">false</span>, <span class="number">0</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="number">1</span>], item =&gt; item == <span class="literal">true</span>) </span><br><span class="line">=&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h3><p>_.contains(obj, value, [fromIndex])  如果obj包含指定的value则返回true。如果obj 是数组，内部使用indexOf判断。使用fromIndex来给定开始检索的索引位置。这个方法ES6已有实现 参考<code>Array.prototype.includes</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_.contains = _.includes = _.include = <span class="function"><span class="keyword">function</span>(<span class="params">obj, item, fromIndex, guard</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isArrayLike(obj)) obj = _.values(obj);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fromIndex != <span class="string">'number'</span> || guard) fromIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> _.indexOf(obj, item, fromIndex) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.contains([a,b,c], <span class="number">3</span>)</span><br><span class="line">=&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="invoke"><a href="#invoke" class="headerlink" title="invoke"></a>invoke</h3><p>_.invoke(list, methodName, *arguments) 在list的每个元素上执行methodName方法。 任何传递给invoke的额外参数，invoke都会在调用methodName方法的时候传递给它</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">_.invoke = restArgs(<span class="function"><span class="keyword">function</span>(<span class="params">obj, path, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> contextPath, func;</span><br><span class="line">  <span class="keyword">if</span> (_.isFunction(path)) &#123;</span><br><span class="line">    func = path;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_.isArray(path)) &#123;</span><br><span class="line">    contextPath = path.slice(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    path = path[path.length - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _.map(obj, <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> method = func;</span><br><span class="line">    <span class="keyword">if</span> (!method) &#123;</span><br><span class="line">      <span class="keyword">if</span> (contextPath &amp;&amp; contextPath.length) &#123;</span><br><span class="line">        context = deepGet(context, contextPath);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (context == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">      method = context[path];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> method == <span class="literal">null</span> ? method : method.apply(context, args);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.invoke([[<span class="number">5</span>, <span class="number">1</span>, <span class="number">7</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]], <span class="string">'sort'</span>);</span><br><span class="line">=&gt; [[<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br></pre></td></tr></table></figure><h3 id="pluck"><a href="#pluck" class="headerlink" title="pluck"></a>pluck</h3><p>_.pluck(list, propertyName)  萃取数组对象中某属性值，返回一个数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_.pluck = <span class="function"><span class="keyword">function</span>(<span class="params">obj, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _.map(obj, _.property(key));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stooges = [&#123;<span class="attr">name</span>: <span class="string">'moe'</span>, <span class="attr">age</span>: <span class="number">40</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">'larry'</span>, <span class="attr">age</span>: <span class="number">50</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">'curly'</span>, <span class="attr">age</span>: <span class="number">60</span>&#125;];</span><br><span class="line">_.pluck(stooges, <span class="string">'name'</span>);</span><br><span class="line">=&gt; [<span class="string">"moe"</span>, <span class="string">"larry"</span>, <span class="string">"curly"</span>]</span><br></pre></td></tr></table></figure><p>这是对 _.map用法的一个封装</p><h3 id="where、findWhere"><a href="#where、findWhere" class="headerlink" title="where、findWhere"></a>where、findWhere</h3><p>_.where(obj, attrs) 遍历obj中的每一个值，返回一个数组，这个数组包含attrs所列出的属性的所有的 键 - 值对。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_.where = <span class="function"><span class="keyword">function</span>(<span class="params">obj, attrs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _.filter(obj, _.matcher(attrs));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>_.findWhere(obj, attrs) 遍历整个obj，返回匹配 properties参数所列出的所有 键 - 值 对的第一个值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_.findWhere = <span class="function"><span class="keyword">function</span>(<span class="params">obj, attrs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _.find(obj, _.matcher(attrs));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="max-和-min"><a href="#max-和-min" class="headerlink" title="max 和 min"></a>max 和 min</h3><p>_.max(obj, [iteratee], [context]) 返回list中的最大值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> _.max = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = -<span class="literal">Infinity</span>, </span><br><span class="line">    lastComputed = -<span class="literal">Infinity</span>,</span><br><span class="line">    value, </span><br><span class="line">    computed;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (iteratee == <span class="literal">null</span> || (<span class="keyword">typeof</span> iteratee == <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> obj[<span class="number">0</span>] != <span class="string">'object'</span>) &amp;&amp; obj != <span class="literal">null</span>) &#123;</span><br><span class="line">    obj = isArrayLike(obj) ? obj : _.values(obj);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = obj.length; i &lt; length; i++) &#123;</span><br><span class="line">      value = obj[i];</span><br><span class="line">      <span class="keyword">if</span> (value != <span class="literal">null</span> &amp;&amp; value &gt; result) &#123;</span><br><span class="line">        result = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    iteratee = cb(iteratee, context);</span><br><span class="line">    _.each(obj, <span class="function"><span class="keyword">function</span>(<span class="params">v, index, list</span>) </span>&#123;</span><br><span class="line">      computed = iteratee(v, index, list);</span><br><span class="line">      <span class="keyword">if</span> (computed &gt; lastComputed || computed === -<span class="literal">Infinity</span> &amp;&amp; result === -<span class="literal">Infinity</span>) &#123;</span><br><span class="line">        result = v;</span><br><span class="line">        lastComputed = computed;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里是实现看起来挺复杂，不要畏惧，一行一行来。 第一段if做了安全检测，防止内存溢出，虽然一般人用不会乱传数字，但xx就不一定了是吧。 让我们继续来断句</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  iteratee == <span class="literal">null</span> || (<span class="keyword">typeof</span> iteratee == <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> obj[<span class="number">0</span>] != <span class="string">'object'</span>) </span><br><span class="line">    &amp;&amp; obj != <span class="literal">null</span></span><br><span class="line">) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过条件为 第2行 的 逻辑或 || 成立<br>1  iteratee == null<br>2  typeof iteratee == ‘number’ &amp;&amp; typeof obj[0] != ‘object’<br>两句任其一为真即可，1.8.3与1.8.2中唯一的变化就是对obj类型检测提炼了，让其能对对象或数组都能安全迭代，最后返回的 result 即为安全的value值</p><p>那么当安全检测未通过时，<code>_</code>是这么来处理的，<code>iteratee = cb(iteratee, context)</code> 让其提供安全的作用域，然后对传入的obj进行迭代（_.each） computed拿到了迭代对象的作用域，进行自处理，把拿到的值进行安全处理（赋值）</p><p>继续断句：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  (computed &gt; lastComputed) || </span><br><span class="line">  (computed === -<span class="literal">Infinity</span> &amp;&amp; result === -<span class="literal">Infinity</span>)</span><br><span class="line">) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样看就容易多了，-Infinity限制了所传或最终得到的结果会在js允许的安全范围内</p><p>_.min(obj, [iteratee], [context]) 返回list中的最小值。如果传递iteratee参数，iteratee将作为list中每个值的排序依据，如果list为空，将返回-Infinity，所以你可能需要事先用isEmpty检查 list 。</p><p>这里和 _.max 差不多就不做过多解释了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">_.min = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="literal">Infinity</span>, lastComputed = <span class="literal">Infinity</span>,</span><br><span class="line">      value, computed;</span><br><span class="line">  <span class="keyword">if</span> (iteratee == <span class="literal">null</span> || (<span class="keyword">typeof</span> iteratee == <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> obj[<span class="number">0</span>] != <span class="string">'object'</span>) &amp;&amp; obj != <span class="literal">null</span>) &#123;</span><br><span class="line">    obj = isArrayLike(obj) ? obj : _.values(obj);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = obj.length; i &lt; length; i++) &#123;</span><br><span class="line">      value = obj[i];</span><br><span class="line">      <span class="keyword">if</span> (value != <span class="literal">null</span> &amp;&amp; value &lt; result) &#123;</span><br><span class="line">        result = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    iteratee = cb(iteratee, context);</span><br><span class="line">    _.each(obj, <span class="function"><span class="keyword">function</span>(<span class="params">v, index, list</span>) </span>&#123;</span><br><span class="line">      computed = iteratee(v, index, list);</span><br><span class="line">      <span class="keyword">if</span> (computed &lt; lastComputed || computed === <span class="literal">Infinity</span> &amp;&amp; result === <span class="literal">Infinity</span>) &#123;</span><br><span class="line">        result = v;</span><br><span class="line">        lastComputed = computed;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="sample-和-shuffle"><a href="#sample-和-shuffle" class="headerlink" title="sample 和 shuffle"></a>sample 和 shuffle</h3><p>_.sample(obj, [n], [guard]) 从 obj中产生一个随机样本。传递一个数字表示从obj中返回n个随机元素。否则将返回一个单一的随机项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_.sample = <span class="function"><span class="keyword">function</span>(<span class="params">obj, n, guard</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="literal">null</span> || guard) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isArrayLike(obj)) obj = _.values(obj);</span><br><span class="line">    <span class="keyword">return</span> obj[_.random(obj.length - <span class="number">1</span>)];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);</span><br><span class="line">  <span class="keyword">var</span> length = getLength(sample);</span><br><span class="line">  n = <span class="built_in">Math</span>.max(<span class="built_in">Math</span>.min(n, length), <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">var</span> last = length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; n; index++) &#123;</span><br><span class="line">    <span class="keyword">var</span> rand = _.random(index, last);</span><br><span class="line">    <span class="keyword">var</span> temp = sample[index];</span><br><span class="line">    sample[index] = sample[rand];</span><br><span class="line">    sample[rand] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sample.slice(<span class="number">0</span>, n);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们先看if段，当n或guard未传时返回所传时，返回obj中的一个随机项。<br>若传了n和guard时，用<code>私有变量sample</code>存储了对obj的处理——数组浅拷贝，对象就创建一个副本。然后遍历sample将其内容打乱并返回。</p><p>_.shuffle(obj) 返回一个随机乱序的 list 副本</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_.shuffle = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _.sample(obj, <span class="literal">Infinity</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上懂了sample方法这里就很简单了，shuffle方法即是对sample的一种应用，传入obj，n取无限大（即obj.length）这样返回的是打乱后的obj</p><h3 id="sortBy"><a href="#sortBy" class="headerlink" title="sortBy"></a>sortBy</h3><p>_.sortBy(obj, iteratee, [context]) 返回一个排序后的list拷贝副本。如果传递iteratee参数，iteratee将作为list中每个值的排序依据。迭代器也可以是字符串的属性的名称进行排序的(比如 length)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">_.sortBy = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">  iteratee = cb(iteratee, context);</span><br><span class="line">  <span class="keyword">return</span> _.pluck(_.map(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, key, list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      value: value,</span><br><span class="line">      index: index++,</span><br><span class="line">      criteria: iteratee(value, key, list)</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;).sort(<span class="function"><span class="keyword">function</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = left.criteria;</span><br><span class="line">    <span class="keyword">var</span> b = right.criteria;</span><br><span class="line">    <span class="keyword">if</span> (a !== b) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a &gt; b || a === <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (a &lt; b || b === <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left.index - right.index;</span><br><span class="line">  &#125;), <span class="string">'value'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们直接看return就好， _.pluck()返回由obj的某些值所组成的’数组’(当然，1.8.3扩展后也可以是对象)，然后再对这个’数组’进行原生的sort()排序，并将结果返回</p><h3 id="group"><a href="#group" class="headerlink" title="group"></a>group</h3><p>这是用于聚合group by操作的内部函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> group = <span class="function"><span class="keyword">function</span>(<span class="params">behavior, partition</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = partition ? [[], []] : &#123;&#125;;</span><br><span class="line">    iteratee = cb(iteratee, context);</span><br><span class="line">    _.each(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> key = iteratee(value, index, obj);</span><br><span class="line">      behavior(result, value, key);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所传的behavior其实是一个回调函数，只是这里表现得很语义化，我们读源码要根据上下文来看，不然很容易迷糊。这里的group是一个高阶函数，对内层进行了封装，group执行后返回一个闭包，该闭包执行后返回处理结果。<br>在闭包用变量<code>result</code>对partition进行兼容处理，若数组则[[], []]分隔开，对象的话默认处理为空对象，iteratee我们见得很多了，即返回一个安全的执行环境。然后迭代所传对闭包所传的参数obj，内部有声明一个变量key用于返回新的执行环境<br>这里有点绕，允许我啰嗦一下（以后水平上来了会精简，这里我尽量用自己的话说清楚）iteratee()后返回的执行环境在 group执行返回的闭包中，这个闭包里进行的迭代由于绑定了obj，就由group的调用 _ 这个环境跳到了 所要迭代的对象 obj 中了~ 然后此时的回调 behavior再来对result进行处理</p><p>有点把自己绕进去了，我们先来看看实际运用，就知道为什么要进行这个封装了</p><p><strong>groupBy</strong> _.groupBy(result, value, key) 把一个集合分组为多个集合，通过 value 返回的结果进行分组. 如果 value 是一个字符串而不是函数, 那么将使用 value 作为各元素的属性名来对比进行分组.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_.groupBy = group(<span class="function"><span class="keyword">function</span>(<span class="params">result, value, key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// _.has()方法在1369行  用于对象是否包含给定的键</span></span><br><span class="line">  <span class="keyword">if</span> (_.has(result, key)) result[key].push(value); </span><br><span class="line">  <span class="keyword">else</span> result[key] = [value];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>indexBy</strong> </p><p>_.indexBy(result, value, key) 给定一个集合(对象)，和 一个用来返回一个在列表中的每个元素键 的iterator 函数（或属性名）， 返回一个每一项索引的对象。和groupBy非常像，但是当你知道你的键是唯一的时候可以使用indexBy 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_.indexBy = group(<span class="function"><span class="keyword">function</span>(<span class="params">result, value, key</span>) </span>&#123;</span><br><span class="line">  result[key] = value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>countBy</strong>  countBy_.countBy(list, iteratee, [context]) 排序一个列表组成一个组，并且返回各组中的对象的数量的计数。类似groupBy，但是不是返回列表的值，而是返回在该组中值的数目。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_.countBy = group(<span class="function"><span class="keyword">function</span>(<span class="params">result, value, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_.has(result, key)) result[key]++; <span class="keyword">else</span> result[key] = <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h3><p>_.toArray(obj) 把obj(任何可以迭代的对象)转换成一个数组，在转换 arguments 对象时非常有用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_.toArray = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!obj) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">if</span> (_.isArray(obj)) <span class="keyword">return</span> slice.call(obj);</span><br><span class="line">  <span class="keyword">if</span> (_.isString(obj)) &#123;</span><br><span class="line">    <span class="comment">// Keep surrogate pair characters together</span></span><br><span class="line">    <span class="keyword">return</span> obj.match(reStrSymbol);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isArrayLike(obj)) <span class="keyword">return</span> _.map(obj, _.identity);</span><br><span class="line">  <span class="keyword">return</span> _.values(obj);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>.size(obj) 返回所传合法对象的长度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_.size = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> isArrayLike(obj) ? obj.length : _.keys(obj).length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这其实是一个扩展处理，我们知道对象是没有length属性的。这里进行了处理，返回 由对象的key值所组成数组的长度~</p><h3 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h3><p>_.partition(array, predicate) 拆分一个数组（array）为两个数组：  第一个数组其元素都满足predicate迭代函数， 而第二个的所有元素均不能满足predicate迭代函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_.partition = group(<span class="function"><span class="keyword">function</span>(<span class="params">result, value, pass</span>) </span>&#123;</span><br><span class="line">  result[pass ? <span class="number">0</span> : <span class="number">1</span>].push(value);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>group的第一个参数是个回调没异议，第二个传了一个true是什么呢？ 我们可翻到上面看看，<code>partition</code>的值决定了如何处理result 这里变成了 [[], []] 的形式。那么很简单了，根据回调的pass结果，通过放到 [[], []][0]中， 未通过则放到[[], []][1]中</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>随着 underscore.js 源码的阅读与学习深入，我们可以了解到很多底层封装的原理与细节。在阅读源码时，不要害怕自己看不懂，理解错，不清楚的地方可以单独拎出来，自己写写或者代码跑起来看看效果以便加深理解。</p><p>Collections Function中，其实很多都是对第一章核心函数的一些封装和重复使用，如cb optimizeCb这类用得多的，向外暴露的API又可以让封装的其他API来使用，如 where findWhere就是对filter的运用， pluck是对map的二次封装。</p>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> underscore </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【学习】underscore源码学习（一）——核心架构</title>
      <link href="/2017/06/02/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91underscore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84/"/>
      <url>/2017/06/02/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91underscore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84/</url>
      <content type="html"><![CDATA[<blockquote><p>读源码是一个提升自己编码和架构的有效方式，明明知道但一直没敢尝试，就算是学习jQuery的源码也是跟着大神的视频，博客一点点填坑的，之前也苦于写的博客没什么技术含量，要不就是自己都知道的，要不就是摘录书中的一些经验，久之反倒没了写博客的兴趣。underscore.js是个优秀的工具库，总代码行也就1600行+ 每天读50行+的速度一个月也能搞定，这么一想完全就不怕了。</p></blockquote><p>多点信心，不怕犯错，多记录和搜索这样利于自己巩固，嗯嗯… 也为后面看Vue、React、Redux源码什么的打点基础，当然那是后话了… 希望这个系列能把坑填完就好</p><a id="more"></a><hr><p><code>注：underscore 叫着太啰嗦- - 下文都用 _ 来指代了， 既然是读underscore想必也能接受</code></p><p>那么直接开始正文吧~~</p><h2 id="命名空间管理"><a href="#命名空间管理" class="headerlink" title="命名空间管理"></a>命名空间管理</h2><p>最外层是一个IIFE(立即调用函数)，各大框架常用，如jQuery就是典型，这是为了模拟块级作用域，防止污染全局命名空间。具体的好处和由来可以去谷歌一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">((<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)());</span><br></pre></td></tr></table></figure><h2 id="变量声明-14-168行"><a href="#变量声明-14-168行" class="headerlink" title="变量声明 14-168行"></a>变量声明 14-168行</h2><h3 id="巧妙地变量声明"><a href="#巧妙地变量声明" class="headerlink" title="巧妙地变量声明"></a>巧妙地变量声明</h3><p>巧妙地变量声明可以让程序执行地更加效率，关于这些点，在后文中我会力所能及地表达清楚<br>在说这点前，大家可以看看JS高级程序的第7章函数部分有提到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> root = <span class="keyword">typeof</span> self == <span class="string">'object'</span> &amp;&amp; self.self === self &amp;&amp; self ||</span><br><span class="line">  <span class="keyword">typeof</span> global == <span class="string">'object'</span> &amp;&amp; global.global === global &amp;&amp; global ||</span><br><span class="line">  <span class="keyword">this</span> ||</span><br><span class="line">  &#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="了解运算符优先级"><a href="#了解运算符优先级" class="headerlink" title="了解运算符优先级"></a>了解运算符优先级</h3><p>声明root变量，首先我们要了解JS的运算符优先级，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener">运算符优先级</a></p><p>以下运算符从高到低:</p><ul><li>16  typeof</li><li>10  ==、=== </li><li>6   逻辑与 &amp;&amp;</li><li>5   逻辑或 ||</li></ul><p>那么我们重新审视这串代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> root = </span><br><span class="line">  ((<span class="keyword">typeof</span> self == <span class="string">'object'</span>) &amp;&amp; (self.self === self) &amp;&amp; self) ||</span><br><span class="line">  ((<span class="keyword">typeof</span> global == <span class="string">'object'</span>) &amp;&amp; (global.global === global) &amp;&amp; global) ||</span><br><span class="line">  <span class="keyword">this</span> ||</span><br><span class="line">  &#123;&#125;;</span><br></pre></td></tr></table></figure><p>这样会好理解一些了，把root定义为全局对象，如果不是在浏览器或者Node.js环境中就设为一个空对象</p><pre><code>var previousUnderscore = root._;</code></pre><p>previousUnderscore作为全局对象的属性存储，其名为 <code>_</code> ，说不清，但很简单，举个例：</p><pre><code>((function() {  var root = window || {};  var pu = root._;  pu = {    &apos;name&apos;: &apos;fri&apos;,    &apos;age&apos;: 24  }})());console.log(_);</code></pre><p>内部作用域的私有变量是pu，但通过root._ 的形式暴露给了全局对象，所以在全局通过 <code>_</code> 变量就能访问到内部pu对象了</p><p><code>注：这段代码在严格模式下会报错 ReferenceError: _ is not defined</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ArrayProto = <span class="built_in">Array</span>.prototype, </span><br><span class="line">    ObjProto = <span class="built_in">Object</span>.prototype;</span><br><span class="line"><span class="keyword">var</span> SymbolProto = <span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">'undefined'</span> ? <span class="built_in">Symbol</span>.prototype : <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> push = ArrayProto.push,</span><br><span class="line">    slice = ArrayProto.slice,</span><br><span class="line">    toString = ObjProto.toString,</span><br><span class="line">    hasOwnProperty = ObjProto.hasOwnProperty;</span><br><span class="line"><span class="keyword">var</span> nativeIsArray = <span class="built_in">Array</span>.isArray,</span><br><span class="line">    nativeKeys = <span class="built_in">Object</span>.keys,</span><br><span class="line">    nativeCreate = <span class="built_in">Object</span>.create;</span><br></pre></td></tr></table></figure><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>这里的用处差不多，我就放到一块了，之前我提到过作用域链，而JS是没有类这一说的，其实是通过对象，对象的原型这样一层一层建立起对象的引用关系从而拿到活动对象上的值。</p><p>我们看几个原型变量的声明，其实就是简化原型链的查找过程，还是举个例子：</p><pre><code>var arr = [];arr.push(&apos;a&apos;);</code></pre><p>声明arr变量为一个空数组，添加一个元素’a’，这个push方法是在arr上的吗？并不是，arr变量上找不到push方法，会搜索arr的原型prototype(arr的constructor指向的对象 -&gt; 这里是Array)。<br>通过原型链一层层往上找，最终在Array.prototype上找到了push方法，也就是说程序执行 arr.push(‘a’)时，检索到push方法经历了3次搜索即 <code>arr本身 -&gt; Array对象 -&gt; Array.prototype</code><br>执行效率并不高，所以 var ArrPro = Array.prototype 这样的声明就是减少了搜索过程，从而提升了最终的运行速度</p><pre><code>var SymbolProto = typeof Symbol !== &apos;undefined&apos; ? Symbol.prototype : null;</code></pre><p>这里顺便提一下，是对ES6新增的基本数据类型Symbol进行兼容处理</p><p>我们接着读</p><pre><code>var Ctor = function(){};    </code></pre><p>这里声明了<code>Ctor</code>对象 为一个匿名函数，用于代理原型交换</p><h3 id="安全引用"><a href="#安全引用" class="headerlink" title="安全引用"></a>安全引用</h3><p>这里为 <code>_</code> 创建一个安全的引用，这里 <code>_</code> 是作为一个方法存在，我们结合后面的例子再来说这块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> _) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> _)) <span class="keyword">return</span> <span class="keyword">new</span> _(obj);</span><br><span class="line">  <span class="keyword">this</span>._wrapped = obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> exports != <span class="string">'undefined'</span> &amp;&amp; !exports.nodeType) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> != <span class="string">'undefined'</span> &amp;&amp; !<span class="built_in">module</span>.nodeType &amp;&amp; <span class="built_in">module</span>.exports) &#123;</span><br><span class="line">    exports = <span class="built_in">module</span>.exports = _;</span><br><span class="line">  &#125;</span><br><span class="line">  exports._ = _;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  root._ = _;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用于支持Node.js，若在浏览器中就让<code>_</code>成为全局对象<br>xxx &amp;&amp; xxx 这样的语句其实有断句，首先 typeof exports != ‘undefinded’ 若为false 函数将直接跳过这段语句</p><pre><code>_.VERSION = &apos;1.8.3&apos;;</code></pre><p><code>_</code> 的属性， 存储版本号，你看到这里可能很奇怪，之前不是让 <code>var _ = function() { ... }</code>了吗，这并不冲突，因为在JS这门语言中一切皆对象，函数也是对象仅此而已<code>(Function instanceof Object  // true)</code>  <code>_</code> 本身声明为一个匿名函数，但它本身是一个引用类型的数据(对象)，所以继续声明其他属性，或是删除属性也是没有问题的。</p><p>68-87行</p><h3 id="optimizeCb-与-函数柯里化"><a href="#optimizeCb-与-函数柯里化" class="headerlink" title="optimizeCb 与 函数柯里化"></a>optimizeCb 与 函数柯里化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> optimizeCb = <span class="function"><span class="keyword">function</span>(<span class="params">func, context, argCount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context === <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">return</span> func;</span><br><span class="line">  <span class="keyword">switch</span> (argCount) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> func.call(context, value);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// The 2-parameter case has been omitted only because no current consumers</span></span><br><span class="line">    <span class="comment">// made use of it.</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">null</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">value, index, collection</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> func.call(context, value, index, collection);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">accumulator, value, index, collection</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> func.call(context, accumulator, value, index, collection);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> func.apply(context, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>optimizeCb</code>是<code>_</code>的一个内部函数，该框架内的函数都是以变量的形式来声明，这么做的好处有几点：</p><ol><li>避免了不必要的函数声明提升，流程控制性更强</li><li>更利于实现内存的回收</li></ol><p>我们先暂时跳过流程控制语句，该函数会返回一个匿名函数（闭包），该匿名函数执行并返回第一个参数func，<code>这个func就是要进行柯里化的函数</code>，此时的func作为 optimizeCb的一个参数，其this指向会上一层寻找，即整个 <code>_</code> 的内部作用域，这显然是不行的，所以func.apply的作用即是将func的作用域绑定到所传的context中，arguments为剩下的argCount</p><p>参考 高级程序设计198页</p><p><code>optimizeCb</code>若执行，所传参数，都将作为optimizeCb内部的活动对象，函数执行完毕所返回的匿名函数是一个闭包，它能访问到当前活动对象上的参数，即函数传参。</p><p>比如在 case 4 里的代码段</p><pre><code>...return function(accumulator, value, index, collection) {  return func.call(context, accumulator, value, index, collection);};</code></pre><p>function(accumulator, value, index, collection) 能访问到上层，传参进行活动对象，执行后返回的func是之前传入，这里调用call方法，以传入的<code>context</code>来替换当前的活动对象，并将 accumulator, value, index, collection 作为参数传递给 当前传入的 <code>context</code> ，这里有点绕，大家最好自己写点代码在浏览器中测试</p><h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p>这里顺便理一下这个话题，因为下面会用到，且强行克服一下这个一直没攻破的难关。<br>函数柯里化<code>用于创建</code>已经设置好了一个或多个参数的<code>函数</code>，其基本方法与函数绑定一样：使用闭包返回一个函数。<br>与apply,call,bind等绑定方法的区别在于：返回的函数还需要设置一些传入的参数</p><p>柯里化函数通常由以下步骤动态创建：<code>调用另一个函数</code>并为它<code>传入</code>要<code>柯里化的函数</code>和<code>必要参数</code>，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param fn 表示要柯里化的函数</span></span><br><span class="line"><span class="comment"> * @return 返回一个闭包，这个闭包能够访问当前的函数作用域</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// args包含了来自外部函数的参数</span></span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// innerArgs 用于存放所有传入的参数</span></span><br><span class="line">    <span class="keyword">var</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="comment">// finalArgs 将内外参数合并到一起</span></span><br><span class="line">    <span class="keyword">var</span> finalArgs = args.concat(innerArgs)</span><br><span class="line">    <span class="comment">// 使用apply将结果传递给该函数，这里由于没考虑执行环境所以传了null</span></span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, finalArgs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cb-安全的上下文环境"><a href="#cb-安全的上下文环境" class="headerlink" title="cb 安全的上下文环境"></a>cb 安全的上下文环境</h3><p>这个cb函数用于生成可以应用到集合中的每个元素的回调函数，返回想要的结果或标识<code>（一个任意的回调，一个属性matcher，或者一个属性访问器）</code><br>iteratee和builtinIteratee赋值为一个匿名函数，返回了在这个执行环境中的一个标识<br>要注意的是 <code>Infinity</code>这是一个系统常量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> builtinIteratee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cb = <span class="function"><span class="keyword">function</span>(<span class="params">value, context, argCount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_.iteratee !== builtinIteratee) <span class="keyword">return</span> _.iteratee(value, context);</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="literal">null</span>) <span class="keyword">return</span> _.identity;</span><br><span class="line">  <span class="keyword">if</span> (_.isFunction(value)) <span class="keyword">return</span> optimizeCb(value, context, argCount);</span><br><span class="line">  <span class="keyword">if</span> (_.isObject(value) &amp;&amp; !_.isArray(value)) <span class="keyword">return</span> _.matcher(value);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> _.property(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.iteratee = builtinIteratee = <span class="function"><span class="keyword">function</span>(<span class="params">value, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cb(value, context, <span class="literal">Infinity</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>内部作用域是 4个 if语句，若继续执行会 返回 <code>_.property(value)</code>(1408行) 这里还是贴一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_.property = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!_.isArray(path)) &#123;</span><br><span class="line">    <span class="keyword">return</span> shallowProperty(path);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> deepGet(obj, path);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们来具体分析一下：</p><pre><code>if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);</code></pre><p>也就是说上一句 <code>_.iterate = builtinIteratee = function(value, context) {...}</code> 未生效就重新赋值一次，</p><pre><code>if (value == null) return _.identity;</code></pre><p>没有传value就默认返回最大</p><pre><code>if (_.isFunction(value)) return optimizeCb(value, context, argCount);</code></pre><p><code>_</code>自己实现的方法，判断传入对象的引用类型是否为 function 是就用optimizeCb函数柯里化处理所传value</p><pre><code>if (_.isObject(value) &amp;&amp; !_.isArray(value)) return _.matcher(value);</code></pre><p>同上，若判断成功则用 matcher方法来处理（1429行）<br>通过这样的判断及调用，可保证我们处理的value值是合法且可控的</p><h3 id="restArgs方法"><a href="#restArgs方法" class="headerlink" title="restArgs方法"></a>restArgs方法</h3><p>该方法作用类似于ES6的 function(…args) {…} 展开符，注释上是这么说的：（来自我的渣翻译）<br>这些剩余的参数会进到一个数组，并对应给一个索引，我们还是来看代码吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> restArgs = <span class="function"><span class="keyword">function</span>(<span class="params">func, startIndex</span>) </span>&#123;</span><br><span class="line">  startIndex = startIndex == <span class="literal">null</span> ? func.length - <span class="number">1</span> : +startIndex;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> length = <span class="built_in">Math</span>.max(<span class="built_in">arguments</span>.length - startIndex, <span class="number">0</span>),</span><br><span class="line">        rest = <span class="built_in">Array</span>(length),</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; index &lt; length; index++) &#123;</span><br><span class="line">      rest[index] = <span class="built_in">arguments</span>[index + startIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (startIndex) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> func.call(<span class="keyword">this</span>, rest);</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> func.call(<span class="keyword">this</span>, <span class="built_in">arguments</span>[<span class="number">0</span>], rest);</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> func.call(<span class="keyword">this</span>, <span class="built_in">arguments</span>[<span class="number">0</span>], <span class="built_in">arguments</span>[<span class="number">1</span>], rest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>(startIndex + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; startIndex; index++) &#123;</span><br><span class="line">      args[index] = <span class="built_in">arguments</span>[index];</span><br><span class="line">    &#125;</span><br><span class="line">    args[startIndex] = rest;</span><br><span class="line">    <span class="keyword">return</span> func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><pre><code>startIndex = startIndex == null ? func.length - 1 : +startIndex;</code></pre><p><code>startIndex</code>是第二个参数， startIndex == null 这一句很有意思，很多框架里都喜欢这么用，我们可能经常听说要用 === 少用 == 吗，这里有个隐式转换， 这里判断了startIndex变量是否为空对象，毕竟进入函数作用域，startIndex作为参数是定义过的，这个函数会返回一个匿名函数（闭包），其作用是循环传递的func，将其作用域作为参数传递给调用者</p><h3 id="baseCreate"><a href="#baseCreate" class="headerlink" title="baseCreate"></a>baseCreate</h3><p>用于创建新对象的内部函数，该对象继承自另一个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> baseCreate = <span class="function"><span class="keyword">function</span>(<span class="params">prototype</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!_.isObject(prototype)) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (nativeCreate) <span class="keyword">return</span> nativeCreate(prototype);</span><br><span class="line">  Ctor.prototype = prototype;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">new</span> Ctor;</span><br><span class="line">  Ctor.prototype = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>_.isObject(prototype)</code> 这是 <code>_</code> 的一个内置方法用于判断传入参数是否为对象，这里加上!就是说，若不是对象则返回一个空对象 {}。<br>nativeCreate之前已声明过，这是ES5原生的创建对象方法，我们把之前匿名函数的原型赋给了传入的prototype，然后把这里的结果赋给一个新对象result并返回出来。<br>这里的 Ctor.prototype = null 是精髓，用于内存回收，<code>简单说一下，函数运行会创建自己的活动对象，执行环境，运行结束后会自行销毁，但闭包中的变量和方法将存于内存中得不到回收，具体可读一下高级程序设计</code><br>这样Ctor这个匿名函数我们重复使用且不会造成内存泄漏了。</p><h3 id="shallowProperty"><a href="#shallowProperty" class="headerlink" title="shallowProperty"></a>shallowProperty</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shallowProperty = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj == <span class="literal">null</span> ? <span class="keyword">void</span> <span class="number">0</span> : obj[key];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>意同名，浅属性~ shallowProperty返回了一个匿名函数，该匿名函数根据所传入的key的有无来决定是返回一个空对象还是对象的值</p><h3 id="deepGet"><a href="#deepGet" class="headerlink" title="deepGet"></a>deepGet</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deepGet = <span class="function"><span class="keyword">function</span>(<span class="params">obj, path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> length = path.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">    obj = obj[path[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> length ? obj : <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>内部辅助方法，这里要说下第二个参数path，比如一个 <code>var arr = [1, [2,3]]</code> 二维数组，要拿到3，只能通过arr[1][1]来完成，再看下上面的代码是不是懂了呢？</p><h3 id="isArrayLike"><a href="#isArrayLike" class="headerlink" title="isArrayLike"></a>isArrayLike</h3><p>一个处理类数组的方法，注释上说 —— 根据所传参数<code>collection</code>确定是否应该将一个集合作为数组或对象进行迭代<br>该方法返回一个布尔值，该判断结果用于后续的执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MAX_ARRAY_INDEX = <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> getLength = shallowProperty(<span class="string">'length'</span>);</span><br><span class="line"><span class="keyword">var</span> isArrayLike = <span class="function"><span class="keyword">function</span>(<span class="params">collection</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> length = getLength(collection);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> length == <span class="string">'number'</span> &amp;&amp; length &gt;= <span class="number">0</span> &amp;&amp; length &lt;= MAX_ARRAY_INDEX;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Math.pow()方法可返回 x 的 y 次幂的值。这里是一个安全值的处理，防止内存溢出<br>这里的isArrayLike将传入的collection类数组进行这样的处理：<br>通过getLength辅助函数拿到collection的长度，之前的shallowProperty就是用于此处，getLength返回一个闭包，从而拿到 collection.length</p><pre><code>return typeof length == &apos;number&apos; &amp;&amp; length &gt;= 0 &amp;&amp; length &lt;= MAX_ARRAY_INDEX;</code></pre><p>根据之前的经验，这里 &amp;&amp; 优先级平级，即 <code>typeof length == &#39;number&#39; &amp;&amp; length &gt;= 0</code> 比较完后的结果 再拿去和 <code>length &lt;= MAX_ARRAY_INDEX</code> 进行逻辑与运算即可</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> underscore </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【搬家】wordpress到hexo~ 都是泪</title>
      <link href="/2017/05/15/%E3%80%90%E8%B5%B7%E8%88%AA%E3%80%91hexo%E5%8D%9A%E5%AE%A2/"/>
      <url>/2017/05/15/%E3%80%90%E8%B5%B7%E8%88%AA%E3%80%91hexo%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<blockquote><p>个人博客什么的，15年建的wordpress小站在2017年4月被我搞崩了…… 文章也没有备份，加上阿里云到期，备案等各种问题，最后还是先转到github，一来速度不错，二来可以hit督促自己学习，三来用于备份，以后有时间和心情还是弄个云服务器玩玩吧。不过最重要的一点还是因为程序员就是爱折腾…… 好在之前写的文章也没什么营养，丢就丢了吧，希望放在这上面的能精简些</p></blockquote><p>如果你对 hexo搭建博客感兴趣可以参考这篇：<a href="http://www.jianshu.com/p/e99ed60390a8" target="_blank" rel="noopener">20分钟教你使用hexo搭建github博客</a>，主题的话推荐下很好看的 <a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">yilia</a>。<br>如果想和我使用的一样可以参考下我的仓库：<a href="https://github.com/Fridolph/Fridolph.github.io" target="_blank" rel="noopener">我的主题备份</a></p><a id="more"></a><p>所以说，一切都是自作孽啊，博客重新运营吧，正好多说关闭了，评论模块还得折腾下。</p><h2 id="其他叨唠"><a href="#其他叨唠" class="headerlink" title="其他叨唠"></a>其他叨唠</h2><p>作为过来人的经验，我们应该做的第一件事是为博客备份，至于怎么做就不展开了，本地备份加上云盘备份一份最好。<br>虽然之前的文章都不要了，但貌似也没什么损失，确实文才不好也算了，原创质量都不高，也没法啊~~<br>重新开个坑，希望业余时间能多多充实下自我，多多学习，提高学习力与竞争力</p><h2 id="开始写博客"><a href="#开始写博客" class="headerlink" title="开始写博客"></a>开始写博客</h2><p>这里就记些简单的操作吧（虽然以后会很常用）</p><h3 id="发表一篇文章"><a href="#发表一篇文章" class="headerlink" title="发表一篇文章"></a>发表一篇文章</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;文章标题&quot;</span><br></pre></td></tr></table></figure><p>新建的文章会统一存放在 source -&gt; _post 路径下，至于markdown的语法可以参考 <a href="http://www.appinn.com/markdown/" target="_blank" rel="noopener">markdown语法</a> 很简单，多写几次就会了。</p><h3 id="本地环境"><a href="#本地环境" class="headerlink" title="本地环境"></a>本地环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><h3 id="上线部署"><a href="#上线部署" class="headerlink" title="上线部署"></a>上线部署</h3><p>然后在启动本地环境 localhost:4000 默认地址，点开可查看最近修改，之后没问题就可以部署了<br>_config.yml 已做好备份，可以直接参考我的设置，官方文档的说明也很详细</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>那么直接开始吧！</p>]]></content>
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 吐槽 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【CSS】纯CSS3手工打造变形金刚</title>
      <link href="/2017/02/20/%E3%80%90CSS%E3%80%91%E7%BA%AFCSS3%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0%E5%8F%98%E5%BD%A2%E9%87%91%E5%88%9A/"/>
      <url>/2017/02/20/%E3%80%90CSS%E3%80%91%E7%BA%AFCSS3%E6%89%8B%E5%B7%A5%E6%89%93%E9%80%A0%E5%8F%98%E5%BD%A2%E9%87%91%E5%88%9A/</url>
      <content type="html"><![CDATA[<p>老外写的一个很有意思的demo~ 就copy到本地了，地址找不到了… 请原谅我就不贴网址了<br>我把代码扒下来重新写了遍，整理了下就记录下来了，还是挺有意思的</p><p>只要有想法，真的是各种强啊， 简直不敢相信这居然是纯CSS代码完成的，里面有很多 transform 及 css三角的应用，代码读起来很顺， 理解起来也不难，但想到…那是真的难… 很多地方需要细细拆分才能琢磨透，先上图上DEMO</p><iframe style="width:100%; height:460px;" src="https://jsfiddle.net/vho3j50x/embedded/result,html,css,js/"></iframe><a id="more"></a><p>那开始我们的编程吧：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 外层容器结构可以根据自己的情况来调整 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"batianhu-wrapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"batianhu"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"head-body"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"head-topcover"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"head-toplogo-bg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"head-toplogo"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"head-toplogo-2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"head-bottom-left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"head-bottom-right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"head-sw-left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"head-sw-right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"head-eye"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"head-eye-2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#batianhu-wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">250px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">325px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">50px</span> auto <span class="number">20px</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.head-body</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">25px</span> <span class="number">0</span> <span class="number">50px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">150px</span> solid <span class="number">#555</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">25px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">25px</span> solid transparent;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.head-topcover</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative; <span class="attribute">z-index</span>: <span class="number">5</span>; <span class="attribute">top</span>: -<span class="number">225px</span>; <span class="attribute">left</span>: -<span class="number">19px</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">80px</span> solid <span class="number">#333</span>; </span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">60px</span> solid transparent; </span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">60px</span> solid transparent;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">169px</span>; <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.head-topcover</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>; <span class="attribute">position</span>: absolute; <span class="attribute">top</span>: <span class="number">0px</span>; <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#333</span> transparent transparent transparent;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">15px</span> <span class="number">85px</span> <span class="number">0</span> <span class="number">85px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>; <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.head-toplogo-bg</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative; <span class="attribute">z-index</span>: <span class="number">6</span>; <span class="attribute">top</span>: -<span class="number">267px</span>; <span class="attribute">left</span>: <span class="number">67px</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">110px</span> solid <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">35px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">35px</span> solid transparent;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">46px</span>; <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.head-toplogo-bg</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>; <span class="attribute">position</span>: absolute; <span class="attribute">top</span>: <span class="number">0px</span>; <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#333</span> transparent transparent transparent;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">30px</span> <span class="number">23px</span> <span class="number">0</span> <span class="number">23px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>; <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.head-toplogo</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative; <span class="attribute">z-index</span>: <span class="number">7</span>; <span class="attribute">top</span>: -<span class="number">377px</span>; <span class="attribute">left</span>: <span class="number">75px</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">105px</span> solid <span class="number">#555</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">30px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">30px</span> solid transparent;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">40px</span>; <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.head-toplogo</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>; <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">position</span>: absolute; <span class="attribute">top</span>: -<span class="number">42px</span>; <span class="attribute">left</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">30px</span> solid <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">10px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">10px</span> solid transparent;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>; <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.head-toplogo</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute; <span class="attribute">top</span>: <span class="number">0px</span>; <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#555</span> transparent transparent transparent;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">28px</span> <span class="number">20px</span> <span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>; <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.head-toplogo-2</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative; <span class="attribute">z-index</span>: <span class="number">8</span>; <span class="attribute">top</span>: -<span class="number">482px</span>; <span class="attribute">left</span>: <span class="number">75px</span>; </span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">37px</span> solid <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">35px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">35px</span> solid transparent;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>; <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.head-bottom-left</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block; <span class="attribute">margin</span>: <span class="number">50px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative; <span class="attribute">top</span>: -<span class="number">365px</span>; <span class="attribute">left</span>: -<span class="number">31px</span>; <span class="attribute">z-index</span>: <span class="number">10</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">107px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">44px</span> solid <span class="number">#555</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">60px</span> solid transparent;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0px</span>; <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#555</span>;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(236deg);</span><br><span class="line">          <span class="attribute">transform</span>: <span class="built_in">rotate</span>(236deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.head-bottom-right</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">position</span>: relative; <span class="attribute">top</span>: -<span class="number">460px</span>; <span class="attribute">left</span>: <span class="number">115px</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">60px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">44px</span> solid <span class="number">#555</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">107px</span> solid transparent;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0px</span>; <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#555</span>;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(484deg);</span><br><span class="line">          <span class="attribute">transform</span>: <span class="built_in">rotate</span>(484deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有困惑的地方，可以把容器的<code>overflow:hidden</code>属性去掉， 一行一行去掉我们所写的css效果，看看是由怎样的变化得到的，如上图，我们就是用两个三角拼出来的脸颊，利用overflow属性得到了我们想要的效果 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.head-sw-left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative; <span class="attribute">z-index</span>: <span class="number">15</span>; <span class="attribute">left</span>: <span class="number">45px</span>; <span class="attribute">top</span>: -<span class="number">629px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">49px</span>; <span class="attribute">height</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#333</span>;  </span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">skew</span>(-149deg) <span class="built_in">rotate</span>(9deg);</span><br><span class="line">          <span class="attribute">transform</span>: <span class="built_in">skew</span>(-149deg) <span class="built_in">rotate</span>(9deg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.head-sw-left</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute; <span class="attribute">top</span>: <span class="number">24px</span>; <span class="attribute">left</span>: -<span class="number">6px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">53px</span>; <span class="attribute">height</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">skew</span>(-174deg) <span class="built_in">rotate</span>(1deg);</span><br><span class="line">          <span class="attribute">transform</span>: <span class="built_in">skew</span>(-174deg) <span class="built_in">rotate</span>(1deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.head-sw-right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative; <span class="attribute">z-index</span>: <span class="number">15</span>; <span class="attribute">left</span>: <span class="number">155px</span>; <span class="attribute">top</span>: -<span class="number">637px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">49px</span>; <span class="attribute">height</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">skew</span>(279deg) <span class="built_in">rotate</span>(10deg);</span><br><span class="line">          <span class="attribute">transform</span>: <span class="built_in">skew</span>(279deg) <span class="built_in">rotate</span>(10deg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.head-sw-right</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute; <span class="attribute">top</span>: -<span class="number">2px</span>; <span class="attribute">left</span>: <span class="number">132px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">45px</span>; <span class="attribute">height</span>: <span class="number">9px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">skew</span>(-212deg) <span class="built_in">rotate</span>(0deg);</span><br><span class="line">          <span class="attribute">transform</span>: <span class="built_in">skew</span>(-212deg) <span class="built_in">rotate</span>(0deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.head-eye</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative; <span class="attribute">z-index</span>: <span class="number">12</span>; <span class="attribute">left</span>: <span class="number">67px</span>; <span class="attribute">top</span>: -<span class="number">585px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="built_in">rgba</span>(255, 255, 255, 0.4) <span class="number">0</span> <span class="number">0</span> <span class="number">15px</span>, <span class="built_in">rgba</span>(76, 190, 255, 0.95) <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">32px</span>; <span class="attribute">height</span>: <span class="number">22px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#4CBEFF</span>;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">skew</span>(46deg) <span class="built_in">rotate</span>(14deg);</span><br><span class="line">          <span class="attribute">transform</span>: <span class="built_in">skew</span>(46deg) <span class="built_in">rotate</span>(14deg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.head-eye-2</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative; <span class="attribute">z-index</span>: <span class="number">12</span>; <span class="attribute">left</span>: <span class="number">150px</span>; <span class="attribute">top</span>: -<span class="number">607px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="built_in">rgba</span>(255, 255, 255, 0.4) <span class="number">0</span> <span class="number">0</span> <span class="number">15px</span>, <span class="built_in">rgba</span>(76, 190, 255, 0.95) <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">32px</span>; <span class="attribute">height</span>: <span class="number">22px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#4CBEFF</span>;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">skew</span>(-46deg) <span class="built_in">rotate</span>(-14deg);</span><br><span class="line">          <span class="attribute">transform</span>: <span class="built_in">skew</span>(-46deg) <span class="built_in">rotate</span>(-14deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>文章到此的完整展示代码请参考上面demo的jsfiddle里的css部分</code></p><p>至此，我们的纯css所写的变形金刚的静态效果就完成了，是不是很有趣呢？<br>这个结构按照身体各部分拆成了很多份，感兴趣还可以做成动画~~ 待填坑…</p>]]></content>
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> demo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【配置】VS Code常用插件整理</title>
      <link href="/2017/02/20/%E3%80%90%E9%85%8D%E7%BD%AE%E3%80%91VS%20Code%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86/"/>
      <url>/2017/02/20/%E3%80%90%E9%85%8D%E7%BD%AE%E3%80%91VS%20Code%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<p>Visual Studio Code是个牛逼的编辑器，启动非常快，我已经抛弃WebStorm Sublime了。<br>支持各种语言，相比其他IDE，轻量级完全可配置还集成Git感觉非常的适合前端开发。 所以我仔细研究了一下文档未来可能会作为主力工具使用。</p><p>虽然习惯了N久的快捷键，没法，习惯什么的是吧，习惯下就好了所以 <a href="https://code.visualstudio.com/docs/customization/keybindings" target="_blank" rel="noopener">官方快捷键大全</a> ，看看这个就好，好在现在快捷键熟悉得差不多了，不会比sublime慢多少</p><a id="more"></a><h2 id="用户设置备份"><a href="#用户设置备份" class="headerlink" title="用户设置备份"></a>用户设置备份</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"workbench.iconTheme"</span>: <span class="string">"vscode-icons"</span>,</span><br><span class="line">  <span class="attr">"workbench.colorTheme"</span>: <span class="string">"One Monokai"</span>,</span><br><span class="line">  <span class="attr">"editor.wordWrap"</span>: <span class="string">"on"</span>,</span><br><span class="line">  <span class="attr">"editor.wordWrapColumn"</span>: <span class="number">120</span>,</span><br><span class="line">  <span class="attr">"terminal.integrated.shell.windows"</span>: <span class="string">"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe"</span>,</span><br><span class="line">  <span class="attr">"editor.tabSize"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"vetur.format.defaultFormatter.html"</span>: <span class="string">"js-beautify-html"</span>,</span><br><span class="line">  <span class="attr">"eslint.autoFixOnSave"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"files.autoSave"</span>: <span class="string">"afterDelay"</span>,</span><br><span class="line">  <span class="attr">"eslint.validate"</span>: [</span><br><span class="line">    <span class="string">"javascript"</span>,</span><br><span class="line">    <span class="string">"javascriptreact"</span>,</span><br><span class="line">    <span class="string">"html"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"language"</span>: <span class="string">"vue"</span>,</span><br><span class="line">      <span class="attr">"autoFix"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"eslint.options"</span>: &#123;</span><br><span class="line">    <span class="attr">"plugins"</span>: [</span><br><span class="line">      <span class="string">"html"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"extensions.autoUpdate"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"prettier.singleQuote"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"prettier.semi"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"prettier.eslintIntegration"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"files.eol"</span>: <span class="string">"\n"</span>,</span><br><span class="line">  <span class="attr">"explorer.confirmDragAndDrop"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"files.autoSaveDelay"</span>: <span class="number">5000</span>,</span><br><span class="line">  <span class="attr">"fileheader.tpl"</span>: <span class="string">"/*\n * @Author: fridolph\n*  @Date: &#123;createTime&#125;\n * @Last Modified by: fridolph\n*  @Last Modified time: &#123;updateTime&#125;\n */\n"</span>,</span><br><span class="line">  <span class="attr">"fileheader.Author"</span>: <span class="string">"fridolph"</span>,</span><br><span class="line">  <span class="attr">"fileheader.LastModifiedBy"</span>: <span class="string">"fridolph"</span>,</span><br><span class="line">  <span class="attr">"editor.fontSize"</span>: <span class="number">14</span>,</span><br><span class="line">  <span class="attr">"editor.lineHeight"</span>: <span class="number">22</span>,</span><br><span class="line">  <span class="attr">"editor.lineNumbers"</span>: <span class="string">"on"</span>,</span><br><span class="line">  <span class="attr">"editor.quickSuggestions"</span>: &#123;</span><br><span class="line">    <span class="attr">"other"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"comments"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"strings"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"files.trimFinalNewlines"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"files.trimTrailingWhitespace"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"files.insertFinalNewline"</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="VS-code插件整理"><a href="#VS-code插件整理" class="headerlink" title="VS code插件整理"></a>VS code插件整理</h2><h3 id="风格"><a href="#风格" class="headerlink" title="风格"></a>风格</h3><ul><li>one monokai 因为我喜欢，我放在第一了</li><li>vscode-icons</li><li>output colorizer 让log文件变得五颜六色</li></ul><h3 id="风格检查-格式化"><a href="#风格检查-格式化" class="headerlink" title="风格检查 格式化"></a>风格检查 格式化</h3><ul><li>vetur 用vue的必装插件</li><li>prettier 代码格式化，这两个选一个就好</li><li>beautify 代码格式化你值得拥有</li><li>better comments 为注释增加几种风格的标注</li><li>editorconfig for vscode 支持 .editorconfig</li><li>ESlint 代码检查工具不解释了</li><li>html snippets</li><li>javascript code snippets</li></ul><hr><p>typescript的单独拿出来了，用都可以装</p><ul><li>TSlint 用typescript的可以装</li><li>TypeScript Hero</li><li>Typescript Extension Pack</li><li>typescript importer</li><li>typescript react code snippets</li><li>typescript toolbox</li><li>vue typescript snippets</li></ul><h3 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h3><ul><li>html snippets</li><li>snippets 自己搜啦</li><li>file peek 可以看到对应文件的代码片段</li><li>vscode-js-console-utils 为变量增加console，调试经常用</li></ul><h3 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h3><ul><li>Auto Close Tag，适用于 JSX、Vue、HTML，在打开标签并且键入 <code>&lt;/</code> 的时候，能自动补全要闭合的标签；</li><li>Auto Rename Tag，适用于 JSX、Vue、HTML，在修改标签名时，能在你修改开始（结束）标签的时候修改对应的结束（开始）标签，帮你减少 50% 的击键；</li><li>Path Intellisense，文件路径补全，在你用任何方式引入文件系统中的路径时提供智能提示和自动完成；</li><li>NPM Intellisense，NPM 依赖补全，在你引入任何 node_modules 里面的依赖包时提供智能提示和自动完成；</li><li>IntelliSense for CSS class names，CSS 类名补全，会自动扫描整个项目里面的 CSS 类名并在你输入类名时做智能提示；</li><li>Emmet，以前叫做 Zen Coding，我发现后，也是爱不释手，可以把类 CSS 选择符的字符串展开成 HTML 标签，VSCode 已经内置，官方介绍文档参见，你需要做的就是熟悉他的语法，并勤加练习；</li></ul><h3 id="编码效率"><a href="#编码效率" class="headerlink" title="编码效率"></a>编码效率</h3><ul><li>Document This 能够一键给代码中的类、函数加上注释，支持函数声明、函数表达式、箭头函数等</li><li>Embrace 快速的在选中代码两边添加各种引号、括号，不用来回移动光标</li></ul><table><thead><tr><th>Command</th><th>Description</th><th>Notation</th><th>Suggested Key</th></tr></thead><tbody><tr><td>extension.embraceParenthesis</td><td>Surround with Parenthesis</td><td>( )</td><td>ctrl+k,e</td></tr><tr><td>extension.embraceSquareBrackets</td><td>Surround with Square Brackets</td><td>[ ]</td><td>ctrl+k,s</td></tr><tr><td>extension.embraceCurlyBrackets</td><td>Surround with Curly Brackets</td><td>{ }</td><td></td><td>ctrl+k,l</td></tr><tr><td>extension.embraceAngleBrackets</td><td>Surround with Angle Brackets</td><td>&lt; &gt;</td><td>ctrl+k,a</td></tr><tr><td>extension.embraceSingleQuotes</td><td>Surround with Single Quotes</td><td>‘ ‘</td><td>ctrl+k,q</td></tr><tr><td>extension.embraceDoubleQuotes</td><td>Surround with Double Quotes</td><td>“ “</td><td>ctrl+k,o</td></tr></tbody></table><ul><li>Bracket Pair Colorizer 更方便看括号，作用域等</li><li>ECMAScript Quoets Transformer 方便在字符串和变量混搭模式（String Concat）的代码和字符串模板（Template Literals）模式间来回转换，省去手动的移动光标、修改引号等操作</li><li>Code Spell Checker 检查英语拼写是否合法. 选装… 一堆报错</li><li>Code Runner 名副其实的代码运行插件，支持数十种语言，在不离开代码编辑器的前提下通过命令面板可直接执行代码，并查看输出</li></ul><p>其他的配置：关于行末的空格、文件末尾的空行，以前需要使用插件来实现，现在直接修改 VSCode 内置配置即可实现：</p><p>福利啊，不然每次eslint一堆报错</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"files.trimTrailingWhitespace"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"files.insertFinalNewline"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"files.trimFinalNewlines"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>path autocomplete 路径补全</li></ul><h3 id="功能增强"><a href="#功能增强" class="headerlink" title="功能增强"></a>功能增强</h3><ul><li>Color Highlight，识别代码中的颜色，包括各种颜色格式；</li><li>Bracket Pair Colorizer，识别代码中的各种括号，并且标记上不同的颜色，方便你扫视到匹配的括号，在括号使用非常多的情况下能环节眼部压力，编辑器快捷键固然好用，但是在临近嵌套多的情况下却有些力不从心；</li><li>Project Manager，项目管理，让我们方便的在命令面板中切换项目文件夹，当然，你也可以直接打开包含多个项目的父级文件夹，但这样可能会让 VSCode 变慢；</li><li>Settings Sync 基于 Gist 实现 VSCode 用户配置、快捷键配置、已安装插件列表等的备份和恢复功能，配置过程有详细精确的操作步骤文档。生成的备份 Gist 默认是私密的，如果你想设置为共享的，也可以一键切换。</li><li>Git Lens 把 VSCode 结合 Git 的使用体验优化到了极致，能让我们在不离开编辑器，不执行任何命令的情况下知晓光标所在位置代码的修改时间、作者信息等。</li><li>Code Outline 能在单独窗口中列出当源代码中的各种符号，比如变量名、类名、方法名等，并支持快速跳转，有点类似于 Vim 里面的 ctags，翻看老代码、开源项目代码时非常有用。</li></ul><h3 id="辅助工具"><a href="#辅助工具" class="headerlink" title="辅助工具"></a>辅助工具</h3><ul><li>can i use 浏览器兼容性检查</li><li>Debugger for Chrome 允许像chrome一样在vs code里调试</li><li>partial diff 同名，可以查看文件间的差异</li><li>todo highlight 待做项高亮，且可查看统计</li><li>Version lens 查看package依赖，且帮更新，需要自行npm install</li><li>VSCode Map Preview 地图坐标信息格式文件，就可就行预览</li><li>vscode-fileheader 自行生成file header</li></ul>]]></content>
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【ESLint】配置详解，规范代码</title>
      <link href="/2017/01/22/%E3%80%90%E9%85%8D%E7%BD%AE%E3%80%91ESLint%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%EF%BC%8C%E8%A7%84%E8%8C%83%E4%BB%A3%E7%A0%81/"/>
      <url>/2017/01/22/%E3%80%90%E9%85%8D%E7%BD%AE%E3%80%91ESLint%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%EF%BC%8C%E8%A7%84%E8%8C%83%E4%BB%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<blockquote><p>在很久之前就想通过工具来规范自己的代码风格，减少程序出错的概率，特别是最近的React, Vue项目里，ESlint成了标配，但是实际上一直懒癌发作也没去看它的文档，使用着它默认的规则，有的地方确实是逼死强迫症，所以为了不那么费力，自己灵活配置会更好些！</p></blockquote><p>作为一个有理想有抱负的前端工程师，只是使用默认规则，而不是看完文档了然于心，显然是不行滴 ^_^.. 团队协作时，若是团队的代码风格统一，能够大大减少沟通成本。（其实面试时和老大聊到代码规范，当时就说到用 JSHint ，或者 ESLint 等工具来统一的。。。这也算是我来填一个坑吧~）</p><p>好了，前情摘要就到这，我们开始吧！</p><h2 id="什么是-ESLint-？"><a href="#什么是-ESLint-？" class="headerlink" title="什么是 ESLint ？"></a>什么是 ESLint ？</h2><blockquote><p>ESLint 是在 ECMAScript/JavaScript 代码中识别和报告模式匹配的工具，它的目标是保证代码的一致性和避免错误。</p></blockquote><a id="more"></a><p>在许多方面，它和 JSLint、JSHint 相似，除了少数的例外：</p><ul><li>ESLint 使用 Espree 解析 JavaScript。</li><li>ESLint 使用 AST 去分析代码中的模式</li><li>ESLint 是完全插件化的。</li></ul><p>每一个规则都是一个插件并且你可以在运行时添加更多的规则。以上来自官网。不想再说下去，反正就是一个代码风格检测工具就对了</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><pre><code>npm install -g eslint</code></pre><p>如果你第一次使用 ESLint，你必须使用 –init 命令新建一个配置文件：</p><pre><code>eslint –init</code></pre><p>使用 ESLint 检测任何 JavaScript 文件：</p><pre><code>eslint test 2.js</code></pre><p>ESLint 中一些规则运行命令它可以帮你自动修复</p><pre><code>eslint test.js –fix</code></pre><p>为了可以更直观的反馈，可能更多的会直接安装编辑器插件来进行错误提示，我使用的是VS Code下个插件就好，配置起来很简单，会自动生成配置文件</p><h2 id="规则定义"><a href="#规则定义" class="headerlink" title="规则定义"></a>规则定义</h2><p>ESLint 支持几种格式的配置文件，如果同一个目录下有多个配置文件，ESLint 只会使用一个。优先级顺序如下：</p><ul><li>JavaScript - 使用 .eslintrc.js 然后输出一个配置对象。</li><li>YAML - 使用 .eslintrc.yaml 或 .eslintrc.yml 去定义配置的结构。</li><li>JSON -使用 .eslintrc.json 去定义配置的结构，ESLint 的 JSON 文件允许 JavaScript 风格的注释。</li><li>Deprecated -使用 .eslintrc，可以使 JSON 也可以是 YAML。</li><li>package.json - 在 package.json 里创建一个 eslintConfig属性，在那里定义你的配置。</li></ul><h2 id="这是我目前使用的-eslintrc"><a href="#这是我目前使用的-eslintrc" class="headerlink" title="这是我目前使用的 .eslintrc"></a>这是我目前使用的 <code>.eslintrc</code></h2><p>算是备份了，也有注释，文件不大，推荐不去掉注释，不然到时忘了难得查</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 环境定义了预定义的全局变量。</span></span><br><span class="line">  <span class="string">"env"</span>: &#123;</span><br><span class="line">    <span class="comment">//环境定义了预定义的全局变量。更多在官网查看</span></span><br><span class="line">    <span class="string">"browser"</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="string">"node"</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="string">"commonjs"</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="string">"amd"</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="string">"es6"</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="string">"mocha"</span>:<span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// JavaScript 语言选项</span></span><br><span class="line">  <span class="string">"parserOptions"</span>: &#123;</span><br><span class="line">    <span class="comment">// ECMAScript 版本</span></span><br><span class="line">    <span class="string">"ecmaVersion"</span>:<span class="number">6</span>,</span><br><span class="line">    <span class="string">"sourceType"</span>:<span class="string">"script"</span>,<span class="comment">//module</span></span><br><span class="line">    <span class="comment">// 想使用的额外的语言特性:</span></span><br><span class="line">    <span class="string">"ecmaFeatures"</span>: &#123;</span><br><span class="line">      <span class="comment">// 允许在全局作用域下使用 return 语句</span></span><br><span class="line">      <span class="string">"globalReturn"</span>:<span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// impliedStric</span></span><br><span class="line">      <span class="string">"impliedStrict"</span>:<span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 启用 JSX</span></span><br><span class="line">      <span class="string">"jsx"</span>:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// "off" 或 0 - 关闭规则</span></span><br><span class="line">  <span class="comment">// "warn" 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出),</span></span><br><span class="line">  <span class="comment">// "error" 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)  </span></span><br><span class="line">  <span class="string">"rules"</span>: &#123;</span><br><span class="line">    <span class="comment">////////////////</span></span><br><span class="line">    <span class="comment">// 可能的错误 //</span></span><br><span class="line">    <span class="comment">////////////////</span></span><br><span class="line">    <span class="comment">// 禁止条件表达式中出现赋值操作符</span></span><br><span class="line">    <span class="string">"no-cond-assign"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁用 console</span></span><br><span class="line">    <span class="string">"no-console"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止在条件中使用常量表达式</span></span><br><span class="line">    <span class="comment">// if (false) &#123;</span></span><br><span class="line">    <span class="comment">// doSomethingUnfinished();</span></span><br><span class="line">    <span class="comment">// &#125; //cuowu</span></span><br><span class="line">    <span class="string">"no-constant-condition"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止在正则表达式中使用控制字符 ：new RegExp("\x1f")</span></span><br><span class="line">    <span class="string">"no-control-regex"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗号，</span></span><br><span class="line">    <span class="comment">// always-multiline：多行模式必须带逗号，单行模式不能带逗号</span></span><br><span class="line">    <span class="string">"comma-dangle"</span>: [<span class="number">1</span>,<span class="string">"always-multiline"</span>],</span><br><span class="line">    <span class="comment">// 禁用 debugger</span></span><br><span class="line">    <span class="string">"no-debugger"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止 function 定义中出现重名参数</span></span><br><span class="line">    <span class="string">"no-dupe-args"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止对象字面量中出现重复的 key</span></span><br><span class="line">    <span class="string">"no-dupe-keys"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止重复的 case 标签</span></span><br><span class="line">    <span class="string">"no-duplicate-case"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止空语句块</span></span><br><span class="line">    <span class="string">"no-empty"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止在正则表达式中使用空字符集 (/^abc[]/)</span></span><br><span class="line">    <span class="string">"no-empty-character-class"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止对 catch 子句的参数重新赋值</span></span><br><span class="line">    <span class="string">"no-ex-assign"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止不必要的布尔转换</span></span><br><span class="line">    <span class="string">"no-extra-boolean-cast"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止不必要的括号 //(a * b) + c;//报错</span></span><br><span class="line">    <span class="string">"no-extra-parens"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止不必要的分号</span></span><br><span class="line">    <span class="string">"no-extra-semi"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止对 function 声明重新赋值</span></span><br><span class="line">    <span class="string">"no-func-assign"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止在嵌套的块中出现 function 或 var 声明</span></span><br><span class="line">    <span class="string">"no-inner-declarations"</span>: [<span class="number">2</span>,<span class="string">"functions"</span>],</span><br><span class="line">    <span class="comment">// 禁止 RegExp 构造函数中无效的正则表达式字符串</span></span><br><span class="line">    <span class="string">"no-invalid-regexp"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止在字符串和注释之外不规则的空白</span></span><br><span class="line">    <span class="string">"no-irregular-whitespace"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止在 in 表达式中出现否定的左操作数</span></span><br><span class="line">    <span class="string">"no-negated-in-lhs"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止把全局对象 (Math 和 JSON) 作为函数调用 错误：var math = Math();</span></span><br><span class="line">    <span class="string">"no-obj-calls"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止直接使用 Object.prototypes 的内置属性</span></span><br><span class="line">    <span class="string">"no-prototype-builtins"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止正则表达式字面量中出现多个空格</span></span><br><span class="line">    <span class="string">"no-regex-spaces"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁用稀疏数组</span></span><br><span class="line">    <span class="string">"no-sparse-arrays"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止出现令人困惑的多行表达式</span></span><br><span class="line">    <span class="string">"no-unexpected-multiline"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止在return、throw、continue 和 break语句之后出现不可达代码</span></span><br><span class="line">    <span class="comment">// function foo() &#123;  return true;  console.log("done"); &#125;</span></span><br><span class="line">    <span class="comment">//错误    </span></span><br><span class="line">    <span class="string">"no-unreachable"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 要求使用 isNaN() 检查 NaN</span></span><br><span class="line">    <span class="string">"use-isnan"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 强制使用有效的 JSDoc 注释</span></span><br><span class="line">    <span class="string">"valid-jsdoc"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 强制 typeof 表达式与有效的字符串进行比较</span></span><br><span class="line">    <span class="comment">// typeof foo === "undefimed" 错误</span></span><br><span class="line">    <span class="string">"valid-typeof"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">//////////////</span></span><br><span class="line">    <span class="comment">// 最佳实践 //</span></span><br><span class="line">    <span class="comment">//////////////</span></span><br><span class="line">    <span class="comment">// 定义对象的set存取器属性时，强制定义get</span></span><br><span class="line">    <span class="string">"accessor-pairs"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 强制数组方法的回调函数中有 return 语句</span></span><br><span class="line">    <span class="string">"array-callback-return"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制把变量的使用限制在其定义的作用域范围内</span></span><br><span class="line">    <span class="string">"block-scoped-var"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 限制圈复杂度，也就是类似if else能连续接多少个</span></span><br><span class="line">    <span class="string">"complexity"</span>: [<span class="number">2</span>,<span class="number">9</span>],</span><br><span class="line">    <span class="comment">// 要求 return 语句要么总是指定返回的值，要么不指定</span></span><br><span class="line">    <span class="string">"consistent-return"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制所有控制语句使用一致的括号风格</span></span><br><span class="line">    <span class="string">"curly"</span>: [<span class="number">2</span>,<span class="string">"all"</span>],</span><br><span class="line">    <span class="comment">// switch 语句强制 default 分支，也可添加 // no default 注释取消此次警告</span></span><br><span class="line">    <span class="string">"default-case"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 强制object.key 中 . 的位置，参数:</span></span><br><span class="line">    <span class="comment">// property，'.'号应与属性在同一行</span></span><br><span class="line">    <span class="comment">// object, '.' 号应与对象名在同一行</span></span><br><span class="line">    <span class="string">"dot-location"</span>: [<span class="number">2</span>,<span class="string">"property"</span>],</span><br><span class="line">    <span class="comment">// 强制使用.号取属性</span></span><br><span class="line">    <span class="comment">// 参数： allowKeywords：true 使用保留字做属性名时，只能使用.方式取属性</span></span><br><span class="line">    <span class="comment">// false 使用保留字做属性名时, 只能使用[]方式取属性 e.g [2, &#123;"allowKeywords": false&#125;]</span></span><br><span class="line">    <span class="comment">// allowPattern: 当属性名匹配提供的正则表达式时，</span></span><br><span class="line">    <span class="comment">// 允许使用[]方式取值,否则只能用.号取值 e.g [2, &#123;"allowPattern": "^[a-z]+(_[a-z]+)+$"&#125;]</span></span><br><span class="line">    <span class="string">"dot-notation"</span>: [<span class="number">2</span>, &#123;<span class="string">"allowKeywords"</span>:<span class="literal">false</span>&#125;],</span><br><span class="line">    <span class="comment">// 使用 === 替代 == allow-null允许null和undefined==</span></span><br><span class="line">    <span class="string">"eqeqeq"</span>: [<span class="number">2</span>,<span class="string">"allow-null"</span>],</span><br><span class="line">    <span class="comment">// 要求 for-in 循环中有一个 if 语句</span></span><br><span class="line">    <span class="string">"guard-for-in"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁用 alert、confirm 和 prompt</span></span><br><span class="line">    <span class="string">"no-alert"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁用 arguments.caller 或 arguments.callee</span></span><br><span class="line">    <span class="string">"no-caller"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 不允许在 case 子句中使用词法声明</span></span><br><span class="line">    <span class="string">"no-case-declarations"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止除法操作符显式的出现在正则表达式开始的位置</span></span><br><span class="line">    <span class="string">"no-div-regex"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止 if 语句中有 return 之后有 else</span></span><br><span class="line">    <span class="string">"no-else-return"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止出现空函数.如果一个函数包含了一条注释，它将不会被认为有问题。</span></span><br><span class="line">    <span class="string">"no-empty-function"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止使用空解构模式no-empty-pattern</span></span><br><span class="line">    <span class="string">"no-empty-pattern"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止在没有类型检查操作符的情况下与 null 进行比较</span></span><br><span class="line">    <span class="string">"no-eq-null"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 禁用 eval()</span></span><br><span class="line">    <span class="string">"no-eval"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止扩展原生类型</span></span><br><span class="line">    <span class="string">"no-extend-native"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止不必要的 .bind() 调用</span></span><br><span class="line">    <span class="string">"no-extra-bind"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁用不必要的标签</span></span><br><span class="line">    <span class="string">"no-extra-label:"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止 case 语句落空</span></span><br><span class="line">    <span class="string">"no-fallthrough"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止数字字面量中使用前导和末尾小数点</span></span><br><span class="line">    <span class="string">"no-floating-decimal"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止使用短符号进行类型转换(!!fOO)</span></span><br><span class="line">    <span class="string">"no-implicit-coercion"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止在全局范围内使用 var 和命名的 function 声明</span></span><br><span class="line">    <span class="string">"no-implicit-globals"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 禁止使用类似 eval() 的方法</span></span><br><span class="line">    <span class="string">"no-implied-eval"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止 this 关键字出现在类和类对象之外</span></span><br><span class="line">    <span class="string">"no-invalid-this"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁用 __iterator__ 属性</span></span><br><span class="line">    <span class="string">"no-iterator"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁用标签语句</span></span><br><span class="line">    <span class="string">"no-labels"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁用不必要的嵌套块</span></span><br><span class="line">    <span class="string">"no-lone-blocks"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止在循环中出现 function 声明和表达式</span></span><br><span class="line">    <span class="string">"no-loop-func"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 禁用魔术数字(3.14什么的用常量代替)</span></span><br><span class="line">    <span class="comment">// "no-magic-numbers":[2,&#123;"ignore": [0,-1,1] &#125;],</span></span><br><span class="line">    <span class="comment">// 禁止使用多个空格</span></span><br><span class="line">    <span class="string">"no-multi-spaces"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止使用多行字符串，在 JavaScript 中，可以在新行之前使用斜线创建多行字符串</span></span><br><span class="line">    <span class="string">"no-multi-str"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止对原生对象赋值</span></span><br><span class="line">    <span class="string">"no-native-reassign"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止在非赋值或条件语句中使用 new 操作符</span></span><br><span class="line">    <span class="string">"no-new"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止对 Function 对象使用 new 操作符</span></span><br><span class="line">    <span class="string">"no-new-func"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止对 String，Number 和 Boolean 使用 new 操作符</span></span><br><span class="line">    <span class="string">"no-new-wrappers"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁用八进制字面量</span></span><br><span class="line">    <span class="string">"no-octal"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止在字符串中使用八进制转义序列</span></span><br><span class="line">    <span class="string">"no-octal-escape"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 不允许对 function 的参数进行重新赋值</span></span><br><span class="line">    <span class="string">"no-param-reassign"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁用 __proto__ 属性</span></span><br><span class="line">    <span class="string">"no-proto"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止使用 var 多次声明同一变量</span></span><br><span class="line">    <span class="string">"no-redeclare"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁用指定的通过 require 加载的模块</span></span><br><span class="line">    <span class="string">"no-return-assign"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止使用 javascript: url</span></span><br><span class="line">    <span class="string">"no-script-url"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止自我赋值</span></span><br><span class="line">    <span class="string">"no-self-assign"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止自身比较</span></span><br><span class="line">    <span class="string">"no-self-compare"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁用逗号操作符</span></span><br><span class="line">    <span class="string">"no-sequences"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止抛出非异常字面量</span></span><br><span class="line">    <span class="string">"no-throw-literal"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁用一成不变的循环条件</span></span><br><span class="line">    <span class="string">"no-unmodified-loop-condition"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止出现未使用过的表达式</span></span><br><span class="line">    <span class="string">"no-unused-expressions"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁用未使用过的标签</span></span><br><span class="line">    <span class="string">"no-unused-labels"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止不必要的 .call() 和 .apply()</span></span><br><span class="line">    <span class="string">"no-useless-call"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止不必要的字符串字面量或模板字面量的连接</span></span><br><span class="line">    <span class="string">"no-useless-concat"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁用不必要的转义字符</span></span><br><span class="line">    <span class="string">"no-useless-escape"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁用 void 操作符</span></span><br><span class="line">    <span class="string">"no-void"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止在注释中使用特定的警告术语</span></span><br><span class="line">    <span class="string">"no-warning-comments"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁用 with 语句</span></span><br><span class="line">    <span class="string">"no-with"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 强制在parseInt()使用基数参数</span></span><br><span class="line">    <span class="string">"radix"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 要求所有的 var 声明出现在它们所在的作用域顶部</span></span><br><span class="line">    <span class="string">"vars-on-top"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求 IIFE 使用括号括起来</span></span><br><span class="line">    <span class="string">"wrap-iife"</span>: [<span class="number">2</span>,<span class="string">"any"</span>],</span><br><span class="line">    <span class="comment">// 要求或禁止 “Yoda” 条件</span></span><br><span class="line">    <span class="string">"yoda"</span>: [<span class="number">2</span>,<span class="string">"never"</span>],</span><br><span class="line">    <span class="comment">// 要求或禁止使用严格模式指令</span></span><br><span class="line">    <span class="string">"strict"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">//////////////</span></span><br><span class="line">    <span class="comment">// 变量声明 //</span></span><br><span class="line">    <span class="comment">//////////////</span></span><br><span class="line">    <span class="comment">// 要求或禁止 var 声明中的初始化(初值)</span></span><br><span class="line">    <span class="string">"init-declarations"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 不允许 catch 子句的参数与外层作用域中的变量同名</span></span><br><span class="line">    <span class="string">"no-catch-shadow"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止删除变量</span></span><br><span class="line">    <span class="string">"no-delete-var"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 不允许标签与变量同名</span></span><br><span class="line">    <span class="string">"no-label-var"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁用特定的全局变量</span></span><br><span class="line">    <span class="string">"no-restricted-globals"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止 var 声明 与外层作用域的变量同名</span></span><br><span class="line">    <span class="string">"no-shadow"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止覆盖受限制的标识符</span></span><br><span class="line">    <span class="string">"no-shadow-restricted-names"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁用未声明的变量，除非它们在 /*global */ 注释中被提到</span></span><br><span class="line">    <span class="string">"no-undef"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止将变量初始化为 undefined</span></span><br><span class="line">    <span class="string">"no-undef-init"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止将 undefined 作为标识符</span></span><br><span class="line">    <span class="string">"no-undefined"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止出现未使用过的变量</span></span><br><span class="line">    <span class="string">"no-unused-vars"</span>: [<span class="number">0</span>, &#123;<span class="string">"vars"</span>:<span class="string">"all"</span>,<span class="string">"args"</span>:<span class="string">"none"</span>&#125;],</span><br><span class="line">    <span class="comment">// 不允许在变量定义之前使用它们</span></span><br><span class="line">    <span class="string">"no-use-before-define"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">//////////////////////////</span></span><br><span class="line">    <span class="comment">// Node.js and CommonJS //</span></span><br><span class="line">    <span class="comment">//////////////////////////</span></span><br><span class="line">    <span class="comment">// require return statements after callbacks</span></span><br><span class="line">    <span class="string">"callback-return"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求 require() 出现在顶层模块作用域中</span></span><br><span class="line">    <span class="string">"global-require"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 要求回调函数中有容错处理</span></span><br><span class="line">    <span class="string">"handle-callback-err"</span>: [<span class="number">2</span>,<span class="string">"^(err|error)$"</span>],</span><br><span class="line">    <span class="comment">// 禁止混合常规 var 声明和 require 调用</span></span><br><span class="line">    <span class="string">"no-mixed-requires"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止调用 require 时使用 new 操作符</span></span><br><span class="line">    <span class="string">"no-new-require"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止对 __dirname 和 __filename进行字符串连接</span></span><br><span class="line">    <span class="string">"no-path-concat"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁用 process.env</span></span><br><span class="line">    <span class="string">"no-process-env"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁用 process.exit()</span></span><br><span class="line">    <span class="string">"no-process-exit"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁用同步方法</span></span><br><span class="line">    <span class="string">"no-sync"</span>:<span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////</span></span><br><span class="line">    <span class="comment">// 风格指南 //</span></span><br><span class="line">    <span class="comment">//////////////</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定数组的元素之间要以空格隔开(, 后面)， </span></span><br><span class="line">    <span class="comment">// never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格</span></span><br><span class="line">    <span class="string">"array-bracket-spacing"</span>: [<span class="number">2</span>,<span class="string">"never"</span>],</span><br><span class="line">    <span class="comment">// 禁止或强制在单行代码块中使用空格(禁用)</span></span><br><span class="line">    <span class="string">"block-spacing"</span>:[<span class="number">1</span>,<span class="string">"never"</span>],</span><br><span class="line">    <span class="comment">//强制使用一致的缩进 第二个参数为 "tab" 时，会使用tab，</span></span><br><span class="line">    <span class="comment">// if while function 后面的&#123;必须与if在同一行，java风格。</span></span><br><span class="line">    <span class="string">"brace-style"</span>: [<span class="number">2</span>,<span class="string">"1tbs"</span>, &#123;<span class="string">"allowSingleLine"</span>:<span class="literal">true</span>&#125;],</span><br><span class="line">    <span class="comment">// 双峰驼命名格式</span></span><br><span class="line">    <span class="string">"camelcase"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 控制逗号前后的空格</span></span><br><span class="line">    <span class="string">"comma-spacing"</span>: [<span class="number">2</span>, &#123;<span class="string">"before"</span>:<span class="literal">false</span>,<span class="string">"after"</span>:<span class="literal">true</span>&#125;],</span><br><span class="line">    <span class="comment">// 控制逗号在行尾出现还是在行首出现 (默认行尾)</span></span><br><span class="line">    <span class="comment">// http://eslint.org/docs/rules/comma-style</span></span><br><span class="line">    <span class="string">"comma-style"</span>: [<span class="number">2</span>,<span class="string">"last"</span>],</span><br><span class="line">    <span class="comment">//"SwitchCase" (默认：0) 强制 switch 语句中的 case 子句的缩进水平</span></span><br><span class="line">    <span class="comment">// 以方括号取对象属性时，[ 后面和 ] 前面是否需要空格, 可选参数 never, always</span></span><br><span class="line">    <span class="string">"computed-property-spacing"</span>: [<span class="number">2</span>,<span class="string">"never"</span>],</span><br><span class="line">    <span class="comment">// 用于指统一在回调函数中指向this的变量名，箭头函数中的this已经可以指向外层调用者，应该没卵用了</span></span><br><span class="line">    <span class="comment">// e.g [0,"that"] 指定只能 var that = this. </span></span><br><span class="line">    <span class="comment">// that不能指向其他任何值，this也不能赋值给that以外的其他值</span></span><br><span class="line">    <span class="string">"consistent-this"</span>: [<span class="number">1</span>,<span class="string">"that"</span>],</span><br><span class="line">    <span class="comment">// 强制使用命名的 function 表达式</span></span><br><span class="line">    <span class="string">"func-names"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 文件末尾强制换行</span></span><br><span class="line">    <span class="string">"eol-last"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// "indent": [2,4, &#123;"SwitchCase":1&#125;],</span></span><br><span class="line">    <span class="comment">// 强制在对象字面量的属性中键和值之间使用一致的间距</span></span><br><span class="line">    <span class="string">"key-spacing"</span>: [<span class="number">2</span>, &#123;<span class="string">"beforeColon"</span>:<span class="literal">false</span>,<span class="string">"afterColon"</span>:<span class="literal">true</span>&#125;],</span><br><span class="line">    <span class="comment">// 强制使用一致的换行风格</span></span><br><span class="line">    <span class="string">"linebreak-style"</span>: [<span class="number">1</span>,<span class="string">"unix"</span>],</span><br><span class="line">    <span class="comment">// 要求在注释周围有空行 ( 要求在块级注释之前有一空行)</span></span><br><span class="line">    <span class="string">"lines-around-comment"</span>: [<span class="number">1</span>,&#123;<span class="string">"beforeBlockComment"</span>:<span class="literal">true</span>&#125;],</span><br><span class="line">    <span class="comment">// 强制一致地使用函数声明或函数表达式，方法定义风格，参数：</span></span><br><span class="line">    <span class="comment">// declaration: 强制使用方法声明的方式，function f()&#123;&#125; e.g [2, "declaration"]</span></span><br><span class="line">    <span class="comment">// expression：强制使用方法表达式的方式，var f = function() &#123;&#125; e.g [2, "expression"]</span></span><br><span class="line">    <span class="comment">// allowArrowFunctions: declaration风格中允许箭头函数。 </span></span><br><span class="line">    <span class="comment">// e.g [2, "declaration", &#123; "allowArrowFunctions": true &#125;]</span></span><br><span class="line">    <span class="string">"func-style"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制回调函数最大嵌套深度 5层</span></span><br><span class="line">    <span class="string">"max-nested-callbacks"</span>: [<span class="number">1</span>,<span class="number">5</span>],</span><br><span class="line">    <span class="comment">// 禁止使用指定的标识符</span></span><br><span class="line">    <span class="string">"id-blacklist"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制标识符的最新和最大长度</span></span><br><span class="line">    <span class="string">"id-length"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求标识符匹配一个指定的正则表达式</span></span><br><span class="line">    <span class="string">"id-match"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制在 JSX 属性中一致地使用双引号或单引号</span></span><br><span class="line">    <span class="string">"jsx-quotes"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制在关键字前后使用一致的空格 (前后腰需要)</span></span><br><span class="line">    <span class="string">"keyword-spacing"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 强制一行的最大长度</span></span><br><span class="line">    <span class="string">"max-len"</span>:[<span class="number">1</span>,<span class="number">200</span>],</span><br><span class="line">    <span class="comment">// 强制最大行数</span></span><br><span class="line">    <span class="string">"max-lines"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制 function 定义中最多允许的参数数量</span></span><br><span class="line">    <span class="string">"max-params"</span>:[<span class="number">1</span>,<span class="number">7</span>],</span><br><span class="line">    <span class="comment">// 强制 function 块最多允许的的语句数量</span></span><br><span class="line">    <span class="string">"max-statements"</span>:[<span class="number">1</span>,<span class="number">200</span>],</span><br><span class="line">    <span class="comment">// 强制每一行中所允许的最大语句数量</span></span><br><span class="line">    <span class="string">"max-statements-per-line"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求构造函数首字母大写 </span></span><br><span class="line">    <span class="comment">//（要求调用 new 操作符时有首字母大小的函数，允许调用首字母大写的函数时没有 new 操作符。）</span></span><br><span class="line">    <span class="string">"new-cap"</span>: [<span class="number">2</span>, &#123;<span class="string">"newIsCap"</span>:<span class="literal">true</span>,<span class="string">"capIsNew"</span>:<span class="literal">false</span>&#125;],</span><br><span class="line">    <span class="comment">// 要求调用无参构造函数时有圆括号</span></span><br><span class="line">    <span class="string">"new-parens"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 要求或禁止 var 声明语句后有一行空行</span></span><br><span class="line">    <span class="string">"newline-after-var"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止使用 Array 构造函数</span></span><br><span class="line">    <span class="string">"no-array-constructor"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁用按位运算符</span></span><br><span class="line">    <span class="string">"no-bitwise"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求 return 语句之前有一空行</span></span><br><span class="line">    <span class="string">"newline-before-return"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求方法链中每个调用都有一个换行符</span></span><br><span class="line">    <span class="string">"newline-per-chained-call"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 禁用 continue 语句</span></span><br><span class="line">    <span class="string">"no-continue"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止在代码行后使用内联注释</span></span><br><span class="line">    <span class="string">"no-inline-comments"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止 if 作为唯一的语句出现在 else 语句中</span></span><br><span class="line">    <span class="string">"no-lonely-if"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止混合使用不同的操作符</span></span><br><span class="line">    <span class="string">"no-mixed-operators"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 不允许空格和 tab 混合缩进</span></span><br><span class="line">    <span class="string">"no-mixed-spaces-and-tabs"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 不允许多个空行</span></span><br><span class="line">    <span class="string">"no-multiple-empty-lines"</span>: [<span class="number">2</span>, &#123;<span class="string">"max"</span>:<span class="number">2</span>&#125;],</span><br><span class="line">    <span class="comment">// 不允许否定的表达式</span></span><br><span class="line">    <span class="string">"no-negated-condition"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 不允许使用嵌套的三元表达式</span></span><br><span class="line">    <span class="string">"no-nested-ternary"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止使用 Object 的构造函数</span></span><br><span class="line">    <span class="string">"no-new-object"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止使用一元操作符 ++ 和 --</span></span><br><span class="line">    <span class="string">"no-plusplus"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止使用特定的语法</span></span><br><span class="line">    <span class="string">"no-restricted-syntax"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止 function 标识符和括号之间出现空格</span></span><br><span class="line">    <span class="string">"no-spaced-func"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 不允许使用三元操作符</span></span><br><span class="line">    <span class="string">"no-ternary"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁用行尾空格</span></span><br><span class="line">    <span class="string">"no-trailing-spaces"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止标识符中有悬空下划线_bar</span></span><br><span class="line">    <span class="string">"no-underscore-dangle"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止可以在有更简单的可替代的表达式时使用三元操作符</span></span><br><span class="line">    <span class="string">"no-unneeded-ternary"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止属性前有空白</span></span><br><span class="line">    <span class="string">"no-whitespace-before-property"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制花括号内换行符的一致性</span></span><br><span class="line">    <span class="string">"object-curly-newline"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制在花括号中使用一致的空格</span></span><br><span class="line">    <span class="string">"object-curly-spacing"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制将对象的属性放在不同的行上</span></span><br><span class="line">    <span class="string">"object-property-newline"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制函数中的变量要么一起声明要么分开声明</span></span><br><span class="line">    <span class="string">"one-var"</span>: [<span class="number">2</span>, &#123;<span class="string">"initialized"</span>:<span class="string">"never"</span>&#125;],</span><br><span class="line">    <span class="comment">// 要求或禁止在 var 声明周围换行</span></span><br><span class="line">    <span class="string">"one-var-declaration-per-line"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求或禁止在可能的情况下要求使用简化的赋值操作符</span></span><br><span class="line">    <span class="string">"operator-assignment"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制操作符使用一致的换行符</span></span><br><span class="line">    <span class="string">"operator-linebreak"</span>: [<span class="number">2</span>,<span class="string">"after"</span>, &#123;<span class="string">"overrides"</span>: &#123;<span class="string">"?"</span>:<span class="string">"before"</span>,<span class="string">":"</span>:<span class="string">"before"</span>&#125; &#125;],</span><br><span class="line">    <span class="comment">// 要求或禁止块内填充</span></span><br><span class="line">    <span class="string">"padded-blocks"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求对象字面量属性名称用引号括起来</span></span><br><span class="line">    <span class="string">"quote-props"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制使用一致的反勾号、双引号或单引号</span></span><br><span class="line">    <span class="string">"quotes"</span>: [<span class="number">2</span>,<span class="string">"single"</span>,<span class="string">"avoid-escape"</span>],</span><br><span class="line">    <span class="comment">// 要求使用 JSDoc 注释</span></span><br><span class="line">    <span class="string">"require-jsdoc"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 要求或禁止使用分号而不是 ASI（这个才是控制行尾部分号的，）</span></span><br><span class="line">    <span class="string">"semi"</span>: [<span class="number">2</span>,<span class="string">"always"</span>],</span><br><span class="line">    <span class="comment">// 强制分号之前和之后使用一致的空格</span></span><br><span class="line">    <span class="string">"semi-spacing"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求同一个声明块中的变量按顺序排列</span></span><br><span class="line">    <span class="string">"sort-vars"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制在块之前使用一致的空格</span></span><br><span class="line">    <span class="string">"space-before-blocks"</span>: [<span class="number">2</span>,<span class="string">"always"</span>],</span><br><span class="line">    <span class="comment">// 强制在 function的左括号之前使用一致的空格</span></span><br><span class="line">    <span class="comment">// "space-before-function-paren": [0,"always"],</span></span><br><span class="line">    <span class="comment">// 强制在圆括号内使用一致的空格</span></span><br><span class="line">    <span class="string">"space-in-parens"</span>: [<span class="number">2</span>,<span class="string">"never"</span>],</span><br><span class="line">    <span class="comment">// 要求操作符周围有空格</span></span><br><span class="line">    <span class="string">"space-infix-ops"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 强制在一元操作符前后使用一致的空格</span></span><br><span class="line">    <span class="string">"space-unary-ops"</span>: [<span class="number">2</span>, &#123;<span class="string">"words"</span>:<span class="literal">true</span>,<span class="string">"nonwords"</span>:<span class="literal">false</span>&#125;],</span><br><span class="line">    <span class="comment">// 强制在注释中 // 或 /* 使用一致的空格</span></span><br><span class="line">    <span class="string">"spaced-comment"</span>: [</span><br><span class="line">      <span class="number">2</span>,</span><br><span class="line">      <span class="string">"always"</span>, </span><br><span class="line">      &#123;<span class="string">"markers"</span>: [<span class="string">"global"</span>,<span class="string">"globals"</span>,<span class="string">"eslint"</span>,<span class="string">"eslint-disable"</span>,<span class="string">"*package"</span>,<span class="string">"!"</span>] &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 要求或禁止 Unicode BOM</span></span><br><span class="line">    <span class="string">"unicode-bom"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求正则表达式被括号括起来</span></span><br><span class="line">    <span class="string">"wrap-regex"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">//////////////</span></span><br><span class="line">    <span class="comment">// ES6.相关 //</span></span><br><span class="line">    <span class="comment">//////////////</span></span><br><span class="line">    <span class="comment">// 要求箭头函数体使用大括号</span></span><br><span class="line">    <span class="string">"arrow-body-style"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 要求箭头函数的参数使用圆括号</span></span><br><span class="line">    <span class="string">"arrow-parens"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="string">"arrow-spacing"</span>:[<span class="number">2</span>,&#123;<span class="string">"before"</span>:<span class="literal">true</span>,<span class="string">"after"</span>:<span class="literal">true</span>&#125;],</span><br><span class="line">    <span class="comment">// 强制在子类构造函数中用super()调用父类构造函数，TypeScrip的编译器也会提示</span></span><br><span class="line">    <span class="string">"constructor-super"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制 generator 函数中 * 号周围使用一致的空格</span></span><br><span class="line">    <span class="string">"generator-star-spacing"</span>: [<span class="number">2</span>, &#123;<span class="string">"before"</span>:<span class="literal">true</span>,<span class="string">"after"</span>:<span class="literal">true</span>&#125;],</span><br><span class="line">    <span class="comment">// 禁止修改类声明的变量</span></span><br><span class="line">    <span class="string">"no-class-assign"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 不允许箭头功能，在那里他们可以混淆的比较</span></span><br><span class="line">    <span class="string">"no-confusing-arrow"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止修改 const 声明的变量</span></span><br><span class="line">    <span class="string">"no-const-assign"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止类成员中出现重复的名称</span></span><br><span class="line">    <span class="string">"no-dupe-class-members"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 不允许复制模块的进口</span></span><br><span class="line">    <span class="string">"no-duplicate-imports"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止 Symbol 的构造函数</span></span><br><span class="line">    <span class="string">"no-new-symbol"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 允许指定模块加载时的进口</span></span><br><span class="line">    <span class="string">"no-restricted-imports"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止在构造函数中，在调用 super() 之前使用 this 或 super</span></span><br><span class="line">    <span class="string">"no-this-before-super"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止不必要的计算性能键对象的文字</span></span><br><span class="line">    <span class="string">"no-useless-computed-key"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求使用 let 或 const 而不是 var</span></span><br><span class="line">    <span class="string">"no-var"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求或禁止对象字面量中方法和属性使用简写语法</span></span><br><span class="line">    <span class="string">"object-shorthand"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求使用箭头函数作为回调</span></span><br><span class="line">    <span class="string">"prefer-arrow-callback"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求使用 const 声明那些声明后不再被修改的变量</span></span><br><span class="line">    <span class="string">"prefer-const"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求在合适的地方使用 Reflect 方法</span></span><br><span class="line">    <span class="string">"prefer-reflect"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求使用扩展运算符而非 .apply()</span></span><br><span class="line">    <span class="string">"prefer-spread"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求使用模板字面量而非字符串连接</span></span><br><span class="line">    <span class="string">"prefer-template"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// Suggest using the rest parameters instead of arguments</span></span><br><span class="line">    <span class="string">"prefer-rest-params"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求generator 函数内有 yield</span></span><br><span class="line">    <span class="string">"require-yield"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// enforce spacing between rest and spread operators and their expressions</span></span><br><span class="line">    <span class="string">"rest-spread-spacing"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制模块内的 import 排序</span></span><br><span class="line">    <span class="string">"sort-imports"</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求或禁止模板字符串中的嵌入表达式周围空格的使用</span></span><br><span class="line">    <span class="string">"template-curly-spacing"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 强制在 yield* 表达式中 * 周围使用空格</span></span><br><span class="line">    <span class="string">"yield-star-spacing"</span>:<span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eslint </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【JS】写一个累加函数</title>
      <link href="/2016/09/21/%E3%80%90JS%E3%80%91%E5%86%99%E4%B8%80%E4%B8%AA%E7%B4%AF%E5%8A%A0%E5%87%BD%E6%95%B0/"/>
      <url>/2016/09/21/%E3%80%90JS%E3%80%91%E5%86%99%E4%B8%80%E4%B8%AA%E7%B4%AF%E5%8A%A0%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<blockquote><p>也是最近看到的面试题，看似简单，其实有很多东西可学习理解。正好写到博客里进行下总结</p></blockquote><p>add(2)(3)(4) 希望输出9</p><a id="more"></a><p>其实这可以理解为 </p><ul><li>add(2) 返回函数A </li><li>A(3) 返回函数B</li><li>B(4) 返回函数C </li><li>C函数运行的最终结果为 9</li></ul><p>那么最初的做法可以是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">  sum += n1</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n2</span>) </span>&#123;</span><br><span class="line">    sum += n2</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n3</span>) </span>&#123;</span><br><span class="line">      sum += n3</span><br><span class="line">      <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = add(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>) <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><p>考虑其他的扩展性，若要求调用4次或者2次等，则上面的函数就不能满足这样的需求了。</p><p>那为什么不满足呢？ 其原因是我们最后返回的结果是 sum 一个变量值，而不是函数对象。</p><p>那么，按前面的写法，改一下，使之继续返回函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">  sum += n1</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n2</span>) </span>&#123;</span><br><span class="line">    sum += n2</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n3</span>) </span>&#123;</span><br><span class="line">      sum += n3</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">nn</span>) </span>&#123;<span class="comment">/* xxx */</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题是要调用的次数是未知的。就此可以利用链式调用，让函数返回后返回自身</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">  sum += n1</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">add2</span>(<span class="params">n2</span>) </span>&#123;</span><br><span class="line">    sum += n2</span><br><span class="line">    <span class="keyword">return</span> add2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数执行返回的结果是函数对象的字符串表示，怎样让之变位输出结果呢？</p><ol><li>在函数中添加判断，当没有输入参数时，直接返回调用的结果而不是返回函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">  sum += n1</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">add2</span>(<span class="params">n2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) <span class="keyword">return</span> sum</span><br><span class="line">    sum += n2</span><br><span class="line">    <span class="keyword">return</span> add2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用时，需要多加一个()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = add(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>)() <span class="comment">// 14</span></span><br></pre></td></tr></table></figure><ol><li>利用JS对象到原始值的转换规则</li></ol><blockquote><p>当一个对象转换成原始值时，先查看对象是否有valueOf方法，如果有并且返回值是一个原始值，那么直接返回这个值；否则没有valueOf或返回的不是原始值，那么调用toString方法，返回字符串表示</p></blockquote><p>我们就位函数对象添加一个valueOf方法和toString方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">  sum += n1</span><br><span class="line">  <span class="keyword">var</span> add2 = <span class="function"><span class="keyword">function</span>(<span class="params">n2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) <span class="keyword">return</span> sum</span><br><span class="line">    sum += n2</span><br><span class="line">    <span class="keyword">return</span> add2</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add2.valueOf = <span class="function"><span class="params">()</span> =&gt;</span> sum</span><br><span class="line">  add2.toString = <span class="function"><span class="params">()</span> =&gt;</span> sum + <span class="string">''</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> add2</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>) <span class="comment">// function 10 这是toString返回的所以是字符串</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)() <span class="comment">// 10 number类型</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">  sum += n1</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">add2</span>(<span class="params">n2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) <span class="keyword">return</span> sum</span><br><span class="line">    sum += n2</span><br><span class="line">    <span class="keyword">return</span> add2</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add2.valueOf = <span class="function"><span class="params">()</span> =&gt;</span> sum</span><br><span class="line">  add2.toString = <span class="function"><span class="params">()</span> =&gt;</span> sum + <span class="string">''</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> add2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我在segmentFault看到的另一种实现方法，就直接抄过来了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = []</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">add2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> calRet</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">Array</span>.prototype.push.apply(args, <span class="built_in">Array</span>.prototype.splice.call(<span class="built_in">arguments</span>, <span class="number">0</span>))</span><br><span class="line">      <span class="keyword">return</span> add</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">calRet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = args.reduce(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> acc + val, <span class="number">0</span>)</span><br><span class="line">    args = []</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add2.valueOf = <span class="function"><span class="params">()</span> =&gt;</span> calRet()</span><br><span class="line">  add2.toString = <span class="function"><span class="params">()</span> =&gt;</span> calRet() + <span class="string">''</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> add2</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 解题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【JS】编译一个函数，解析url字符串</title>
      <link href="/2016/08/28/%E3%80%90JS%E3%80%91%E8%A7%A3%E6%9E%90url%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2016/08/28/%E3%80%90JS%E3%80%91%E8%A7%A3%E6%9E%90url%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<blockquote><p>这是最近看到的一道面试题，看似简单，其实有很多东西可深挖。正好写到博客里进行下总结</p></blockquote><a id="more"></a><p>题目：编写一个函数解析 url 参数，尽可能全面正确的解析一个任意 url 的所有参数为 Object</p><pre><code>var url = &apos;http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;d&amp;enabled&apos;;parseParam(url);</code></pre><p>希望结果返回：</p><p> {<br>user: ‘anonymous’,<br>// 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型<br>id: [123, 456],<br>// 中文<br>city: ‘北京’,<br>// 未指定值的 key 约定值为 true<br>enabled: true<br>}</p><hr><p>分析下题目，编写函数，解析 url 参数，要求返回是对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大致思路有了，把框架勾勒出来</span></span><br><span class="line"><span class="keyword">const</span> parseUrl = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 声明变量存储结果</span></span><br><span class="line">  <span class="keyword">let</span> result = &#123;&#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 返回结果</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>query 值是 ?后面的所有字符串，不同参数间以&amp;为分隔，根据题目可知 key 不一定都带上 value，我们所需的即是处理字符串，即以下方法：</p><p>String.prototype.substring(a) 拿到 a 以后（包含 a）的所有字符串<br>String.prototype.split(‘&amp;’) 将字符串按’&amp;’分隔为数组<br>Array.prototype.map(item) 遍历数组，对每一项进行操作</p><p>…</p><p>思路有了，接下来尝试实现逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parUrl = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> querystring = <span class="string">''</span></span><br><span class="line">  <span class="keyword">let</span> queryArr = []</span><br><span class="line">  <span class="keyword">let</span> key</span><br><span class="line">  <span class="keyword">let</span> value</span><br><span class="line">  <span class="comment">// 若没有 '?' 即不进行处理</span></span><br><span class="line">  <span class="keyword">if</span> (url.indexOf(<span class="string">'?'</span>) === <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取到 ? 后的所有字符串</span></span><br><span class="line">  querystring = url.substring(url.indexOf(<span class="string">'?'</span>) + <span class="number">1</span>)</span><br><span class="line">  queryArr = querystring.split(<span class="string">'&amp;'</span>)</span><br><span class="line">  queryArr.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.indexOf(<span class="string">'='</span>) === <span class="number">-1</span>) &#123;</span><br><span class="line">      result[item] = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> kv = item.split(<span class="string">'='</span>)</span><br><span class="line">      key = kv[<span class="number">0</span>]</span><br><span class="line">      value = kv[<span class="number">1</span>]</span><br><span class="line">      result[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉挺好，不过对于要求还是少了些东西…… 这里直接提出来了，毕竟是看了答案之后：</p><ol><li>校验不够严谨，缺少对传入类型，是否为 url 的判断</li><li>没有对传入值进行解码</li><li>传入相同的 key，后面 key 的值会将前面的值覆盖掉</li></ol><p>接下来，继续优化我们的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析url，将之转换为对象，一个key有多个值时生成数组</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; url 需要解析的url，按照application/x-www-form-urlencode编码</span></span><br><span class="line"><span class="comment"> * @return &#123;Object&#125; result 参数细节后的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> parseUrl = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> url !== <span class="string">'string'</span>) <span class="keyword">return</span> result</span><br><span class="line">  <span class="comment">// 判断是否为合法url可跳过</span></span><br><span class="line">  <span class="keyword">if</span> (url.indexOf(<span class="string">'?'</span>) === <span class="number">-1</span>) <span class="keyword">return</span> reuslt</span><br><span class="line">  <span class="keyword">let</span> querystring = url.substring(url.indexOf(<span class="string">'?'</span>) + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">let</span> queryArr = querystring.split(<span class="string">'&amp;'</span>)</span><br><span class="line">  <span class="keyword">let</span> key</span><br><span class="line">  <span class="keyword">let</span> value</span><br><span class="line">  queryArr.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.indexOf(<span class="string">'='</span>) === <span class="number">-1</span>) &#123;</span><br><span class="line">      result[item] = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> kv = item.split(<span class="string">'='</span>)</span><br><span class="line">      <span class="keyword">let</span> key = <span class="built_in">decodeURIComponent</span>(kv[<span class="number">0</span>])</span><br><span class="line">      <span class="keyword">let</span> value = <span class="built_in">decodeURIComponent</span>(kv[<span class="number">1</span>])</span><br><span class="line">      <span class="comment">// 如果是新key 直接添加</span></span><br><span class="line">      <span class="keyword">if</span> (!(key <span class="keyword">in</span> result)) &#123;</span><br><span class="line">        result[key] = value</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果key已经出现一次以上，直接向数组添加value</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (isArray(result[key])) &#123;</span><br><span class="line">        result[key].push(value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果key第二次出现，将结果改为数组</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> arr = [result[key]]</span><br><span class="line">        arr.push(value)</span><br><span class="line">        result[key] = arr</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> URL = <span class="string">'http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;d&amp;enabled'</span></span><br><span class="line">parseUrl(URL)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  user: 'anonymous',</span></span><br><span class="line"><span class="comment">  // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型</span></span><br><span class="line"><span class="comment">  id: [123, 456], </span></span><br><span class="line"><span class="comment">  // 中文</span></span><br><span class="line"><span class="comment">  city: '北京', </span></span><br><span class="line"><span class="comment">  // 未指定值的 key 约定值为 true</span></span><br><span class="line"><span class="comment">  enabled: true</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 解题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【JS】用Jsonp解决跨域问题</title>
      <link href="/2016/06/04/%E3%80%90JS%E3%80%91%E7%94%A8Jsonp%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <url>/2016/06/04/%E3%80%90JS%E3%80%91%E7%94%A8Jsonp%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<blockquote><p>该篇讲述了同源策略，再到跨域的解决。学习分析了流行的jsonp方案从源码上加深了对jsonp的理解和认识</p></blockquote><a id="more"></a><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>要理解跨域，先要了解一下“同源策略”。所谓同源是指，域名，协议，端口相同。所谓“同源策略“，简单的说就是基于安全考虑，当前域不能访问其他域的东西。</p><pre><code>http://www.abc.com:8080/home?k=v</code></pre><p>这么一个url地址，由协议，域名，端口，路径等部分组成。怎么来区分跨域与否呢？ 这里简单列了一下：</p><p><strong>跨域</strong></p><ul><li>不同协议</li><li>域名不同</li><li>端口不同</li></ul><p><strong>不跨域</strong></p><ul><li>协议、域名和端口相同</li><li>同一域名的不同路径下</li></ul><p><strong>跨域情况</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  xhr.open(<span class="string">'get'</span>, <span class="string">'https://api.douban.com/v2/book/search?q=javascript&amp;count=1'</span>, <span class="literal">true</span>);</span><br><span class="line">  xhr.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但<code>&lt;img&gt;</code>的src（获取图片），<code>&lt;link&gt;</code>的href（获取css），<code>&lt;script&gt;</code>的src（获取javascript）这三个都不符合同源策略，它们可以跨域获取数据。这里要介绍的JSONP就是利用<code>&lt;script&gt;</code>的src来实现跨域获取数据的。</p><h2 id="Jsonp"><a href="#Jsonp" class="headerlink" title="Jsonp"></a>Jsonp</h2><p>JSONP 是 JSON with padding（填充式 JSON 或参数式 JSON）的简写。<br>JSONP实现跨域请求的原理简单的说，就是动态创建<code>&lt;script&gt;</code>标签，然后利用<code>&lt;script&gt;</code>的 src 不受同源策略约束来跨域获取数据。<br>JSONP 由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的 JSON 数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">script.src = <span class="string">"https://api.douban.com/v2/book/search?q=javascript&amp;count=1&amp;callback=handleResponse"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(script, <span class="built_in">document</span>.body.firstChild);</span><br><span class="line"><span class="comment">// 对response数据进行操作代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResponse</span>(<span class="params">response</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>JSONP目前还是比较流行的跨域方式，虽然JSONP使用起来方便，但是也存在一些问题：<br>首先， JSONP 是从其他域中加载代码执行。如果其他域不安全，很可能会在响应中夹带一些恶意代码，而此时除了完全放弃 JSONP 调用之外，没有办法追究。因此在使用不是你自己运维的 Web 服务时，一定得保证它安全可靠。</p><p>其次，要确定 JSONP 请求是否失败并不容易。虽然 HTML5 给 <code>&lt;script&gt;</code> 元素新增了一个 onerror事件处理程序，但目前还没有得到任何浏览器支持。为此，开发人员不得不使用计时器检测指定时间内是否接收到了响应。</p><p>下面来看看 jsonp 的源码解读 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const debug = require('debug')('jsonp')</span></span><br><span class="line"><span class="comment">// 记录回调次数</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line"><span class="comment">// Noop循环函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noop</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现jsonp的主函数，接受3个参数</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; url </span></span><br><span class="line"><span class="comment"> * @param &#123;Object | Function&#125; opts </span></span><br><span class="line"><span class="comment"> * @param &#123;Function&#125; fn </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url, opts, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> opts === <span class="string">'function'</span>) &#123;</span><br><span class="line">    fn = opts</span><br><span class="line">    opts = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!opts) opts = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> prefix = opts.prefix || <span class="string">'__jp'</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果被调用就 使用被提供的回调名称</span></span><br><span class="line">  <span class="comment">// 否则通过增加计数器来生成一个唯一的名称</span></span><br><span class="line">  <span class="keyword">let</span> id = opts.name || (prefix + (count++))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> param = opts.param || <span class="string">'callback'</span></span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span> != opts.timeout ? opts.timeout : <span class="number">60000</span></span><br><span class="line">  <span class="keyword">const</span> enc = <span class="built_in">encodeURIComponent</span></span><br><span class="line">  <span class="keyword">let</span> target = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'script'</span>)[<span class="number">0</span>] || <span class="built_in">document</span>.head</span><br><span class="line">  <span class="keyword">let</span> script</span><br><span class="line">  <span class="keyword">let</span> timer</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 边界条件处理</span></span><br><span class="line">  <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      cleanup()</span><br><span class="line">      <span class="keyword">if</span> (fn) fn(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Timeout'</span>))</span><br><span class="line">    &#125;, timeout)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">cleanup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 方法执行时，删除创建的script节点</span></span><br><span class="line">    <span class="keyword">if</span> (script.parantNode) script.parantNode.removeChild(script)</span><br><span class="line">    <span class="comment">// 且给window对象绑定属性id 为 noop （上面的空函数）</span></span><br><span class="line">    <span class="built_in">window</span>[id] = noop</span><br><span class="line">    <span class="comment">// 若timer不为空，则先清楚一次计时器</span></span><br><span class="line">    <span class="keyword">if</span> (timer) clearTimeout(timer)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">cancel</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 执行时若window已绑定id则执行 cleanup 清除</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>[id]) &#123;</span><br><span class="line">      cleanup()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 为 window[id] 绑定一个匿名函数 </span></span><br><span class="line"><span class="comment">   * 接受data参数，执行回调fn时，将 data作为参数进行传递</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">window</span>[id] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// debug('jsonp got', data)</span></span><br><span class="line">    cleanup()</span><br><span class="line">    <span class="keyword">if</span> (fn) fn(<span class="literal">null</span>, data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改现 url，增加 querystring</span></span><br><span class="line">  url += <span class="string">`<span class="subst">$&#123;~url.indexOf(<span class="string">'?'</span>) ? <span class="string">'&amp;'</span> : <span class="string">'?'</span>&#125;</span><span class="subst">$&#123;param&#125;</span>=<span class="subst">$&#123;enc(id)&#125;</span>`</span></span><br><span class="line">  <span class="comment">// 这针对的是第一个kv对</span></span><br><span class="line">  url = url.replace(<span class="string">'?&amp;'</span>, <span class="string">'?'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// debug('jsonp req "%s"', url)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建script节点</span></span><br><span class="line">  script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">  script.src = url</span><br><span class="line">  target.parentNode.insertBefore(script, target)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cancel</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = jsonp</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/webmodules/jsonp/blob/master/index.js" target="_blank" rel="noopener">开源jsonp实现 github</a></p>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jsonp </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
