<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【CSS】纯CSS3手工打造变形金刚</title>
    <url>/2017/02/20/2179cae0-af92-11ee-a5fe-4dd944bb4eb2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>老外写的一个很有意思的demo~ 就copy到本地了，地址找不到了… 请原谅我就不贴网址了<br>我把代码扒下来重新写了遍，整理了下就记录下来了，还是挺有意思的</p>
<p>只要有想法，真的是各种强啊， 简直不敢相信这居然是纯CSS代码完成的，里面有很多 transform 及 css三角的应用，代码读起来很顺， 理解起来也不难，但想到…那是真的难… 很多地方需要细细拆分才能琢磨透，先上图上DEMO</p>
<iframe style="width:100%; height:460px;" src="https://jsfiddle.net/vho3j50x/embedded/result,html,css,js/"></iframe>

<span id="more"></span>

<p>那开始我们的编程吧：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 外层容器结构可以根据自己的情况来调整 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;batianhu-wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;batianhu&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;head-body&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;head-topcover&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;head-toplogo-bg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;head-toplogo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;head-toplogo-2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;head-bottom-left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;head-bottom-right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;head-sw-left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;head-sw-right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;head-eye&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;head-eye-2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#batianhu-wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">250px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">325px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">50px</span> auto <span class="number">20px</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.head-body</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">25px</span> <span class="number">0</span> <span class="number">50px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">150px</span> solid <span class="number">#555</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">25px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">25px</span> solid transparent;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.head-topcover</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative; <span class="attribute">z-index</span>: <span class="number">5</span>; <span class="attribute">top</span>: -<span class="number">225px</span>; <span class="attribute">left</span>: -<span class="number">19px</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">80px</span> solid <span class="number">#333</span>; </span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">60px</span> solid transparent; </span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">60px</span> solid transparent;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">169px</span>; <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.head-topcover</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>; <span class="attribute">position</span>: absolute; <span class="attribute">top</span>: <span class="number">0px</span>; <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#333</span> transparent transparent transparent;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">15px</span> <span class="number">85px</span> <span class="number">0</span> <span class="number">85px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>; <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.head-toplogo-bg</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative; <span class="attribute">z-index</span>: <span class="number">6</span>; <span class="attribute">top</span>: -<span class="number">267px</span>; <span class="attribute">left</span>: <span class="number">67px</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">110px</span> solid <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">35px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">35px</span> solid transparent;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">46px</span>; <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.head-toplogo-bg</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>; <span class="attribute">position</span>: absolute; <span class="attribute">top</span>: <span class="number">0px</span>; <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#333</span> transparent transparent transparent;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">30px</span> <span class="number">23px</span> <span class="number">0</span> <span class="number">23px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>; <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.head-toplogo</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative; <span class="attribute">z-index</span>: <span class="number">7</span>; <span class="attribute">top</span>: -<span class="number">377px</span>; <span class="attribute">left</span>: <span class="number">75px</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">105px</span> solid <span class="number">#555</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">30px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">30px</span> solid transparent;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">40px</span>; <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.head-toplogo</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>; <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">position</span>: absolute; <span class="attribute">top</span>: -<span class="number">42px</span>; <span class="attribute">left</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">30px</span> solid <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">10px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">10px</span> solid transparent;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>; <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.head-toplogo</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute; <span class="attribute">top</span>: <span class="number">0px</span>; <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#555</span> transparent transparent transparent;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">28px</span> <span class="number">20px</span> <span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>; <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.head-toplogo-2</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative; <span class="attribute">z-index</span>: <span class="number">8</span>; <span class="attribute">top</span>: -<span class="number">482px</span>; <span class="attribute">left</span>: <span class="number">75px</span>; </span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">37px</span> solid <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">35px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">35px</span> solid transparent;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>; <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.head-bottom-left</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block; <span class="attribute">margin</span>: <span class="number">50px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative; <span class="attribute">top</span>: -<span class="number">365px</span>; <span class="attribute">left</span>: -<span class="number">31px</span>; <span class="attribute">z-index</span>: <span class="number">10</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">107px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">44px</span> solid <span class="number">#555</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">60px</span> solid transparent;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0px</span>; <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#555</span>;</span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">236deg</span>);</span><br><span class="line">          <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">236deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.head-bottom-right</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">position</span>: relative; <span class="attribute">top</span>: -<span class="number">460px</span>; <span class="attribute">left</span>: <span class="number">115px</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">60px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">44px</span> solid <span class="number">#555</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">107px</span> solid transparent;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0px</span>; <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#555</span>;</span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">484deg</span>);</span><br><span class="line">          <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">484deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有困惑的地方，可以把容器的<code>overflow:hidden</code>属性去掉， 一行一行去掉我们所写的css效果，看看是由怎样的变化得到的，如上图，我们就是用两个三角拼出来的脸颊，利用overflow属性得到了我们想要的效果 </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.head-sw-left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative; <span class="attribute">z-index</span>: <span class="number">15</span>; <span class="attribute">left</span>: <span class="number">45px</span>; <span class="attribute">top</span>: -<span class="number">629px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">49px</span>; <span class="attribute">height</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#333</span>;  </span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="built_in">skew</span>(-<span class="number">149deg</span>) <span class="built_in">rotate</span>(<span class="number">9deg</span>);</span><br><span class="line">          <span class="attribute">transform</span>: <span class="built_in">skew</span>(-<span class="number">149deg</span>) <span class="built_in">rotate</span>(<span class="number">9deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.head-sw-left</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute; <span class="attribute">top</span>: <span class="number">24px</span>; <span class="attribute">left</span>: -<span class="number">6px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">53px</span>; <span class="attribute">height</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#333</span>;</span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="built_in">skew</span>(-<span class="number">174deg</span>) <span class="built_in">rotate</span>(<span class="number">1deg</span>);</span><br><span class="line">          <span class="attribute">transform</span>: <span class="built_in">skew</span>(-<span class="number">174deg</span>) <span class="built_in">rotate</span>(<span class="number">1deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.head-sw-right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative; <span class="attribute">z-index</span>: <span class="number">15</span>; <span class="attribute">left</span>: <span class="number">155px</span>; <span class="attribute">top</span>: -<span class="number">637px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">49px</span>; <span class="attribute">height</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#333</span>;</span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="built_in">skew</span>(<span class="number">279deg</span>) <span class="built_in">rotate</span>(<span class="number">10deg</span>);</span><br><span class="line">          <span class="attribute">transform</span>: <span class="built_in">skew</span>(<span class="number">279deg</span>) <span class="built_in">rotate</span>(<span class="number">10deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.head-sw-right</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute; <span class="attribute">top</span>: -<span class="number">2px</span>; <span class="attribute">left</span>: <span class="number">132px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">45px</span>; <span class="attribute">height</span>: <span class="number">9px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#333</span>;</span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="built_in">skew</span>(-<span class="number">212deg</span>) <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">          <span class="attribute">transform</span>: <span class="built_in">skew</span>(-<span class="number">212deg</span>) <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.head-eye</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative; <span class="attribute">z-index</span>: <span class="number">12</span>; <span class="attribute">left</span>: <span class="number">67px</span>; <span class="attribute">top</span>: -<span class="number">585px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">0</span> <span class="number">0</span> <span class="number">15px</span>, <span class="built_in">rgba</span>(<span class="number">76</span>, <span class="number">190</span>, <span class="number">255</span>, <span class="number">0.95</span>) <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">32px</span>; <span class="attribute">height</span>: <span class="number">22px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#4CBEFF</span>;</span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="built_in">skew</span>(<span class="number">46deg</span>) <span class="built_in">rotate</span>(<span class="number">14deg</span>);</span><br><span class="line">          <span class="attribute">transform</span>: <span class="built_in">skew</span>(<span class="number">46deg</span>) <span class="built_in">rotate</span>(<span class="number">14deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.head-eye-2</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative; <span class="attribute">z-index</span>: <span class="number">12</span>; <span class="attribute">left</span>: <span class="number">150px</span>; <span class="attribute">top</span>: -<span class="number">607px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">0</span> <span class="number">0</span> <span class="number">15px</span>, <span class="built_in">rgba</span>(<span class="number">76</span>, <span class="number">190</span>, <span class="number">255</span>, <span class="number">0.95</span>) <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">32px</span>; <span class="attribute">height</span>: <span class="number">22px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#4CBEFF</span>;</span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="built_in">skew</span>(-<span class="number">46deg</span>) <span class="built_in">rotate</span>(-<span class="number">14deg</span>);</span><br><span class="line">          <span class="attribute">transform</span>: <span class="built_in">skew</span>(-<span class="number">46deg</span>) <span class="built_in">rotate</span>(-<span class="number">14deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>文章到此的完整展示代码请参考上面demo的jsfiddle里的css部分</code></p>
<p>至此，我们的纯css所写的变形金刚的静态效果就完成了，是不是很有趣呢？<br>这个结构按照身体各部分拆成了很多份，感兴趣还可以做成动画~~ 待填坑…</p>
]]></content>
      <categories>
        <category>代码相关</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>demo</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】变量声明与赋值，引用、值传递与对象拷贝</title>
    <url>/2018/06/23/eb34aa40-af91-11ee-b05c-4d928a9d6fe1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>夯实基础系列。虽然想整理之前测试相关的东西，不过最近看书有讲到这个，遂将之前收藏的博客、文章结合书里的讲解做了一些整理和例子来加深这块的印象。（今天也才把测试的看了没来得及整理）</p>
</blockquote>
<span id="more"></span>

<p>ES6 为我们引入了 <code>let</code> 与 <code>const</code> 两种新的变量声明关键字，同时也引入了块作用域；本文首先介绍 ES6 中常用的三种变量声明方式，然后讨论了 JavaScript 按值传递的特性以及多种的赋值方式，最后介绍了复合类型拷贝的技巧</p>
<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>在 JavaScript 中，基本的变量声明可以用 var 方式；JavaScript 允许省略 var，直接对未声明的变量赋值。也就是说，var a &#x3D; 1 与 a &#x3D; 1，这两条语句的效果相同。但是由于这样的做法很容易不知不觉地创建全局变量（尤其是在函数内部），所以建议总是使用 var 命令声明变量。在 ES6 中，对于变量声明的方式进行了扩展，引入了 let 与 const。var 与 let 两个关键字创建变量的区别在于， var 声明的变量作用域是最近的函数块；而 let 声明的变量作用域是最近的闭合块，往往会小于函数块。另一方面，以 let 关键字创建的变量虽然同样被提升到作用域头部，但是并不能在实际声明前使用；如果强行使用则会抛出 ReferenceError 异常。</p>
<h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><p>var 是 JavaScript 中基础的变量声明方式之一，其基本语法为:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="comment">// Declaration and initialization</span></span><br><span class="line">x = <span class="string">&#x27;Hello World&#x27;</span> <span class="comment">// Assignment</span></span><br><span class="line"><span class="comment">// Or all in one</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="string">&#x27;Hello World&#x27;</span></span><br></pre></td></tr></table></figure>

<p>ECMAScript 6 以前我们在 JavaScript 中并没有其他的变量声明方式，以 var 声明的变量作用于函数作用域中，如果没有相应的闭合函数作用域，那么该变量会被当做默认的全局变量进行处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> hello = <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> hello</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hello)</span><br></pre></td></tr></table></figure>

<p>像如上这种调用方式会抛出异常: ReferenceError: hello is not defined，因为 hello 变量只能作用于 sayHello 函数中，不过如果按照如下先声明全局变量方式再使用时，其就能够正常调用:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> hello</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hello)</span><br></pre></td></tr></table></figure>

<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>在 ECMAScript 6 中我们可以使用 let 关键字进行变量声明:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x <span class="comment">// Declaration and initialization</span></span><br><span class="line">x = <span class="string">&#x27;Hello World&#x27;</span> <span class="comment">// Assignment</span></span><br><span class="line"><span class="comment">// Or all in one</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="string">&#x27;Hello World&#x27;</span></span><br></pre></td></tr></table></figure>

<p>let 关键字声明的变量是属于块作用域，也就是包含在 {} 之内的作用于。使用 let 关键字的优势在于能够降低偶然的错误的概率，因为其保证了每个变量只能在最小的作用域内进行访问。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Peter&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (name === <span class="string">&#x27;Peter&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> hello = <span class="string">&#x27;Hello Peter&#x27;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> hello = <span class="string">&#x27;Hi&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hello)</span><br></pre></td></tr></table></figure>

<p>上述代码同样会抛出 ReferenceError: hello is not defined 异常，因为 hello 只能够在闭合的块作用域中进行访问，我们可以进行如下修改:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Peter&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (name === <span class="string">&#x27;Peter&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> hello = <span class="string">&#x27;Hello Peter&#x27;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(hello)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> hello = <span class="string">&#x27;Hi&#x27;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(hello)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以利用这种块级作用域的特性来避免闭包中因为变量保留而导致的问题，譬如如下两种异步代码，使用 var 时每次循环中使用的都是相同变量；而使用 let 声明的 i 则会在每次循环时进行不同的绑定，即每次循环中闭包捕获的都是不同的 i 实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`i:<span class="subst">$&#123;i&#125;</span>`</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`j:<span class="subst">$&#123;j&#125;</span>`</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> k = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`k:<span class="subst">$&#123;k&#125;</span>`</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="attr">i</span>: <span class="number">0</span></span><br><span class="line"><span class="attr">i</span>: <span class="number">1</span></span><br><span class="line"><span class="attr">j</span>: <span class="number">2</span></span><br><span class="line"><span class="attr">j</span>: <span class="number">2</span></span><br><span class="line"><span class="attr">k</span>: <span class="number">2</span></span><br><span class="line"><span class="attr">k</span>: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const 关键字一般用于常量声明，用 const 关键字声明的常量需要在声明时进行初始化并且不可以再进行修改，并且 const 关键字声明的常量被限制于块级作用域中进行访问。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> x;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// okay, block scoped name</span></span><br><span class="line">      <span class="keyword">const</span> x = <span class="string">&quot;sneaky&quot;</span>;</span><br><span class="line">      <span class="comment">// error, const</span></span><br><span class="line">      x = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// error, already declared in block</span></span><br><span class="line">    <span class="keyword">let</span> x = <span class="string">&quot;inner&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JavaScript 中 const 限制的并非值不可变性；而是创建了不可变的绑定，即对于某个值的只读引用，并且禁止了对于该引用的重赋值，即如下的代码会触发错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line">numbers = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>] <span class="comment">// error: assignment to constant variable</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numbers[<span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<p>我们可以参考如下图片理解这种机制，每个变量标识符都会关联某个存放变量实际值的物理地址；所谓只读的变量即是该变量标识符不可以被重新赋值，而该变量指向的值还是可变的。</p>
<p>JavaScript 中存在着所谓的原始类型与复合类型，使用 const 声明的原始类型是值不可变的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># <span class="title class_">Example</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">10</span></span><br><span class="line">a = a + <span class="number">1</span> <span class="comment">// error: assignment to constant variable</span></span><br><span class="line"># <span class="title class_">Example</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">const</span> isTrue = <span class="literal">true</span></span><br><span class="line">isTrue = <span class="literal">false</span> <span class="comment">// error: assignment to constant variable</span></span><br><span class="line"># <span class="title class_">Example</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">const</span> sLower = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="keyword">const</span> sUpper = sLower.<span class="title function_">toUpperCase</span>() <span class="comment">// create a new string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sLower) <span class="comment">// print hello world</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sUpper) <span class="comment">// print HELLO WORLD</span></span><br></pre></td></tr></table></figure>

<p>而如果我们希望将某个对象同样变成不可变类型，则需要使用 Object.freeze()；不过该方法仅对于键值对的 Object 起作用，而无法作用于 Date、Map 与 Set 等类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># <span class="title class_">Example</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">const</span> me = <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;<span class="attr">name</span>: “<span class="title class_">Jacopo</span>”&#125;)</span><br><span class="line">me.<span class="property">age</span> = <span class="number">28</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me.<span class="property">age</span>) <span class="comment">// print undefined</span></span><br><span class="line"># <span class="title class_">Example</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="title class_">Object</span>.<span class="title function_">freeze</span>([-<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">0</span>]) <span class="comment">// print -1</span></span><br><span class="line"># <span class="title class_">Example</span> <span class="number">6</span></span><br><span class="line"><span class="keyword">const</span> me = <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Jacopo&#x27;</span>,</span><br><span class="line">  <span class="attr">pet</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;dog&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Spock&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">me.<span class="property">pet</span>.<span class="property">name</span> = <span class="string">&#x27;Rocky&#x27;</span></span><br><span class="line">me.<span class="property">pet</span>.<span class="property">breed</span> = <span class="string">&#x27;German Shepherd&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me.<span class="property">pet</span>.<span class="property">name</span>) <span class="comment">// print Rocky</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me.<span class="property">pet</span>.<span class="property">breed</span>) <span class="comment">// print German Shepherd</span></span><br></pre></td></tr></table></figure>

<p>即使是 Object.freeze() 也只能防止顶层属性被修改，而无法限制对于嵌套属性的修改，这一点我们会在下文的浅拷贝与深拷贝部分继续讨论。</p>
<h2 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h2><h3 id="按值传递"><a href="#按值传递" class="headerlink" title="按值传递"></a>按值传递</h3><p>JavaScript 中永远是按值传递（pass-by-value），只不过当我们传递的是某个对象的引用时，这里的值指的是对象的引用。按值传递中函数的形参是被调用时所传实参的副本。修改形参的值并不会影响实参。而按引用传递（pass-by-reference）时，函数的形参接收实参的隐式引用，而不再是副本。这意味着函数形参的值如果被修改，实参也会被修改。同时两者指向相同的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">changeStuff</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  a = a * <span class="number">10</span>;</span><br><span class="line">  b.<span class="property">item</span> = <span class="string">&quot;changed&quot;</span>;</span><br><span class="line">  c = &#123;<span class="attr">item</span>: <span class="string">&quot;changed&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">item</span>: <span class="string">&quot;unchanged&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">item</span>: <span class="string">&quot;unchanged&quot;</span>&#125;;</span><br><span class="line"><span class="title function_">changeStuff</span>(num, obj1, obj2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">item</span>); <span class="comment">// changed</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">item</span>); <span class="comment">// unchanged</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 按值传递就表现于在内部修改了 c 的值但是并不会影响到外部的 obj2 变量。如果我们更深入地来理解这个问题，JavaScript 对于对象的传递则是按共享传递的（pass-by-sharing，也叫按对象传递、按对象共享传递）。最早由Barbara Liskov. 在1974年的GLU语言中提出；该求值策略被用于Python、Java、Ruby、JS等多种语言。该策略的重点是：调用函数传参时，函数接受对象实参引用的副本(既不是按值传递的对象副本，也不是按引用传递的隐式引用)。 它和按引用传递的不同在于：在共享传递中对函数形参的赋值，不会影响实参的值。按共享传递的直接表现就是上述代码中的 obj1，当我们在函数内修改了 b 指向的对象的属性值时，我们使用 obj1 来访问相同的变量时同样会得到变化后的值。</p>
<h3 id="连续赋值"><a href="#连续赋值" class="headerlink" title="连续赋值"></a>连续赋值</h3><p>JavaScript 中是支持变量的连续赋值，即譬如：</p>
<pre><code>var a=b=1;
</code></pre>
<p>为了解释上述问题，我们引入一个新的变量:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">n</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a; <span class="comment">// 持有a，以回查</span></span><br><span class="line">a.<span class="property">x</span> = a = &#123;<span class="attr">n</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="title function_">alert</span>(a.<span class="property">x</span>);<span class="comment">// --&gt; undefined</span></span><br><span class="line"><span class="title function_">alert</span>(b.<span class="property">x</span>);<span class="comment">// --&gt; [object Object]</span></span><br></pre></td></tr></table></figure>

<p>实际上在连续赋值中，值是直接赋予给变量指向的内存地址：</p>
<pre><code>  a.x  =  a  = &#123;n:2&#125;
          │      │
  &#123;n:1&#125;&lt;──┘      └─&gt;&#123;n:2&#125;
</code></pre>
<h3 id="Deconstruction-解构赋值"><a href="#Deconstruction-解构赋值" class="headerlink" title="Deconstruction: 解构赋值"></a>Deconstruction: 解构赋值</h3><p>解构赋值允许你使用类似数组或对象字面量的语法将数组和对象的属性赋给各种变量。这种赋值语法极度简洁，同时还比传统的属性访问方法更为清晰。传统的访问数组前三个元素的方式为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> first = someArray[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> second = someArray[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> third = someArray[<span class="number">2</span>];</span><br><span class="line"><span class="comment">// 结构赋值</span></span><br><span class="line"><span class="keyword">var</span> [first, second, third] = someArray;</span><br><span class="line"><span class="comment">// === Arrays</span></span><br><span class="line"><span class="keyword">var</span> [a, b] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b);<span class="comment">//=&gt; 1 2</span></span><br><span class="line"><span class="comment">// Use from functions, only select from pattern</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">foo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> [a, b] = <span class="title function_">foo</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b);<span class="comment">// =&gt; 1 2</span></span><br><span class="line"><span class="comment">// Omit certain values</span></span><br><span class="line"><span class="keyword">var</span> [a, , b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b);<span class="comment">// =&gt; 1 3</span></span><br><span class="line"><span class="comment">// Combine with spread/rest operator (accumulates the rest of the values)</span></span><br><span class="line"><span class="keyword">var</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b);<span class="comment">// =&gt; 1 [ 2, 3 ]</span></span><br><span class="line"><span class="comment">// Fail-safe.</span></span><br><span class="line"><span class="keyword">var</span> [, , , a, b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b);<span class="comment">// =&gt; undefined undefined</span></span><br><span class="line"><span class="comment">// Swap variables easily without temp</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">[b, a] = [a, b];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b);<span class="comment">// =&gt; 2 1</span></span><br><span class="line"><span class="comment">// Advance deep arrays</span></span><br><span class="line"><span class="keyword">var</span> [a, [b, [c, d]]] = [<span class="number">1</span>, [<span class="number">2</span>, [[[<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>], <span class="number">6</span>]]];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a:&quot;</span>, a, <span class="string">&quot;b:&quot;</span>, b, <span class="string">&quot;c:&quot;</span>, c, <span class="string">&quot;d:&quot;</span>, d);<span class="comment">// =&gt; a: 1 , b: 2,  c: [ [ 3, 4 ], 5 ] , d: 6</span></span><br><span class="line"><span class="comment">// === Objects</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">user</span>: x&#125; = &#123;<span class="attr">user</span>: <span class="number">5</span>&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);<span class="comment">// =&gt; 5</span></span><br><span class="line"><span class="comment">// Fail-safe</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">user</span>: x&#125; = &#123;<span class="attr">user2</span>: <span class="number">5</span>&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);<span class="comment">// =&gt; undefined</span></span><br><span class="line"><span class="comment">// More values</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">prop</span>: x, <span class="attr">prop2</span>: y&#125; = &#123;<span class="attr">prop</span>: <span class="number">5</span>, <span class="attr">prop2</span>: <span class="number">10</span>&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);<span class="comment">// =&gt; 5 10</span></span><br><span class="line"><span class="comment">// Short-hand syntax</span></span><br><span class="line"><span class="keyword">var</span> &#123; prop, prop2&#125; = &#123;<span class="attr">prop</span>: <span class="number">5</span>, <span class="attr">prop2</span>: <span class="number">10</span>&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(prop, prop2);<span class="comment">// =&gt; 5 10</span></span><br><span class="line"><span class="comment">// Equal to:</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">prop</span>: prop, <span class="attr">prop2</span>: prop2&#125; = &#123;<span class="attr">prop</span>: <span class="number">5</span>, <span class="attr">prop2</span>: <span class="number">10</span>&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(prop, prop2);<span class="comment">// =&gt; 5 10</span></span><br><span class="line"><span class="comment">// Oops: This doesn&#x27;t work:</span></span><br><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line">&#123; a, b &#125; = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">// But this does work</span></span><br><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line">(&#123; a, b &#125; = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b);<span class="comment">// =&gt; 1 2</span></span><br><span class="line"><span class="comment">// This due to the grammar in JS.</span></span><br><span class="line"><span class="comment">// Starting with &#123; implies a block scope, not an object literal.</span></span><br><span class="line"><span class="comment">// () converts to an expression.</span></span><br><span class="line"><span class="comment">// From Harmony Wiki:</span></span><br><span class="line"><span class="comment">// Note that object literals cannot appear in</span></span><br><span class="line"><span class="comment">// statement positions, so a plain object</span></span><br><span class="line"><span class="comment">// destructuring assignment statement</span></span><br><span class="line"><span class="comment">//  &#123; x &#125; = y must be parenthesized either</span></span><br><span class="line"><span class="comment">// as (&#123; x &#125; = y) or (&#123; x &#125;) = y.</span></span><br><span class="line"><span class="comment">// Combine objects and arrays</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">prop</span>: x, <span class="attr">prop2</span>: [, y]&#125; = &#123;<span class="attr">prop</span>: <span class="number">5</span>, <span class="attr">prop2</span>: [<span class="number">10</span>, <span class="number">100</span>]&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);<span class="comment">// =&gt; 5 100</span></span><br><span class="line"><span class="comment">// Deep objects</span></span><br><span class="line"><span class="keyword">var</span> &#123;</span><br><span class="line">  <span class="attr">prop</span>: x,</span><br><span class="line">  <span class="attr">prop2</span>: &#123;</span><br><span class="line">    <span class="attr">prop2</span>: &#123;</span><br><span class="line">      <span class="attr">nested</span>: [ , , b]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; = &#123; <span class="attr">prop</span>: <span class="string">&quot;Hello&quot;</span>, <span class="attr">prop2</span>: &#123; <span class="attr">prop2</span>: &#123; <span class="attr">nested</span>: [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]&#125;&#125;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x, b);<span class="comment">// =&gt; Hello c</span></span><br><span class="line"><span class="comment">// === Combining all to make fun happen</span></span><br><span class="line"><span class="comment">// All well and good, can we do more? Yes!</span></span><br><span class="line"><span class="comment">// Using as method parameters</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span> (<span class="params">&#123;prop: x&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">foo</span>(&#123;<span class="attr">invalid</span>: <span class="number">1</span>&#125;);<span class="comment">// =&gt; undefined</span></span><br><span class="line"><span class="title function_">foo</span>(&#123;<span class="attr">prop</span>: <span class="number">1</span>&#125;);<span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="comment">// Can also use with the advanced example</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span> (<span class="params">&#123;</span></span><br><span class="line"><span class="params">  prop: x,</span></span><br><span class="line"><span class="params">  prop2: &#123;</span></span><br><span class="line"><span class="params">    prop2: &#123;</span></span><br><span class="line"><span class="params">      nested: b</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">  &#125;</span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, ...b);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">foo</span>(&#123; <span class="attr">prop</span>: <span class="string">&quot;Hello&quot;</span>, <span class="attr">prop2</span>: &#123; <span class="attr">prop2</span>: &#123; <span class="attr">nested</span>: [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]&#125;&#125;&#125;); <span class="comment">// =&gt; Hello a b c</span></span><br><span class="line"><span class="comment">// In combination with other ES2015 features.</span></span><br><span class="line"><span class="comment">// Computed property names</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;fieldName&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> computedObject = &#123; [name]: name &#125;; <span class="comment">// (where object is &#123; &#x27;fieldName&#x27;: &#x27;fieldName&#x27; &#125;)</span></span><br><span class="line"><span class="keyword">const</span> &#123; [name]: nameValue &#125; = computedObject;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nameValue) <span class="comment">// =&gt; fieldName</span></span><br><span class="line"><span class="comment">// Rest and defaults</span></span><br><span class="line"><span class="keyword">var</span> ajax = <span class="keyword">function</span> (<span class="params">&#123; url = <span class="string">&quot;localhost&quot;</span>, port: p = <span class="number">80</span>&#125;, ...data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Url:&quot;</span>, url, <span class="string">&quot;Port:&quot;</span>, p, <span class="string">&quot;Rest:&quot;</span>, data);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">ajax</span>(&#123; <span class="attr">url</span>: <span class="string">&quot;someHost&quot;</span> &#125;, <span class="string">&quot;additional&quot;</span>, <span class="string">&quot;data&quot;</span>, <span class="string">&quot;hello&quot;</span>);<span class="comment">// =&gt; Url: someHost Port: 80 Rest: [ &#x27;additional&#x27;, &#x27;data&#x27;, &#x27;hello&#x27; ]</span></span><br><span class="line"><span class="title function_">ajax</span>(&#123; &#125;, <span class="string">&quot;additional&quot;</span>, <span class="string">&quot;data&quot;</span>, <span class="string">&quot;hello&quot;</span>);<span class="comment">// =&gt; Url: localhost Port: 80 Rest: [ &#x27;additional&#x27;, &#x27;data&#x27;, &#x27;hello&#x27; ]</span></span><br><span class="line"><span class="comment">// Ooops: Doesn&#x27;t work (in traceur)</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">ajax</span> = (<span class="params">&#123; url = <span class="string">&quot;localhost&quot;</span>, port: p = <span class="number">80</span>&#125;, ...data</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Url:&quot;</span>, url, <span class="string">&quot;Port:&quot;</span>, p, <span class="string">&quot;Rest:&quot;</span>, data);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">ajax</span>(&#123; &#125;, <span class="string">&quot;additional&quot;</span>, <span class="string">&quot;data&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">// probably due to traceur compiler</span></span><br><span class="line"><span class="title class_">But</span> <span class="variable language_">this</span> <span class="attr">does</span>:</span><br><span class="line"><span class="keyword">var</span> <span class="title function_">ajax</span> = (<span class="params">&#123; url: url = <span class="string">&quot;localhost&quot;</span>, port: p = <span class="number">80</span>&#125;, ...data</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Url:&quot;</span>, url, <span class="string">&quot;Port:&quot;</span>, p, <span class="string">&quot;Rest:&quot;</span>, data);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">ajax</span>(&#123; &#125;, <span class="string">&quot;additional&quot;</span>, <span class="string">&quot;data&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">// Like _.pluck</span></span><br><span class="line"><span class="keyword">var</span> users = [</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">&quot;Name1&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">&quot;Name2&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">&quot;Name2&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">&quot;Name3&quot;</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> names = users.<span class="title function_">map</span>( <span class="function">(<span class="params">&#123; user &#125;</span>) =&gt;</span> user );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(names);<span class="comment">// =&gt; [ &#x27;Name1&#x27;, &#x27;Name2&#x27;, &#x27;Name2&#x27;, &#x27;Name3&#x27; ]</span></span><br><span class="line"><span class="comment">// Advanced usage with Array Comprehension and default values</span></span><br><span class="line"><span class="keyword">var</span> users = [</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">&quot;Name1&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">&quot;Name2&quot;</span>, <span class="attr">age</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">&quot;Name2&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">user</span>: <span class="string">&quot;Name3&quot;</span>, <span class="attr">age</span>: <span class="number">4</span> &#125;</span><br><span class="line">];</span><br><span class="line">[<span class="keyword">for</span> (&#123; user, age = <span class="string">&quot;DEFAULT AGE&quot;</span> &#125; <span class="keyword">of</span> users) <span class="variable language_">console</span>.<span class="title function_">log</span>(user, age)];</span><br><span class="line"><span class="comment">// =&gt; Name1 DEFAULT AGE</span></span><br><span class="line"><span class="comment">// =&gt; Name2 2</span></span><br><span class="line"><span class="comment">// =&gt; Name2 DEFAULT AGE</span></span><br><span class="line"><span class="comment">// =&gt; Name3 4</span></span><br></pre></td></tr></table></figure>

<h3 id="数组与迭代器"><a href="#数组与迭代器" class="headerlink" title="数组与迭代器"></a>数组与迭代器</h3><p>以上是数组解构赋值的一个简单示例，其语法的一般形式为：</p>
<pre><code>[ variable1, variable2, ..., variableN ] = array;
</code></pre>
<p>事实上，用变量来描述并不恰当，因为你可以对任意深度的嵌套数组进行解构：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);<span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar);<span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz);<span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>此外，你可以在对应位留空来跳过被解构数组中的某些元素：</p>
<pre><code>var [,,third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];
console.log(third);  // &quot;baz&quot;
</code></pre>
<p>而且你还可以通过“不定参数”模式捕获数组中的所有尾随元素：</p>
<pre><code>var [head, ...tail] = [1, 2, 3, 4];
console.log(tail);// [2, 3, 4]
</code></pre>
<p>当访问空数组或越界访问数组时，对其解构与对其索引的行为一致，最终得到的结果都是：undefined。</p>
<pre><code>console.log([][0]); // undefined
var [missing] = [];
console.log(missing); // undefined
</code></pre>
<p>请注意，数组解构赋值的模式同样适用于任意迭代器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">fibs</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> [first, second, third, fourth, fifth, sixth] = <span class="title function_">fibs</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sixth); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>通过解构对象，你可以把它的每个属性与不同的变量绑定，首先指定被绑定的属性，然后紧跟一个要解构的变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> robotA = &#123; <span class="attr">name</span>: <span class="string">&quot;Bender&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> robotB = &#123; <span class="attr">name</span>: <span class="string">&quot;Flexo&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">name</span>: nameA &#125; = robotA;</span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">name</span>: nameB &#125; = robotB;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nameA);<span class="comment">// &quot;Bender&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nameB);<span class="comment">// &quot;Flexo&quot;</span></span><br></pre></td></tr></table></figure>

<p>当属性名与变量名一致时，可以通过一种实用的句法简写：</p>
<pre><code>var &#123; foo, bar &#125; = &#123; foo: &quot;lorem&quot;, bar: &quot;ipsum&quot; &#125;;
console.log(foo);    // &quot;lorem&quot;
console.log(bar);    // &quot;ipsum&quot;
</code></pre>
<p>与数组解构一样，你可以随意嵌套并进一步组合对象解构：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> complicatedObj = &#123;</span><br><span class="line">  <span class="attr">arrayProp</span>: [</span><br><span class="line">    <span class="string">&quot;Zapp&quot;</span>,</span><br><span class="line">    &#123; <span class="attr">second</span>: <span class="string">&quot;Brannigan&quot;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">arrayProp</span>: [first, &#123; second &#125;] &#125; = complicatedObj;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(first);<span class="comment">// &quot;Zapp&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(second);<span class="comment">// &quot;Brannigan&quot;</span></span><br></pre></td></tr></table></figure>

<p>当你解构一个未定义的属性时，得到的值为undefined：</p>
<pre><code>var &#123; missing &#125; = &#123;&#125;;
console.log(missing);    // undefined
</code></pre>
<p>请注意，当你解构对象并赋值给变量时，如果你已经声明或不打算声明这些变量（亦即赋值语句前没有let、const或var关键字），你应该注意这样一个潜在的语法错误：</p>
<pre><code>&#123; blowUp &#125; = &#123; blowUp: 10 &#125;;    // Syntax error 语法错误
</code></pre>
<p>为什么会出错？这是因为JavaScript语法通知解析引擎将任何以{开始的语句解析为一个块语句（例如，{console}是一个合法块语句）。解决方案是将整个表达式用一对小括号包裹：</p>
<pre><code>(&#123; safe &#125; = &#123;&#125;);    // No errors 没有语法错误
</code></pre>
<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>当你要解构的属性未定义时你可以提供一个默认值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [missing = <span class="literal">true</span>] = [];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(missing);<span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">message</span>: msg = <span class="string">&quot;Something went wrong&quot;</span> &#125; = &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(msg);<span class="comment">// &quot;Something went wrong&quot;</span></span><br><span class="line"><span class="keyword">var</span> &#123; x = <span class="number">3</span> &#125; = &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);<span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>由于解构中允许对对象进行解构，并且还支持默认值，那么完全可以将解构应用在函数参数以及参数的默认值中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">removeBreakpoint</span>(<span class="params">&#123; url, line, column &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们构造一个提供配置的对象，并且需要这个对象的属性携带默认值时，解构特性就派上用场了。举个例子，jQuery的ajax函数使用一个配置对象作为它的第二参数，我们可以这样重写函数定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">jQuery.<span class="property">ajax</span> = <span class="keyword">function</span> (<span class="params">url, &#123;</span></span><br><span class="line"><span class="params">  <span class="keyword">async</span> = <span class="literal">true</span>,</span></span><br><span class="line"><span class="params">  beforeSend = noop,</span></span><br><span class="line"><span class="params">  cache = <span class="literal">true</span>,</span></span><br><span class="line"><span class="params">  complete = noop,</span></span><br><span class="line"><span class="params">  crossDomain = <span class="literal">false</span>,</span></span><br><span class="line"><span class="params">  <span class="variable language_">global</span> = <span class="literal">true</span>,</span></span><br><span class="line"><span class="params">  // ... 更多配置</span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同样，解构也可以应用在函数的多重返回值中，可以类似于其他语言中的元组的特性：</p>
<pre><code>function returnMultipleValues() &#123;
  return [1, 2];
&#125;
var [foo, bar] = returnMultipleValues();
</code></pre>
<h3 id="Three-Dots-…"><a href="#Three-Dots-…" class="headerlink" title="Three Dots …"></a>Three Dots …</h3><p>es6新增的特性</p>
<h3 id="Rest-Operator"><a href="#Rest-Operator" class="headerlink" title="Rest Operator"></a>Rest Operator</h3><p>在 JavaScript 函数调用时我们往往会使用内置的 arguments 对象来获取函数的调用参数，不过这种方式却存在着很多的不方便性。譬如 arguments 对象是 Array-Like 对象，无法直接运用数组的 .map() 或者 .forEach() 函数；并且因为 arguments 是绑定于当前函数作用域，如果我们希望在嵌套函数里使用外层函数的 arguments 对象，我们还需要创建中间变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// store arguments into a separated variable</span></span><br><span class="line">  <span class="keyword">var</span> argsOuter = <span class="variable language_">arguments</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">innerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// args is an array-like object</span></span><br><span class="line">    <span class="keyword">var</span> even = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span>.<span class="title function_">call</span>(argsOuter, <span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">      <span class="comment">// do something with argsOuter</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ES6 中为我们提供了 Rest Operator 来以数组形式获取函数的调用参数，Rest Operator 也可以用于在解构赋值中以数组方式获取剩余的变量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countArguments</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> args.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// get the number of arguments</span></span><br><span class="line"><span class="title function_">countArguments</span>(<span class="string">&#x27;welcome&#x27;</span>, <span class="string">&#x27;to&#x27;</span>, <span class="string">&#x27;Earth&#x27;</span>); <span class="comment">// =&gt; 3</span></span><br><span class="line"><span class="comment">// destructure an array</span></span><br><span class="line"><span class="keyword">let</span> otherSeasons, autumn;</span><br><span class="line">[autumn, ...otherSeasons] = cold;</span><br><span class="line">otherSeasons  <span class="comment">// =&gt; [&#x27;winter&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>典型的 Rest Operator 的应用场景譬如进行不定数组的指定类型过滤：</p>
<pre><code>function filter(type, ...items) &#123;
  return items.filter(item =&gt; typeof item === type);
&#125;
filter(&#39;boolean&#39;, true, 0, false);        // =&gt; [true, false]
filter(&#39;number&#39;, false, 4, &#39;Welcome&#39;, 7); // =&gt; [4, 7]
</code></pre>
<p>尽管 Arrow Function 中并没有定义 arguments 对象，但是我们仍然可以使用 Rest Operator 来获取 Arrow Function 的调用参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> outerArguments = <span class="variable language_">arguments</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">concat</span> = (<span class="params">...items</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span> === outerArguments); <span class="comment">// =&gt; true</span></span><br><span class="line">    <span class="keyword">return</span> items.<span class="title function_">reduce</span>(<span class="function">(<span class="params">result, item</span>) =&gt;</span> result + item, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">concat</span>(<span class="number">1</span>, <span class="number">5</span>, <span class="string">&#x27;nine&#x27;</span>); <span class="comment">// =&gt; &#x27;15nine&#x27;</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h3 id="Spread-Operator"><a href="#Spread-Operator" class="headerlink" title="Spread Operator"></a>Spread Operator</h3><p>Spread Operator 则与 Rest Opeator 的功能正好相反，其常用于进行数组构建与解构赋值，也可以用于将某个数组转化为函数的参数列表，其基本使用方式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cold = [<span class="string">&#x27;autumn&#x27;</span>, <span class="string">&#x27;winter&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> warm = [<span class="string">&#x27;spring&#x27;</span>, <span class="string">&#x27;summer&#x27;</span>];</span><br><span class="line"><span class="comment">// construct an array</span></span><br><span class="line">[...cold, ...warm] <span class="comment">// =&gt; [&#x27;autumn&#x27;, &#x27;winter&#x27;, &#x27;spring&#x27;, &#x27;summer&#x27;]</span></span><br><span class="line"><span class="comment">// function arguments from an array</span></span><br><span class="line">cold.<span class="title function_">push</span>(...warm);</span><br><span class="line">cold <span class="comment">// =&gt; [&#x27;autumn&#x27;, &#x27;winter&#x27;, &#x27;spring&#x27;, &#x27;summer&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>我们也可以使用 Spread Operator 来简化函数调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">King</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, country</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">country</span> = country;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getDescription</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> leads <span class="subst">$&#123;<span class="variable language_">this</span>.country&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> details = [<span class="string">&#x27;Alexander the Great&#x27;</span>, <span class="string">&#x27;Greece&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Alexander</span> = <span class="keyword">new</span> <span class="title class_">King</span>(...details);</span><br><span class="line"><span class="title class_">Alexander</span>.<span class="title function_">getDescription</span>(); <span class="comment">// =&gt; &#x27;Alexander the Great leads Greece&#x27;</span></span><br></pre></td></tr></table></figure>

<p>还有另外一个好处就是可以用来替换 Object.assign 来方便地从旧有的对象中创建新的对象，并且能够修改部分值；譬如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj_new_1 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;,obj,&#123;<span class="attr">a</span>:<span class="number">3</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> obj_new_2 = &#123;</span><br><span class="line">  ...obj,</span><br><span class="line">  <span class="attr">a</span>:<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们还需要讨论下 Spread Operator 与 Iteration Protocols，实际上 Spread Operator 也是使用的 Iteration Protocols 来进行元素遍历与结果搜集；因此我们也可以通过自定义 Iterator 的方式来控制 Spread Operator 的表现。Iterable 协议规定了对象必须包含 Symbol.iterator 方法，该方法返回某个 Iterator 对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">Iterable</span> &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Iterator</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该 Iterator 对象从属于 Iterator Protocol，其需要提供 next 成员方法，该方法会返回某个包含 done 与 value 属性的对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">Iterator</span> &#123;</span><br><span class="line">  <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">value</span>: &lt;value&gt;,</span><br><span class="line">        <span class="attr">done</span>: &lt;boolean&gt;</span><br><span class="line">     &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>典型的 Iterable 对象就是字符串：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;hi&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> iterator = str[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line">iterator.<span class="title function_">toString</span>(); <span class="comment">// =&gt; &#x27;[object String Iterator]&#x27;</span></span><br><span class="line">iterator.<span class="title function_">next</span>();     <span class="comment">// =&gt; &#123; value: &#x27;h&#x27;, done: false &#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>();     <span class="comment">// =&gt; &#123; value: &#x27;i&#x27;, done: false &#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>();     <span class="comment">// =&gt; &#123; value: undefined, done: true &#125;</span></span><br><span class="line">[...str];            <span class="comment">// =&gt; [&#x27;h&#x27;, &#x27;i&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>我们可以通过自定义 array-like 对象的 Symbol.iterator 属性来控制其在迭代器上的效果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">iterator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function">() =&gt;</span> (&#123; <span class="comment">// Conform to Iterator protocol</span></span><br><span class="line">      done : index &gt;= <span class="variable language_">this</span>.<span class="property">length</span>,</span><br><span class="line">      <span class="attr">value</span>: <span class="variable language_">this</span>[index++]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;Cat&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;Bird&#x27;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Conform to Iterable Protocol</span></span><br><span class="line">arrayLike[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = iterator;</span><br><span class="line"><span class="keyword">var</span> array = [...arrayLike];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array); <span class="comment">// =&gt; [&#x27;Cat&#x27;, &#x27;Bird&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>arrayLike[Symbol.iterator] 为该对象创建了值为某个迭代器的属性，从而使该对象符合了 Iterable 协议；而 iterator() 又返回了包含 next 成员方法的对象，使得该对象最终具有和数组相似的行为表现。</p>
<h2 id="Copy-Composite-Data-Types-复合类型的拷贝"><a href="#Copy-Composite-Data-Types-复合类型的拷贝" class="headerlink" title="Copy Composite Data Types: 复合类型的拷贝"></a>Copy Composite Data Types: 复合类型的拷贝</h2><h3 id="Shallow-Copy-浅拷贝"><a href="#Shallow-Copy-浅拷贝" class="headerlink" title="Shallow Copy 浅拷贝"></a>Shallow Copy 浅拷贝</h3><p>浅拷贝是指复制时，指对第一层键值对进行独立的赋值，一个简单的实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shallowCopy</span>(<span class="params">target, source</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!source || <span class="keyword">typeof</span> source !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 这个方法有点问题，target一定要事先定好，不然就不能改变实参了</span></span><br><span class="line">  <span class="comment">// 具体原因解释可看参考资料中 JS是值传递还是引用传递</span></span><br><span class="line">  <span class="keyword">if</span> (!target || <span class="keyword">typeof</span> target !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这边最好区别一下对象和数组的复制</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">    <span class="keyword">if</span> (source.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      target[key] = source[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><p>Object.assign() 方法可以把任意多个源对象所拥有的自身可枚举属性拷贝给目标对象，然后返回目标对象。<br>Object.assign 方法只会拷贝 源对象自身的并且可枚举的属性 到目标对象身上。注意，对于访问器属性，该方法会执行那个访问器属性的 getter 函数，然后把得到的值拷贝给目标对象如果你想拷贝访问器属性本身，请使用 <code>Object.getOwnPropertyDescriptor</code> 和 <code>Object.difineProperties()</code>方法</p>
<p>注意，字符串类型和 symbol 类型的属性都会被拷贝。</p>
<p>注意，在属性拷贝过程中可能会产生异常，比如目标对象的某个只读属性和源对象的某个属性同名，这时该方法会抛出一个 TypeError 异常，拷贝过程中断，已经拷贝成功的属性不会受到影响，还未拷贝的属性将不会再被拷贝。</p>
<p>注意， Object.assign 会跳过那些值为 null 或 undefined 的源对象。</p>
<pre><code>Object.assign(target, ...sources)
</code></pre>
<p>浅拷贝一个对象</p>
<pre><code>var obj = &#123;a: 1&#125;
var copy = Object.assign(&#123;&#125;, obj)
console.log(copy) // &#123;a:1&#125;
</code></pre>
<p>合并若干个对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">var</span> o3 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(o1, o2, o3)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj) <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o1) <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;, 注意目标对象自身也会改变。</span></span><br></pre></td></tr></table></figure>

<p>拷贝 symbol 类型的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; [<span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)]: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, o1, o2)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj) <span class="comment">// &#123; a: 1, [Symbol(&quot;foo&quot;)]: 2 &#125;</span></span><br></pre></td></tr></table></figure>

<p>继承属性和不可枚举属性是不能拷贝的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(</span><br><span class="line">  &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// foo是个继承属性</span></span><br><span class="line">    <span class="attr">bar</span>: &#123; <span class="attr">value</span>: <span class="number">2</span> &#125;, <span class="comment">// bar是个不可枚举属性</span></span><br><span class="line">    <span class="attr">baz</span>: &#123;</span><br><span class="line">      <span class="attr">value</span>: <span class="number">3</span>,</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">true</span> <span class="comment">// baz是个自身可枚举属性</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> copy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy) <span class="comment">// &#123;baz: 3&#125;</span></span><br></pre></td></tr></table></figure>

<p>原始值会被隐式转换成其包装对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="keyword">var</span> v2 = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> v3 = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> v4 = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, v1, <span class="literal">null</span>, v2, <span class="literal">undefined</span>, v3, v4)</span><br><span class="line"><span class="comment">// 源对象如果是原始值，会被自动转换成它们的包装对象，</span></span><br><span class="line"><span class="comment">// 而 null 和 undefined 这两种原始值会被完全忽略。</span></span><br><span class="line"><span class="comment">// 注意，只有字符串的包装对象才有可能有自身可枚举属性。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj) <span class="comment">// &#123; &quot;0&quot;: &quot;1&quot;, &quot;1&quot;: &quot;2&quot;, &quot;2&quot;: &quot;3&quot; &#125;</span></span><br></pre></td></tr></table></figure>

<p>例子：拷贝属性过程中发生异常</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(&#123;&#125;, <span class="string">&#x27;foo&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">writeable</span>: <span class="literal">false</span></span><br><span class="line">&#125;) <span class="comment">// target 的 foo 属性是个只读属性。</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, &#123; <span class="attr">bar</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">foo2</span>: <span class="number">3</span>, <span class="attr">foo</span>: <span class="number">3</span>, <span class="attr">foo3</span>: <span class="number">3</span> &#125;, &#123; <span class="attr">baz</span>: <span class="number">4</span> &#125;)</span><br><span class="line"><span class="comment">// TypeError: &quot;foo&quot; is read-only</span></span><br><span class="line"><span class="comment">// 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">bar</span>) <span class="comment">// 2，说明第一个源对象拷贝成功了。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo2</span>) <span class="comment">// 3，说明第二个源对象的第一个属性也拷贝成功了。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo</span>) <span class="comment">// 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">foo3</span>) <span class="comment">// undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">baz</span>) <span class="comment">// undefined，第三个源对象更是不会被拷贝到的。</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-concat-来复制数组"><a href="#使用-concat-来复制数组" class="headerlink" title="使用 [].concat 来复制数组"></a>使用 [].concat 来复制数组</h3><p>同样类似于对于对象的复制，我们建议使用[].concat 来进行数组的深复制:</p>
<pre><code>ar list = [1, 2, 3];
var changedList = [].concat(list);
changedList[1] = 2;
list === changedList; // false
</code></pre>
<p>同样的，concat 方法也只能保证一层深复制:</p>
<pre><code>&gt; list = [[1,2,3]]
[ [ 1, 2, 3 ] ]
&gt; new_list = [].concat(list)
[ [ 1, 2, 3 ] ]
&gt; new_list[0][0] = 4
4
&gt; list
[ [ 4, 2, 3 ] ]
</code></pre>
<h3 id="浅拷贝的缺陷"><a href="#浅拷贝的缺陷" class="headerlink" title="浅拷贝的缺陷"></a>浅拷贝的缺陷</h3><p>不过需要注意的是，assign 是浅拷贝，或者说，它是一级深拷贝，举两个例子说明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultOpt = &#123;</span><br><span class="line">  <span class="attr">title</span>: &#123;</span><br><span class="line">    <span class="attr">text</span>: <span class="string">&#x27;hello world&#x27;</span>,</span><br><span class="line">    <span class="attr">subtext</span>: <span class="string">&quot;It&#x27;s my world&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> opt = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, defaultOpt, &#123;</span><br><span class="line">  <span class="attr">title</span>: &#123;</span><br><span class="line">    <span class="attr">subtext</span>: <span class="string">&#x27;Yes, your world&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(opt) <span class="comment">// &#123; title: &#123; subtext: &#x27;Yes, your world.&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面这个例子中，对于对象的一级子元素而言，只会替换引用，而不会动态的添加内容。那么，其实 assign 并没有解决对象的引用混乱问题，参考下下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultOpt = &#123;</span><br><span class="line">  <span class="attr">title</span>: &#123;</span><br><span class="line">    <span class="attr">text</span>: <span class="string">&#x27;hello world&#x27;</span>,</span><br><span class="line">    <span class="attr">subtext</span>: <span class="string">&quot;It&#x27;s my world.&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> opt1 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, defaultOpt);</span><br><span class="line"><span class="keyword">const</span> opt2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, defaultOpt);</span><br><span class="line">opt2.<span class="property">title</span>.<span class="property">subtext</span> = <span class="string">&#x27;Yes, your world.&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(opt1); <span class="comment">// &#123; title: &#123; text: &#x27;hello world&#x27;, subtext: &#x27;Yes, your world.&#x27; &#125; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(opt2); <span class="comment">// &#123; title: &#123; text: &#x27;hello world&#x27;, subtext: &#x27;Yes, your world.&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="DeepCopy-深拷贝"><a href="#DeepCopy-深拷贝" class="headerlink" title="DeepCopy: 深拷贝"></a>DeepCopy: 深拷贝</h3><p><strong>递归属性遍历</strong></p>
<p>一般来说，在JavaScript中考虑复合类型的深层复制的时候，往往就是指对于Date、Object与Array这三个复合类型的处理。我们能想到的最常用的方法就是先创建一个空的新对象，然后递归遍历旧对象，直到发现基础类型的子节点才赋予到新对象对应的位置。不过这种方法会存在一个问题，就是JavaScript中存在着神奇的原型机制，并且这个原型会在遍历的时候出现，然后原型不应该被赋予给新对象。那么在遍历的过程中，我们应该考虑使用hasOenProperty方法来过滤掉那些继承自原型链上的属性:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> copy</span><br><span class="line">  <span class="comment">// 处理基本类型 null undefined</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">null</span> === obj || <span class="string">&#x27;object&#x27;</span> !== <span class="keyword">typeof</span> obj) <span class="keyword">return</span> obj</span><br><span class="line">  <span class="comment">// 若为 Date 对象时</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">    copy = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">    copy.<span class="title function_">setTime</span>(obj.<span class="title function_">getTime</span>())</span><br><span class="line">    <span class="keyword">return</span> copy</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理数组</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Array</span>) &#123;</span><br><span class="line">    copy = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = obj.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">      copy[i] = <span class="title function_">clone</span>(obj[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理对象</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Object</span>) &#123;</span><br><span class="line">    copy = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(attr)) &#123;</span><br><span class="line">        copy[attr] = <span class="title function_">clone</span>(obj[arr])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Unable to copy obj! Its type isn\&#x27;t supported!&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This would be cloneable:</span></span><br><span class="line"><span class="keyword">var</span> tree = &#123;</span><br><span class="line">    <span class="string">&quot;left&quot;</span>  : &#123; <span class="string">&quot;left&quot;</span> : <span class="literal">null</span>, <span class="string">&quot;right&quot;</span> : <span class="literal">null</span>, <span class="string">&quot;data&quot;</span> : <span class="number">3</span> &#125;,</span><br><span class="line">    <span class="string">&quot;right&quot;</span> : <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&quot;data&quot;</span>  : <span class="number">8</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// This would kind-of work, but you would get 2 copies of the</span></span><br><span class="line"><span class="comment">// inner node instead of 2 references to the same copy</span></span><br><span class="line"><span class="keyword">var</span> directedAcylicGraph = &#123;</span><br><span class="line">    <span class="string">&quot;left&quot;</span>  : &#123; <span class="string">&quot;left&quot;</span> : <span class="literal">null</span>, <span class="string">&quot;right&quot;</span> : <span class="literal">null</span>, <span class="string">&quot;data&quot;</span> : <span class="number">3</span> &#125;,</span><br><span class="line">    <span class="string">&quot;data&quot;</span>  : <span class="number">8</span></span><br><span class="line">&#125;;</span><br><span class="line">directedAcyclicGraph[<span class="string">&quot;right&quot;</span>] = directedAcyclicGraph[<span class="string">&quot;left&quot;</span>];</span><br><span class="line"><span class="comment">// Cloning this would cause a stack overflow due to infinite recursion:</span></span><br><span class="line"><span class="keyword">var</span> cylicGraph = &#123;</span><br><span class="line">    <span class="string">&quot;left&quot;</span>  : &#123; <span class="string">&quot;left&quot;</span> : <span class="literal">null</span>, <span class="string">&quot;right&quot;</span> : <span class="literal">null</span>, <span class="string">&quot;data&quot;</span> : <span class="number">3</span> &#125;,</span><br><span class="line">    <span class="string">&quot;data&quot;</span>  : <span class="number">8</span></span><br><span class="line">&#125;;</span><br><span class="line">cylicGraph[<span class="string">&quot;right&quot;</span>] = cylicGraph;</span><br></pre></td></tr></table></figure>

<h3 id="利用JSON深拷贝"><a href="#利用JSON深拷贝" class="headerlink" title="利用JSON深拷贝"></a>利用JSON深拷贝</h3><pre><code>JSON.parse(JSON.stringify(obj))
</code></pre>
<p>对于一般的需求是可以满足的，但是它有缺点，下例中，可以看到JSON赋值会忽略掉值为undefined以及函数表达式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">sum</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2) <span class="comment">// Object &#123;a: 1, b: 2&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zhuanlan.zhihu.com/p/28313321">基于 JSX 的动态数据绑定</a><br><a href="https://zhuanlan.zhihu.com/p/27844393">ECMAScript 2017（ES8）特性概述</a><br><a href="https://zhuanlan.zhihu.com/p/27410280">WebAssembly 初体验：从零开始重构计算模块</a></p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>浅拷贝</tag>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hexo】2024新博客启动~记录搭建的过程</title>
    <url>/2024/01/01/026e8eb0-af92-11ee-a381-25748bdd419b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h1><p>用的是Hexo，按着官方文档来就好了，最好的例子就是文档啦。当然写博客的话，是为了记录一些需要留意的地方</p>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul>
<li>Nodejs: 12.16.0</li>
<li>npm: 6.13.4</li>
<li>hexo: 6.3.0</li>
<li>hexo-cli: 4.3.1  直接hexo init 即可</li>
<li>hexo-theme-butterfly: 4.12.0</li>
</ul>
<p>一定要看是否安装完对应依赖，大部分看似复杂的问题基本都是不经意的小地方造成。说多了都是泪</p>
<span id="more"></span>

<h2 id="关于路径问题"><a href="#关于路径问题" class="headerlink" title="关于路径问题"></a>关于路径问题</h2><p>_config.yml 中 需注意下面几项，根据需要改成自己用的路径即可，便于归类可用中文路径（传服务器可能遇到转义的坑注意下就好）</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>踩坑1 最好不要改动tags、categories、archives 这三项的路径配置。某些插件直接写死的 &#x3D; &#x3D; 虽然也可进入到项目中把配置 改成 hexo.config.archive_dir 拿到修改后的值 （两个字，麻烦）</p>
</blockquote>
<h3 id="图片放本地-随文章路径"><a href="#图片放本地-随文章路径" class="headerlink" title="图片放本地 随文章路径"></a>图片放本地 随文章路径</h3><p>当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们</p>
<blockquote>
<p>之前的想法很美好，CDN加速整个七牛云啥的，折腾了半天 &#x3D; &#x3D; 没充钱，现啥都没保留。暂时先算了，还是本地，服务器，和项目里各备份一份来得实在，github pages确实会慢不少，后续迁移到ECS里应该会快不少</p>
</blockquote>
<p>这样写即可，<code>![头像](avatar.jpg)</code></p>
<p>_config.yml 里设置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h1 id="使用到的插件"><a href="#使用到的插件" class="headerlink" title="使用到的插件"></a>使用到的插件</h1><h2 id="aplayer-播放器"><a href="#aplayer-播放器" class="headerlink" title="aplayer 播放器"></a>aplayer 播放器</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># _config.yml中配置</span></span><br><span class="line"><span class="attr">aplayer:</span></span><br><span class="line">  <span class="attr">meting:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># _config.butterfly.yml</span></span><br><span class="line"><span class="comment"># Inject the css and script (aplayer/meting)</span></span><br><span class="line"><span class="attr">aplayer:</span> </span><br><span class="line">  <span class="attr">meting:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">asset_inject:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">aplayerInject:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="comment"># 添加底部音乐</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;div</span> <span class="string">class=&quot;aplayer</span> <span class="literal">no</span><span class="string">-destroy&quot;</span> <span class="string">data-id=&quot;9115784260&quot;</span> <span class="string">data-server=&quot;netease&quot;</span> <span class="string">data-type=&quot;playlist&quot;</span> <span class="string">data-fixed=&quot;true&quot;</span> <span class="string">data-listfolded=&quot;true&quot;</span> <span class="string">data-autoplay=&quot;true&quot;&gt;</span> <span class="string">&lt;/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>具体api看文档就成，倒是inject那里可以自行根据需要修改样式，如布局，背景色等</p>
<h2 id="分类目录-hexo-magnet"><a href="#分类目录-hexo-magnet" class="headerlink" title="分类目录 hexo-magnet"></a>分类目录 hexo-magnet</h2><p>可能是版本原因，疑似会和douban 和 bangumis 冲突 ~ 暂时忍痛放弃</p>
<h2 id="hexo-tag-bangumi"><a href="#hexo-tag-bangumi" class="headerlink" title="hexo-tag-bangumi"></a>hexo-tag-bangumi</h2><p>追番页，改自 hexo-douban，目前服务器还没审核通过，暂不想搭后端（还是因为麻烦） &#x3D; &#x3D; </p>
<a class="tag-Link" target="_blank" href="https://github.com/netbeifeng/hexo-tag-bangumi">
    <div class="tag-link-tips">引用站外地址，点击打开新页面标签</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style="background-image: url(https://api.iowen.cn/favicon/github.com/netbeifeng/hexo-tag-bangumi.png);"></div>
        <div class="tag-link-right">
            <div class="tag-link-title">hexo-tag-bangumi</div>
            <div class="tag-link-sitename">netbeifeng</div>
        </div>
        <i class="fa-solid fa-angle-right"></i>
    </div>
    </a>

<p>这个再结合自带的tab来用，展示已看，未看和正在看就行</p>
<h2 id="hexo-wordcount"><a href="#hexo-wordcount" class="headerlink" title="hexo-wordcount"></a>hexo-wordcount</h2><p>文章字数统计 和 阅读时长，感觉不错，就加进来了</p>
<h2 id="hexo-tag-steamgame"><a href="#hexo-tag-steamgame" class="headerlink" title="hexo-tag-steamgame"></a>hexo-tag-steamgame</h2><p>在Hexo博客中嵌入steam游戏</p>
<a class="tag-Link" target="_blank" href=" https://github.com/HCLonely/hexo-tag-steamgame/blob/master/README_CN.md">
    <div class="tag-link-tips">引用站外地址，点击打开新页面标签</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style="background-image: url(https://api.iowen.cn/favicon/ https://github.com/HCLonely/hexo-tag-steamgame/blob/master/README_CN.md.png);"></div>
        <div class="tag-link-right">
            <div class="tag-link-title">hexo-tag-steamgame</div>
            <div class="tag-link-sitename"> HConely</div>
        </div>
        <i class="fa-solid fa-angle-right"></i>
    </div>
    </a>

<h2 id="hexo-douban"><a href="#hexo-douban" class="headerlink" title="hexo-douban"></a>hexo-douban</h2><a class="tag-Link" target="_blank" href=" https://github.com/mythsman/hexo-douban">
    <div class="tag-link-tips">引用站外地址，点击打开新页面标签</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style="background-image: url(https://api.iowen.cn/favicon/ https://github.com/mythsman/hexo-douban.png);"></div>
        <div class="tag-link-right">
            <div class="tag-link-title">hexo-douban</div>
            <div class="tag-link-sitename"> mythsman</div>
        </div>
        <i class="fa-solid fa-angle-right"></i>
    </div>
    </a>

<p>跟着文档配置即可，需要注意的是，页面自动生成好了，若之前有新建 page 重名，如： <code>movies.md</code>、<code>books.md</code> 这类的记得删掉。</p>
<h2 id="hexo-uuid"><a href="#hexo-uuid" class="headerlink" title="hexo-uuid"></a>hexo-uuid</h2><a class="tag-Link" target="_blank" href=" https://github.com/chekun/hexo-uuid">
    <div class="tag-link-tips">引用站外地址，点击打开新页面标签</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style="background-image: url(https://api.iowen.cn/favicon/ https://github.com/chekun/hexo-uuid.png);"></div>
        <div class="tag-link-right">
            <div class="tag-link-title">hexo-uuid</div>
            <div class="tag-link-sitename"> chekun</div>
        </div>
        <i class="fa-solid fa-angle-right"></i>
    </div>
    </a>

<p>该插件用来解决上线后，网站不支持中文路径的问题（会乱码，linux下读取不到路径）</p>
<h1 id="其他魔改"><a href="#其他魔改" class="headerlink" title="其他魔改"></a>其他魔改</h1><h2 id="展示视频"><a href="#展示视频" class="headerlink" title="展示视频"></a>展示视频</h2><a class="tag-Link" target="_blank" href="https://blog.dorakika.cn/post/20220118/">
    <div class="tag-link-tips">引用站外地址，点击打开新页面标签</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style="background-image: url(https://api.iowen.cn/favicon/blog.dorakika.cn/post/20220118/.png);"></div>
        <div class="tag-link-right">
            <div class="tag-link-title">转自[Hexo博客 | 视频点播页面，如何在博客上优雅地展示B站等平台视频]</div>
            <div class="tag-link-sitename"> 作者：Justlovesmile</div>
        </div>
        <i class="fa-solid fa-angle-right"></i>
    </div>
    </a>


<blockquote>
<p>转载请注明来自 Justlovesmile’s BLOG！思路很好拷贝过来，学习下（怕哪天网站没了）</p>
</blockquote>
<ol>
<li>新建路径页面</li>
</ol>
<p>首先使用命令新建一个页面：<code>hexo new page video</code>，其内容如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">我的视频</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-07-17 20:54:09</span></span><br><span class="line"><span class="attr">comment:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">top_img:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">showToc:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">aside:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;video&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">&lt;script</span> <span class="string">src=&quot;https://unpkg.com/jquery@latest/dist/jquery.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">function</span> <span class="string">selectVideo(id)&#123;</span></span><br><span class="line">    <span class="string">var</span> <span class="string">src=$(&quot;#video-item-&quot;+id).attr(&quot;data-src&quot;);</span></span><br><span class="line">    <span class="string">$(&quot;#video-select&quot;).html(&quot;&lt;iframe</span> <span class="string">id=&#x27;video-iframe&#x27;</span> <span class="string">src=&#x27;&quot;+src+&quot;&#x27;</span> <span class="string">scrolling=&#x27;no&#x27;</span> <span class="string">border=&#x27;0&#x27;</span> <span class="string">frameborder=&#x27;no&#x27;</span> <span class="string">framespacing=&#x27;0&#x27;</span> <span class="string">allowfullscreen=&#x27;true&#x27;&gt;</span> <span class="string">&lt;/iframe&gt;&quot;);</span></span><br><span class="line">    <span class="string">var</span> <span class="string">iframe</span> <span class="string">=</span> <span class="string">document.getElementById(&quot;video-select&quot;)</span></span><br><span class="line">    <span class="string">if(iframe.attachEvent)&#123;</span></span><br><span class="line">      <span class="string">iframe.attachEvent(&quot;onreadystatechange&quot;,</span> <span class="string">function()</span> &#123;</span><br><span class="line">        <span class="string">if</span> <span class="string">(iframe.readyState</span> <span class="string">===</span> <span class="string">&quot;complete&quot;</span> <span class="string">||</span> <span class="string">iframe.readyState</span> <span class="string">==</span> <span class="string">&quot;loaded&quot;</span><span class="string">)</span> &#123;</span><br><span class="line">          <span class="string">iframe.detachEvent(&quot;onreadystatechange&quot;</span>, <span class="string">arguments.callee);</span></span><br><span class="line">        <span class="string">if</span> <span class="string">(document.getElementsByClassName(&#x27;video-mirror&#x27;).length&gt;0)</span> &#123;</span><br><span class="line">          <span class="string">console.log(&quot;1true&quot;)</span></span><br><span class="line">          <span class="string">$(&quot;.video-mirror&quot;).attr(&quot;style&quot;</span>,<span class="string">&quot;transform:scaleX(-1);&quot;</span><span class="string">)</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="string">);</span></span><br><span class="line">    <span class="string">&#125;else&#123;</span></span><br><span class="line">      <span class="string">iframe.addEventListener(&quot;load&quot;,</span> <span class="string">function()</span> &#123;</span><br><span class="line">        <span class="string">this.removeEventListener(&quot;load&quot;</span>, <span class="string">arguments.call</span>, <span class="literal">false</span><span class="string">);</span></span><br><span class="line">      <span class="string">if</span> <span class="string">(document.getElementsByClassName(&#x27;video-mirror&#x27;).length&gt;0)</span> &#123;</span><br><span class="line">        <span class="string">console.log(&quot;2true&quot;)</span></span><br><span class="line">        <span class="string">$(&quot;.video-mirror&quot;).attr(&quot;style&quot;</span>,<span class="string">&quot;transform:scaleX(-1);&quot;</span><span class="string">)</span></span><br><span class="line">      &#125;</span><br><span class="line">      &#125;<span class="string">,</span> <span class="literal">false</span><span class="string">);</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">$(document).ready(selectVideo(0));</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>新建主题页面</li>
</ol>
<p>在主题路径<code>themes\butterfly-dev\layout\includes\page</code>下新建<code>video.pug</code>，内容如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">//if</span> <span class="string">top_img</span> <span class="string">===</span> <span class="literal">false</span></span><br><span class="line"><span class="string">//</span>  <span class="string">h1.page-title=</span> <span class="string">page.title</span></span><br><span class="line"><span class="comment">#video-select.video-select</span></span><br><span class="line"><span class="string">hr</span></span><br><span class="line"><span class="string">h3=</span> <span class="string">视频列表</span></span><br><span class="line"><span class="string">.videos</span></span><br><span class="line">  <span class="string">if</span> <span class="string">site.data.video</span></span><br><span class="line">    <span class="string">each</span> <span class="string">i,index</span> <span class="string">in</span> <span class="string">site.data.video</span></span><br><span class="line">      <span class="string">div(class=&quot;myvideo&quot;</span> <span class="string">onclick=`javascipt:selectVideo(`+index+`)`)</span></span><br><span class="line">        <span class="string">div(id=`video-item-`+index</span> <span class="string">class=&quot;video-item&quot;</span> <span class="string">data-src=url_for(i.link))</span></span><br><span class="line">          <span class="string">a(href=&quot;#video-select&quot;)</span></span><br><span class="line">            <span class="string">img.video-item-cover(src=url_for(i.cover))</span></span><br><span class="line">        <span class="string">.video-desc</span></span><br><span class="line">          <span class="string">.video-title</span></span><br><span class="line">            <span class="string">a(href=&quot;#video-select&quot;)=</span> <span class="string">i.title</span></span><br><span class="line">          <span class="string">.video-info=</span> <span class="string">i.description</span></span><br><span class="line"></span><br><span class="line"><span class="string">style.</span></span><br><span class="line">  <span class="string">.videos&#123;</span></span><br><span class="line">    <span class="attr">display:</span> <span class="string">grid;</span></span><br><span class="line">    <span class="attr">grid-template-columns:</span> <span class="string">repeat(4,</span> <span class="string">1fr);</span></span><br><span class="line">    <span class="attr">grid-column-gap:</span> <span class="string">20px;</span></span><br><span class="line">    <span class="attr">grid-row-gap:</span> <span class="string">20px;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">@media</span> <span class="string">screen</span> <span class="string">and</span> <span class="string">(max-width:</span> <span class="string">1200px)&#123;</span></span><br><span class="line">    <span class="string">.videos&#123;</span></span><br><span class="line">      <span class="attr">display:</span> <span class="string">grid;</span></span><br><span class="line">      <span class="attr">grid-template-columns:</span> <span class="string">repeat(3,</span> <span class="string">1fr);</span></span><br><span class="line">      <span class="attr">grid-column-gap:</span> <span class="string">20px;</span></span><br><span class="line">      <span class="attr">grid-row-gap:</span> <span class="string">20px;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">@media</span> <span class="string">screen</span> <span class="string">and</span> <span class="string">(max-width:</span> <span class="string">900px)&#123;</span></span><br><span class="line">    <span class="string">.videos&#123;</span></span><br><span class="line">      <span class="attr">display:</span> <span class="string">grid;</span></span><br><span class="line">      <span class="attr">grid-template-columns:</span> <span class="string">repeat(2,</span> <span class="string">1fr);</span></span><br><span class="line">      <span class="attr">grid-column-gap:</span> <span class="string">20px;</span></span><br><span class="line">      <span class="attr">grid-row-gap:</span> <span class="string">20px;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">@media</span> <span class="string">screen</span> <span class="string">and</span> <span class="string">(max-width:</span> <span class="string">600px)&#123;</span></span><br><span class="line">    <span class="string">.videos&#123;</span></span><br><span class="line">      <span class="attr">display:</span> <span class="string">grid;</span></span><br><span class="line">      <span class="attr">grid-template-columns:</span> <span class="string">repeat(1,</span> <span class="string">1fr);</span></span><br><span class="line">      <span class="attr">grid-column-gap:</span> <span class="string">20px;</span></span><br><span class="line">      <span class="attr">grid-row-gap:</span> <span class="string">20px;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">.myvideo&#123;</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">relative;</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">100</span><span class="string">%;</span></span><br><span class="line">    <span class="attr">border:</span> <span class="string">1px</span> <span class="string">solid</span> <span class="string">var(--mj-card-border);</span></span><br><span class="line">    <span class="attr">border-radius:</span> <span class="string">12px;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">.video-item&#123;</span></span><br><span class="line">    <span class="attr">overflow:</span> <span class="string">hidden;</span></span><br><span class="line">    <span class="attr">height:</span> <span class="string">160px;</span></span><br><span class="line">    <span class="attr">border-top-left-radius:</span> <span class="string">12px;</span></span><br><span class="line">    <span class="attr">border-top-right-radius:</span> <span class="string">12px;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">.video-item</span> <span class="string">img</span> &#123;</span><br><span class="line">    <span class="attr">position:</span> <span class="string">relative;</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">100</span><span class="string">%;</span></span><br><span class="line">    <span class="attr">margin:</span> <span class="number">0</span> <span class="type">!important;</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">100</span><span class="string">%;</span></span><br><span class="line">    <span class="attr">transform:</span> <span class="string">scale(1.0);</span></span><br><span class="line">    <span class="attr">transition:</span> <span class="string">.3s;</span></span><br><span class="line">    <span class="attr">object-fit:</span> <span class="string">cover;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="string">.myvideo:hover</span> <span class="string">.video-item</span> <span class="string">img</span> &#123;</span><br><span class="line">    <span class="attr">transition:</span> <span class="string">.3s;</span></span><br><span class="line">    <span class="attr">transform:</span> <span class="string">scale(1.1);</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="string">.video-title&#123;</span></span><br><span class="line">    <span class="attr">padding:</span> <span class="string">5px</span> <span class="string">10px;</span></span><br><span class="line">    <span class="attr">font-size:</span> <span class="string">18px;</span></span><br><span class="line">    <span class="attr">font-weight:</span> <span class="string">bold;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">.video-info&#123;</span></span><br><span class="line">    <span class="attr">font-size:</span> <span class="string">14px;</span></span><br><span class="line">    <span class="attr">padding:</span> <span class="number">0</span> <span class="string">10px;</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">var(--mj-secondtext);</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">.video-select&#123;</span></span><br><span class="line">    <span class="string">position:relative;</span></span><br><span class="line">    <span class="string">width:100%;</span></span><br><span class="line">    <span class="string">height:0;</span></span><br><span class="line">    <span class="string">padding-bottom:75%;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">.video-select</span> <span class="string">iframe&#123;</span></span><br><span class="line">    <span class="string">position:absolute;</span></span><br><span class="line">    <span class="string">width:100%;</span></span><br><span class="line">    <span class="string">height:100%;</span></span><br><span class="line">    <span class="string">left:0;</span></span><br><span class="line">    <span class="string">top:0;</span></span><br><span class="line">    <span class="attr">border-radius:</span> <span class="string">12px;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="type">!=</span> <span class="string">page.content</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>注册video页面。在主题路径<code>butterfly/layout/</code>的<code>page.pug</code>文件中注册上述页面模板：</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">extends</span> <span class="string">includes/layout.pug</span></span><br><span class="line"></span><br><span class="line"><span class="string">block</span> <span class="string">content</span></span><br><span class="line">  <span class="comment">#page</span></span><br><span class="line">    <span class="string">if</span> <span class="string">top_img</span> <span class="string">===</span> <span class="literal">false</span></span><br><span class="line">      <span class="string">h1.page-title=</span> <span class="string">page.title</span></span><br><span class="line"></span><br><span class="line">    <span class="string">case</span> <span class="string">page.type</span></span><br><span class="line">      <span class="string">when</span> <span class="string">&#x27;tags&#x27;</span></span><br><span class="line">        <span class="string">include</span> <span class="string">includes/page/tags.pug</span></span><br><span class="line">      <span class="string">when</span> <span class="string">&#x27;link&#x27;</span></span><br><span class="line">        <span class="string">include</span> <span class="string">includes/page/flink.pug</span></span><br><span class="line">      <span class="string">when</span> <span class="string">&#x27;categories&#x27;</span></span><br><span class="line">        <span class="string">include</span> <span class="string">includes/page/categories.pug</span></span><br><span class="line"><span class="string">+</span>     <span class="string">when</span> <span class="string">&#x27;video&#x27;</span></span><br><span class="line"><span class="string">+</span>       <span class="string">include</span> <span class="string">includes/page/video.pug</span></span><br><span class="line">      <span class="string">default</span></span><br><span class="line">        <span class="string">include</span> <span class="string">includes/page/default-page.pug</span></span><br><span class="line"></span><br><span class="line">    <span class="string">if</span> <span class="string">page.comments</span> <span class="type">!==</span> <span class="literal">false</span> <span class="string">&amp;&amp;</span> <span class="string">theme.comments</span> <span class="string">&amp;&amp;</span> <span class="string">theme.comments.use</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">var</span> <span class="string">commentsJsLoad</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line">      <span class="type">!=partial(&#x27;includes/third</span><span class="string">-party/comments/index&#x27;,</span> &#123;&#125;<span class="string">,</span> &#123;<span class="attr">cache:</span> <span class="literal">true</span>&#125;<span class="string">)</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>获取B站等平台视频嵌入代码。复制iframe代码，如下：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?aid=937145035&amp;bvid=BV18T4y1D7wj&amp;cid=545915013&amp;page=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>新建data文件。在<code>hexo\source\_data</code>路径下(没有就创建一个文件夹)新建一个数据文件<code>video.yml</code>，把刚才的iframe代码内容转换成</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">cover:</span> <span class="string">图片背景图</span></span><br><span class="line">  <span class="attr">time:</span> <span class="string">发布时间</span></span><br><span class="line">  <span class="attr">link:</span> <span class="string">//player.bilibili.com/player.html?aid=xxx&amp;bvid=xxx&amp;cid=xxx&amp;page=1</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">展示到页面里的标题</span></span><br><span class="line">  <span class="attr">description:</span> <span class="string">展示到页面的该视频描述</span></span><br></pre></td></tr></table></figure>

<h2 id="网址卡片外置标签"><a href="#网址卡片外置标签" class="headerlink" title="网址卡片外置标签"></a>网址卡片外置标签</h2><p><a href="https://blog.zhheo.com/p/ccaf9148.html">转载自 Hexo的Butterfly魔改教程：网址卡片外置标签</a></p>
<a class="tag-Link" target="_blank" href="https://github.com/netbeifeng/hexo-tag-bangumi">
    <div class="tag-link-tips">引用站外地址，点击打开新页面标签</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style="background-image: url(https://api.iowen.cn/favicon/github.com/netbeifeng/hexo-tag-bangumi.png);"></div>
        <div class="tag-link-right">
            <div class="tag-link-title">hexo-tag-bangumi</div>
            <div class="tag-link-sitename">netbeifeng</div>
        </div>
        <i class="fa-solid fa-angle-right"></i>
    </div>
    </a>


<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">&#123;% link 获取网站的Favicon图标并显示在你的网页上,owen0o0,https://github.com/owen0o0/getFavicon %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="右键自定义菜单"><a href="#右键自定义菜单" class="headerlink" title="右键自定义菜单"></a>右键自定义菜单</h2><a class="tag-Link" target="_blank" href="https://blog.dorakika.cn/post/20220118/">
    <div class="tag-link-tips">引用站外地址，点击打开新页面标签</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style="background-image: url(https://api.iowen.cn/favicon/blog.dorakika.cn/post/20220118/.png);"></div>
        <div class="tag-link-right">
            <div class="tag-link-title">hexo-tag-bangumi</div>
            <div class="tag-link-sitename">作者：dorakika</div>
        </div>
        <i class="fa-solid fa-angle-right"></i>
    </div>
    </a>

<p>需要注意的是，inject right-menu.js </p>
<p>会前端就是好，自行加了几个分类，添加了站内搜索和音乐开关</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#rightMenu</span><br><span class="line">	.rightMenu-group.rightMenu-small</span><br><span class="line">		a.rightMenu-item(href=&quot;javascript:window.history.back();&quot;)</span><br><span class="line">			i.fa-solid.fa-arrow-left</span><br><span class="line">		a.rightMenu-item(href=&quot;javascript:window.location.reload();&quot;)</span><br><span class="line">			i.fa-solid.fa-rotate-right</span><br><span class="line">		a.rightMenu-item(href=&quot;javascript:window.history.forward();&quot;)</span><br><span class="line">			i.fa-solid.fa-arrow-right</span><br><span class="line">		a.rightMenu-item(href=&quot;javascript:rmf.scrollToTop();&quot;)</span><br><span class="line">			i.fa-solid.fa-arrow-up</span><br><span class="line"></span><br><span class="line">	.rightMenu-group.rightMenu-line</span><br><span class="line">		a.rightMenu-item(href=&quot;javascript:document.querySelector(&#x27;#search-button .search&#x27;).click()&quot;, data-pjax-state=&quot;external&quot;)</span><br><span class="line">			i.fa-solid.fa-search</span><br><span class="line">			span=&#x27;站内搜索&#x27;</span><br><span class="line">		a.rightMenu-item(href=&quot;/tags/&quot;)</span><br><span class="line">			i.fa-solid.fa-tag</span><br><span class="line">			span=&#x27;文章标签&#x27;</span><br><span class="line">		a.rightMenu-item(href=&quot;/categories/&quot;)</span><br><span class="line">			i.fa-solid.fa-bars</span><br><span class="line">			span=&#x27;博客分类&#x27;</span><br><span class="line">			</span><br><span class="line">	.rightMenu-group.rightMenu-line.hide#menu-text</span><br><span class="line">		a.rightMenu-item(href=&quot;javascript:rmf.copySelect();&quot;)</span><br><span class="line">			i.fa-regular.fa-copy</span><br><span class="line">			span=&#x27;复制&#x27;</span><br><span class="line"></span><br><span class="line">	.rightMenu-group.rightMenu-line</span><br><span class="line">		a.rightMenu-item(href=&quot;javascript:document.querySelector(&#x27;.aplayer-pic&#x27;).click()&quot;)</span><br><span class="line">			i.fa-solid.fa-headphones</span><br><span class="line">			span=&#x27;音乐开关&#x27;</span><br><span class="line">		a.rightMenu-item(href=&quot;javascript:rmf.switchDarkMode();&quot;)</span><br><span class="line">			i.fa-regular.fa-lightbulb</span><br><span class="line">			span=&#x27;昼夜切换&#x27;</span><br><span class="line">		</span><br><span class="line">	.rightMenu-group.rightMenu-line</span><br><span class="line">		a.rightMenu-item(href=&quot;/about_page&quot;)</span><br><span class="line">			i.fa-solid.fa-house-user</span><br><span class="line">			span=&#x27;关于本站&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="其他自改和TODO"><a href="#其他自改和TODO" class="headerlink" title="其他自改和TODO"></a>其他自改和TODO</h1><h2 id="文章字体和字号"><a href="#文章字体和字号" class="headerlink" title="文章字体和字号"></a>文章字体和字号</h2><p>之前0.8 0.9em 感觉小了些，特别是在2k屏下~ 适当加大了些，看上线后效果再修改吧</p>
<ul>
<li>header 调整item边距，加大字体到1.5em</li>
</ul>
<h2 id="设置Footer"><a href="#设置Footer" class="headerlink" title="设置Footer"></a>设置Footer</h2><p>自带的展示总感觉差点什么，暂用自带的 mark标签样式，icon+文字的形式来了，纯色背景有点丑，后面P张啥图上去吧</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="comment">// _layout/footer.styl 目前自定义样式 把 copyright隐藏了</span></span><br><span class="line"><span class="selector-id">#footer</span></span><br><span class="line">  <span class="selector-class">.copyright</span></span><br><span class="line">    <span class="attribute">display</span> none</span><br></pre></td></tr></table></figure>

<p>添加 .footer-copyright 改成自定义TAG展示</p>
<h2 id="部署后中文路径访问不到的问题"><a href="#部署后中文路径访问不到的问题" class="headerlink" title="部署后中文路径访问不到的问题"></a>部署后中文路径访问不到的问题</h2><ol>
<li>具体文章名可以用hexo-uuid解决</li>
</ol>
<p>由上可知，主要是由于中文名称造成的，所以关键还是转成英文或数字</p>
<ol start="2">
<li>category_map 和 tag_map</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">category_map:</span></span><br><span class="line">  <span class="string">&#x27;代码相关&#x27;</span><span class="string">:</span> <span class="string">code</span></span><br><span class="line">  <span class="string">&#x27;前端学习&#x27;</span><span class="string">:</span> <span class="string">fe</span></span><br><span class="line">  <span class="string">&#x27;编程学习&#x27;</span><span class="string">:</span> <span class="string">js</span></span><br><span class="line">  <span class="string">&#x27;读书笔记&#x27;</span><span class="string">:</span> <span class="string">note</span></span><br><span class="line">  <span class="string">&#x27;随笔随想&#x27;</span><span class="string">:</span> <span class="string">&#x27;other&#x27;</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line">  <span class="string">&#x27;正则表达式&#x27;</span><span class="string">:</span> <span class="string">&#x27;reg&#x27;</span></span><br><span class="line">  <span class="string">&#x27;hexo插件&#x27;</span><span class="string">:</span> <span class="string">&#x27;hexo&#x27;</span></span><br><span class="line">  <span class="string">&#x27;柯里化&#x27;</span><span class="string">:</span> <span class="string">&#x27;currying&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通过这样的配置就解决了</p>
<h2 id="dark模式下的一些变量"><a href="#dark模式下的一些变量" class="headerlink" title="dark模式下的一些变量"></a>dark模式下的一些变量</h2><p>TODO - 后续有时间再完善</p>
]]></content>
      <categories>
        <category>代码相关</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hexo插件</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】函数柯里化</title>
    <url>/2018/04/15/afd1e030-af91-11ee-b57c-8be65f3ce2c9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>柯里化 curring 是把接收多个参数的函数变换成接收一个单一参数（最初函数的第一个参数）的函数，并且返回接收余下参数并且返回结果的新函数的技术。</p>
<span id="more"></span>

<p>柯里化 -&gt; 部分求值，返回接收剩余参数且返回结果的新函数。</p>
<h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><ul>
<li>参数复用 - 复用最初函数的第一个参数</li>
<li>提前返回 - 返回接收余下的参数且返回结果的新函数</li>
<li>延迟执行 - 返回新函数，等待执行</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>兼容浏览器事件监听方法</li>
<li>性能优化：防抖和节流</li>
<li>兼容低版本IE bind方法等</li>
</ul>
<h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> addEvent = <span class="keyword">function</span>(<span class="params">elm, type, fn, isCapture</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">addEventListener</span>) &#123;</span><br><span class="line">    elm.<span class="title function_">addEventListner</span>(type, fn, isCapture)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">attachEvent</span>) &#123;</span><br><span class="line">    elm.<span class="title function_">attachEvent</span>(<span class="string">&#x27;on&#x27;</span> + type, fn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们调用addEvent方法时，都会执行if else-if 进行一次兼容判断，其实这个判断是无必要的，用柯里化优化后如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> addEvent = <span class="keyword">function</span>(<span class="params">elm, type, fn, isCapture</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">addEventListener</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">elm, type, fn, isCapture</span>) &#123;</span><br><span class="line">      elm.<span class="title function_">addEventListen</span>(type, fn, isCapture)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">attachEvent</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">elm, type, fn</span>) &#123;</span><br><span class="line">      elm.<span class="title function_">attachEvent</span>(<span class="string">&#x27;on&#x27;</span> + type, fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该例就利用了柯里化提前返回和执行的特点：</p>
<ul>
<li>提前返回 - 使用函数立即调用进行一次兼容判断，返回兼容的事件绑定方法</li>
<li>延迟执行 - 返回新函数，在新函数调用兼容的事件方法。等待addEvent新函数调用，延迟执行</li>
</ul>
<h3 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h3><p>web开发中，事件<code>resize, scroll, mousemove</code>等属于高频事件。浏览器页面渲染帧率为60fps，大约16.67ms刷新一帧。 若事件触发频率大于显示帧率，则会发生掉帧、卡顿等现象，更坏地浏览器直接崩溃。</p>
<p>要解决高频事件的问题，其根本在于：</p>
<ul>
<li>高频事件处理函数，不应该含有复杂操作，如DOM操作和复杂计算（DOM操作一般会造成页面回流和重绘，使浏览器不断重新渲染页面）</li>
<li>控制高频事件的触发频率</li>
</ul>
<p>其中防抖和节流对高频事件进行优化的原理就是通过延迟执行，将多个间隔接近的函数执行合并成一次函数执行。</p>
<h4 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖 debounce"></a>防抖 debounce</h4><p>针对高频事件，防抖就是讲多个触发间隔接近的事件函数执行，合并成一次函数执行</p>
<p>实现防抖的关键点有两个：</p>
<ul>
<li><p>使用setTimeout延时器，传入延迟时间，将事件处理函数延迟执行，并且通过事件触发频率与延迟事件值比较，控制处理函数是否执行</p>
</li>
<li><p>使用柯里化函数结合闭包思想，将执行状态保存在闭包中，返回新函数，在新函数中通过执行状态控制是否在滚动时执行处理函数</p>
</li>
</ul>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param    fn              Function    事件处理函数</span></span><br><span class="line"><span class="comment"> * @param    delay           Number      延迟时间</span></span><br><span class="line"><span class="comment"> * @param    isImmediate     Boolean     是否滚动时立刻执行</span></span><br><span class="line"><span class="comment"> * @return   Function                    事件处理函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> debound = <span class="keyword">function</span>(<span class="params">fn, delay, isImmediate</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用闭包，保存执行状态，控制函数调用顺序</span></span><br><span class="line">  <span class="keyword">var</span> timer</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> _args = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>),</span><br><span class="line">      context = <span class="variable language_">this</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _fn = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      timer = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">if</span> (!isImmediate) fn.<span class="title function_">apply</span>(context, _args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否滚动时立即执行</span></span><br><span class="line">    <span class="keyword">var</span> callNow = !timer &amp;&amp; isImmediate</span><br><span class="line"></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(_fn, delay)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callNow) fn.<span class="title function_">apply</span>(context, _args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 防抖使用如下：</span></span><br><span class="line"><span class="keyword">var</span> debounceScroll = <span class="title function_">debounce</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 事件处理函数，滚动时进行的处理</span></span><br><span class="line">&#125;, <span class="number">100</span>)</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, debounceScroll)</span><br></pre></td></tr></table></figure>

<p>防抖技术仅靠传入延迟时间值的大小控制高频事件的触发频率。如果传入的延迟事件较大，则可能导致不触发事件处理函数，这时节流就派上用场了</p>
<h4 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流 throttle"></a>节流 throttle</h4><p>节流也是将多个触发间隔接近的事件函数执行，合并成一次函数执行，并且在指定时间内执行执行一次事件处理函数。</p>
<p>节流实现原理跟防抖类似，但是比防抖多了一次实函数执行判断，实现的关键点是：</p>
<ul>
<li>利用闭包存储了当前和上一次执行的时间戳，通过两次函数执行的时间差跟指定的延迟事件的比较，控制函数是否执行</li>
</ul>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @param    fn          Function    事件处理函数</span></span><br><span class="line"><span class="comment">* @param    wait        Number      延迟时间</span></span><br><span class="line"><span class="comment">* @return   Function                事件处理函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> throttle = <span class="keyword">function</span>(<span class="params">fn, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> timer, previous, now, diff</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> _args = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>),</span><br><span class="line">      context = <span class="variable language_">this</span></span><br><span class="line">    <span class="comment">// 存储当前时间戳</span></span><br><span class="line">    now = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _fn = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 存储上一次执行的时间戳</span></span><br><span class="line">      previous = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">      timer = <span class="literal">null</span></span><br><span class="line">      fn.<span class="title function_">apply</span>(context, _args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (previous !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="comment">// 时间差</span></span><br><span class="line">      diff = now - previous</span><br><span class="line">      <span class="keyword">if</span> (diff &gt;= wait) &#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(context, _args)</span><br><span class="line">        previous = now</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(_fn, wait)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">_fn</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>拓展：节流和防抖都是用setTimeout实现的，改用window.requestAnimationFrame</strong></p>
<p>实现起来更简单，性能更好，但不支持低版本IE</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解决requestAnimationFrame兼容</span></span><br><span class="line"><span class="keyword">var</span> reFrame = <span class="variable language_">window</span>.<span class="property">requestAnimationFrame</span> ||</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">webkitRequestAnimationFrame</span> ||</span><br><span class="line">  <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(callback, <span class="number">1000</span> / <span class="number">60</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化封装</span></span><br><span class="line"><span class="keyword">var</span> refThrottle = <span class="keyword">function</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> isLocked</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">var</span> _args = <span class="variable language_">arguments</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isLocked) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    isLocked = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">reFrame</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      isLocked = <span class="literal">false</span></span><br><span class="line">      fn.<span class="title function_">apply</span>(context, _args)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bind柯里化函数"><a href="#bind柯里化函数" class="headerlink" title="bind柯里化函数"></a>bind柯里化函数</h3><p>函数的bind方法我们不陌生，但在低版本IE不兼容，若要实现兼容其关键点在于：</p>
<ul>
<li>bind方法改变this指向，却不会执行原函数，那么我们可以利用柯里化延迟执行，参数复用和提前返回的特点，返回新函数，在新函数是用apply方法执行原函数</li>
</ul>
<p>我们这里将bind方法封装为两种情况：</p>
<ol>
<li>简单的bind方法封装，不考虑构造函数等，实现如下：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span>) &#123;</span><br><span class="line">  <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context.<span class="title function_">toString</span>() !== <span class="string">&#x27;[object Object]&#x27;</span> &amp;&amp; context.<span class="title function_">toString</span>() !== <span class="string">&#x27;[object Window]&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;context is not a Object&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">var</span> args = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> _args = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">      _this.<span class="title function_">apply</span>(context, _args.<span class="title function_">concat</span>(args))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>复杂情况，考虑bind的任何用法，这里直接是用MDN的bind兼容方法：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span>) &#123;</span><br><span class="line">  <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span>(<span class="params">oThis</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Function.prototype.bind - what is trying to be bound is not callable&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> aArgs = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>),</span><br><span class="line">      fToBind = <span class="variable language_">this</span>,</span><br><span class="line">      fNOP = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">      fBound = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fToBind.<span class="title function_">apply</span>(</span><br><span class="line">          <span class="variable language_">this</span> <span class="keyword">instanceof</span> fNOP ? <span class="variable language_">this</span> : oThis,</span><br><span class="line">          <span class="comment">// 获取调用时 fBound 的传参 .bind返回的函数入参往往是这么传递的</span></span><br><span class="line">          aArgs.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>))</span><br><span class="line">        ) </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 维护原型关系</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">        <span class="comment">// Function.prototype doesn&#x27;t have a prototype property</span></span><br><span class="line">        fNOP.<span class="property"><span class="keyword">prototype</span></span> = <span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">      &#125;</span><br><span class="line">      fBound.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">fNOP</span>()</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> fBound</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要理解复杂的bind兼容方法，必须彻底理解以下四个基础知识</p>
<ul>
<li>JS原型对象</li>
<li>构造函数是用new操作符的过程</li>
<li>this的指向问题</li>
<li>熟悉bind方法的是用场景</li>
</ul>
<h3 id="柯里化函数的封装"><a href="#柯里化函数的封装" class="headerlink" title="柯里化函数的封装"></a>柯里化函数的封装</h3><p>分析了柯里化的各种是用场景，我们来尝试一下封装一个简单的柯里化函数，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createCurry</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;fn is not a function&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 复用第一个参数</span></span><br><span class="line">  <span class="keyword">var</span> args = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 返回新函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 收集剩余参数</span></span><br><span class="line">    <span class="keyword">var</span> _args = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args.<span class="title function_">concat</span>(_args))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>柯里化函数的特点如上注释所示：</p>
<ul>
<li>复用第一个参数</li>
<li>返回新函数</li>
<li>收集剩余参数</li>
<li>返回结果</li>
</ul>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>柯里化</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】应用正则表达式（二）</title>
    <url>/2018/02/26/29a4d0d0-af91-11ee-9c49-fbbec3201c14/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>之前也写过正则学习相关的，取这标题只是因为最近读忍者秘籍第2版又讲到这个话题，作为学习、回顾把一些重要的知识点和方法记录下来。正则表达式需要长时间的积累及不断实践才能提高，虽然工作中碰不到太多正则使用场景，简单的记录也算作一种学习、应用吧</p>
</blockquote>
<span id="more"></span>

<h2 id="我们可以使用正则解决各种任务"><a href="#我们可以使用正则解决各种任务" class="headerlink" title="我们可以使用正则解决各种任务"></a>我们可以使用正则解决各种任务</h2><ul>
<li>操作HTML节点中的字符串</li>
<li>使用CSS选择器表达式定位部分选择器</li>
<li>判断一个元素是否具有指定的类名</li>
<li>输入校验</li>
<li>其他任务</li>
</ul>
<hr>
<h2 id="带着问题学习"><a href="#带着问题学习" class="headerlink" title="带着问题学习"></a>带着问题学习</h2><ol>
<li>什么时候使用正则字面量，而不是使用正则对象</li>
<li>什么是粘连匹配，如何开启粘连匹配</li>
<li>使用全局和非全局正则表达式的区别是什么</li>
</ol>
<hr>
<h2 id="正则相关"><a href="#正则相关" class="headerlink" title="正则相关"></a>正则相关</h2><p>创建正则的方式：</p>
<ul>
<li>使用正则字面量</li>
<li>通过创建 RegExp 对象的实例</li>
</ul>
<p>回答1： 当正则表达式在开发环境是明确的，推荐优先使用字面量语法；当需要在运行时动态创建字符串来构建正则表达式时，则使用构造函数的方式。</p>
<p>正则修饰符：</p>
<ul>
<li>i 对大小写不敏感</li>
<li>g 查找所有匹配项</li>
<li>m 多行匹配</li>
<li>y 开启粘连匹配</li>
<li>u 允许使用 Unicode点转义符</li>
</ul>
<h3 id="术语和操作符"><a href="#术语和操作符" class="headerlink" title="术语和操作符"></a>术语和操作符</h3><p><strong>精确匹配</strong></p>
<p>&#x2F;test&#x2F; 这类，&#x2F;^test$&#x2F;</p>
<p><strong>匹配字符集</strong></p>
<p>[abc] 我们匹配的是 a b 或 c，只是abc其中一个字符</p>
<p>[^abc] 字符集里的 ^ 表示除了abc意外的任意字符，这要和 ^ 以开始作区别</p>
<p><strong>转义</strong></p>
<p>$ . ^ [ &#x2F; ] \ { } ‘ 这些特殊字符都是需要 添加 <code>\</code> 来进行转义的</p>
<p><strong>起止符号</strong></p>
<p>尖括号()用于匹配字符串的开始，如 &#x2F;^test&#x2F;就是匹配test出现在字符串的开头。（注，这只是字符的重载，^还可以表示非）</p>
<p>美元符号$表示字符串的结束，如&#x2F;test$&#x2F; 就是匹配 test出现在字符串的末尾</p>
<p><strong>重复出现</strong></p>
<ul>
<li>? 0次或1次</li>
<li><ul>
<li>1次或多次</li>
</ul>
</li>
<li><ul>
<li>0次或多次</li>
</ul>
</li>
<li>{n} 表重复次数</li>
<li>{2, 4} 重复范围 出现2到4次</li>
<li>{4, } 匹配4次或更多</li>
</ul>
<p>这些字符串都可以是贪婪的或非贪婪的。默认是贪婪模式，可以匹配所有可能的字符。在运算符后添加?，例如 a+?，使得运算符为非贪婪模式，只进行最小限度的匹配。<br>例如，对于字符串aaa，正则表达式&#x2F;a+&#x2F;会匹配全部3个字符，而非贪婪模式&#x2F;a+?&#x2F;则匹配一个字符a，因为一个字符a足以满足a+术语。</p>
<p><strong>预定义字符集</strong>只列常用的</p>
<ul>
<li>\t 水平制表符</li>
<li>\r 回车</li>
<li>\h 换行符</li>
<li>. 匹配除换行意外的任意字符</li>
<li>\d 匹配十进制数字 [0-9]</li>
<li>\D 匹配非十进制数字外任意字符 [^0-9]</li>
<li>\w 匹配任何数字、字母、下划线 [0-9a-zA-Z_]</li>
<li>\W 匹配除了数字、字母、下划线以外的任意字符 [^0-9a-zA-Z_]</li>
<li>\s 匹配任意空白字符 空格、制表符、换行等</li>
<li>\S 匹配除空白符以外的任意字符</li>
<li>\b 匹配单词边界</li>
<li>\B 匹配非单词边界</li>
</ul>
<p><strong>分组</strong></p>
<p>操作符，如 + 和 * 只影响其前面的术语。如果对一组术语使用操作符，可以使用<strong>圆括号</strong>()进行分组，这与数学表达式类似。例如，&#x2F;(ab)+&#x2F;匹配一个或多个连续的ab</p>
<p><strong>或操作符</strong></p>
<p>使用竖线 | 表示或。例如， &#x2F;a|b&#x2F;表示可以匹配a或者b，&#x2F;(ab+)|(cd+)&#x2F;表示可以匹配一个或多个ab或cd</p>
<p><strong>反向引用</strong></p>
<p>反向引用可引用正则中定义的捕获。稍后会详细介绍。</p>
<p>现在只需要把捕获看作待匹配的字符串，也就是前面匹配的字符串。反向引用分组中捕获的内容，使用反斜线加上数字表示引用，该数字从1开始。<br>例如 &#x2F;^([dtn]a)\1&#x2F; 匹配任意从d t或n开始的连续有a的字符串，连续匹配第一个分组中捕获的内容。</p>
<h3 id="编译正则表达式"><a href="#编译正则表达式" class="headerlink" title="编译正则表达式"></a>编译正则表达式</h3><p>处理正则经历多个阶段，其中两个主要的阶段是编译和执行。<br>编译阶段发生在正则表达式被创建的时期。执行发生在使用编译之后的正则表达式进行匹配字符串的时期。</p>
<p>在编译过程中，表达式经过JS引擎的解析，转换为内部代码。解析和转换的过程发生砸死正则表达式创建时期（浏览器会进行内部优化处理）。通常的，浏览器会判断使用哪条正则并缓存表达式的编译结果。但对于复杂表达式，我们通过预编译正则，使得性能得到明显提升。</p>
<p>编译正则并将其保存在变量是个很重要的优化过程。<br>每个正则都有以个独特的对象表示，每次创建一个正则都会创建一个新的正则表达式对象。这与原始类型不同，因为每个正则都是独一无二的。使用构造函数创建正则可以在运行时使用字符串创建正则。对于构建可以重复使用的复杂正则很有用。</p>
<p>在运行时编译一个稍后使用的正则，如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;samurai ninja&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ninja samurai&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;samurai ninja ronin&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">findClassInElements</span>(<span class="params">className, type</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 根据标签类型查找元素</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> elems = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(type || <span class="string">&#x27;*&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 使用传入的class编译正则</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">`(^|\\s)<span class="subst">$&#123;className&#125;</span>(\\s|$)`</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 储存最终结果</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> results = []</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = elems.<span class="property">length</span>; i &lt; length; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 检测是否与正则匹配</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (reg.<span class="title function_">test</span>(elems[i].<span class="property">className</span>)) &#123;</span></span><br><span class="line"><span class="language-javascript">      results.<span class="title function_">push</span>(elems[i])</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">return</span> results</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这种方式可以大大提高性能。一旦正则被编译后，就可以通过该正则的test方法收集匹配的元素。<br>推荐使用预创建和预编译的正则表达式，这对性能有很大提升。在正则表达式中使用圆括号，不仅可以用于术语，还可以创建捕获。</p>
<h3 id="捕获匹配的片段"><a href="#捕获匹配的片段" class="headerlink" title="捕获匹配的片段"></a>捕获匹配的片段</h3><p>执行简单捕获，代码示例如下:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;square&quot;</span> <span class="attr">style</span>=<span class="string">&quot;transform:translateY(15px);&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">getTranslate</span>(<span class="params">elem</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> transformValue = elem.<span class="property">style</span>.<span class="property">transform</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">if</span> (transformValue) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> match = transformValue.<span class="title function_">match</span>(<span class="regexp">/translate[x|y|z|3d]\(([^\)]+)\)/</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(match)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> match ? match[<span class="number">1</span>] : <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> square = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;square&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="title function_">getTranslate</span>(square)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>match方法匹配结果通过第一个索引返回，然后每次捕获结果索引递增。所以第0个匹配的是整个字符串translateY(15px)，第二个位置是15px。<br>在正则表达式中使用圆括号定义捕获。因为我们在正则表达式中仅定义了一个捕获，因此当匹配变换值时，其值存储在[1]中。</p>
<h3 id="使用全局表达式进行匹配"><a href="#使用全局表达式进行匹配" class="headerlink" title="使用全局表达式进行匹配"></a>使用全局表达式进行匹配</h3><p>使用局部正则表示可以返回数组，该数组中包含全部匹配的内容以及操作中的全部匹配结果。<br>但当使用全局正则表达式g返回全部的匹配结果，但不会返回捕获结果。代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> html = <span class="string">`&lt;div class=&quot;test&quot;&gt;&lt;b&gt;hello&lt;/b&gt; &lt;i&gt;world!&lt;/i&gt;&lt;/div&gt;`</span></span><br><span class="line"><span class="keyword">const</span> reg1 = <span class="regexp">/&lt;(\/?)(\w+)([^&gt;]*?)&gt;/</span></span><br><span class="line"><span class="keyword">const</span> reg2 = <span class="regexp">/&lt;(\/?)(\w+)([^&gt;]*?)&gt;/g</span></span><br><span class="line"><span class="keyword">const</span> result = html.<span class="title function_">match</span>(reg1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result) <span class="comment">// [&quot;&lt;div class=&quot;test&quot;&gt;&quot;, &quot;&quot;, &quot;div&quot;, &quot; class=&quot;test&quot;&quot;, index: 0, input: &quot;&lt;div class=&quot;test&quot;&gt;&lt;b&gt;hello&lt;/b&gt; &lt;i&gt;world!&lt;/i&gt;&lt;/div&gt;&quot;]</span></span><br><span class="line"><span class="keyword">const</span> all = html.<span class="title function_">match</span>(reg2)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(all) <span class="comment">// [&quot;&lt;div class=&quot;test&quot;&gt;&quot;, &quot;&lt;b&gt;&quot;, &quot;&lt;/b&gt;&quot;, &quot;&lt;i&gt;&quot;, &quot;&lt;/i&gt;&quot;, &quot;&lt;/div&gt;&quot;]</span></span><br></pre></td></tr></table></figure>

<p>当局部匹配时只有一个实例被匹配，并返回匹配中的捕获结果。但当使用全局匹配时，返回的是匹配的全部内容列表。<br>若捕获结果重要，可以在全局匹配中使用正则的exec方法，可多次对一个正则调用exec方法，每次调用都可以返回下一个匹配的结果，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> html = <span class="string">`&lt;div class=&quot;test&quot;&gt;&lt;b&gt;hello&lt;/b&gt; &lt;i&gt;world!&lt;/i&gt;&lt;/div&gt;`</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/&lt;(\/?)(\w+)([^&gt;]*?)&gt;/g</span></span><br><span class="line"><span class="keyword">let</span> match, num = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (match = reg.<span class="title function_">exec</span>(html) !== <span class="literal">null</span>) &#123;</span><br><span class="line">  num++</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h3 id="捕获的引用"><a href="#捕获的引用" class="headerlink" title="捕获的引用"></a>捕获的引用</h3><p>对捕获结果进行引用有两种方式：</p>
<ol>
<li>在自身匹配</li>
<li>字符串替换</li>
</ol>
<p>下示例为使用反向匹配html标记的内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> html = <span class="string">`&lt;b class=&quot;hello&quot;&gt;hello&lt;/b&gt; &lt;i&gt;world!&lt;/i&gt;`</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/&lt;(\w+)([^&gt;]*)&gt;(.*?)&lt;\/\1&gt;/g</span> <span class="comment">//使用反向引用</span></span><br><span class="line"><span class="keyword">let</span> match = reg.<span class="title function_">exec</span>(html)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(match) <span class="comment">// [&quot;&lt;b class=&quot;hello&quot;&gt;hello&lt;/b&gt;&quot;, &quot;b&quot;, &quot; class=&quot;hello&quot;&quot;, &quot;hello&quot;]</span></span><br><span class="line">match = reg.<span class="title function_">exec</span>(html)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(match) <span class="comment">// [&quot;&lt;i&gt;world!&lt;/i&gt;&quot;, &quot;i&quot;, &quot;&quot;, &quot;world!&quot;]</span></span><br></pre></td></tr></table></figure>

<p>使用 \1 指向表达式中的第一个捕获，在本例中捕获的是标记的名称。使用第一个捕获的内容匹配对应的结束标记。<br>此外，可以调用字符串的replace方法，对替换字符串内获取捕获。不使用反向引用，可以用$1、$2、$3等标记捕获序号，如下：</p>
<pre><code>&#39;fontFamily&#39;.replace(/([A-Z])/g, &#39;-$1&#39;).toLowerCase()
</code></pre>
<p>上述代码中，第一个捕获值 F 通过替代字符$1进行引用，从而替换。由于捕获和分组都可以使用圆括号表示，对于正则处理器来说，无法区别所添加的是捕获还是分组。对于这种情况我们继续介绍</p>
<h3 id="未捕获的分组"><a href="#未捕获的分组" class="headerlink" title="未捕获的分组"></a>未捕获的分组</h3><p>圆括号有两项职责：</p>
<ol>
<li>定义分组</li>
<li>指定捕获</li>
</ol>
<p>对于存在大量分组的正则表达式来说，可能会产生太多不必要的捕获，这会导致处理捕获变得频繁</p>
<pre><code>const pattern = /((ninja-+))sword/
</code></pre>
<p>创建正则时，允许前缀 ninja-单词在sword之前出现1次或多次，并捕获整个前缀。该正则使用了两个括号：</p>
<ol>
<li>定义捕获的圆括号，字符串sword之前的全部内容</li>
<li>定义ninja-和+操作符分组的操作符</li>
</ol>
<p>返回结果中不止一个捕获，因为含有用于分组的圆括号。说明有一组括号不应该产生捕获，正则表达式语法可以在起始圆括号之后使用符号 ?: ，这就是所谓的<code>被动子表达式</code>。</p>
<pre><code>const pattern = /((?:ninja-)+)sword/
</code></pre>
<p>只有外层括号会创建捕获，内层括号会变成一个被动子表达式，我们来看以个具体的示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reg1 = <span class="regexp">/((ninja-+))sword/</span></span><br><span class="line"><span class="keyword">const</span> reg2 = <span class="regexp">/((?:ninja-+))sword/</span></span><br><span class="line"><span class="keyword">const</span> ninjas1 = <span class="string">&#x27;ninja-ninja-sword&#x27;</span>.<span class="title function_">match</span>(reg1) <span class="comment">// [&quot;ninja-sword&quot;, &quot;ninja-&quot;, &quot;ninja-&quot;]</span></span><br><span class="line"><span class="keyword">const</span> ninjas2 = <span class="string">&#x27;ninja-ninja-sword&#x27;</span>.<span class="title function_">match</span>(reg2) <span class="comment">// [&quot;ninja-sword&quot;, &quot;ninja-&quot;]</span></span><br></pre></td></tr></table></figure>

<p>在不需要捕获情况下，尽量使用非捕获分组代替捕获，表达式引擎不需要记忆和返回捕获结果，这利于提高性能。</p>
<h3 id="利用函数进行替换"><a href="#利用函数进行替换" class="headerlink" title="利用函数进行替换"></a>利用函数进行替换</h3><p>replace最重要的特征不仅支持替换值，而且支持替换函数作用参数：</p>
<ul>
<li>全文匹配</li>
<li>匹配时的捕获</li>
<li>在原始字符串匹配的索引</li>
<li>源字符串</li>
<li>从函数返回的值作为替换值</li>
</ul>
<p>下面来看示例，将短横线连接的字符串转换为驼峰式字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">upper</span>(<span class="params">all, letter</span>) &#123;<span class="keyword">return</span> letter.<span class="title function_">toUpperCase</span>()&#125; <span class="comment">// 转换为大写的函数</span></span><br><span class="line"><span class="string">&#x27;border-bottom-width&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/-(\w)/g</span>, upper) <span class="comment">// borderBottomWidth</span></span><br></pre></td></tr></table></figure>

<p>由于全局匹配，对每一个匹配的字符串都会执行替换函数。我们再来看一个实例加深印象</p>
<p>假设需要将查询字符串换为符合我们所需格式的字符串，需将 foo&#x3D;1&amp;foo&#x3D;2&amp;blah&#x3D;a&amp;blah&#x3D;b&amp;foo&#x3D;3转换为 foo&#x3D;1,2,3&amp;blah&#x3D;a,b</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compress</span>(<span class="params">source</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> keys = &#123;&#125;</span><br><span class="line">  source.<span class="title function_">replace</span>(</span><br><span class="line">    <span class="regexp">/([^=&amp;]+)=([^&amp;]*)/g</span>,</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">full, key, value</span>) &#123; <span class="comment">// 提取键值对信息</span></span><br><span class="line">      keys[key] = (keys[key] ? keys[key] + <span class="string">&#x27;,&#x27;</span> : <span class="string">&#x27;&#x27;</span>) + value</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> keys) &#123;</span><br><span class="line">    <span class="keyword">if</span> (keys.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(key + <span class="string">&#x27;=&#x27;</span> + keys[key])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.<span class="title function_">join</span>(<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="几个实例"><a href="#几个实例" class="headerlink" title="几个实例"></a>几个实例</h3><p>匹配所有字符，包括换行符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> html = <span class="string">&#x27;&lt;b class=&quot;hello&quot;&gt;hello&lt;/b&gt; \n&lt;i&gt;world!&lt;/i&gt;&#x27;</span></span><br><span class="line"><span class="comment">// 不匹配换行</span></span><br><span class="line">/.*<span class="regexp">/.exec(html) /</span><span class="regexp">/ [&quot;&lt;b class=&quot;hello&quot;&gt;hello&lt;/b&gt;&quot;]</span></span><br><span class="line"><span class="regexp">/</span>/ 使用空白符匹配所有字符</span><br><span class="line">/[\S\s]*<span class="regexp">/.exec(html) /</span><span class="regexp">/[&quot;&lt;b class=&quot;hello&quot;&gt;hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;]</span></span><br><span class="line"><span class="regexp">/</span>/ 第二种匹配所有字符的方法</span><br><span class="line">/(?:.|\s)*/.<span class="title function_">exec</span>(html)</span><br></pre></td></tr></table></figure>

<p>在css选择器中匹配转义字符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该正则允许任意字符序列组成的单词，包括一个反斜线紧跟任意字符</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/^((\w+)|(\\.))+$/</span></span><br><span class="line"><span class="keyword">const</span> tests = [</span><br><span class="line">  <span class="string">&#x27;formUpdate&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;form\\.update\\.whatever&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;form\\:update&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;\\f\\o\\r\\m\\u\\p\\d\\a\\t\\e&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;form:update&#x27;</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tests.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(tests[i]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>创建正则可以使用正则字面量 &#x2F;test&#x2F; 或正则构造函数 new RegExp(‘test’)。对于在开发环境明确的推荐使用正则字面量，在运行时则推荐使用构造函数</li>
<li>使用section指定一组待匹配的字符</li>
<li>理解掌握5种模式gimyu，各种术语和操作符：匹配字符集[] 转义\ 起止^ 结束$ 重复 预定义字符等</li>
<li>使用圆括号对多个术语进行分组，使用竖线 | 表示或</li>
<li>通过反斜线加数字 \1 \2 可以对匹配的字符串进行反向引用</li>
<li>字符串的正则方法，match test replace</li>
</ul>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】应用正则表达式（一）</title>
    <url>/2018/06/29/e4c289d0-af90-11ee-9d8d-27c80ca01677/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>最近因工作用到了，顺便查看了一些关于正则的博客，确实非常使用。学好正则看来是以后的一个必选项，趁着最近时间挺充裕的，于是系统的入门了一下，也算是能手写几个简单的正则来匹配规则了。</p>
</blockquote>
<span id="more"></span>

<h3 id="子字符串匹配和替换"><a href="#子字符串匹配和替换" class="headerlink" title="子字符串匹配和替换"></a>子字符串匹配和替换</h3><p>如果只想知道某个字符串是否包含在一个更大的字符串中，下面的 String.prototype 方法就可以实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="string">&#x27;As I was going to Saint Ives&#x27;</span></span><br><span class="line">input.<span class="title function_">startsWith</span>(<span class="string">&#x27;As&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">input.<span class="title function_">endsWith</span>(<span class="string">&#x27;Ives&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">input.<span class="title function_">startsWith</span>(<span class="string">&#x27;going&#x27;</span>, <span class="number">9</span>) <span class="comment">// true - 从下标9开始数</span></span><br><span class="line">input.<span class="title function_">endsWith</span>(<span class="string">&#x27;going&#x27;</span>, <span class="number">14</span>) <span class="comment">// true - 将下标14当作字符串结尾</span></span><br><span class="line">input.<span class="title function_">includes</span>(<span class="string">&#x27;going&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">input.<span class="title function_">includes</span>(<span class="string">&#x27;going&#x27;</span>, <span class="number">10</span>) <span class="comment">// false - 从下标10开始</span></span><br><span class="line">input.<span class="title function_">indexOf</span>(<span class="string">&#x27;going&#x27;</span>) <span class="comment">// 9</span></span><br><span class="line">input.<span class="title function_">indexOf</span>(<span class="string">&#x27;going&#x27;</span>, <span class="number">10</span>) <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 若想进一步操作，如替换掉刚才匹配的字符串，可以使用String.prototype.replace</span></span><br><span class="line"><span class="keyword">const</span> output = input.<span class="title function_">replace</span>(<span class="string">&#x27;going&#x27;</span>, <span class="string">&#x27;walking&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="构造正则表达式"><a href="#构造正则表达式" class="headerlink" title="构造正则表达式"></a>构造正则表达式</h3><p>在 JS 中，正则可以通过 RegExp 类来表示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> re1 = <span class="regexp">/going/</span> <span class="comment">// 可以搜索 &#x27;going&#x27;的正则表达式</span></span><br><span class="line"><span class="keyword">const</span> re2 = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;going&#x27;</span>) <span class="comment">// 使用对象构造器的等价形式</span></span><br></pre></td></tr></table></figure>

<h3 id="使用正则进行搜索"><a href="#使用正则进行搜索" class="headerlink" title="使用正则进行搜索"></a>使用正则进行搜索</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="string">&#x27;As I was going to Saint Ives&#x27;</span></span><br><span class="line"><span class="keyword">const</span> re = <span class="regexp">/\w&#123;3,&#125;/gi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串(input)开始</span></span><br><span class="line">input.<span class="title function_">match</span>(re) <span class="comment">// [&#x27;was&#x27;, &#x27;going&#x27;, &#x27;Saint&#x27;, &#x27;Ives&#x27;]</span></span><br><span class="line">input.<span class="title function_">search</span>(re) <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从正则表达式开始(re)</span></span><br><span class="line">re.<span class="title function_">test</span>(input) <span class="comment">// true - input至少包含一个三个字母的单词</span></span><br><span class="line">re.<span class="title function_">exec</span>(input) <span class="comment">// [&#x27;was&#x27;] (第一个匹配)</span></span><br><span class="line">re.<span class="title function_">exec</span>(input) <span class="comment">// [&#x27;going&#x27;] (exec会记住它所在的位置)</span></span><br><span class="line">re.<span class="title function_">exec</span>(input) <span class="comment">// [&#x27;Saint&#x27;]</span></span><br><span class="line">re.<span class="title function_">exec</span>(input) <span class="comment">// [&#x27;Ives&#x27;]</span></span><br><span class="line">re.<span class="title function_">exec</span>(input) <span class="comment">// null - 匹配完毕</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，所有这些方法都可以直接使用字面量语法</span></span><br><span class="line">input.<span class="title function_">match</span>(<span class="regexp">/\w&#123;3,&#125;/gi</span>)</span><br><span class="line">input.<span class="title function_">search</span>(<span class="regexp">/\w&#123;3,&#125;/gi</span>)</span><br><span class="line">;<span class="regexp">/\w&#123;3,&#125;/gi</span>.<span class="title function_">test</span>(input)</span><br><span class="line">;<span class="regexp">/\w&#123;3,&#125;/gi</span>.<span class="title function_">exec</span>(input)</span><br></pre></td></tr></table></figure>

<h3 id="使用正则表达式进行替换"><a href="#使用正则表达式进行替换" class="headerlink" title="使用正则表达式进行替换"></a>使用正则表达式进行替换</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="string">&#x27;As I was going to Saint Ives&#x27;</span></span><br><span class="line"><span class="keyword">const</span> output = input.<span class="title function_">replace</span>(<span class="regexp">/\w&#123;3,&#125;/gi</span>, <span class="string">&#x27;****&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="匹配-HTML"><a href="#匹配-HTML" class="headerlink" title="匹配 HTML"></a>匹配 HTML</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> html1 = <span class="string">`</span></span><br><span class="line"><span class="string">  HTML width &lt;a href=&quot;/one&quot;&gt;one link&lt;/a&gt;, and some JavaScript.</span></span><br><span class="line"><span class="string">  &lt;script src=&quot;strff.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> matches = html.<span class="title function_">match</span>(<span class="regexp">/&lt;area|&lt;a|&lt;link|&lt;script|&lt;source/gi</span>)</span><br></pre></td></tr></table></figure>

<p>要了解的是，现在来说正则表达式不能解析 HTML。为解决这个问题，需引入一个解析器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> html2 = <span class="string">&#x27;&lt;br&gt; [!CDATA[&lt;br&gt;]]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> matches = html.<span class="title function_">match</span>(<span class="regexp">/&lt;br&gt;/gi</span>) <span class="comment">// [&#x27;&lt;br&gt;&#x27;, &#x27;&lt;br&gt;&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>字符集提供了一种简洁的方式，来表达单个字符的分支。如果想在一个字符串中查找所有的数字，可以使用分支：</p>
<p><strong>具名字符集</strong></p>
<p>\d [0-9]<br>\D [^0-9]<br>\s [\t\v\n \r] 包含制表符、空格和垂直制表符<br>\S [^\t\v\n \r]<br>\w [a-zA-Z_] 破折号和句号没有被包含进来，所以它不能用于域名和 CSS 类<br>\W [^a-za-z_]</p>
<h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><p><strong>重复修饰符</strong></p>
<p><code>&#123;n&#125;</code> 精确 n 次<br>&#x2F;\d{5}&#x2F; 匹配 5 位数字</p>
<p><code>&#123;n,&#125;</code> 至少 n 次<br>&#x2F;\d{5,}&#x2F; 匹配 5 位或 5 位以上数字</p>
<p><code>&#123;n, m&#125;</code> 最少 n 次，最多 m 次<br>&#x2F;\d{2,5}&#x2F; 匹配 2 到 5 位数字</p>
<p><code>?</code> 0 或 1 次，等价于{0,1}<br>&#x2F;[a-z]\d?&#x2F;i 匹配跟随了 0 个或 1 个数字的字符</p>
<p><code>*</code> 0 次或多次<br>&#x2F;[a-z]\d*&#x2F;i 匹配跟随了 0 个或多个数字的字母</p>
<p><code>+</code> 1 次或多次<br>&#x2F;[a-z]\d+&#x2F;i 匹配了至少跟随了 1 个数字的字母</p>
<h3 id="句点元字符和转义"><a href="#句点元字符和转义" class="headerlink" title="句点元字符和转义"></a>句点元字符和转义</h3><p>在正则中，句点是一个特殊的字符，表示“匹配任何内容”（除了新的一行）。通常，这个匹配一切的元字符用来消费哪些输入中并不关心的内容。</p>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>到目前为止，所构造的正则能够识别单个字符（重复允许多次匹配，但这依旧是一个单字符匹配）。而分组则允许构造子表达式，它可以被当作一个独立单元来使用。</p>
<p>除了创建子表达式，分组还可以帮助“捕获”分组结果，以便后续使用。<br>“捕获”结果是默认功能，不过也有办法创建“非捕获组”，这也是接下来要学习的内容。</p>
<p>分组是使用圆括号来指定的，非捕获组看起来像 <code>(?:&lt;subexpression&gt;)</code>，其中<subexpression>是需要匹配的内容</p>
<p>看组例子，假设现在要匹配的后缀为.com .org .edu 的域名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">&#x27;Visit oreilly.com today!&#x27;</span></span><br><span class="line"><span class="keyword">const</span> match = text.<span class="title function_">match</span>(<span class="regexp">/[a-z]+(?:\.com|\.org|\.edu)/i</span>)</span><br></pre></td></tr></table></figure>

<p>分组的另一个好处是可以在分组时使用重复。一般情况下，重复仅被用在重复元字符前面的单个字符上。分组则允许将其用在一整个字符串上。有一个常见的例子是，如果想匹配 URL,以及那些以http:&#x2F;&#x2F;或https:&#x2F;&#x2F;（独立于协议的URL）开始的URL，可以在分组上使用代表匹配0个或1个<code>?</code>的重复元字符：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;link rel=&quot;stylesheet&quot; href=&quot;http://insecure.com/stuff.css&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://secure.com/securestuff.css&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;link rel=&quot;stylehseet&quot; href=&quot;//anything.comflexible.css&quot;&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> matches = html.<span class="title function_">match</span>(<span class="regexp">/(?:https?)?\/\/[a-z][a-z0-9-]+[a-z0-9]+/gi</span>)</span><br></pre></td></tr></table></figure>

<p>以一个非捕获组开始 (?:https?)? ，注意这里有两个匹配 0 或 1 个的重复元字符</p>
<p>第一个表示 https 的 s 是可选的（一般情况下重复元字符只作用于它左边最近的字符）第二个指向它左边的整个组（整体来看，它会匹配空字符串：没有 https、http 或者 https）</p>
<p>继续执行，匹配了两个斜杠 // (必须对斜杠进行转义)<br>然后得到了一个复杂的字符类。</p>
<blockquote>
<p>需要记住一点，使用正则时并不需要一次做完所有事情。事实上，每当浏览网站时，可以先找出所有 URL 或疑似 URL 的东西，然后做二次分析，筛选出那些非法或不完整的 URL 等。 但，为防止注入攻击而检查用户输入等情况就要让正则滴水不漏</p>
</blockquote>
<hr>
<h3 id="懒惰匹配、贪婪匹配"><a href="#懒惰匹配、贪婪匹配" class="headerlink" title="懒惰匹配、贪婪匹配"></a>懒惰匹配、贪婪匹配</h3><p>例：html 文本，想将其中的<code>&lt;i&gt;</code>标签替换成<code>&lt;source&gt;</code>标签，下面是第一次尝试：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> input = <span class="string">`</span></span><br><span class="line"><span class="string">  Regex pros know the difference between</span></span><br><span class="line"><span class="string">  &lt;i&gt;greedy&lt;/i&gt; and &lt;i&gt;lazy&lt;/i&gt; matching.</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">input.<span class="title function_">replace</span>(<span class="regexp">/&lt;i&gt;(.*)&lt;\/i&gt;/gi</span>, <span class="string">&#x27;&lt;strong&gt;$1&lt;/strong&gt;&#x27;</span>)</span><br><span class="line"><span class="comment">// Regex pros know the difference between</span></span><br><span class="line"><span class="comment">// &lt;strong&gt;greedy&lt;/i&gt; and &lt;i&gt;lazy&lt;/strong&gt; matching.</span></span><br></pre></td></tr></table></figure>

<p>我们认识一下正则表达式引擎的工作方式，它只有在找到符合要求的匹配后，才会消费输入并且继续运行。默认情况下，它是通过贪婪模式来实现的，它会找到第一个<code>&lt;i&gt;</code>，然后，在找到<code>&lt;/i&gt;</code>并且确定在这个<code>&lt;/i&gt;</code>之后不存在同样的<code>&lt;/i&gt;</code>，查找都不会停止。因为这里有两个<code>&lt;/i&gt;</code>，所以正则会匹配到第二个<code>&lt;/i&gt;</code>，而非第一个。</p>
<p>这里可以使用重复元字符 * 将其转换成懒惰匹配来解决，在后面添加一个问号即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> input = <span class="string">`</span></span><br><span class="line"><span class="string">  Regex pros know the difference between</span></span><br><span class="line"><span class="string">  &lt;i&gt;greedy&lt;/i&gt; and &lt;i&gt;lazy&lt;/i&gt; matching.</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">input.<span class="title function_">replace</span>(<span class="regexp">/&lt;i&gt;(.*?)&lt;\/i&gt;/gi</span>, <span class="string">&#x27;&lt;strong&gt;$1&lt;/strong&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>与之前相比，该正则除了在*后面加了一个问号，其他完全一样。</p>
<p>所有的重复元字符： _ + ？ {n} {n, } {n, m}都可以在后面跟随一个问号将它变成懒惰的（虽然在实践中，通常只把它和_ + 一起使用过）</p>
<h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>先由简单例子入手，假设想匹配符合 XYXY 格式的乐队名字，所以当希望匹配（PJJP、GOOG、ANNA）这些乐队名时，反向引用就可以登场了。正则表达式中的每个组（包括子组）都被分配了一个数字，从左到右依次是 1，2，3…可以通过在反斜杠后加一个数字的方式来引用特定的组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promo = <span class="string">&#x27;Opening for XAAX is the dynamic GOOG! At the box office now !&#x27;</span></span><br><span class="line"><span class="keyword">const</span> bands = promo.<span class="title function_">match</span>(<span class="regexp">/(?:[A-Z])(?:[A-Z])/g</span>)</span><br><span class="line"><span class="comment">// 使用重音符，是因为我们将单引号和双引号都用过了</span></span><br><span class="line"><span class="keyword">const</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;img alt=&quot;A &#x27;simple&#x27; example.&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;img alt=&quot;Don&#x27;t abuse it!&quot;&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> matches = html.<span class="title function_">match</span>(<span class="regexp">/&lt;img alt=(?:[&#x27;&quot;]).*?/g</span>)</span><br></pre></td></tr></table></figure>

<h3 id="替换组"><a href="#替换组" class="headerlink" title="替换组"></a>替换组</h3><p>分组带来的好处是，可以利用它做一些更加复杂的替换，继续看 HTML 的例子，加入想要去掉一个<code>&lt;a&gt;</code>标签中除了 href 以外的内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> html = <span class="string">`&lt;a class=&quot;nope&quot; href=&quot;/yep&quot;&gt;Yep&lt;/a&gt;`</span></span><br><span class="line"><span class="keyword">let</span> str = html.<span class="title function_">replace</span>(<span class="regexp">/&lt;a .*?(href=&quot;.*?&quot;).*?/</span>, <span class="string">&#x27;&lt;a $1&gt;&#x27;</span>)</span><br><span class="line"><span class="comment">// str -&gt; &quot;&lt;a href=&quot;/yep&quot;&gt;&gt;Yep&lt;/a&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>所有的组都被分配了一个从 1 开始的数字，这个正则表达式中，通过\1 来引用第一个组；而在替换字符串上，用的是$1。注意，在这个表达式中使用懒惰量词是为了防止它在匹配时跨域多个<code>&lt;a&gt;</code>标签。不过，如果<code>&lt;a&gt;</code>标签的 href 属性使用的是单引号而非双号，也会匹配失败。</p>
<p>下面来扩展这个例子，希望保持 class 和 href，依旧删除其他元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> html = <span class="string">`&lt;a class=&quot;yep&quot; href=&quot;/yep&quot; id=&quot;nope&quot;&gt;Yep&lt;/a&gt;`</span></span><br><span class="line"><span class="keyword">let</span> str = html.<span class="title function_">replace</span>(<span class="regexp">/&lt;a .*?(class=&quot;.*?&quot;).*?(href=&quot;.*?&quot;).*?&gt;/</span>, <span class="string">&#x27;&lt;a $2 $1&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>注意在这个表达式中，将 class 和 href 的顺序颠倒了，使得 href 始终先出现，这个表达啊是的问题在于 class 和 href 始终要保持相同的顺序，并且，一旦<code>&lt;a&gt;</code>标签中的属性使用了单引号，就会匹配失败</p>
<p>除了$1,$2,$3…这些组引用，还有$&#96; 匹配项之前的所有内容， $&amp; 匹配目标本身， $’匹配项之后的所有内容，如果想使用一个美元符号，可以使用$$:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="string">&#x27;One two three&#x27;</span></span><br><span class="line">input.<span class="title function_">replace</span>(<span class="regexp">/two/</span>, <span class="string">&#x27;($`)&#x27;</span>) <span class="comment">// &quot;One (One ) three&quot;</span></span><br><span class="line">input.<span class="title function_">replace</span>(<span class="regexp">/\w+/g</span>, <span class="string">&#x27;($&amp;)&#x27;</span>) <span class="comment">// &quot;(One) (two) (three)&quot;</span></span><br><span class="line">input.<span class="title function_">replace</span>(<span class="regexp">/two/</span>, <span class="string">&quot;($&#x27;)&quot;</span>) <span class="comment">// &quot;One ( three) three&quot;</span></span><br><span class="line">input.<span class="title function_">replace</span>(<span class="regexp">/two/</span>, <span class="string">&#x27;($$)&#x27;</span>) <span class="comment">// &quot;One ($) three&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="函数替换"><a href="#函数替换" class="headerlink" title="函数替换"></a>函数替换</h3><p>这是正则最棒的一个特性之一，因为它允许将一个非常复杂的正则表达式拆分成一些简单的表达式。</p>
<p>再来看一个实际修改 HTML 的例子：希望保留 class, id, href 属性并删除其他内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;a class=&quot;foo&quot; href=&quot;/foo&quot; id=&quot;foo&quot;&gt;Foo&lt;/a&gt;</span></span><br><span class="line"><span class="string">  &lt;A href=&#x27;/foo&#x27; Class=&quot;foo&quot;&gt;Foo&lt;/a&gt;</span></span><br><span class="line"><span class="string">  &lt;a href=&quot;/foo&quot;&gt;Foo&lt;/a&gt;</span></span><br><span class="line"><span class="string">  &lt;a onclick=&quot;javascript:alert(&#x27;foo!&#x27;)&quot; href=&quot;/foo&quot;&gt;Foo&lt;/a&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<p>用正则来实现感觉很麻烦，因为变化太多！确实，不过之前说过，并不一定要一次到位。可以通过将表达式拆分成两个，从而大大减少变化的数量：一个用于识别<code>&lt;a&gt;</code>标签，而另一个用于将<code>&lt;a&gt;</code>替换成期望的内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sanitizeATag</span>(<span class="params">aTag</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取标签</span></span><br><span class="line">  <span class="keyword">const</span> parts = aTag.<span class="title function_">match</span>(<span class="regexp">/&lt;a\s+(.*?)&gt;(.*?)&lt;\/a&gt;/i</span>)</span><br><span class="line">  <span class="comment">// parts[1]是&lt;a&gt;标签中间的属性</span></span><br><span class="line">  <span class="comment">// parts[2]是&lt;a&gt;和&lt;/a&gt;中间的内容</span></span><br><span class="line">  <span class="keyword">const</span> attributes = parts[<span class="number">1</span>]</span><br><span class="line">    <span class="comment">// 接下来将其分割成独立的属性</span></span><br><span class="line">    .<span class="title function_">split</span>(<span class="regexp">/\s+/</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&lt;a <span class="subst">$&#123;attributes</span></span></span><br><span class="line"><span class="subst"><span class="string">    .filter(attr =&gt; /^(?:<span class="keyword">class</span>|id|href)[\s=]/i.test(attr))</span></span></span><br><span class="line"><span class="subst"><span class="string">    .join(<span class="string">&#x27; &#x27;</span>)&#125;</span>&gt;</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;parts[<span class="number">2</span>]&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/a&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数比想象中要长，不过为了更加清晰，可以将它分成不同的部分。注意即使在这个函数中，依旧使用了多个正则表达式：一个用来匹配<code>&lt;a&gt;</code>，一个用来切割（使用一个正则表达十来识别一个或多个空格字符）字符串，还有一个用来过滤期望的属性。如果只用一个正则表达式来完成这些工作将会非常复杂。</p>
<p>接下来：在一个包含很多<code>&lt;a&gt;</code>的 HTML 块中使用 sanitizeATag 函数，编写一个只匹配<code>&lt;a&gt;</code>的正则表达式就很简单了：</p>
<pre><code>html.match(/&lt;a .*?&gt;(.*?)&lt;\/a&gt;/ig);
</code></pre>
<p>在匹配时，可以将函数当作一个替换参数传给 String.prototype.replace。目前为止，只 ongoing 过字符串作为替换参数。而使用函数则允许对每一个替换执行一个特定的操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">html.<span class="title function_">replace</span>(<span class="regexp">/&lt;a .*?&gt;(.*?)&lt;\/a&gt;/gi</span>, <span class="keyword">function</span>(<span class="params">m, g1, offset</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`&lt;a&gt; tag found at <span class="subst">$&#123;offset&#125;</span>. contents: <span class="subst">$&#123;g1&#125;</span>&lt;/a&gt;`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*undefined</span></span><br><span class="line"><span class="comment">  undefined</span></span><br><span class="line"><span class="comment">  undefined</span></span><br><span class="line"><span class="comment">  undefined</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// &lt;a&gt; tag found at 3. contents: Foo&lt;/a&gt;</span></span><br><span class="line"><span class="comment">// &lt;a&gt; tag found at 49. contents: Foo&lt;/a&gt;</span></span><br><span class="line"><span class="comment">// &lt;a&gt; tag found at 86. contents: Foo&lt;/a&gt;</span></span><br><span class="line"><span class="comment">// &lt;a&gt; tag found at 111. contents: Foo&lt;/a&gt;</span></span><br></pre></td></tr></table></figure>

<p>传给 String.prototype.replace 的函数会按顺序接收以下参数：</p>
<ul>
<li>整个匹配的字符串(等价于$&amp;)</li>
<li>匹配上的组(如果存在)，有多少个组，这种参数就会有多少个</li>
<li>原始字符串中的匹配偏移量(一个数字)</li>
<li>原始字符串(很少使用到)</li>
</ul>
<p>该函数的返回值就是用来替换正则表达式的字符串。在上例中，没有指定返回值，所以默认返回 undefined。它会被转换成字符串后当作替换字符串使用。上例的重点就是强调这种工作机制，而非真实的转换，所以这里并没有返回最终结果。现在来回顾一下这个例子，有了能够清理单个<code>&lt;a&gt;</code>标签的函数，以及在 HTML 中查找<code>&lt;a&gt;</code>标签的方法，所以可以将它们结合起来使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">html.<span class="title function_">replace</span>(<span class="regexp">/&lt;a .*?&lt;\/a&gt;/gi</span>, sanitizeATag)</span><br></pre></td></tr></table></figure>

<p>当需要从一个大字符串中匹配小字符串，并且还要对小字符串做额外处理时，都可以通过向<code>String.prototype.replace</code>中传入函数来解决这个问题！</p>
<h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>通常，我们会关心一个字符串的开始和结束，或者整个字符串（而不只是一部分），这时<code>锚点</code>就派上用场了。有两种锚点：分别是用于匹配行开始的<code>^</code>，以及用于匹配行结束的<code>$</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="string">&#x27;It was the best of times, it was the worst of times&#x27;</span></span><br><span class="line"><span class="keyword">const</span> begin = input.<span class="title function_">match</span>(<span class="regexp">/^\w+/g</span>) <span class="comment">// &quot;It&quot;</span></span><br><span class="line"><span class="keyword">const</span> end = input.<span class="title function_">match</span>(<span class="regexp">/\w+$/g</span>) <span class="comment">// &quot;times&quot;</span></span><br><span class="line"><span class="keyword">const</span> everything = input.<span class="title function_">match</span>(<span class="regexp">/^.*$/g</span>)</span><br><span class="line"><span class="comment">// &quot;It was the best of times, it was the worst of times&quot;</span></span><br><span class="line"><span class="keyword">const</span> nomatch1 = input.<span class="title function_">match</span>(<span class="regexp">/^best/gi</span>)</span><br><span class="line"><span class="keyword">const</span> nomatch2 = input.<span class="title function_">match</span>(<span class="regexp">/worst$/gi</span>)</span><br></pre></td></tr></table></figure>

<p>关于锚点，一般情况下，它匹配的是整个 字符串的开始和末尾，即使字符串中有换行。如果想把某个字符串当作多行字符串（以换行符分隔）来处理，就需要用到 m(多行选项)：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="string">&#x27;One line\nTwo lines\nThree lines\nFour&#x27;</span></span><br><span class="line"><span class="keyword">const</span> begin = input.<span class="title function_">match</span>(<span class="regexp">/^\w+/gm</span>)</span><br><span class="line"><span class="keyword">const</span> end = input.<span class="title function_">match</span>(<span class="regexp">/\w+$/gm</span>)</span><br></pre></td></tr></table></figure>

<h3 id="单词边界匹配"><a href="#单词边界匹配" class="headerlink" title="单词边界匹配"></a>单词边界匹配</h3><p>正则中一个经常被忽视，但却非常有用的特性。类似开始锚点和行末锚点，单词边界匹配的是\b，取反是\B，它不消费输入内容。单词边界界定为一个\w 匹配之前或之后紧挨着一个\W（非单词字符），或字符串的开始或结尾。来看个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> inputs = [</span><br><span class="line">  <span class="string">&#x27;yinlinshengxiao@gmail.com&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;yinlinshengxiao@gmail.com is my email&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;my email is yinlinshengxiao@gmail.com&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;use yinlinshengxiao@gmail.com, my email&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;my email: yinlinshengxiao@gmail.com.&#x27;</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">  虽然有多种不同情况，这些邮箱有一个共同点：它们都处在单词边界。</span></span><br><span class="line"><span class="string">  单词边界标记的另一个好处是，因为它们不消费输入，所以不用担心“将它们放回”到替换字符串中：</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> emailMatcher = <span class="regexp">/\b[a-z][a-z0-9._-]*@[a-z][a-z0-9_-]+\.[a-z]+(?:\.[a-z]+)?\b/gi</span></span><br><span class="line">inputs.<span class="title function_">map</span>(<span class="function"><span class="params">s</span> =&gt;</span> s.<span class="title function_">replace</span>(emailMatcher, <span class="string">&#x27;&lt;a href=&quot;mailto:$&amp;&quot;&gt;$&amp;&lt;/a&gt;&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>当需要搜索以外的单词开始、结束或包含其他单词的文本时，使用单词边界也非常方便。例如：&#x2F;\bcount&#x2F; 会找到 count countdown， 但不会找到 discount recount 等。而 &#x2F;\bcount\B&#x2F;只能找到 countdown，&#x2F;\Bcount\b&#x2F;会找到 discount 和 recount，而 &#x2F;\Bcount\B&#x2F;只能找到 accountable</p>
<h3 id="向前查找"><a href="#向前查找" class="headerlink" title="向前查找"></a>向前查找</h3><p>与锚点和单词边界元字符一样，它不消费输入。然而，不同于锚点和单词边界的是，它们是通用的，可以匹配任何子表达式却不消费它。事实上，正如单词边界元字符，向前查找的这种不消费的特性，解决了有时候不得不进行“原封不动”的替换问题。只要有内容重复，向前查找就是必须的，而且他们可以简化某些特定类型的匹配。</p>
<p>例子：验证密码是否符合预设规则</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">validPassword</span>(<span class="params">p</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="regexp">/[A-Z]/</span>.<span class="title function_">test</span>(p) &amp;&amp;</span><br><span class="line">    <span class="regexp">/[0-9]/</span>.<span class="title function_">test</span>(p) &amp;&amp;</span><br><span class="line">    <span class="regexp">/[a-z]/</span>.<span class="title function_">test</span>(p) &amp;&amp;</span><br><span class="line">    !<span class="regexp">/[^a-zA-Z0-9]/</span>.<span class="title function_">test</span>(p)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 假设想将它们组合成一个正则表达式：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">validPassword</span>(<span class="params">p</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/[A-Z].*[0-9][a-z]/</span>.<span class="title function_">test</span>(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该表达式对顺序有要求，不仅要求大写字母出现在数字之前，数字出现在两个小写字母前，而且没有对非法字符做任何校验。实际上也没有有个好办法可以实现它，因为字符在正则表达式运行时就被消费了。</p>
<p><code>向前查找</code>通过不消费输入来解决这个问题，本质上每个向前查找都是一个不消费输入的独立正则表达式，在 JS 中，向前查找是这样的 <code>(?=&lt;subexpression&gt;)</code>, 还有一个“否定向前查找” <code>:(?!&lt;subexpression&gt;)</code> 只会匹配不存在于子表达式中的内容。下面继续来重写上面的验证密码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">validPassword</span>(<span class="params">p</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/(?=.*[A-Z])(?=.*[0-9])(?=.*[a-z])(?!.*[^a-zA-Z0-9])/</span>.<span class="title function_">test</span>(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该例子展示了向前检查（以及否定向前检查）的一个重要场景。</p>
<h3 id="动态构造正则表达式"><a href="#动态构造正则表达式" class="headerlink" title="动态构造正则表达式"></a>动态构造正则表达式</h3><p>这里提倡优先使用正则表达式字面语法而非构造器，因为不用对反斜杠进行转义。需要使用构造器的地方是动态构造。例如，想在一个字符串中匹配一个包含多个用户名的数组，但却没有办法将这些用户名整合在一个正则表达式字面量中。此时正则构造器就有用了，它可以通过字符串来构造正则表达式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> users = [<span class="string">&#x27;mary&#x27;</span>, <span class="string">&#x27;nick&#x27;</span>, <span class="string">&#x27;arthur&#x27;</span>, <span class="string">&#x27;sam&#x27;</span>, <span class="string">&#x27;yevtte&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> text =</span><br><span class="line">  <span class="string">&#x27;User @arthur started the backup and 15:15, &#x27;</span> +</span><br><span class="line">  <span class="string">&#x27;and @nick and @yvette restored it at 18:35.&#x27;</span></span><br><span class="line"><span class="keyword">const</span> userRegexp = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">`@(?:<span class="subst">$&#123;users.join(<span class="string">&#x27;|&#x27;</span>)&#125;</span>)\\b`</span>, <span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">text.<span class="title function_">match</span>(userRegexp)</span><br></pre></td></tr></table></figure>

<p>与该例正则等价的字面量是： <code>/@(?:mary|nick|arthur|sam|yevtte)\b/g</code><br>需要注意的是：必须在 b 单词边界元字符之前使用双反斜杠</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一篇已经涉及了正则表达式中的主要知识点，但对于正则中包含的技术、例子和其固有的复杂性，也只是浅尝辄止。想要深入学习正则表达式，需要更多的练习与理解，那么以后在工作与学习中多多运用进去吧。</p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】深入理解ES6——JavaScript中的类</title>
    <url>/2017/08/02/5edaf270-af91-11ee-b378-bbe5a3ca1cae/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>理解类的基本原理有助于理解ES6中类的特性，在该篇文章里我们先探讨ES5语法是如何实现类似特性的，再对比ES6的语法对比来学习</p>
</blockquote>
<p>首先，你要知道的是ES6中的类和Java等其他面向对象编程语言是完全不同的。 当然，这是我说的… 我们可认为这是ES6之前实现类及继承的一些语法糖，实则还是面向对象的形式。</p>
<span id="more"></span>

<h2 id="使用ES6的类语法"><a href="#使用ES6的类语法" class="headerlink" title="使用ES6的类语法"></a>使用ES6的类语法</h2><p>首先我们要知道的是，ESMAScript5及早期版本中是没有类的概念的。<br>最相近的思路是创建一个自定义类型，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayname</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;fri&#x27;</span>);</span><br><span class="line">person.<span class="title function_">sayname</span>(); <span class="comment">// &#x27;fri&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面的代码首先创造一个构造函数，然后定义方法并赋值给构造函数的原型，从而实现继承。</p>
<h3 id="基本类声明"><a href="#基本类声明" class="headerlink" title="基本类声明"></a>基本类声明</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 等价于上面的Person构造函数</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 等价于Person.prototype.sayname</span></span><br><span class="line">  <span class="title function_">sayname</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;fri&#x27;</span>);</span><br><span class="line">person.<span class="title function_">sayname</span>(); <span class="comment">// &#x27;fri&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Person</span>); <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayname</span>); <span class="comment">// &#x27;function&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通过对比，可以看出，这里通过在<code>constructor</code>方法名来定义构造函数，<code>其私有属性是实例中的属性，不会出现在原型上，且只有在类的构造函数或方法中创建</code>，上面的name就是一个私有属性</p>
<p>类声明仅仅是基于已有自定义类型声明的语法糖。所以，<code>Person</code>声明实际上创建了一个具有构造函数方法行为的函数。</p>
<hr>
<h3 id="为何使用类语法"><a href="#为何使用类语法" class="headerlink" title="为何使用类语法"></a>为何使用类语法</h3><p>尽管类与自定义类型之间拥有诸多相似处，但我们更需牢记以下差异性：</p>
<ul>
<li>函数声明可以被提升，而类声明与let声明类似，不能被提升；真正执行声明语句之前，它们会一直存在于临时死区中</li>
<li>类声明中的所有代码将自动运行在严格模式下，而且无法强行让代码脱离严格模式执行</li>
<li>在自定义类型中，需要通过<code>Object.defineProperty()</code>方法手工制定某个方法为不可枚举；而在类中，所有方法都是不可枚举的</li>
<li>每个类都有一个名为[[Construct]]的内部方法，通过关键字new调用那些不含[[Construct]]的方法会导致程序抛出错误</li>
<li>使用除关键字new以外的方式调用类的构造函数会导致程序抛出错误</li>
<li>在类中修改类名会导致程序报错</li>
</ul>
<h3 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h3><p><strong>基本的类表达式语法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = <span class="keyword">class</span> &#123;</span><br><span class="line">  <span class="comment">// ... 代码省略，和上面的类一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ol>
<li>类表达式不需要标识符在类后</li>
<li>类表达式在功能上等价于类声明</li>
<li>类声明和类表达式均不会被提升</li>
</ol>
<p>接第3点，二者最重要的区别是，name属性不同，匿名类表达式的name属性值是一个空字符串，而类声明的name属性值为类名。</p>
<p><strong>命名类表达式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = <span class="keyword">class</span> <span class="title class_">Person2</span> &#123;</span><br><span class="line">  <span class="comment">// ...代码省略, 同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于标识符 Person2只存在于类定义中，因此它可被用在像sayname()这样的方法中，而在类外部，不存在名为Person2的绑定，因而typeof Person2的值为undefined</p>
<p>在JS引擎中，类表达试的实现与类声明稍有不同。类声明通过<code>let定义的外部绑定</code>与通过<code>const定义的内部绑定</code>具有相同名称；而<code>命名类表达式通过const定义</code>名称，从而上例的Person2只能在类内部使用。</p>
<h3 id="作为一等公民的类"><a href="#作为一等公民的类" class="headerlink" title="作为一等公民的类"></a>作为一等公民的类</h3><blockquote>
<p>在程序中，一等公民是制一个可以传入函数，可从函数返回，且可赋值给变量的值。</p>
</blockquote>
<p>那么，JS中的函数自然是一等公民，类其实就是这样一个语法糖所以也是一等公民。JS允许通过多种方式使用类的特性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例，可以将类作为参数传入函数中</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createObject</span>(<span class="params">classDef</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">classDef</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="title function_">createObject</span>(<span class="keyword">class</span> &#123;</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">obj.<span class="title function_">sayHi</span>(); <span class="comment">// &#x27;Hi&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上例通过调用<code>createObject()</code>函数时传入一个匿名类表达式作为参数，然后通过new实例化这个类并返回其实例赋值给变量obj。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="keyword">class</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayname</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="string">&#x27;fri&#x27;</span>);</span><br><span class="line">person.<span class="title function_">sayname</span>(); <span class="comment">// &#x27;fri&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这里创建一个立即执行的匿名类表达式，此模式可以使用类语法创建单例，且不会在作用域中暴露类的引用，后面的小括号表明正在调用函数，所以可给函数传参。</p>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>尽管应该在类构造函数中创建其属性，但类也支持直接在原型上定义访问器属性。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomHtmlElement</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">element</span> = element;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">html</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">element</span>.<span class="property">innerHTML</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">html</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">element</span>.<span class="property">innerHTML</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnpropertyDescriptor</span>(<span class="title class_">CustomHtmlElement</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;html&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get&#x27;</span> <span class="keyword">in</span> descriptor); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set&#x27;</span> <span class="keyword">in</span> descriptor); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>代码中CustomHtmlElement类是一个针对现有DOM元素的包装器，通过getter和setter方法将元素的innerHTML方法委托给html属性，该属性访问器是在CustomHtmlElement.prototype上创建的，与其他方法相同，创建时声明该属性不可枚举</p>
<h3 id="可计算成员名称"><a href="#可计算成员名称" class="headerlink" title="可计算成员名称"></a>可计算成员名称</h3><p>类和对象字面量有很多相似处，类方法和访问器属性支持使用可计算名称，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mothodName = <span class="string">&#x27;sayName&#x27;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过变量来给类定义中的方法命名</span></span><br><span class="line">  [methodName]() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;fri&#x27;</span>);</span><br><span class="line">me.<span class="title function_">sayName</span>(); <span class="comment">// &#x27;fri&#x27; </span></span><br></pre></td></tr></table></figure>

<p>通过相同方式可以在属性⑦属性中计算可计算名称</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> propertyName = <span class="string">&#x27;html&#x27;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomHtmlElement</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">element</span> = element;</span><br><span class="line">  &#125;</span><br><span class="line">  get [propertyName]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">element</span>.<span class="property">innerHTML</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  set [propertyName](value) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">element</span>.<span class="property">innerHTML</span> = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里通过propertyName变量并使用<code>getter</code>和<code>setter</code>方法为类添加html属性，且可像往常一样通过 <code>.html</code>访问该属性</p>
<h3 id="生成器方法"><a href="#生成器方法" class="headerlink" title="生成器方法"></a>生成器方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  *<span class="title function_">createIterator</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="keyword">let</span> iterator = instance.<span class="title function_">createIterator</span>();</span><br></pre></td></tr></table></figure>

<p>以上代码创建了MyClass类，它有一个生成器方法<code>createIterator</code>，其返回值为一个硬编码在生成器中的迭代器。<br>如果想要类是用来表示集合的，那么为它定义一个默认迭代器会更好，例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Collection</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  *[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">yield</span> *<span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">values</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> collection = <span class="keyword">new</span> <span class="title class_">Collection</span>();</span><br><span class="line">collection.<span class="property">items</span>.<span class="title function_">push</span>(<span class="number">1</span>);</span><br><span class="line">collection.<span class="property">items</span>.<span class="title function_">push</span>(<span class="number">2</span>);</span><br><span class="line">collection.<span class="property">items</span>.<span class="title function_">push</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> collection) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>现在可以将Collection的实例用于for-of循环中，或用展开运算符操作。</p>
<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>ES5之前我们通常这么来用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">create</span> = <span class="keyword">function</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例方法</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayname</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="title class_">Person</span>.<span class="title function_">create</span>(<span class="string">&#x27;fri&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>由于工厂方法<code>Person.create()</code>使用的数据不依赖Person的实例，因而其会被认为是一个静态方法。<br>ES6的类语法简化了该过程，下面我们用ES6语法重写上面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 等价于Person构造函数</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 等价于Person.prototype.sayname</span></span><br><span class="line">  <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 等价于Person.create</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">create</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="title class_">Person</span>.<span class="title function_">create</span>(<span class="string">&#x27;fri&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>Person有一个静态方法<code>create()</code>，它的语法与sayname()的区别只在于是否使用<code>static关键字</code>。<br>类中的所有方法和访问器属性都可以用static关键字来定义，唯一的限制是不能将static用于定义构造函数方法。</p>
<p>注：不可在实例中访问静态成员，必须要直接在类中访问静态成员</p>
<h3 id="继承与派生类"><a href="#继承与派生类" class="headerlink" title="继承与派生类"></a>继承与派生类</h3><p>同样的，我们来看看ES5的写法，再对比下ES6写法来学习</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Rectangle</span>(<span class="params">length, width</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">length</span> = length;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">width</span> = width;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Rectangle</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getArea</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span> * <span class="variable language_">this</span>.<span class="property">width</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Square</span>(<span class="params">length</span>) &#123;</span><br><span class="line">  <span class="title class_">Rectangle</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, length, length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Square</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Rectangle</span>.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">  <span class="attr">constructor</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="title class_">Square</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> <span class="title class_">Square</span>(<span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(square.<span class="title function_">getArea</span>()); <span class="comment">// 9</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(square <span class="keyword">instanceof</span> <span class="title class_">Square</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(square <span class="keyword">instanceof</span> <span class="title class_">Rectangle</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>为了实现继承，必须用一个创建自<code>Rectangle.prototype</code>的新对象重写<code>Square.prototype</code>，并调用Rectangle.call()方法。<br>那么我们看下ES6能做哪些简化，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length, width</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span> = length;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">width</span> = width;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getArea</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span> * <span class="variable language_">this</span>.<span class="property">width</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Rectangle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length</span>) &#123;</span><br><span class="line">    <span class="comment">// 等价于Rectangle.call(this, length, length)</span></span><br><span class="line">    <span class="variable language_">super</span>(length, length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> square = <span class="keyword">new</span> <span class="title class_">Square</span>(<span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(square.<span class="title function_">getArea</span>()); <span class="comment">// 9</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(square <span class="keyword">instanceof</span> <span class="title class_">Square</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(square <span class="keyword">instanceof</span> <span class="title class_">Rectangle</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Square类通过<code>extends关键字</code>继承Rectangle类，在Square构造函数中通过super()调用Rectangle构造函数并传入相应参数。<br>继承自其他类的类被称作为派生类，如果在派生类中指定了构造函数则必须要调用super()。<br>如果选择不使用构造函数，则当创建新的类实例时会自动调用super()并传入所有参数</p>
<p><strong>使用super()注意事项</strong></p>
<ul>
<li>只可在派生类的构造函数中使用super()</li>
<li>在构造函数中访问this之前一定要调用super() <code>它负责初始化this</code></li>
<li>若不想调用super()，唯一方法是让类的构造函数返回一个对象</li>
</ul>
<h3 id="类方法遮蔽"><a href="#类方法遮蔽" class="headerlink" title="类方法遮蔽"></a>类方法遮蔽</h3><p>派生类中的方法总会覆盖基类中的同名方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Rectangle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(length, length);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 覆盖并遮蔽Rectangle.prototype.getArea()方法</span></span><br><span class="line">  <span class="title function_">getArea</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span> * <span class="variable language_">this</span>.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于Square里定义了getArea方法，便不能在Square的实例中调用Rectangle.prototype.getArea方法。若想调用，可如下使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Rectangle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(length, length);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 覆盖遮蔽后调用Rectangle.prototype.getArea()</span></span><br><span class="line">  <span class="title function_">getArea</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">getArea</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以这种方法使用super，this的值会被自动正确设置</p>
<h3 id="静态成员继承"><a href="#静态成员继承" class="headerlink" title="静态成员继承"></a>静态成员继承</h3><p>如果基类有静态成员，那么这些静态成员在派生类中也可用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length, width</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span> = length;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">width</span> = width;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getArea</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span> * <span class="variable language_">this</span>.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">create</span>(<span class="params">length, width</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectagnle</span>(length, width);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Rectangle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length</span>) &#123;</span><br><span class="line">    <span class="comment">// 等价于Rectangle.call(this, length, length)</span></span><br><span class="line">    <span class="variable language_">super</span>(length, length)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> rect = <span class="title class_">Square</span>.<span class="title function_">create</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rect <span class="keyword">instanceof</span> <span class="title class_">Rectangle</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rect.<span class="title function_">getArea</span>()); <span class="comment">// 12</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rect <span class="keyword">instanceof</span> <span class="title class_">Square</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>以上代码中，新的静态方法create()被添加到Rectangle类中，继承后的Square.create()与Rectangle.create()的行为相似</p>
<h3 id="派生自表达式的类"><a href="#派生自表达式的类" class="headerlink" title="派生自表达式的类"></a>派生自表达式的类</h3><p>只要表达式可以被解析为一个函数并且具有[[Construct]]属性和原型，那么就可以用extends进行派生。我们还是由下面的例子来看：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Rectangle</span>(<span class="params">length, width</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">length</span> = length;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">width</span> = width;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Rectangle</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getArea</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span> * <span class="variable language_">this</span>.<span class="property">width</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Rectangle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(length, width);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="title class_">Square</span>(<span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">getArea</span>()); <span class="comment">// 9</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x <span class="keyword">instanceof</span> <span class="title class_">Rectangle</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Rectagnle是ES5风格的构造函数，Square是一个类，由于Rectangle具有[[Construct]]属性和原型，因此Square类可以直接继承它。<br>由于可以动态确定使用哪个基类，因而可以创建不同的继承方法。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">SerializableMixin</span> = &#123;</span><br><span class="line">  <span class="title function_">serialize</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">AreaMixin</span> = &#123;</span><br><span class="line">  <span class="title function_">getArea</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span> * <span class="variable language_">this</span>.<span class="property">width</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mixin</span>(<span class="params">...mixins</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> base = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">assign</span>(base.<span class="property"><span class="keyword">prototype</span></span>, ...mixins);</span><br><span class="line">  <span class="keyword">return</span> base;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_ inherited__">mixin</span>(<span class="title class_">AreaMixin</span>, <span class="title class_">SerializableMixin</span>) &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span> = length;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">width</span> = length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="title class_">Square</span>(<span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">getArea</span>()); <span class="comment">// 9</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">serialize</span>()); <span class="comment">// &quot;&#123;&quot;length&quot;: 3, &quot;width&quot;: 3&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>mixin函数会用所有mixin对象的自有属性动态填充新函数的原型，如果多个mixin对象具有相同的属性，那么只有最后一个被添加的属性被保留</p>
<blockquote>
<p>在<code>extends</code>后可以使用任意表达式，但不是所有表达式最终都能生成合成的类。如果使用null或生成器函数会导致错误，类在这些情况下没有[[Construct]]属性，尝试为其创建新的实例会导致程序无法调用[[Construct]]而报错</p>
</blockquote>
<h3 id="内建对象的继承"><a href="#内建对象的继承" class="headerlink" title="内建对象的继承"></a>内建对象的继承</h3><p>在ES5的传统继承方式中，先由派生类型创建this的值，然后调用基类型的构造函数。this的值开始指向构造函数的实例，但是随后会被来自内建对象的其他属性所修饰。<br>ES6中的类则于之相反，先由基类创建this的值，然后派生类的构造函数再修改这个值，所以一开始可以通过this访问基类的所有内建功能，然后再正确地接受所有与之相关的功能。<br>以下示例是一个基于类生成特殊数组的实践：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="title class_">MyArray</span>();</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors.<span class="property">length</span>); <span class="comment">// 1</span></span><br><span class="line">colors.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors[<span class="number">0</span>]); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol-species属性"><a href="#Symbol-species属性" class="headerlink" title="Symbol.species属性"></a>Symbol.species属性</h3><p>内建对象继承的一个使用之处是，原本在内建对象中返回实例自身的方法将自动返回派生类的实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> items = <span class="keyword">new</span> <span class="title class_">MyArray</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>),</span><br><span class="line">  subitems = items.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(items <span class="keyword">instanceof</span> <span class="title class_">MyArray</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(subitems <span class="keyword">instanceof</span> <span class="title class_">MyArray</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这里slice()方法返回的是MyArray的实例，浏览器引擎背后是通过<code>Symbol.species</code>属性实现这一行为的</p>
<p>该属性用于定义返回函数的静态访问器属性，每当要在实例的方法中创建类的实例时必须使用这个构造函数。</p>
<p><strong>以下这些内建类型均已定义Symbol.species属性：</strong></p>
<ul>
<li>Array</li>
<li>ArrayBuffer</li>
<li>Map</li>
<li>Promise</li>
<li>RegExp</li>
<li>Set</li>
<li>Typed arrays</li>
</ul>
<p>列表中的每个类型都有一个默认的Symbol.species属性，该属性的返回值为this，这也意味着该属性总会返回构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> get [<span class="title class_">Symbol</span>.<span class="property">species</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="variable language_">this</span>.<span class="property">constructor</span>[<span class="title class_">Symbol</span>.<span class="property">species</span>](<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该例中<code>Symbol.species</code>被用来给MyClass赋值静态访问器属性，这里只有getter而没有setter方法，因为在这里不可以改变类的种类。<br>调用<code>this.constructor[Symbol.species]</code>会返回MyClass，clone方法通过这个定义可以返回新的实例，从而允许派生类覆盖这个值</p>
<h3 id="在类的构造函数中使用new-target"><a href="#在类的构造函数中使用new-target" class="headerlink" title="在类的构造函数中使用new.target"></a>在类的构造函数中使用new.target</h3><p>来类的构造函数中也可以通过new.target来确定类是如何被调用的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length, width</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Rectangle</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span> = length;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">width</span> = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// new.target的值是Rectangle</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上例当调用<code>new Rectangle(3,4)</code>时等价于Rectangle的new.target。类构造函数必须通过new关键字调用，所以总是在类的构造函数中定义new.target属性，但是其值有时不同，我们来看另一个例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length, width</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Rectangle</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span> = length;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">width</span> = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Rectangle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(length, length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// new.target的值是Square</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Square</span>(<span class="number">3</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>这里的super调用了Rectangle的构造函数，所以当调用发生时new.target等于Square。每个构造函数可以根据自身被调用的方式改变自己的行为，我们再来看个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Shape</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;这个类不能直接被实例化&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length, width</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span> = length;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">width</span> = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="title class_">Shape</span>(); <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y <span class="keyword">instanceof</span> <span class="title class_">Shape</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>每当new.target是Shape的构造函数时总会报错，但仍可用Shape作为基类派生其他类。<br>super()调用实行了Shape的构造函数，new.target与Rectangle等价，所以构造函数继续执行不会报错。</p>
<p>注：类必须通过new关键字才能调用，所以在类的构造函数中，new.target属性永远不会是undefined</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>ES6的类语法作为ES5传统继承模型的语法糖出现，但又降低了其风险</li>
<li>通过类在原型上定义非静态方法与原型继承协同工作，而静态方法最终放在构造函数上</li>
<li>类里的静态方法都是不可枚举的，从而可以更好地匹配内建对象的行为</li>
<li>类构造函数必须通过new关键字调用，以确保不会意外地将类作为函数去调用</li>
<li>基于类的继承可以通过函数调用确定最终要继承哪一个类，也可通过mixin对象和其他不同组合模式来创建新类</li>
<li>类构造函数中，可通过new.target随着类被调用的多种方式而做出不同的对应</li>
</ol>
<hr>
<p>以上… 终于耐着性子读完，写完了~~ 总之，对于自己来说还算挺有收获。<br>坚持学习，慢慢成长，欢迎关注，谢谢你的阅读。</p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Class</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】深入理解ES6——Promise与异步编程</title>
    <url>/2017/08/12/4b486b20-af91-11ee-818e-cdb2cca63b90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>Promise可以实现其他语言类似Future和Deferred一样的功能，是另一种异步编程的选择。它既可以像事件和回调函数一样指定稍后执行的代码，也可以明确指示代码是否成功执行。本文重在讨论Promise是如何运转的，所以实践和代码依然是我们的重点，要完全理解其原理，了解构建Promise的一些基本概念尤为重要。</p>
</blockquote>
<span id="more"></span>

<h2 id="异步编程相关知识点"><a href="#异步编程相关知识点" class="headerlink" title="异步编程相关知识点"></a>异步编程相关知识点</h2><p>我们知道的JS是单线程，具体来说：JavaScritp引擎同一时刻只允许执行一个代码块。那么就需要跟踪即将运行的代码块，那些代码块将被添加到任务队列。每当JavaScript引擎中的一段代码结束执行，事件循环会执行队列中的下一个任务，它（事件循环）是JS引擎中的一段程序，负责监控代码执行并管理任务队列。</p>
<h3 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h3><p>我们先来看一段代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#btn&#x27;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;clicked!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单击btn会打印出 clicked 来，这个过程是先赋值给onclick的函数被添加到任务队列中，只有前面的任务都完成后它才会被执行</p>
<h3 id="回调模式"><a href="#回调模式" class="headerlink" title="回调模式"></a>回调模式</h3><p>回调模式与事件模型类似，异步代码都会在未来的某个时间点执行，二者区别是回调函数中被调用的函数是作为参数传入的，示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">readFile</span>(<span class="string">&#x27;example.txt&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, contents</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(contents);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>readFile执行，但当去读取文件时就会暂停，转而执行后面的程序，打印出了hi，当readFile()结束执行时，会向任务队列的末尾添加一个新任务，该任务包含回调函数及相应的参数，当队列前面所有的任务完成才执行该任务，并最终执行<code>console.log(contents)</code></p>
<p>现在来看还是很方便的，但如果执行的回调任务多了…… 那么头皮发麻是一定的…… 所以 -&gt; 才有了后面的Promise ~ 只有生成器、Async啥的放后面来说了，扎扎实实打基础先。</p>
<h2 id="Promise基础"><a href="#Promise基础" class="headerlink" title="Promise基础"></a>Promise基础</h2><p>Promise相当于异步操作结果的占位符，它既不订阅也不传回调，而是让函数返回一个Promise</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// readFile承诺将在未来的某个时刻完成</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="title function_">readFile</span>(<span class="string">&#x27;exm.txt&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>这段代码，readFile()并不会立即开始读取文件，函数会先返回一个表示异步读取操作的Promise对象，未来对这个对象的操作完全取决于Promise的生命周期。</p>
<h3 id="Promise的生命周期"><a href="#Promise的生命周期" class="headerlink" title="Promise的生命周期"></a>Promise的生命周期</h3><ul>
<li>Fulfilled Promise异步操作成功完成</li>
<li>Rejected  Promise异步操作未能成功完成</li>
</ul>
<p>内部属性[[PromiseState]]被用来表示Promise的三种状态：<code>pending</code>、<code>fulfilled</code>及<code>rejected</code>。只有当Promise的状态改变时，通过then()方法来采取特定的行动。<br>Promise具有then方法，它接受两个参数，第一个是当Promise状态转变为fulfilled时要调用的函数；第二个是当Promise状态变为rejected时要调用的函数。</p>
<blockquote>
<p>如果一个对象实现了上述的then()方法，那这个对象我们称之为thenable对象。所有的Promise都是thenable对象</p>
</blockquote>
<p>每次调用then或catch方法都会创建一个新任务，当Promise被resolved时执行，这些任务最终会被加入到一个为Promise量身定制的队列中</p>
<h3 id="创建未完成的Promise"><a href="#创建未完成的Promise" class="headerlink" title="创建未完成的Promise"></a>创建未完成的Promise</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Node.js示例</span></span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readFile</span>(<span class="params">filename</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 触发异步操作</span></span><br><span class="line">    fs.<span class="title function_">readFile</span>(filename, &#123;<span class="attr">encoding</span>: <span class="string">&#x27;utf8&#x27;</span>&#125;, <span class="function">(<span class="params">err, contents</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 检查是否有错</span></span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 成功读取文件</span></span><br><span class="line">      <span class="title function_">resolve</span>(contents);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> promise = <span class="title function_">readFile</span>(<span class="string">&#x27;example.txt&#x27;</span>);</span><br><span class="line"><span class="comment">// 同时监听执行完成和执行被拒</span></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">contents</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 完成</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(contents);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 拒绝</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="全局的Promise拒绝处理"><a href="#全局的Promise拒绝处理" class="headerlink" title="全局的Promise拒绝处理"></a>全局的Promise拒绝处理</h2><p>有关Promise的其中一个最具争议的问题是，如果没有拒绝处理程序的情况下拒绝一个Promise，那么不会提示失败信息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">42</span>);</span><br><span class="line"><span class="comment">// 此rejected还没有被处理</span></span><br><span class="line">rejected.<span class="title function_">catch</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 现在rejected已经被处理了</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="我们来看看在Node-js环境下的拒绝处理"><a href="#我们来看看在Node-js环境下的拒绝处理" class="headerlink" title="我们来看看在Node.js环境下的拒绝处理"></a>我们来看看在Node.js环境下的拒绝处理</h3><ul>
<li>unhandledRejection 在一个<code>事件循环中</code>，当Promise被拒绝，并且没有提供拒绝处理程序时被调用</li>
<li>rejectionHandled 在一个<code>事件循环后</code>，当Promise被拒绝，并且没有提供拒绝处理程序时被调用</li>
</ul>
<p>我们还是来看一下实际代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected;</span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;unhandledRejection&#x27;</span>, <span class="function">(<span class="params">reason, promise</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(reason.<span class="property">message</span>); <span class="comment">// &#x27;explosion&#x27;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(rejected === promise); <span class="comment">// true</span></span><br><span class="line">&#125;)</span><br><span class="line">rejected = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Explosion&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>以上代码创建了一个已拒绝的Promise和一个错误对象，并监听了unhandledRejection事件，事件处理程序分别接受错误对象和Promise作为它的两个参数。<br>rejectionHandled事件处理程序只有一个参数——被拒绝的Promise：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected;</span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;rejectionHandled&#x27;</span>, <span class="function"><span class="params">promise</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(rejected === promise); <span class="comment">// true  </span></span><br><span class="line">&#125;);</span><br><span class="line">rejected = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Explosion&#x27;</span>));</span><br><span class="line"><span class="comment">// 等待添加拒绝错误处理</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  rejected.<span class="title function_">catch</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="property">message</span>);  <span class="comment">// &#x27;Explosion&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>这里的rejectionHandled事件在拒绝处理程序最后被调用时触发，如果在创建rejected之后直接添加拒绝处理程序，那么rejectionHandled事件不会被触发，因为rejected创建的过程与拒绝处理程序的调用在同一个事件循环中，此时rejectionHandled事件尚未生效。</p>
<h3 id="浏览器环境的拒绝处理"><a href="#浏览器环境的拒绝处理" class="headerlink" title="浏览器环境的拒绝处理"></a>浏览器环境的拒绝处理</h3><p>浏览器也是通过触发两个事件来识别未处理的拒绝的，虽然这些事件是在window对象上触发的，但实际上与Node.js中的完全等效</p>
<ul>
<li>unhandledrejection 同上Node.js</li>
<li>rejectionhandled 同上Node.js</li>
</ul>
<p>在Node.js的实现中，事件处理程序接受多个独立参数，而在浏览器中，事件处理程序接受一个有以下属性的事件对象作为参数：</p>
<ul>
<li>type 事件名称（’unhandledrejection’或’rejectionhandled’）</li>
<li>promise 被拒绝的Promise对象</li>
<li>reason 来自Promise的拒绝值</li>
</ul>
<p>浏览器实现中固定另一处不同是，在两个事件中都可以使用拒绝值reason，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onhandledrejection</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">type</span>); <span class="comment">// &#x27;unhandledrejection&#x27;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">reason</span>.<span class="property">message</span>); <span class="comment">// &#x27;Explosion&#x27;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(rejected === event.<span class="property">promise</span>); <span class="comment">// true</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onrejectionhandled</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">type</span>); <span class="comment">// &#x27;rejectionhandled&#x27;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">reason</span>.<span class="property">message</span>); <span class="comment">// &#x27;Explosion&#x27;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(rejected === event.<span class="property">promise</span>); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line">rejected = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Explosion&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>以上Node.js环境与浏览器环境中的处理差不多，区别在于，事件处理程序中检索信息的位置不同。</p>
<h2 id="串联Promise"><a href="#串联Promise" class="headerlink" title="串联Promise"></a>串联Promise</h2><p>每次调用then或catch方法时实际上创建并返回了另一个Promise，只有当第一个Promise完成或被拒绝后，第二个才会被解决，示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line">&#125;)</span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Finished&#x27;</span>))</span><br><span class="line"><span class="comment">// 42</span></span><br><span class="line"><span class="comment">// Finished</span></span><br></pre></td></tr></table></figure>

<p>调用p1.then后返回第二个Promise，然后又调用then，只有当第一个Promise被解决后才会调用第二个then的完成处理程序，如果将拆开，可写成如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value));</span><br><span class="line">p2.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Finished&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>在这个非串联版本的代码中，调用p1.then()的结果被存储在了p2中，然后p2.then()被调用来添加最终的完成处理程序。</p>
<h3 id="捕捉错误"><a href="#捕捉错误" class="headerlink" title="捕捉错误"></a>捕捉错误</h3><p>在之前的示例中，完成处理程序或拒绝处理程序中可能发生错误，而Promise链可以用来捕获这些错误</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Boom&#x27;</span>))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>));</span><br></pre></td></tr></table></figure>

<p>p1完成处理程序，而后抛错，链式调用第二个Promise的catch方法后，可以通过它的拒绝处理程序接收这个错误，如果拒绝处理程序抛出错误，也可以通过相同的方式接收到这个错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Explosion&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error.<span class="property">message</span>); <span class="comment">// &#x27;Explosion&#x27;</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Boom&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>); <span class="comment">// &#x27;Boom&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>此处的执行器抛出错误并触发Promise p1的拒绝处理程序，这个处理程序又抛出另一个错，并且第二个Promise拒绝处理程序捕获，链式Promise调用可以感知到链中其他Promise错误。</p>
<p>注：务必在Promise链的末尾留有一个拒绝处理程序以确保能正确处理所有可能发生的错误</p>
<h3 id="Promise链的返回值"><a href="#Promise链的返回值" class="headerlink" title="Promise链的返回值"></a>Promise链的返回值</h3><p>Promise链可以给下游Promise传递数据。 上面代码很多都已经显示出了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="number">66</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.<span class="title function_">catch</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// &#x27;66&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> value + <span class="number">1</span>;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value)); <span class="comment">// &#x27;67&#x27;</span></span><br></pre></td></tr></table></figure>

<p>执行器调用reject方法向Promise的拒绝处理程序传入值66，最终返回value+1。拒绝处理程序中返回的值仍可用在下一个Promise的完成处理程序中，在必要时，即使其中一个Promise失败也能恢复整条链的执行。</p>
<h3 id="Promise链中返回Promise"><a href="#Promise链中返回Promise" class="headerlink" title="Promise链中返回Promise"></a>Promise链中返回Promise</h3><p>同样的还是来看例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">8</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 第一个完成处理程序</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 6</span></span><br><span class="line">  <span class="keyword">return</span> p2;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 第二个完成处理程序</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 8</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>关于这个模式需要注意的是，第二个完成处理程序被添加到了第三个Promise而不是p2。我们来看另一种可能发生的情况</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">66</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="number">88</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 第一个完成处理程序</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 66</span></span><br><span class="line">  <span class="keyword">return</span> p2;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 第二个完成处理程序</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 从未调用</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个示例中由于p2被拒绝了，所以处理程序永不会被调用，所以，无论怎样，我们都应添加一个拒绝处理程序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">66</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="number">88</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 第一个完成处理程序</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 66</span></span><br><span class="line">  <span class="keyword">return</span> p2;</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 拒绝处理程序</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 88</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>p2被拒绝后，拒绝处理程序被调用并传入p2的拒绝值 88.</p>
<h2 id="响应多个Promise"><a href="#响应多个Promise" class="headerlink" title="响应多个Promise"></a>响应多个Promise</h2><p>在ES6中可以使用Promise.all()和Promise.race()方法来监听多个Promise</p>
<h3 id="Promise-all-和-Promise-race"><a href="#Promise-all-和-Promise-race" class="headerlink" title="Promise.all() 和 Promise.race()"></a>Promise.all() 和 Promise.race()</h3><p>该方法只接受一个参数并返回一个Promise，该参数是一个含有多个受监视Promise的可迭代对象。只有当可迭代对象中所有Promise都被解决后返回的Promise才会被解决，只有当可迭代对象中所有Promise都被完成后返回的Promise才会被完成，示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">66</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">88</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">99</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p4 = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br><span class="line">p4.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)); <span class="comment">// true</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value[<span class="number">0</span>]); <span class="comment">//66</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value[<span class="number">1</span>]); <span class="comment">//88</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value[<span class="number">2</span>]); <span class="comment">//99</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>对于所有传入Promise.all()方法的Promise只要有一个被拒绝，那么返回的Promise没等所有Promise都完成就立即被拒绝</p>
<p><strong>Promise.race()</strong></p>
<p>该方法监听多个Promise方法，与all稍有不同的是，只要有一个Promise被解决，返回的Promise就被解决，毋须等到所有Promise都被完成。一旦数组中某个Promise被完成，Promise.race()也会像Promise.all()一样返回特定的Promise</p>
<h2 id="基于Promise的异步任务执行"><a href="#基于Promise的异步任务执行" class="headerlink" title="基于Promise的异步任务执行"></a>基于Promise的异步任务执行</h2><p>来点实战~</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="comment">/* 创建可以在其他地方使用的迭代器 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">run</span>(<span class="params">taskDef</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> task = <span class="title function_">taskDef</span>();</span><br><span class="line">  <span class="comment">// 开始执行任务</span></span><br><span class="line">  <span class="keyword">let</span> result = task.<span class="title function_">next</span>();</span><br><span class="line">  <span class="comment">// 不断调用next()的递归函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">step</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 如果有更多任务要做</span></span><br><span class="line">    <span class="keyword">if</span> (!result.<span class="property">done</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> result.<span class="property">value</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        result.<span class="title function_">value</span>(<span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            result = task.<span class="keyword">throw</span>(err);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          result = task.<span class="title function_">next</span>(data);</span><br><span class="line">          <span class="title function_">step</span>();</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = task.<span class="title function_">next</span>(result.<span class="property">value</span>);</span><br><span class="line">        <span class="title function_">step</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 启动递归进程</span></span><br><span class="line">  <span class="title function_">step</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 定义一个可用于任务执行器的函数 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readFile</span>(<span class="params">filename</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(filename, callback);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 执行一个任务 */</span></span><br><span class="line"><span class="title function_">run</span>(<span class="keyword">function</span> *() &#123;</span><br><span class="line">  <span class="keyword">let</span> contents = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;config.json&#x27;</span>);</span><br><span class="line">  <span class="title function_">doSomethingWith</span>(contents);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Done&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>实现起来多多少少还是有一些问题：</p>
<ol>
<li>逻辑让人困惑（在返回值是函数的函数中包裹每一个函数）</li>
<li>无法区分返回值（用作任务执行器回调函数的返回值和一个不是回调函数的返回值）</li>
</ol>
<p>说了这么多，于是用Promise来改写主要逻辑部分吧：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">run</span>(<span class="params">taskDef</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建迭代器</span></span><br><span class="line">  <span class="keyword">let</span> task = <span class="title function_">taskDef</span>();</span><br><span class="line">  <span class="comment">// 开始执行任务</span></span><br><span class="line">  <span class="keyword">let</span> result = task.<span class="title function_">next</span>();</span><br><span class="line">  <span class="comment">// 递归函数遍历</span></span><br><span class="line">  (<span class="keyword">function</span> <span class="title function_">step</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 如果有更多任务要做</span></span><br><span class="line">    <span class="keyword">if</span> (!result.<span class="property">done</span>) &#123;</span><br><span class="line">      <span class="comment">// 用一个Promise来解决会简化问题</span></span><br><span class="line">      <span class="keyword">let</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(result.<span class="property">value</span>);</span><br><span class="line">      promise.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        result = task.<span class="title function_">next</span>(value);</span><br><span class="line">        <span class="title function_">step</span>();</span><br><span class="line">      &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        result = task.<span class="keyword">throw</span>(err);</span><br><span class="line">        <span class="title function_">step</span>();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个可用于任务执行器的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readFile</span>(<span class="params">filename</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(filename, <span class="function">(<span class="params">err, contents</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(err);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(contents);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行一个任务</span></span><br><span class="line"><span class="title function_">run</span>(<span class="keyword">function</span> *() &#123;</span><br><span class="line">  <span class="keyword">let</span> contents = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;config.json&#x27;</span>);</span><br><span class="line">  <span class="title function_">doSomethingWith</span>(contents);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Done&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在该版本中，一个通用的run()函数执行生成器创建一个迭代器，它调用task.next()方法来启动任务并递归调用step()方法直到迭代器完成。</p>
<p><strong>未来的异步任务执行</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略部分代码</span></span><br><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> contents = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="string">&#x27;config.json&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Done&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在函数前添加关键字async表示该函数以异步模式运行，await关键字表示调用readFile(‘config.json’)的函数应该返回一个Promise，否则，响应应该被包裹在Promise中。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Promise的设计目标是改进JavaScript中的异步编程，它能够更好地掌控并组合多个同步操作，比事件系统和回调更符合我们的逻辑认知。</p>
<ol>
<li>执行Promise，会将其内部的任务添加到JS引擎队列并在未来执行</li>
<li>Promise有3个状态：pending进行中、fulfilled已完成和rejected已拒绝，一旦进入pending只能变成已完成或已拒绝且该过程不可逆</li>
<li>通过then方法可以添加完成处理程序或拒绝处理程序，通过catch方法智能添加拒绝处理程序</li>
<li>通过Promise.all()或Promise.race()来处理多个执行任务</li>
<li>迭代器及Async都是基于Promise实现的，让我们拥抱Promise进行异步编程</li>
</ol>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>异步</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】深入理解ES6——块级作用域绑定</title>
    <url>/2017/07/17/6fa50af0-af91-11ee-9d0b-b39eb4ffb84f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>想了很久还是决定一边看书一边把所记多得用博客的形式记录下来。毕竟好记性不如烂笔头嘛，而且，ES6这么多的内容很适合记博客啊，哈哈~~ 可以产出很多篇不说，还可以顺便练练文笔什么的啦… 额，废话就直接跳过了</p>
<blockquote>
<p>ES6的新语法可以让我们更好地控制作用域。这里我们先理解var声明的一些坑，然后从ES6新引入的块级作用域说起，然后到其绑定机制和最佳实践。</p>
</blockquote>
<span id="more"></span>

<h2 id="var声明及变量提升机制"><a href="#var声明及变量提升机制" class="headerlink" title="var声明及变量提升机制"></a>var声明及变量提升机制</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getValue</span>(<span class="params">something</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (something) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    result value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们读着代码，可能会认为只有something为true(存在)时，value才会被声明，但事实上，在<code>预编译</code>阶段，JavaScritp引擎会将上面的getValue函数修成成下面这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是全局作用域 window或global下</span></span><br><span class="line"><span class="comment">// getValue也会有函数声明提升，所以直接调用是能访问并正确执行getValue函数的</span></span><br><span class="line"><span class="title function_">getValue</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getValue</span>(<span class="params">something</span>) &#123;</span><br><span class="line">  <span class="comment">// getValue的函数作用域顶层</span></span><br><span class="line">  <span class="keyword">var</span> value;  </span><br><span class="line">  <span class="keyword">if</span> (something) &#123;</span><br><span class="line">    value = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    result value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 此处可访问变量value，其值为undefined</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 此处可访问变量value，其值为undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量value的声明被提升至顶部。所以在注释处我们都可以在<code>getValue函数内部</code>访问到value。那ES6引入块级作用域就是来强化对变量声明周期的控制的。</p>
<h2 id="块级声明"><a href="#块级声明" class="headerlink" title="块级声明"></a>块级声明</h2><blockquote>
<p>块级声明用于声明在指定块的作用域之外无法访问的变量，块级作用域存在于：函数内部和块中（字符<code>&#123; &#125;</code>之前的区域）</p>
</blockquote>
<h3 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h3><p>还是以刚才的代码为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是全局作用域 window或global下</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getValue</span>(<span class="params">something</span>) &#123;</span><br><span class="line">  <span class="comment">// getValue的函数作用域顶层  </span></span><br><span class="line">  <span class="keyword">if</span> (something) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    result &#123; value, <span class="variable constant_">PI</span> &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 变量value，PI在此处不存在</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 变量value，PI在此处不存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用let或const进行的声明不再被提升至函数顶部。执行流离开if块后，value、PI被立即销毁，如果something为false，就永不会声明及初始化变量。</p>
<p><strong>二者间的相同点</strong> 禁止重声明</p>
<p><code>在同级的作用域内，若变量用let或const声明过后，再次声明会直接报错</code>。但如果当前作用域嵌另一个作用域便可在内嵌的作用域中用let或const声明同名变量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;fri&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 不会报错</span></span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;fridolph&#x27;</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="临时死区-Temporal-Dead-Zone"><a href="#临时死区-Temporal-Dead-Zone" class="headerlink" title="临时死区 (Temporal Dead Zone)"></a>临时死区 (Temporal Dead Zone)</h2><blockquote>
<p>JavaScript引擎在扫描代码时发现变量声明，要么将它们提升至作用域顶部（遇到var声明），要么将声明放到TDZ中（遇到let或const声明）</p>
</blockquote>
<p>访问TDZ中的变量会触发运行时错误。只有执行过变量声明语句后，变量才会从TDZ中移出，然后才可正常访问。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>块级作用域绑定的let和const为JavaScript引入了词法作用域（它们声明的变量不会提升），而且只可以在声明这些变量的代码块中使用。</p>
</li>
<li><p>在for-in和for-of循环中，let和const都会为每次迭代时创建新绑定（从而使循环体内创建的函数可以访问到相应迭代的值，而非最后一次迭代后的值）</p>
</li>
</ul>
<p>注：在for循环中使用const声明可能引发错误，要尽量避免</p>
<ul>
<li>使用块级作用域绑定的最佳实践是：默认使用const，只有在确实需要改变变量时才使用let</li>
</ul>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>作用域</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】用Jsonp解决跨域问题</title>
    <url>/2016/06/04/d38eda10-af90-11ee-9e84-27243060ec45/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>该篇讲述了同源策略，再到跨域的解决。学习分析了流行的jsonp方案从源码上加深了对jsonp的理解和认识</p>
</blockquote>
<span id="more"></span>

<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>要理解跨域，先要了解一下“同源策略”。所谓同源是指，域名，协议，端口相同。所谓“同源策略“，简单的说就是基于安全考虑，当前域不能访问其他域的东西。</p>
<pre><code>http://www.abc.com:8080/home?k=v
</code></pre>
<p>这么一个url地址，由协议，域名，端口，路径等部分组成。怎么来区分跨域与否呢？ 这里简单列了一下：</p>
<p><strong>跨域</strong></p>
<ul>
<li>不同协议</li>
<li>域名不同</li>
<li>端口不同</li>
</ul>
<p><strong>不跨域</strong></p>
<ul>
<li>协议、域名和端口相同</li>
<li>同一域名的不同路径下</li>
</ul>
<p><strong>跨域情况</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;https://api.douban.com/v2/book/search?q=javascript&amp;count=1&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">  xhr.<span class="title function_">send</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但<code>&lt;img&gt;</code>的src（获取图片），<code>&lt;link&gt;</code>的href（获取css），<code>&lt;script&gt;</code>的src（获取javascript）这三个都不符合同源策略，它们可以跨域获取数据。这里要介绍的JSONP就是利用<code>&lt;script&gt;</code>的src来实现跨域获取数据的。</p>
<h2 id="Jsonp"><a href="#Jsonp" class="headerlink" title="Jsonp"></a>Jsonp</h2><p>JSONP 是 JSON with padding（填充式 JSON 或参数式 JSON）的简写。<br>JSONP实现跨域请求的原理简单的说，就是动态创建<code>&lt;script&gt;</code>标签，然后利用<code>&lt;script&gt;</code>的 src 不受同源策略约束来跨域获取数据。<br>JSONP 由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的 JSON 数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&quot;https://api.douban.com/v2/book/search?q=javascript&amp;count=1&amp;callback=handleResponse&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">insertBefore</span>(script, <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">firstChild</span>);</span><br><span class="line"><span class="comment">// 对response数据进行操作代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleResponse</span>(<span class="params">response</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>JSONP目前还是比较流行的跨域方式，虽然JSONP使用起来方便，但是也存在一些问题：<br>首先， JSONP 是从其他域中加载代码执行。如果其他域不安全，很可能会在响应中夹带一些恶意代码，而此时除了完全放弃 JSONP 调用之外，没有办法追究。因此在使用不是你自己运维的 Web 服务时，一定得保证它安全可靠。</p>
<p>其次，要确定 JSONP 请求是否失败并不容易。虽然 HTML5 给 <code>&lt;script&gt;</code> 元素新增了一个 onerror事件处理程序，但目前还没有得到任何浏览器支持。为此，开发人员不得不使用计时器检测指定时间内是否接收到了响应。</p>
<p>下面来看看 jsonp 的源码解读 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// const debug = require(&#x27;debug&#x27;)(&#x27;jsonp&#x27;)</span></span><br><span class="line"><span class="comment">// 记录回调次数</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line"><span class="comment">// Noop循环函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">noop</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现jsonp的主函数，接受3个参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">String</span>&#125; url </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object | Function</span>&#125; opts </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; fn </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">jsonp</span>(<span class="params">url, opts, fn</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> opts === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    fn = opts</span><br><span class="line">    opts = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!opts) opts = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> prefix = opts.<span class="property">prefix</span> || <span class="string">&#x27;__jp&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果被调用就 使用被提供的回调名称</span></span><br><span class="line">  <span class="comment">// 否则通过增加计数器来生成一个唯一的名称</span></span><br><span class="line">  <span class="keyword">let</span> id = opts.<span class="property">name</span> || (prefix + (count++))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> param = opts.<span class="property">param</span> || <span class="string">&#x27;callback&#x27;</span></span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span> != opts.<span class="property">timeout</span> ? opts.<span class="property">timeout</span> : <span class="number">60000</span></span><br><span class="line">  <span class="keyword">const</span> enc = <span class="built_in">encodeURIComponent</span></span><br><span class="line">  <span class="keyword">let</span> target = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;script&#x27;</span>)[<span class="number">0</span>] || <span class="variable language_">document</span>.<span class="property">head</span></span><br><span class="line">  <span class="keyword">let</span> script</span><br><span class="line">  <span class="keyword">let</span> timer</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 边界条件处理</span></span><br><span class="line">  <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">cleanup</span>()</span><br><span class="line">      <span class="keyword">if</span> (fn) <span class="title function_">fn</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Timeout&#x27;</span>))</span><br><span class="line">    &#125;, timeout)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">cleanup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 方法执行时，删除创建的script节点</span></span><br><span class="line">    <span class="keyword">if</span> (script.<span class="property">parantNode</span>) script.<span class="property">parantNode</span>.<span class="title function_">removeChild</span>(script)</span><br><span class="line">    <span class="comment">// 且给window对象绑定属性id 为 noop （上面的空函数）</span></span><br><span class="line">    <span class="variable language_">window</span>[id] = noop</span><br><span class="line">    <span class="comment">// 若timer不为空，则先清楚一次计时器</span></span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">cancel</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 执行时若window已绑定id则执行 cleanup 清除</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">window</span>[id]) &#123;</span><br><span class="line">      <span class="title function_">cleanup</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 为 window[id] 绑定一个匿名函数 </span></span><br><span class="line"><span class="comment">   * 接受data参数，执行回调fn时，将 data作为参数进行传递</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="variable language_">window</span>[id] = <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">// debug(&#x27;jsonp got&#x27;, data)</span></span><br><span class="line">    <span class="title function_">cleanup</span>()</span><br><span class="line">    <span class="keyword">if</span> (fn) <span class="title function_">fn</span>(<span class="literal">null</span>, data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改现 url，增加 querystring</span></span><br><span class="line">  url += <span class="string">`<span class="subst">$&#123;~url.indexOf(<span class="string">&#x27;?&#x27;</span>) ? <span class="string">&#x27;&amp;&#x27;</span> : <span class="string">&#x27;?&#x27;</span>&#125;</span><span class="subst">$&#123;param&#125;</span>=<span class="subst">$&#123;enc(id)&#125;</span>`</span></span><br><span class="line">  <span class="comment">// 这针对的是第一个kv对</span></span><br><span class="line">  url = url.<span class="title function_">replace</span>(<span class="string">&#x27;?&amp;&#x27;</span>, <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// debug(&#x27;jsonp req &quot;%s&quot;&#x27;, url)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建script节点</span></span><br><span class="line">  script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">  script.<span class="property">src</span> = url</span><br><span class="line">  target.<span class="property">parentNode</span>.<span class="title function_">insertBefore</span>(script, target)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cancel</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = jsonp</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/webmodules/jsonp/blob/master/index.js">开源jsonp实现 github</a></p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>jsonp</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】脚本错误及错误捕获</title>
    <url>/2018/07/14/c0412e80-af91-11ee-b477-83d3895bc24d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>从脚本错误开始，了解脚本为什么会报错以及抛出错误，最后介绍了用window.onerror、try catch捕获错误。</p>
</blockquote>
<span id="more"></span>

<h2 id="什么是脚本错误"><a href="#什么是脚本错误" class="headerlink" title="什么是脚本错误"></a>什么是脚本错误</h2><p>如果您以前使用过JavaScript onerror事件做过任何工作，您可能会遇到以下情况：</p>
<p>“Script error.”</p>
<p>“脚本错误”是当错误源自从不同来源（不同域，端口或协议）提供的JavaScript文件时，浏览器发送到onerror回调的内容。这很痛苦，因为即使出现错误，您也不知道错误是什么，也不知道它来自哪个代码。这就是window.onerror的全部目的 - 深入了解应用程序中未捕获的错误。</p>
<h2 id="产生原因：跨源脚本"><a href="#产生原因：跨源脚本" class="headerlink" title="产生原因：跨源脚本"></a>产生原因：跨源脚本</h2><p>为了更好地了解正在发生的事情，请考虑以下示例HTML文档，假设从<a href="http://example.com/test%E6%8F%90%E4%BE%9B%EF%BC%9A">http://example.com/test提供：</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>example.com/test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://another-domain.com/app.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">message, url, line, column, error</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(message, url, line, column, error);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">foo</span>(); <span class="comment">// call function declared in app.js</span></span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这是<a href="http://another-domain.com/app.js%E7%9A%84%E5%86%85%E5%AE%B9%E3%80%82%E5%AE%83%E5%A3%B0%E6%98%8E%E4%BA%86%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0foo%EF%BC%8C%E5%85%B6%E8%B0%83%E7%94%A8%E5%B0%86%E5%A7%8B%E7%BB%88%E6%8A%9B%E5%87%BAReferenceError%E3%80%82">http://another-domain.com/app.js的内容。它声明了一个函数foo，其调用将始终抛出ReferenceError。</a></p>
<p>在浏览器中加载此文档并执行JavaScript时，会将以下内容输出到控制台（通过window.onerror回调记录）：</p>
<p>“Script error.”, “”, 0, 0, undefined</p>
<p>这不是JavaScript错误 - 出于安全原因，浏览器故意隐藏源自不同来源的脚本文件的错误。这是为了避免脚本无意中将潜在敏感信息泄露给它无法控制的onerror回调。出于这个原因，浏览器只允许window.onerror洞察来自同一域的错误。我们所知道的是发生了一个错误 - 没有别的！</p>
<h2 id="但这并不坏"><a href="#但这并不坏" class="headerlink" title="但这并不坏"></a>但这并不坏</h2><p>尽管浏览器有良好的意图，但是有一些很好的理由可以让您深入了解从不同来源提供的脚本引发的错误：</p>
<ol>
<li>您的应用程序JavaScript文件是从不同的主机名提供的，例如static.sentry.io&#x2F;app.js</li>
<li>您正在使用社区CDN提供的库，例如cdnjs或Google的托管库</li>
<li>您正在使用商业第三方JavaScript库，该库仅由外部服务器提供</li>
</ol>
<p>但不要担心 - 深入了解这些文件所提供的JavaScript错误只需要进行一些简单的调整。</p>
<h2 id="修复：CORS-attributes-headers"><a href="#修复：CORS-attributes-headers" class="headerlink" title="修复：CORS attributes &amp; headers"></a>修复：CORS attributes &amp; headers</h2><p>为了了解源自不同来源的脚本引发的JavaScript异常，您必须做两件事:</p>
<ol>
<li>添加 crossorigin&#x3D;”anonymous” 脚本属性</li>
</ol>
<p><code>&lt;script src=&quot;http://another-domain.com/app.js&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;</code></p>
<p>这告诉浏览器应该“anonymous”(匿名)获取目标文件。这意味着在请求此文件时，浏览器不会将任何潜在的用户识别信息（如cookie或HTTP凭据）传输到服务器。</p>
<ol start="2">
<li>添加Cross Origin HTTP header</li>
</ol>
<p><code>Access-Control-Allow-Origin: *</code></p>
<p>CORS是“跨源资源共享”的缩写，它是一组API（主要是HTTP标头），它们规定了文件应该如何从源头下载和提供。</p>
<p>通过设置Access-Control-Allow-Origin：*，服务器向浏览器指示任何源可以获取此文件。或者，您可以将其限制为您控制的已知来源，例如</p>
<p><code>Access-Control-Allow-Origin: https://www.example.com</code></p>
<p>注意：大多数社区CDN正确设置了Access-Control-Allow-Origin标头。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl --<span class="built_in">head</span> https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.js | \</span><br><span class="line">  grep -i <span class="string">&quot;access-control-allow-origin&quot;</span></span><br><span class="line"></span><br><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure>

<p>完成这两个步骤后，此脚本触发的任何错误都将向window.onerror报告，就像任何常规的同域脚本一样。因此，代替“脚本错误”，从一开始的onerror示例将产生：</p>
<p><code>&quot;ReferenceError: bar is not defined&quot;, &quot;http://another-domain.com/app.js&quot;, 2, 1, [Object Error]</code></p>
<h2 id="另一种解决方案：try-catch"><a href="#另一种解决方案：try-catch" class="headerlink" title="另一种解决方案：try &#x2F; catch"></a>另一种解决方案：try &#x2F; catch</h2><p>有时，我们并不总是能够调整Web应用程序正在使用的脚本的HTTP头。在这些情况下，有一种替代方法：使用try &#x2F; catch。</p>
<p>再次考虑原始示例，这次使用try &#x2F; catch：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- <span class="doctag">note:</span> crossorigin=&quot;anonymous&quot; intentionally absent --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://another-domain.com/app.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">message, url, line, column, error</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(message, url, line, column, error);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">foo</span>(); <span class="comment">// call function declared in app.js</span></span></span><br><span class="line"><span class="language-javascript">  &#125; <span class="keyword">catch</span> (e) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">throw</span> e; <span class="comment">// intentionally re-throw (caught by window.onerror)</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于后代，some-domain.com&#x2F;app.js再次看起来像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// another-domain.com/app.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">bar</span>(); <span class="comment">// ReferenceError: bar is not a function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行示例HTML将向控制台输出以下2个条目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=&gt; ReferenceError: bar is not defined</span><br><span class="line">    at foo (http://another-domain.com/b.js:2:3)</span><br><span class="line">    at http://example.com/test/:15:3</span><br><span class="line"></span><br><span class="line">=&gt; <span class="string">&quot;Script error.&quot;</span>, <span class="string">&quot;&quot;</span>, 0, 0, undefined</span><br></pre></td></tr></table></figure>

<p>第一个控制台语句 - 来自try &#x2F; catch - 设法获取一个错误对象，包括类型，消息和堆栈跟踪，包括文件名和行号。来自window.onerror的第二个控制台语句再一次只能输出“脚本错误”。</p>
<p>现在，这是否意味着您需要尝试&#x2F;捕获所有代码？可能不是 - 如果您可以轻松更改HTML并在CDN上指定CORS标题，则最好这样做并坚持使用window.onerror。但是，如果您不控制这些资源，使用try &#x2F; catch包装第三方代码是一种可靠的（虽然是乏味的）方式，可以深入了解跨源脚本引发的错误。</p>
<p>注意：默认情况下，Raven.js - Sentry的JavaScript SDK - 仔细设备内置方法，尝试自动将代码包装在try &#x2F; catch块中。它这样做是为了尝试捕获所有脚本中的错误消息和堆栈跟踪，无论它们来自哪个来源。如果可能，仍建议设置CORS属性和标头。</p>
<h2 id="window-onerror"><a href="#window-onerror" class="headerlink" title="window.onerror"></a>window.onerror</h2><p>onerror是一个特殊的浏览器事件，只要抛出未捕获的JavaScript错误就会触发该事件。这是记录客户端错误并将其报告给服务器的最简单方法之一。它也是Sentry的客户端JavaScript集成（raven-js）工作的主要机制之一。</p>
<p>你通过向window.onerror分配一个函数来监听onerror事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">msg, url, lineNo, columnNo, error</span>) &#123;</span><br><span class="line">  <span class="comment">// ... handle error ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抛出错误时，以下参数将传递给函数：</p>
<ul>
<li>msg - 与错误相关的消息，例如“未捕获的ReferenceError：foo未定义”</li>
<li>url - 与错误关联的脚本或文档的URL，例如“&#x2F;dist&#x2F;app.js”</li>
<li>lineNo - 行号（如果有）</li>
<li>columnNo - 列号（如果可用）</li>
<li>error - 与此错误关联的Error对象（如果可用）</li>
</ul>
<p>前四个参数告诉你错误发生在哪个脚本，行和列中。最后一个参数Error对象可能是最有价值的。让我们来了解原因。</p>
<h3 id="Error对象和error-stack"><a href="#Error对象和error-stack" class="headerlink" title="Error对象和error.stack"></a>Error对象和error.stack</h3><p>乍一看，Error对象不是很特别。它包含3个标准化属性：message，fileName和lineNumber。已通过window.onerror提供给你的冗余值。</p>
<p>有价值的部分是非标准属性：Error.prototype.stack。此堆栈属性告诉你错误发生时程序的每个帧的源位置。错误堆栈跟踪可能是调试的关键部分。尽管不标准，但每个现代浏览器都提供此属性。</p>
<p>以下是Chrome 46中Error对象的堆栈属性的示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Error: foobar\n    at new bar (&lt;anonymous&gt;:241:11)\n    at foo (&lt;anonymous&gt;:245:5)\n    at &lt;anonymous&gt;:250:5\n    at &lt;anonymous&gt;:251:3\n    at &lt;anonymous&gt;:267:4\n    at callFunction (&lt;anonymous&gt;:229:33)\n    at &lt;anonymous&gt;:239:23\n    at &lt;anonymous&gt;:240:3\n    at Object.InjectedScript._evaluateOn (&lt;anonymous&gt;:875:140)\n    at Object.InjectedScript._evaluateAndWrap (&lt;anonymous&gt;:808:34)&quot;</span></span><br></pre></td></tr></table></figure>

<p>难以阅读，对吗？stack属性实际上只是一个未格式化的字符串。这是格式化的样子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Error: foobar</span></span><br><span class="line"><span class="string">    at new bar (&lt;anonymous&gt;:241:11)</span></span><br><span class="line"><span class="string">    at foo (&lt;anonymous&gt;:245:5)</span></span><br><span class="line"><span class="string">    at &lt;anonymous&gt;:250:5</span></span><br><span class="line"><span class="string">    at &lt;anonymous&gt;:251:3</span></span><br><span class="line"><span class="string">    at &lt;anonymous&gt;:267:4</span></span><br><span class="line"><span class="string">    at callFunction (&lt;anonymous&gt;:229:33)</span></span><br><span class="line"><span class="string">    at &lt;anonymous&gt;:239:23</span></span><br><span class="line"><span class="string">    at &lt;anonymous&gt;:240:3</span></span><br><span class="line"><span class="string">    at Object.InjectedScript._evaluateOn (&lt;anonymous&gt;:875:140)</span></span><br><span class="line"><span class="string">    at Object.InjectedScript._evaluateAndWrap (&lt;anonymous&gt;:808:34)&quot;</span></span><br></pre></td></tr></table></figure>

<p>一旦格式化，就很容易看出堆栈属性如何在帮助调试错误时起到关键作用。只有一个障碍：堆栈属性是非标准的，它的实现在浏览器之间有所不同。例如，这是来自Internet Explorer 11的相同堆栈跟踪：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Error</span>: foobar</span><br><span class="line">   at bar (<span class="title class_">Unknown</span> script <span class="attr">code</span>:<span class="number">2</span>:<span class="number">5</span>)</span><br><span class="line">   at foo (<span class="title class_">Unknown</span> script <span class="attr">code</span>:<span class="number">6</span>:<span class="number">5</span>)</span><br><span class="line">   at <span class="title class_">Anonymous</span> <span class="keyword">function</span> (<span class="params">Unknown script code:<span class="number">11</span>:<span class="number">5</span></span>)</span><br><span class="line">   at <span class="title class_">Anonymous</span> <span class="keyword">function</span> (<span class="params">Unknown script code:<span class="number">10</span>:<span class="number">2</span></span>)</span><br><span class="line">   at <span class="title class_">Anonymous</span> <span class="keyword">function</span> (<span class="params">Unknown script code:<span class="number">1</span>:<span class="number">73</span></span>)</span><br></pre></td></tr></table></figure>

<p>不仅每个帧的格式不同，帧也具有较少的细节。例如，Chrome会识别出已使用新关键字，并且对eval调用有更深入的了解。这只是IE 11与Chrome的比较 - 其他类似的浏览器具有不同的格式和细节。</p>
<p>幸运的是，有一些工具可以规范化堆栈属性，使其在浏览器中保持一致。例如，raven-js使用TraceKit来规范化错误字符串。还有stacktrace.js和其他一些项目。</p>
<h3 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h3><p>window.onerror已经在浏览器中出现了一段时间 - 你会在浏览器中找到它与IE6和Firefox 2一样古老的版本。</p>
<p>问题是每个浏览器都以不同的方式实现window.onerror。特别是，将多少个参数发送给onerror侦听器，以及这些参数的结构。</p>
<p>这是一个在大多数浏览器中将参数传递给onerror的表：</p>
<table>
<thead>
<tr>
<th align="center">Browser</th>
<th align="center">Message</th>
<th align="center">URL</th>
<th align="center">lineNo</th>
<th align="center">colNo</th>
<th align="center">errorObj</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Firefox</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">Chrome</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">Edge</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">IE 11</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">IE 10</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">IE 9, 8</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Safari 10 and up</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">Safari 9</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Android Browser 4.4</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>Internet Explorer 8,9和10对onerror的支持有限，这可能不足为奇。但是你可能会惊讶于Safari只在Safari 10中添加了对错误对象的支持（2016年发布）。此外，仍旧使用现有Android浏览器（现已替换为Chrome Mobile）的旧手机版仍然在那里，并且不会传递错误对象。</p>
<p>没有错误对象，就没有堆栈跟踪属性。这意味着这些浏览器无法从错误捕获的错误中检索有价值的堆栈信息。</p>
<h3 id="使用try-catch-兼容-window-onerror"><a href="#使用try-catch-兼容-window-onerror" class="headerlink" title="使用try &#x2F; catch 兼容 window.onerror"></a>使用try &#x2F; catch 兼容 window.onerror</h3><p>但是有一种解决方法 - 你可以将应用程序中的代码包装在try &#x2F; catch中并自己捕获错误。这个错误对象将在每个现代浏览器中包含我们令人垂涎的堆栈属性。</p>
<p>考虑以下帮助器方法invoke，它使用参数数组调用对象上的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">invoke</span>(<span class="params">obj, method, args</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj[method].<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">invoke</span>(<span class="title class_">Math</span>, <span class="string">&#x27;max&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// returns 2</span></span><br></pre></td></tr></table></figure>

<p>这里再次调用，这次包装在try &#x2F; catch中，以捕获任何抛出的错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">invoke</span>(<span class="params">obj, method, args</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj[method].<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="title function_">captureError</span>(e); <span class="comment">// report the error</span></span><br><span class="line">    <span class="keyword">throw</span> e; <span class="comment">// re-throw the error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">invoke</span>(<span class="title class_">Math</span>, <span class="string">&#x27;highest&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// throws error, no method Math.highest</span></span><br></pre></td></tr></table></figure>

<p>当然，在任何地方手动执行此操作非常麻烦。你可以通过创建通用包装器实用程序函数来使其更容易：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">wrapErrors</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="comment">// don&#x27;t wrap function more than once</span></span><br><span class="line">  <span class="keyword">if</span> (!fn.<span class="property">__wrapped__</span>) &#123;</span><br><span class="line">    fn.<span class="property">__wrapped__</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">captureError</span>(e); <span class="comment">// report the error</span></span><br><span class="line">        <span class="keyword">throw</span> e; <span class="comment">// re-throw the error</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fn.<span class="property">__wrapped__</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> invoke = <span class="title function_">wrapErrors</span>(<span class="keyword">function</span>(<span class="params">obj, method, args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[method].<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">invoke</span>(<span class="title class_">Math</span>, <span class="string">&#x27;highest&#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// no method Math.highest</span></span><br></pre></td></tr></table></figure>

<p>因为JavaScript是单线程的，所以你不需要在任何地方使用wrap  - 只是在每个新堆栈的开头。</p>
<p>这意味着你需要包装函数声明：</p>
<ul>
<li>在你的应用程序开始时（例如，如果你使用jQuery，请在$（document）.ready中）</li>
<li>在事件处理程序中，例如addEventListener或$ .fn.click</li>
<li>基于计时器的回调，例如setTimeout或requestAnimationFrame</li>
</ul>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="title function_">wrapErrors</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// application start</span></span><br><span class="line">  <span class="title function_">doSynchronousStuff1</span>(); <span class="comment">// doesn&#x27;t need to be wrapped</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="title function_">wrapErrors</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">doSynchronousStuff2</span>(); <span class="comment">// doesn&#x27;t need to be wrapped</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  $(<span class="string">&#x27;.foo&#x27;</span>).<span class="title function_">click</span>(<span class="title function_">wrapErrors</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">doSynchronousStuff3</span>(); <span class="comment">// doesn&#x27;t need to be wrapped</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>如果这看起来像是很多工作，请不要担心！大多数错误报告库都具有增强内置函数（如addEventListener和setTimeout）的机制，因此你不必每次都调用包装实用程序。是的，raven-js也这样做。</p>
<h3 id="将错误传输到你的服务器"><a href="#将错误传输到你的服务器" class="headerlink" title="将错误传输到你的服务器"></a>将错误传输到你的服务器</h3><p>好的，所以你已经完成了你的工作 - 你已经插入window.onerror，并且你还在try &#x2F; catch中包装函数，以便捕获尽可能多的错误信息。</p>
<p>最后一步是：将错误信息传输到你的服务器。为了实现这一点，你需要设置某种报告Web服务，该服务将通过HTTP接受你的错误数据，将其记录到文件和&#x2F;或将其存储在数据库中。</p>
<p>如果此Web服务与Web应用程序位于同一个域中，则可以使用XMLHttpRequest轻松实现。在下面的示例中，我们使用jQuery的AJAX函数将数据传输到我们的服务器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">captureError</span>(<span class="params">ex</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> errorData = &#123;</span><br><span class="line">    <span class="attr">name</span>: ex.<span class="property">name</span>, <span class="comment">// e.g. ReferenceError</span></span><br><span class="line">    <span class="attr">message</span>: ex.<span class="property">line</span>, <span class="comment">// e.g. x is undefined</span></span><br><span class="line">    <span class="attr">url</span>: <span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">href</span>,</span><br><span class="line">    <span class="attr">stack</span>: ex.<span class="property">stack</span> <span class="comment">// stacktrace string; remember, different per-browser!</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  $.<span class="title function_">post</span>(<span class="string">&#x27;/logger/js/&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">data</span>: errorData</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，如果必须跨源传输错误，则报告端点需要支持CORS（跨源资源共享）。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://blog.sentry.io/2016/05/17/what-is-script-error">什么是脚本错误</a></li>
<li><a href="https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror.html">window.onerror捕获错误</a></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你已经做到这一点，那么你现在可以拥有所需的所有工具来推送自己的基本错误报告库并将其与你的应用程序集成：</p>
<ul>
<li>window.onerror的工作原理以及它支持的浏览器</li>
<li>如何使用try &#x2F; catch来捕获缺少window.onerror的堆栈跟踪</li>
<li>将错误数据传输到你的服务器</li>
</ul>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】面向对象相关设计模式</title>
    <url>/2017/11/01/7fa1e860-af91-11ee-99d8-b9d7e0e3e566/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>面向对象应该是一种思想，而不是代码的组织形式。</p>
</blockquote>
<p>面向对象的特点：</p>
<ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
<p>子类继承了父类的函数，同时覆盖实现了父类的某些行为。上面的setProgress函数即体现了多态又体现了继承</p>
<span id="more"></span>

<h3 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h3><p>集成商为了实现复用，组合其实也是为了实现复用。继承是is-a的关系，而组合是has-a的关系。</p>
<p>可以把上面的ProgressBar改成组合的方式。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProgressBar</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">$container</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fullWidth</span> = $container.<span class="title function_">width</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$bar</span> = <span class="literal">null</span></span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">// 设置宽度</span></span><br><span class="line">  <span class="title function_">setProgress</span>(<span class="params">percentage</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$bar</span>.<span class="title function_">animate</span>(&#123;</span><br><span class="line">      <span class="attr">width</span>: <span class="variable language_">this</span>.<span class="property">fullWidth</span> * percentage + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 完成</span></span><br><span class="line">  <span class="title function_">finished</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$bar</span>.<span class="title function_">hide</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 失败</span></span><br><span class="line">  <span class="title function_">failed</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">addFailedText</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addFailedText</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProgressBarWithNumber</span> <span class="keyword">extends</span> <span class="title class_ inherited__">ProgressBar</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">$container</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>($container)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 多态</span></span><br><span class="line">  <span class="title function_">setProgress</span>(<span class="params">percentage</span>) &#123;</span><br><span class="line">    <span class="comment">// 先借助继承父类的函数</span></span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">setProgress</span>(percentage)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">showPercentageText</span>(percentage)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">showPercentageText</span>(<span class="params">percentage</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在构造函数里面组合了一个progressBar的实例，然后在setProgress函数里面利用这个实例去设置进度条的百分比。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProgressBarWithNumber</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">$container</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">progressBar</span> = <span class="keyword">new</span> <span class="title class_">ProgressBar</span>($container)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setProgress</span>(<span class="params">percentage</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">progressBar</span>.<span class="title function_">setProgress</span>(percentage)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">showPercentageText</span>(percentage)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">showPercentageText</span>(<span class="params">percentage</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>偏向于使用组合而非继承</strong></p>
<p>因为继承的耦合性要大于组合，组合更加灵活。继承是编译阶段就决定了关系，而组合是运行阶段才决定关系。</p>
<h3 id="面向对象编程原则和设计模式"><a href="#面向对象编程原则和设计模式" class="headerlink" title="面向对象编程原则和设计模式"></a>面向对象编程原则和设计模式</h3><ol>
<li>单例模式</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> taskWorker = &#123;</span><br><span class="line">  <span class="attr">tasks</span>: [],</span><br><span class="line">  <span class="title function_">draw</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="title function_">addTask</span>(<span class="params">task</span>) &#123;</span><br><span class="line">    <span class="title class_">Task</span>.<span class="property">tasks</span>.<span class="title function_">push</span>(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> mapTask = &#123;</span><br><span class="line">  <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params">task</span>) &#123;</span><br><span class="line">    taskWorker.<span class="title function_">addTask</span>(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次get的时候先判断mapTask有没有Task的新实例，如果没有则为第一次。先去实例化一个，并做些初始化工作，如果有则直接返回。然后执行mapTask.get()的时候就能够保证获取到的是一个单例。</p>
<ul>
<li><p>破坏单例</p>
<pre><code>  mapTask.aTask = null
</code></pre>
</li>
</ul>
<ol start="2">
<li>策略模式</li>
</ol>
<p>场景：注册弹框，不同的弹框文字。把文案当做一个个的策略，使用时根据不同类型，映射到不同的策略。<br>这样比写if-else或者switch的好处在于：如果以后要增加或删除某种类型，只需要增删一个type就可以了，而不用去改动if-else逻辑。这就叫做开放封闭原则——对修改是封闭的，而对扩展是开放的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> popType = &#123;</span><br><span class="line">  <span class="attr">userReg</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;Create your account&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">favHouse</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;Add home to favorite&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">saveSearch</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;Save this search&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tpl = <span class="string">`&lt;section&gt;&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;/section&gt;`</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Mustache</span>.<span class="title function_">render</span>(tpl, popType[<span class="string">&#x27;userReg&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把回调操作封装成一个策略</span></span><br><span class="line"><span class="keyword">var</span> popCallback = &#123;</span><br><span class="line">  <span class="attr">userReg</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="attr">favHouse</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="attr">saveSearch</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">util.<span class="title function_">ajax</span>(<span class="string">&#x27;/register&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> popType = <span class="string">&#x27;favHouse&#x27;</span> <span class="comment">// 获取popType</span></span><br><span class="line">  popCallback[popType]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>观察者模式</li>
</ol>
<p>观察者向消息的接受者订阅消息，一旦接受者收到消息后就把消息下发给它的观察者们。在一个回执搜索的应用里面，单击最后一个点关闭路径，要触发搜索。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Input</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">inputDom</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">inputDom</span> = inputDom</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">visitors</span> = &#123;</span><br><span class="line">      <span class="attr">click</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加访问者</span></span><br><span class="line">  <span class="title function_">on</span>(<span class="params">eventType, visitor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">visitors</span>.<span class="title function_">push</span>(visitor)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 收到消息，把消息分发给访问者</span></span><br><span class="line">  <span class="title function_">trigger</span>(<span class="params">type, event</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">visitors</span>[type]) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">visitors</span>[type]; i++) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">visitors</span>[type]()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>适配器模式</li>
</ol>
<p>在一个响应式的页面里，假设小屏和大屏显示的分页样式不同，它们初始化和更新状态的函数都不同，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 小屏</span></span><br><span class="line"><span class="keyword">var</span> pagination = <span class="keyword">new</span> <span class="title function_">jqPagination</span>(&#123;</span><br><span class="line">&#125;)</span><br><span class="line">pagination.<span class="property">showPage</span> = <span class="keyword">function</span>(<span class="params">curPage, totalPage</span>) &#123;</span><br><span class="line">  pagination.<span class="title function_">setPage</span>(curPage, totalPage)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 大屏</span></span><br><span class="line"><span class="keyword">var</span> pagination = <span class="keyword">new</span> <span class="title class_">Pagination</span>(&#123;</span><br><span class="line">&#125;)</span><br><span class="line">pagination.<span class="property">showPage</span> = <span class="keyword">function</span>(<span class="params">curPage, totalPage</span>) &#123;</span><br><span class="line">  pagination.<span class="title function_">showItem</span>(curPage, totalPage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果每次调用都得判断一下不同的屏幕大小然后调用不同函数就很麻烦，所以用一个适配器，对外提供统一的接口：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> screen = $(<span class="variable language_">window</span>).<span class="title function_">width</span>() &lt; <span class="number">800</span> ? <span class="string">&#x27;small&#x27;</span> : <span class="string">&#x27;large&#x27;</span></span><br><span class="line"><span class="keyword">var</span> paginationAdapter = &#123;</span><br><span class="line">  <span class="attr">init</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pagination</span> = screen === <span class="string">&#x27;small&#x27;</span> ? <span class="keyword">new</span> <span class="title function_">jqPagination</span>() : <span class="keyword">new</span> <span class="title class_">Pagination</span>()</span><br><span class="line">    <span class="keyword">if</span> (screen === <span class="string">&#x27;large&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">showItem</span> = <span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="property">setPage</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">showPage</span>: <span class="keyword">function</span>(<span class="params">curPage, totalPage</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pagination</span>.<span class="title function_">showItem</span>(curPage, totalPage)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用者只要调用 <code>paginationAdapter.showPage</code> 就可以更新分页状态，它不需要去关心当前是大屏还是小屏，由适配器去处理这些细节</p>
<ol start="5">
<li>工厂模式</li>
</ol>
<p>工厂模式是把创建交给一个工厂，使用者无需要关心创建细节，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> taskCreator = &#123;</span><br><span class="line">  <span class="attr">createTask</span>: <span class="keyword">function</span>(<span class="params">type</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;map&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MapTask</span>()</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;search&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SearchTask</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> mapTask = taskCreator.<span class="title function_">createTask</span>(<span class="string">&#x27;map&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>需要哪种类型的Task时就传一个类型或者name给以个工厂，工厂根据名字去生产相应的产品，不用关心它是怎么创建的，要不要单例之类。</p>
<ol start="6">
<li>外观&#x2F;门面模式</li>
</ol>
<p>在一个搜索逻辑里，为了显示搜索结果需要执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">hideNoResult</span>() <span class="comment">// 隐藏没有结果的显示</span></span><br><span class="line"><span class="title function_">removeOldResult</span>() <span class="comment">// 删除老的结果</span></span><br><span class="line"><span class="title function_">showNewResult</span>() <span class="comment">// 显示新结果</span></span><br><span class="line"><span class="title function_">showPageItem</span>() <span class="comment">// 更新分页</span></span><br><span class="line"><span class="title function_">resizePhoto</span>() <span class="comment">// 结果图片大小重置</span></span><br></pre></td></tr></table></figure>

<p>于是考虑用一个模块把它包起来</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showResult</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">hideNoResult</span>() <span class="comment">// 隐藏没有结果的显示</span></span><br><span class="line">  <span class="title function_">removeOldResult</span>() <span class="comment">// 删除老的结果</span></span><br><span class="line">  <span class="title function_">showNewResult</span>() <span class="comment">// 显示新结果</span></span><br><span class="line">  <span class="title function_">showPageItem</span>() <span class="comment">// 更新分页</span></span><br><span class="line">  <span class="title function_">resizePhoto</span>() <span class="comment">// 结果图片大小重置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 需要时调用 showResult()</span></span><br></pre></td></tr></table></figure>

<p>把多个操作封装成一个模块，对外只提供一个门面叫showResult，使用者只要调一下该函数即可</p>
<ol start="7">
<li>状态模式</li>
</ol>
<p>实现一个类似微博的消息框，要求是当数字为0或者超过140时，发推按钮可单击，且剩余数字会跟着变</p>
<p>可用一个state来保存当前的状态，然后当用户输入时，这个state的数据会跟着变，同时更新按钮状态</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tweetBox = &#123;</span><br><span class="line">  <span class="title function_">init</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化一个state</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;&#125;</span><br><span class="line">    tweetBox.<span class="title function_">bindEvent</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">setState</span>(<span class="params">key, val</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span>[key] = val</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">changeSubmit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 通过获取当前的state</span></span><br><span class="line">    $(<span class="string">&#x27;#submit&#x27;</span>)[<span class="number">0</span>].<span class="property">disabled</span> = tweeetBox.<span class="property">state</span>.<span class="property">text</span>.<span class="property">length</span> === <span class="number">0</span></span><br><span class="line">      || tweetBox.<span class="property">state</span>.<span class="property">text</span>.<span class="property">length</span> &gt; <span class="number">140</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">showLeftTextCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    $(<span class="string">&#x27;#text-count&#x27;</span>).<span class="title function_">text</span>(<span class="number">140</span> - <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">text</span>.<span class="property">length</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">bindEvent</span>(<span class="params"></span>) &#123;</span><br><span class="line">    $(<span class="string">&#x27;.tweet-textarea&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;input&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 改变当前的state</span></span><br><span class="line">      tweetBox.<span class="title function_">setState</span>(<span class="string">&#x27;text&#x27;</span>, <span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">      tweetBox.<span class="title function_">changeSubmit</span>()</span><br><span class="line">      tweetBox.<span class="title function_">showLeftTextCount</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用一个state保存当前状态，通过获取当前state进行下一步操作。</p>
<p>当然，上面的还有优化空间，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tweetBox = &#123;</span><br><span class="line">  <span class="title function_">setState</span>(<span class="params">key, val</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span>[key] = val</span><br><span class="line">    <span class="title function_">renderDom</span>($(<span class="string">&#x27;.tweet&#x27;</span>))</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">renderDom</span>(<span class="params">$currentDom</span>) &#123;</span><br><span class="line">    <span class="title function_">diffAndChange</span>($currentDom, <span class="title function_">renderVirtualDom</span>(tweetBox.<span class="property">state</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// `&lt;input type=&quot;submit&quot; disabled=&#123;&#123;this.state.text.length === 0 || this.state.text.length &gt; 140&#125;&#125; /&gt;`</span></span><br></pre></td></tr></table></figure>

<p>这其实就是React的原型，不同的状态有不同的表现行为，所以可以认为是一个状态模式，并且通过状态去驱动DOM更改</p>
<ol start="8">
<li>代理模式</li>
</ol>
<p>其实React不直接操作DOM，而是把数据给state，然后委托给state和虚拟DOM去操作真实DOM，所以它是一个代理模式</p>
<p>eventHandler -&gt; state -&gt; renderDom()</p>
<ol start="9">
<li>状态模式的另一个例子</li>
</ol>
<p>改变一个房源的状态：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (newState === <span class="string">&#x27;sold&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (currentState === <span class="string">&#x27;building&#x27;</span> || currentState === <span class="string">&#x27;dold&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;error&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentState === <span class="string">&#x27;ready&#x27;</span>) &#123;</span><br><span class="line">    currentState = <span class="string">&#x27;sold&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;ok&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (newState === <span class="string">&#x27;ready&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (currentState === <span class="string">&#x27;building&#x27;</span>) &#123;</span><br><span class="line">    currentState = <span class="string">&#x27;toBeSold&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;ok&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更改一个房源的状态之前先要判断一下当前的状态，如果当前状态不支持那么不允许修改。对上面的代码我们可以用代理模式重构一下，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stateChange = &#123;</span><br><span class="line">  <span class="attr">ready</span>: &#123;</span><br><span class="line">    <span class="attr">building</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">    <span class="attr">ready</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">    <span class="attr">sold</span>: <span class="string">&#x27;ok&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">building</span>: &#123;</span><br><span class="line">    <span class="attr">building</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">    <span class="attr">ready</span>: <span class="string">&#x27;ok&#x27;</span>,</span><br><span class="line">    <span class="attr">sold</span>: <span class="string">&#x27;error&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (stateChange[currentState][newState] !== <span class="string">&#x27;error&#x27;</span>) &#123;</span><br><span class="line">  currentState = newState</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> stateChange[currentState][newState]</span><br></pre></td></tr></table></figure>

<p>你会发现状态模式和策略模式是孪生兄弟，它们形式相同，只是目的不同。</p>
<p>策略模式封装成策略，状态模式封装成状态。这样的代码就比写很多个if-else强多了，特别是当切换关系比较复杂的时候</p>
<ol start="10">
<li>装饰者模式</li>
</ol>
<p>要实现一个贷款的计算器，点计算按钮后，除了要计算结果，还要把结果发给后端做一个埋点。所以写了一个calculateResult函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calculateResult</span>(<span class="params">form</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> data = $(form).<span class="title function_">serializeForm</span>()</span><br><span class="line">  <span class="keyword">var</span> l = data.<span class="property">rate</span> / <span class="number">1200</span></span><br><span class="line">  <span class="keyword">var</span> o = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">1</span> + l, data.<span class="property">term</span> * <span class="number">12</span>)</span><br><span class="line">  <span class="keyword">var</span> e = data.<span class="property">price</span> * (<span class="number">1</span> - data.<span class="property">payment</span> / <span class="number">100</span>)</span><br><span class="line">  <span class="keyword">var</span> result = (e * l * o / (o - <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">var</span> formatResult = util.<span class="title function_">formatMoney</span>(result).<span class="title function_">toFixed</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> $calResult = $(<span class="string">&#x27;.loan-cal .cal-result-con&#x27;</span>)</span><br><span class="line">  $calResult.<span class="title function_">find</span>(<span class="string">&#x27;.pi-result&#x27;</span>).<span class="title function_">text</span>(formatResult)</span><br><span class="line">  <span class="comment">// 这个函数包含了两个功能，一个计算结果，一个改变DOM</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算按钮click回调</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">calculateResult</span>(form)</span><br><span class="line"><span class="comment">// 发送一个埋点请求</span></span><br><span class="line">util.<span class="title function_">ajax</span>(<span class="string">&#x27;/cal-load&#x27;</span>, &#123;result&#125;)</span><br></pre></td></tr></table></figure>

<p>因为要把结果返回出来，所以这个函数有两个功能，一个是计算结果，第二个是改变DOM，这样写在一起感觉不太好。<br>于是我们把函数拆了，首先有一个LoanCalculator的类专门负责计算小数结果： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算结果</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoanCalculator</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">form</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">form</span> = form</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">calResult</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">result</span> = result</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getResult</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">result</span>) <span class="variable language_">this</span>.<span class="property">result</span> = <span class="variable language_">this</span>.<span class="title function_">calResult</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它还提供了一个getResult的函数，如果结果没算过那先算一下保存起来，如果已经计算过了那就直接用算好的结果。<br>然后再写一个<code>NumberFormater</code>，它负责把小数结果格式化成带逗号的形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumberFormater</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">calculator</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">calculator</span> = calculator</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">calResult</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="property">calculator</span>.<span class="title function_">calResult</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">result</span> = result</span><br><span class="line">    <span class="keyword">return</span> util.<span class="title function_">formatMoney</span>(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在它的构造函数里传一个calculator给它，这个calculator可以是上面的LoanCalculator，获取到它的计算结果然后格式化。<br>接着写一个DOMRenderer的类，它负责把结果下显示出来：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显示结果</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DOMRenderer</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">calculator</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">calculator</span> = calculator</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">calResult</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="variable language_">this</span>.<span class="property">calculator</span>.<span class="title function_">calResult</span>()</span><br><span class="line">    $(<span class="string">&#x27;.pi-result&#x27;</span>).<span class="title function_">text</span>(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后代码调用如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> loadCalculator = <span class="keyword">new</span> <span class="title class_">LoanCalculator</span>(form)</span><br><span class="line"><span class="keyword">let</span> numberFormator = <span class="keyword">new</span> <span class="title class_">NumberFormator</span>(loadCalculator)</span><br><span class="line"><span class="keyword">let</span> domRenderer = <span class="keyword">new</span> <span class="title class_">DOMRenderer</span>(numberFormator)</span><br><span class="line">domRenderer.<span class="title function_">calResult</span>()</span><br><span class="line">util.<span class="title function_">ajax</span>(<span class="string">&#x27;/cal-loan&#x27;</span>, &#123;<span class="attr">result</span>: loadCalculator.<span class="title function_">getResult</span>()&#125;)</span><br></pre></td></tr></table></figure>

<p>可以看到它就是一个装饰的过程，一层一层地装饰：</p>
<p>DOMRenderer -&gt; NumberFormator -&gt; LoanCalculator</p>
<p>下一个装饰者调用上一个calResult函数，对它的结果进一步地装饰。如果这些装饰者的返回结果类型比较平行时，可以一层层地装饰下去。</p>
<p>使用装饰者模式，逻辑是清晰了，但是系统的复杂性增加了，有时候能用简单方式实现还是用简单方式。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下上文提到的面向对象的编程原则：</p>
<ol>
<li>把共性和特性或者会变和不变的部分分离出来</li>
<li>少用继承，多用组合</li>
<li>低耦合高聚合</li>
<li>开放封闭原则（对修改封闭，对扩展开放）</li>
<li>单一职责原则</li>
</ol>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【Next】一次掌握ES6到ES8新增功能</title>
    <url>/2018/04/22/b41ac9f0-af90-11ee-95d8-d38cc97ebde8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>转自 <a href="https://medium.freecodecamp.org/here-are-examples-of-everything-new-in-ecmascript-2016-2017-and-2018-d52fa3b5a70e">https://medium.freecodecamp.org/here-are-examples-of-everything-new-in-ecmascript-2016-2017-and-2018-d52fa3b5a70e</a><br>作者 rajaraodv<br>感觉挺好的，就搬过来了，很多代码值得敲一遍多多回顾理解</p>
</blockquote>
<span id="more"></span>

<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><h3 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes"></a>Array.prototype.includes</h3><p>找到数组中是否包含某项，直接返回布尔值（能找到NaN）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="title class_">NaN</span>]</span><br><span class="line"><span class="comment">// 之前</span></span><br><span class="line"><span class="keyword">if</span> (arr.<span class="title function_">indexOf</span>(<span class="number">3</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">if</span> (arr.<span class="title function_">includes</span>(<span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ps: includes还可以用来判断是否包含NaN</span></span><br><span class="line">arr.<span class="title function_">includes</span>(<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br><span class="line">arr.<span class="title function_">indexOf</span>(<span class="title class_">NaN</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="1-Object-values"><a href="#1-Object-values" class="headerlink" title="1. Object.values()"></a>1. Object.values()</h3><p>这个还好，我们已经在使用了，原来还是es7的。Object.values()是一个类似于Object.keys()的新函数，但是它返回了对象自身属性的所有值，不包括原型链中的任何值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cars = &#123;<span class="attr">BMW</span>: <span class="number">3</span>, <span class="title class_">Tesla</span>: <span class="number">2</span>, <span class="title class_">Toyota</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="keyword">const</span> vals = <span class="title class_">Object</span>.<span class="title function_">keys</span>(cars).<span class="title function_">map</span>(<span class="function"><span class="params">key</span> =&gt;</span> cars[key])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(vals) <span class="comment">// [3,2,1]</span></span><br><span class="line"><span class="comment">// use</span></span><br><span class="line"><span class="keyword">const</span> values = <span class="title class_">Object</span>.<span class="title function_">values</span>(cars) <span class="comment">// [3,2,1]</span></span><br></pre></td></tr></table></figure>

<h3 id="2-Object-entries"><a href="#2-Object-entries" class="headerlink" title="2. Object.entries()"></a>2. Object.entries()</h3><p>同上，返回的是 由键值对组成的数组的数组集合~ 好像解释得绕了，我们还是看代码吧：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cars = &#123;<span class="attr">BMW</span>: <span class="number">3</span>, <span class="title class_">Tesla</span>: <span class="number">2</span>, <span class="title class_">Toyota</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">const</span> ret = <span class="title class_">Object</span>.<span class="title function_">entries</span>(cars) <span class="comment">// [ [BWM, 3], [Tesla, 2], [Toyota, 1] ]</span></span><br><span class="line"><span class="comment">// 场景1 - 利用解构赋值，直接拿到 k v </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, val] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(cars)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`key: <span class="subst">$&#123;key&#125;</span>, value: <span class="subst">$&#123;val&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 场景2 - 将拿到的 kv对存到 Map中</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(cars))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map) <span class="comment">// Map(3) &#123;&quot;BMW&quot; =&gt; 3, &quot;Tesla&quot; =&gt; 2, &quot;Toyota&quot; =&gt; 1&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-Object-getOwnPropertyDescriptors"><a href="#3-Object-getOwnPropertyDescriptors" class="headerlink" title="3. Object.getOwnPropertyDescriptors"></a>3. Object.getOwnPropertyDescriptors</h3><p>该方法返回给定对象的所有属性的所有细节(包括getter getand setter set方法)。<br>添加这一功能的主要动机是允许浅层复制&#x2F;克隆一个对象到另一个对象，该对象也复制getter和setter函数。</p>
<p>而&#96;Object.assign 浅复制原始源对象的getter和setter函数外的所有细节。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Car</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;BWM&#x27;</span>,</span><br><span class="line">  <span class="attr">price</span>: <span class="number">10000</span>,</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">discount</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">d</span> = x</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">discount</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">d</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="title class_">Car</span>, <span class="string">&#x27;discount&#x27;</span>)) <span class="comment">// 返回某一属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(<span class="title class_">Car</span>) <span class="comment">// 返回所有属性</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oCar = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, <span class="title class_">Car</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(oCar)) <span class="comment">// 没有了discount的 getter setter</span></span><br></pre></td></tr></table></figure>

<h3 id="4-剩余对象属性"><a href="#4-剩余对象属性" class="headerlink" title="4. 剩余对象属性"></a>4. 剩余对象属性</h3><p>点点点的扩展，- - 其实用得很多了，比如写redux里经常~~</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;firstName, age, ...remaining &#125; = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">24</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">170</span>,</span><br><span class="line">  <span class="attr">hoby</span>: <span class="string">&#x27;coding&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">firstName <span class="comment">// hello</span></span><br><span class="line">age <span class="comment">// 24</span></span><br><span class="line">remaining <span class="comment">// &#123; lastName: &#x27;world&#x27;, height: 170, hoby: &#x27;coding&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以用这一点，删除对象中不需要的属性</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="variable constant_">SSN</span>, ...cleanObj&#125; = &#123;</span><br><span class="line">  <span class="attr">SSN</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;fri&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">24</span></span><br><span class="line">&#125;</span><br><span class="line">cleanObj <span class="comment">// &#123;name: &#x27;fri&#x27;, age: 24&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然，还可以利用这一点扩展对象属性</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = &#123;<span class="attr">name</span>: <span class="string">&#x27;fri&#x27;</span>, <span class="attr">age</span>: <span class="number">24</span>&#125;</span><br><span class="line"><span class="keyword">let</span> p2 = &#123;<span class="attr">name</span>: <span class="string">&#x27;yk&#x27;</span>, <span class="attr">hobby</span>: <span class="string">&#x27;coding&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;...p1, ...p2&#125; <span class="comment">// &#123;name: &quot;yk&quot;, age: 24, hobby: &quot;coding&quot;&#125; 有同名key后面的会覆盖前面的</span></span><br></pre></td></tr></table></figure>


<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="1-String-padding-字符串填充"><a href="#1-String-padding-字符串填充" class="headerlink" title="1. String padding 字符串填充"></a>1. String padding 字符串填充</h3><p>允许将空字符串或其他字符串添加到原始字符串的开头或结尾。直接上代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;5&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">10</span>)  <span class="comment">// &quot;         5&quot; 不传第二个参数默认填充空格</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">10</span>, <span class="string">&#x27;=*&#x27;</span>)  <span class="comment">// &quot;=*=*=*=*=5&quot; 第一个参数决定返回字符串的length，第二个参数用于填充，但会保留初始字符串</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;fri&#x27;</span>.<span class="title function_">padEnd</span>(<span class="number">10</span>)  <span class="comment">// &quot;fri       &quot;  和padStart类似，不过是在末尾加</span></span><br><span class="line"><span class="string">&#x27;fri&#x27;</span>.<span class="title function_">padEnd</span>(<span class="number">10</span>, <span class="string">&#x27;|--|&#x27;</span>)  <span class="comment">// &quot;fri|--||--&quot; 字符串最大长度为10，所以最终成这样</span></span><br></pre></td></tr></table></figure>

<p>我们来看一个高级点的用法，用于游戏，或是渲染字符串图片等很有用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> formatted = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">123</span>, <span class="number">1234</span>, <span class="number">12345</span>].<span class="title function_">map</span>(<span class="function"><span class="params">num</span> =&gt;</span> (</span><br><span class="line">  num.<span class="title function_">toString</span>().<span class="title function_">padStart</span>(<span class="number">10</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(formateed)</span><br><span class="line"><span class="comment">/* [</span></span><br><span class="line"><span class="comment">  &quot;0000000000&quot;, </span></span><br><span class="line"><span class="comment">  &quot;0000000001&quot;, </span></span><br><span class="line"><span class="comment">  &quot;0000000012&quot;, </span></span><br><span class="line"><span class="comment">  &quot;0000000123&quot;, </span></span><br><span class="line"><span class="comment">  &quot;0000001234&quot;, </span></span><br><span class="line"><span class="comment">  &quot;0000012345&quot;</span></span><br><span class="line"><span class="comment">] */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cars = &#123;</span><br><span class="line">  <span class="string">&#x27;😀BWM&#x27;</span>: <span class="string">&#x27;10&#x27;</span></span><br><span class="line">  <span class="string">&#x27;😎Tesla&#x27;</span>: <span class="string">&#x27;5&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;😝Lamborghini&#x27;</span>: <span class="string">&#x27;0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(cars).<span class="title function_">map</span>(<span class="function">(<span class="params">[name, count]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;name.padEnd(<span class="number">20</span>, <span class="string">&#x27; -&#x27;</span>)&#125;</span> Count: <span class="subst">$&#123;padStart(<span class="number">3</span>, <span class="string">&#x27;0&#x27;</span>)&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 😀BWM - - - - - - - Count: 010</span></span><br><span class="line"><span class="comment">// 😎Tesla - - - - - - Count: 010</span></span><br><span class="line"><span class="comment">// 😝Lamborghini - - - Count: 010</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：在Emojis和其他双字节字符上使用padStart和padEnd，一个emoji表情是2个字符</p>
</blockquote>
<h2 id="正则扩展"><a href="#正则扩展" class="headerlink" title="正则扩展"></a>正则扩展</h2><h3 id="1-s-模式"><a href="#1-s-模式" class="headerlink" title="1. s 模式"></a>1. <code>s</code> 模式</h3><p>这种增强使得点操作符可以匹配任何单个字符。为了确保这不会破坏任何东西，我们需要使用\s标志，当我们创建RegEx来工作时。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/first.<span class="property">second</span>/s.<span class="title function_">test</span>(<span class="string">&#x27;first\nsecond&#x27;</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="2-RegExp命名组捕获"><a href="#2-RegExp命名组捕获" class="headerlink" title="2. RegExp命名组捕获"></a>2. RegExp命名组捕获</h3><p>在下面的例子中，我们使用<code>(?&lt;year&gt;) (?&lt;month&gt;) (?&lt;day&gt;)</code>名称来分组日期RegEx的不同部分。产生的对象现在将包含具有属性年、月、日和相应值的组属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line"><span class="keyword">let</span> re1 = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span></span><br><span class="line"><span class="keyword">let</span> ret1 = re1.<span class="title function_">exec</span>(<span class="string">&#x27;2015-01-02&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ret1) <span class="comment">// [&quot;2015-01-02&quot;, &quot;2015&quot;, &quot;01&quot;, &quot;02&quot;, index: 0, input: &quot;2015-01-02&quot;, groups: undefined]</span></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line"><span class="keyword">let</span> re2 = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span></span><br><span class="line"><span class="keyword">let</span> ret2 = re2.<span class="title function_">exec</span>(<span class="string">&#x27;2015-01-02&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ret2.<span class="property">goups</span>) <span class="comment">// &#123;year: &quot;2015&quot;, month: &quot;01&quot;, day: &quot;02&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-使用命名组"><a href="#3-使用命名组" class="headerlink" title="3. 使用命名组"></a>3. 使用命名组</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sameWords = <span class="regexp">/(?&lt;fruit&gt;apple|orange)==\k&lt;fruit&gt;/u</span>;</span><br><span class="line">sameWords.<span class="title function_">test</span>(<span class="string">&#x27;apple==apple&#x27;</span>)   <span class="comment">// true</span></span><br><span class="line">sameWords.<span class="title function_">test</span>(<span class="string">&#x27;orange==orange&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">sameWords.<span class="title function_">test</span>(<span class="string">&#x27;apple==orange&#x27;</span>)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="4-在字符串中使用命名组"><a href="#4-在字符串中使用命名组" class="headerlink" title="4. 在字符串中使用命名组"></a>4. 在字符串中使用命名组</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;firstName&gt;[A-Za-z]+) (?&lt;lastName&gt;[A-Za-z]+$)/u</span>;</span><br><span class="line"><span class="string">&#x27;Raja Rao&#x27;</span>.<span class="title function_">replace</span>(re, <span class="string">&#x27;$&lt;lastName&gt;, $&lt;firstName&gt;&#x27;</span>) <span class="comment">// &#x27;Rao Raja&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-正则向后插入断言"><a href="#5-正则向后插入断言" class="headerlink" title="5. 正则向后插入断言"></a>5. 正则向后插入断言</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/(?&lt;=#).*<span class="regexp">/.test(&#x27;winning&#x27;) /</span>/ <span class="literal">false</span></span><br><span class="line">/(?&lt;=#).*<span class="regexp">/.test(&#x27;#winning&#x27;) /</span>/ <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>之前我们写(?&#x3D;) 这类匹配到的一般从[1]开始，这样写从[0]就可以匹配到，习惯了用之前的也行，毕竟这样会增加学习成本。</p>
<h3 id="6-正则匹配unicode"><a href="#6-正则匹配unicode" class="headerlink" title="6. 正则匹配unicode"></a>6. 正则匹配unicode</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//The following matches multiple hindi character</span></span><br><span class="line">/^\p&#123;<span class="title class_">Script</span>=<span class="title class_">Devanagari</span>&#125;+$/u.<span class="title function_">test</span>(<span class="string">&#x27;हिन्दी&#x27;</span>); <span class="comment">//true  </span></span><br><span class="line"><span class="comment">//PS:there are 3 hindi characters h</span></span><br></pre></td></tr></table></figure>

<h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h3 id="1-用来替代-Math-pow"><a href="#1-用来替代-Math-pow" class="headerlink" title="1. ** 用来替代 Math.pow"></a>1. <code>**</code> 用来替代 <code>Math.pow</code></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">7</span>, <span class="number">2</span>) <span class="comment">// 49  7的2次方</span></span><br><span class="line"><span class="comment">// use</span></span><br><span class="line"><span class="number">7</span>**<span class="number">2</span> <span class="comment">// 49 </span></span><br></pre></td></tr></table></figure>

<h3 id="2-在函数参数中添加尾随逗号，现在不会报错了"><a href="#2-在函数参数中添加尾随逗号，现在不会报错了" class="headerlink" title="2. 在函数参数中添加尾随逗号，现在不会报错了"></a>2. 在函数参数中添加尾随逗号，现在不会报错了</h3><h3 id="3-async-await"><a href="#3-async-await" class="headerlink" title="3. async&#x2F;await"></a>3. async&#x2F;await</h3><p>这个用得也挺多了，同步写法的异步函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">doubleAndAdd</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  a = <span class="keyword">await</span> <span class="title function_">doubleAfterSec</span>(a)</span><br><span class="line">  b = <span class="keyword">await</span> <span class="title function_">doubleAfterSec</span>(b)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">doubleAndAdd</span>(<span class="number">1</span>, <span class="number">2</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doubleAfterSec</span>(<span class="params">param</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="title function_">resolve</span>(param * <span class="number">2</span>), <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看一个高级用法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">doubleAndAdd</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    [a, b] = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">doubleAfterSel</span>(a), <span class="title function_">doubleAfterSec</span>(b)])</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">doubleAndAdd</span>(<span class="number">1</span>, <span class="number">2</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doubleAfterSec</span>(<span class="params">param</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="title function_">resolve</span>(param * <span class="number">2</span>), <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-Promise-prototype-finally"><a href="#4-Promise-prototype-finally" class="headerlink" title="4. Promise.prototype.finally()"></a>4. Promise.prototype.finally()</h3><p>主要的想法是允许在解决或拒绝帮助清理问题之后运行回调。最后回调被调用，没有任何值，无论如何都要执行。可以理解为增加了一个生命周期钩子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> started = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> myPromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;all good&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(val) <span class="comment">// &#x27;all good&#x27;</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finally&#x27;</span>)</span><br><span class="line">  started = <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="5-异步迭代器"><a href="#5-异步迭代器" class="headerlink" title="5. 异步迭代器"></a>5. 异步迭代器</h3><p>这是一个非常有用的特性。基本上，它允许我们轻松地创建异步代码的循环！<br>这个特性添加了一个新的“for-awaof”循环，它允许我们调用async函数，它在循环中返回承诺（或带有一堆承诺的数组）。<br>很酷的一点是，循环等待每个承诺在执行下一个循环之前解决。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="number">1</span>)),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="number">2</span>)),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="number">3</span>))</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 之前这么用</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> obj <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj) <span class="comment">// 打印3个promise</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 现在可以</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> obj <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj) <span class="comment">// 直接打印结果 1 2 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>Array方法</p>
<ol>
<li>Array.prototype.includes 是否包含某项，返回Boolean</li>
</ol>
</li>
<li><p>Object方法</p>
<ol>
<li>Object.values() 迭代器 返回value组成的对象</li>
<li>Object.entries() 迭代器，返回 k v组成的数组</li>
<li>Object.getOwnPropertyDescriptors? 取某个属性能拿到getter setter</li>
<li>对象扩展 … 点点点</li>
</ol>
</li>
<li><p>String方法</p>
<ol>
<li>padStart</li>
<li>padEnd</li>
</ol>
</li>
<li><p>正则扩展</p>
<ol>
<li>s模式 匹配换行等而不破坏字符串</li>
<li>命名组捕获</li>
<li>插入断言</li>
<li>匹配unicode</li>
</ol>
</li>
<li><p>函数扩展</p>
<ol>
<li>async&#x2F;await</li>
<li>Promise.finally 钩子</li>
<li>async函数里 for 可以使用 await</li>
<li>原生方法扩展 Math.pow -&gt; <code>**</code></li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ESNext</tag>
      </tags>
  </entry>
  <entry>
    <title>【Node】学习stream模块</title>
    <url>/2018/11/15/a288a680-af90-11ee-aa25-75a00b1cf52a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>正好读到了相关的文章推送，正巧也把之前看到的和弄了一小半的资料整理一下。- - node的学习又再此开启</p>
</blockquote>
<h1 id="stream的基本概念和常用API概述"><a href="#stream的基本概念和常用API概述" class="headerlink" title="stream的基本概念和常用API概述"></a>stream的基本概念和常用API概述</h1><p>让数据流动起来。数据从原来的source流向dest，要像水一样，慢慢的一点一点通过一个管道流过去。stream并不是node.js独有的概念，而是一个操作系统最基本的操作方式，只不过node.js有API支持这种操作方式。linux命令的<code>|</code>就是stream，因此所有server端语言都应该实现stream的API。</p>
<span id="more"></span>

<h2 id="为何要使用stream"><a href="#为何要使用stream" class="headerlink" title="为何要使用stream"></a>为何要使用stream</h2><p>例子，在线播放视频。一点一点从服务端将视频流动到本地播放器，一边流动一边播放，直到播放完成。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> server = http.<span class="title function_">createServer</span>(<span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> fileName = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;data.txt&#x27;</span>)</span><br><span class="line">  fs.<span class="title function_">readFile</span>(fileName, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">    res.<span class="title function_">end</span>(data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8000</span>)</span><br></pre></td></tr></table></figure>

<p>这段node.js代码跑起来会读取文件，语法上没问题，但如果data.txt文件非常大，在响应大量用户的并发请求时，程序可能会消耗大量的内存，这样很可能会造成用户连接缓慢的问题。而且，如果并发请求过大，服务器内存开销也很大。</p>
<p>要解决该问题很简单，用stream改造一下。即不是把全部文件读取了再返回，而是一边读取一边返回，一点点地把数据流动到客户端。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> server = http.<span class="title function_">createServer</span>(<span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> fileName = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;data.txt&#x27;</span>)</span><br><span class="line">  <span class="keyword">var</span> stream = fs.<span class="title function_">createReadStream</span>(fileName)</span><br><span class="line">  stream.<span class="title function_">pipe</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8000</span>)</span><br></pre></td></tr></table></figure>

<p>小结一下，之所以用stream，是因为一次性读取、操作大文件，内存和网络是吃不消的，因此要让数据流动起来，一点一点地进行操作。这符合分而治之的思想。</p>
<h2 id="stream流转的过程"><a href="#stream流转的过程" class="headerlink" title="stream流转的过程"></a>stream流转的过程</h2><p>从管道换水的例子可看出，stream包括source, dest还有中间的管道，下面将通过这三方面介绍stream的过程。其中比较关键的api有：</p>
<ul>
<li>data事件，用来监听stream数据的输入</li>
<li>end事件，用来监听stream数据输入完成</li>
<li>fs.createReadStream方法，返回一个文件读取的stream对象</li>
<li>fs.createWriteStream方法， 返回一个文件读取的stream对象</li>
<li>pipe方法，用来做数据流转</li>
</ul>
<h3 id="source-——-从哪里来"><a href="#source-——-从哪里来" class="headerlink" title="source —— 从哪里来"></a>source —— 从哪里来</h3><p>stream常见的来源主要有三种：</p>
<ul>
<li>从控制台输入</li>
<li>http请求中的request</li>
<li>读取文件</li>
</ul>
<p>运行如下代码，然后从控制台输入任何内容，都会被data事件监听到，process.stdin就是一个stream对象。<code>注意data就是stream用来监听数据传入的一个自定义函数</code>，后续会大量用到该方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">process.<span class="property">stdin</span>.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span>(<span class="params">chunk</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;stream by stdin&#x27;</span>, chunk.<span class="title function_">toString</span>())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>http请求中的request输入可以参考如下代码片段。即客户端发起http请求，服务端可以通过这种方式（用到了data事件监听）。这种http请求一般是一个post请求，上传数据。注意，end用来监听stream数据传输完毕，一般和data共用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span>(<span class="params">chunk</span>) &#123;</span><br><span class="line">  <span class="comment">// 一点一点 接受内容</span></span><br><span class="line">  data += chunk.<span class="title function_">toString</span>()</span><br><span class="line">&#125;)</span><br><span class="line">res.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// end表示数据接受完成</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>读取文件用 fs.createReadStream(…) 可以返回一个读取文件的stream对象，该对象可以监听data和end事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> readStream = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;./file1.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> length = <span class="number">0</span></span><br><span class="line">readStream.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span>(<span class="params">chunk</span>) &#123;</span><br><span class="line">  length += chunk.<span class="title function_">toString</span>().<span class="property">length</span></span><br><span class="line">&#125;)</span><br><span class="line">readStream.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(length)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>以上source三种代码示例有一个共同特点，就是对stream对象可以监听data和end事件。nodejs监听自定义事件要使用.on方法，例如 process.stdin.on(‘data’, …) ，能很直观地监听到stream数据的传入和结束。</p>
<h3 id="dest-——-到哪里去"><a href="#dest-——-到哪里去" class="headerlink" title="dest —— 到哪里去"></a>dest —— 到哪里去</h3><p>stream常见的输出方式主要有三种：</p>
<ul>
<li>输出到控制台</li>
<li>http请求中的response</li>
<li>写入文件</li>
</ul>
<p>如果让控制台输入这个source直接通过管道连接到控制台输入，即让数据从输入直接流向输出，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">process.<span class="property">stdin</span>.<span class="title function_">pipe</span>(process.<span class="property">stdout</span>)</span><br></pre></td></tr></table></figure>

<p>nodejs处理http请求时会用到req和res，其实这两者都是stream对象。其中，req是source，res是dest。所以stream方式读取文件然后直接返回http请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stream = fs.<span class="title function_">createReadStream</span>(fileName)</span><br><span class="line">stream.<span class="title function_">pipe</span>(res)</span><br></pre></td></tr></table></figure>

<p>读取文件可以用stream，写入文件也可以用stream，其中 fs.createWriteStream(…) 会返回一个写入文件的stream对象，即dest。这段代码，就是将一个文件中的内容，一点一点地流动到另外的文件中，完成复制功能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> readStream = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;./file1.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> writeStrea = fs.<span class="title function_">createWriteStream</span>(<span class="string">&#x27;./file2.txt&#x27;</span>)</span><br><span class="line">readStream.<span class="title function_">pipe</span>(writeStream)</span><br></pre></td></tr></table></figure>

<h3 id="stream常见使用场景"><a href="#stream常见使用场景" class="headerlink" title="stream常见使用场景"></a>stream常见使用场景</h3><p>stream常见的使用场景是http请求和文件操作。 总结来看，http请求和文件操作都属于IO，即stream主要的应用场景是处理IO，这又回到了stream的本质——由于一次性IO操作过大，硬件开销太多，影响软件运行效率，因此将IO分批分段操作，让数据一点一点地流动起来，直到操作完成。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本章主要介绍了stream的基本概念和常用API</p>
<ul>
<li>stream的基本概念，即 source -&gt; 管道 -&gt; dest</li>
<li>为何要用stream —— 一次性操作IO，内存和网络开销过大</li>
<li>source pipe dest各部分常用API</li>
<li>stream的常见应用场景——IO操作</li>
</ul>
<hr>
<h2 id="node-js实现http请求"><a href="#node-js实现http请求" class="headerlink" title="node.js实现http请求"></a>node.js实现http请求</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.<span class="title function_">createServer</span>(<span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> fileName = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;data.txt&#x27;</span>)</span><br><span class="line">  fs.<span class="title function_">readFile</span>(fileName, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">    res.<span class="title function_">end</span>(data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8000</span>)</span><br></pre></td></tr></table></figure>

<h2 id="get请求和response"><a href="#get请求和response" class="headerlink" title="get请求和response"></a>get请求和response</h2><p>通过req.method可获取请求方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.<span class="title function_">createServer</span>(<span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> method = req.<span class="property">method</span></span><br><span class="line">  <span class="keyword">if</span> (method === <span class="string">&#x27;GET&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> fileName = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;data.txt&#x27;</span>)</span><br><span class="line">    fs.<span class="title function_">readFile</span>(fileName, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">      res.<span class="title function_">end</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8000</span>)</span><br></pre></td></tr></table></figure>

<h3 id="response和stream"><a href="#response和stream" class="headerlink" title="response和stream"></a>response和stream</h3><p>response常用的API有send、end等，如上面代码中的<code>res.end(data)</code>，但是response也是一个stream对象。大家再次回顾一开始的管道换水的图，以及source.pipe(dest)模型，response就是一个dest</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.<span class="title function_">createServer</span>(<span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> method = req.<span class="property">method</span></span><br><span class="line">  <span class="keyword">if</span> (method === <span class="string">&#x27;GET&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> fileName = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;data.txt&#x27;</span>)</span><br><span class="line">    <span class="keyword">var</span> stream = fs.<span class="title function_">createReadStream</span>(fileName)</span><br><span class="line">    stream.<span class="title function_">pipe</span>(res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8000</span>)</span><br></pre></td></tr></table></figure>

<h3 id="使用stream对性能的提升"><a href="#使用stream对性能的提升" class="headerlink" title="使用stream对性能的提升"></a>使用stream对性能的提升</h3><p>略</p>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>对response使用stream特性能提高性能。因此，在nodejs中如果要返回的数据是经过IO操作得来的，例如上面例子中读取文件内容，可以直接使用stream.pipe(res)这种方式，而不再使用res.end(data)了。</p>
<p>这种应用的实例很多，主要有两种场景：</p>
<ul>
<li>使用node.js作为服务代理，即客户端通过node.js服务作为跳板去请求其他服务，返回请求的内容</li>
<li>使用node.js作为静态文件服务器，直接返回静态文件</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本节主要讲解了node.js如何处理http的get请求，以及如何对response使用stream特性，并做了压力测试证明可以提高性能。</p>
<h2 id="在http-post请求中使用stream"><a href="#在http-post请求中使用stream" class="headerlink" title="在http post请求中使用stream"></a>在http post请求中使用stream</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.<span class="title function_">createServer</span>(<span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> method = req.<span class="property">method</span></span><br><span class="line">  <span class="keyword">if</span> (method === <span class="string">&#x27;POST&#x27;</span>) &#123;</span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span>(<span class="params">chunk</span>) &#123;</span><br><span class="line">      <span class="comment">// 接受到部分数据</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;chunk&#x27;</span>, chunk.<span class="title function_">toString</span>().<span class="property">length</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">      res.<span class="title function_">end</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8000</span>)</span><br></pre></td></tr></table></figure>

<p>post请求发送数据量若很大， res.on(‘data’, …) 要分多次才能把数据接受完毕</p>
<p>小结一下，request和response一样，本身也是一个stream对象，可以用stream的特性，那肯定也能提高性能。两者的区别在于，request是source类型，是stream的源头，而response是dest类型，是stream的目的地。</p>
<p>再举个例子，如果要把request请求的数据直接response，那么最快的方式就是res.pipe(res)</p>
<h3 id="使用stream对性能的提升-1"><a href="#使用stream对性能的提升-1" class="headerlink" title="使用stream对性能的提升"></a>使用stream对性能的提升</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.<span class="title function_">createServer</span>(<span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> method = req.<span class="property">method</span></span><br><span class="line">  <span class="keyword">if</span> (method === <span class="string">&#x27;POST&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> dataStr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span>(<span class="params">chunk</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> chunkStr = chunk.<span class="title function_">toString</span>()</span><br><span class="line">      dataStr += chunkStr</span><br><span class="line">    &#125;)</span><br><span class="line">    res.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> fileName = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;data.txt&#x27;</span>)</span><br><span class="line">      fs.<span class="title function_">writeFile</span>(fileName, dataStr)</span><br><span class="line">      res.<span class="title function_">end</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8000</span>)</span><br></pre></td></tr></table></figure>

<p>用stream改良后如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> server = http.<span class="title function_">createServer</span>(<span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> method = req.<span class="property">method</span></span><br><span class="line">  <span class="keyword">if</span> (method === <span class="string">&#x27;POST&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> dataStr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span>(<span class="params">chunk</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> chunkStr = chunk.<span class="title function_">toString</span>()</span><br><span class="line">      dataStr += chunkStr</span><br><span class="line">    &#125;)</span><br><span class="line">    res.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> fileName = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;data.txt&#x27;</span>)</span><br><span class="line">      <span class="keyword">var</span> writeStream = fs.<span class="title function_">createWriteStream</span>(fileName)</span><br><span class="line">      res.<span class="title function_">pipe</span>(writeStream)</span><br><span class="line">      req.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        res.<span class="title function_">end</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="实际应用-1"><a href="#实际应用-1" class="headerlink" title="实际应用"></a>实际应用</h3><p>和get请求使用stream场景类似，post请求使用stream的场景，主要是用于将接受的数据直接进行IO操作，例如：</p>
<ul>
<li>将接收的数据直接存储为文件</li>
<li>将接收的数据直接post给其他的web server</li>
</ul>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>介绍了stream在http请求中的应用和性能提升，IO操作不仅仅包括网络IO，还包括文件IO，下一节讲解stream在文件操作中的使用，以及性能提升。</p>
<hr>
<h2 id="node-js读写文件"><a href="#node-js读写文件" class="headerlink" title="node.js读写文件"></a>node.js读写文件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> fileName = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;data.txt&#x27;</span>)</span><br><span class="line"><span class="comment">// 读文件</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(fileName, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>())</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 写文件</span></span><br><span class="line">fs.<span class="title function_">writeFile</span>(fileName, <span class="string">&#x27;xxx&#x27;</span>, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>根据以上读写操作，可以做一个简单的文件拷贝程序，将data.txt中的内容拷贝到data-bak.txt 中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读文件</span></span><br><span class="line"><span class="keyword">var</span> fileName1 = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;data.txt&#x27;</span>)</span><br><span class="line">fs.<span class="title function_">readFile</span>(fileName1, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">var</span> dataStr = data.<span class="title function_">toString</span>()</span><br><span class="line">  <span class="comment">// 写入文件</span></span><br><span class="line">  <span class="keyword">var</span> fileName2 = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;data-bak.txt&#x27;</span>)</span><br><span class="line">  fs.<span class="title function_">writeFile</span>(fileName2, dataStr, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;拷贝文件成功&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="使用stream读写文件"><a href="#使用stream读写文件" class="headerlink" title="使用stream读写文件"></a>使用stream读写文件</h3><ul>
<li>使用 fs.cretaeReadStream(filename) 来创建读取文件的stream对象</li>
<li>使用 fs.createWriteStream(filename) 来创建写入文件的stream对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> filename1 = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;data.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> filename2 = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;data-bak.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> readStream = fs.<span class="title function_">createReadStream</span>(filename1)</span><br><span class="line"><span class="keyword">var</span> writeStream = fs.<span class="title function_">createWriteStream</span>(filename2)</span><br><span class="line">readStream.<span class="title function_">pipe</span>(writeStream)</span><br><span class="line">readStream.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;拷贝完成&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="使用stream带来的性能提升"><a href="#使用stream带来的性能提升" class="headerlink" title="使用stream带来的性能提升"></a>使用stream带来的性能提升</h3><p>略</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>所有执行文件操作的场景，都应该尝试使用stream，例如文件的读写、拷贝、解压缩、格式转换等。除非是体积小且读写次数少，性能上可忽略。</p>
<hr>
<p>原生的stream对“行”无能为力，它只是把文件当作一个数据流，简单粗暴地流动。很多文件格式都是分行的，例如csv文件、日志文件等</p>
<p>node.js提供了按行读取API——readline，它本质上也是stream，只不过是以“行”作为数据流动的单位</p>
<h2 id="readline的使用"><a href="#readline的使用" class="headerlink" title="readline的使用"></a>readline的使用</h2><p>相比于stream的data和end自定义事件，readline需要监听line和close两个自定义事件。readline的基本使用示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="title function_">requrie</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> readline = <span class="built_in">require</span>(<span class="string">&#x27;readline&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fileName = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;readline-data.txt&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建读取文件的stream对象</span></span><br><span class="line"><span class="keyword">var</span> readStream = fs.<span class="title function_">createReadStream</span>(fileName)</span><br><span class="line"><span class="comment">// 创建readline对象</span></span><br><span class="line"><span class="keyword">var</span> rl = readline.<span class="title function_">createInterface</span>(&#123;</span><br><span class="line">  <span class="comment">// 输入，依赖于stream对象</span></span><br><span class="line">  <span class="attr">input</span>: readStream</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 监听逐行读取的内容</span></span><br><span class="line">rl.<span class="title function_">on</span>(<span class="string">&#x27;line&#x27;</span>, <span class="keyword">function</span>(<span class="params">lineData</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;lineData: &#x27;</span>, lineData)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 监听读取完成</span></span><br><span class="line">rl.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;readline end&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以上代码，需要先根据文件名，创建读取文件的stream对象，然后传入并生成一个readline对象，然后通过line事件监听逐行读取，通过close事件监听读取完成。</p>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>对于处理按行为单位的文件，如日志文件，使用readline是最佳选择。下面是一个实际例子，用来记录访问数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line"><span class="comment">// 监听逐行读取的内容</span></span><br><span class="line">rl.<span class="title function_">on</span>(<span class="string">&#x27;line&#x27;</span>, <span class="keyword">function</span>(<span class="params">lineData</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (lineData.<span class="title function_">indexOf</span>(<span class="string">&#x27;2018-10-30 14:00&#x27;</span>) &gt;= <span class="number">0</span> &amp;&amp; lineData.<span class="title function_">indexOf</span>(<span class="string">&#x27;user.html&#x27;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    num++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 监听读取完成</span></span><br><span class="line">rl.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;num: &#x27;</span>, num)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最后，将这个示例所用的代码贴到下面，供学习参考：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> memeye = <span class="built_in">require</span>(<span class="string">&#x27;memeye&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> readline = <span class="built_in">require</span>(<span class="string">&#x27;readline&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">memeye</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doReadLine</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> fileName = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;readline-data.txt&#x27;</span>)</span><br><span class="line">  <span class="keyword">var</span> readStream = fs.<span class="title function_">createReadStream</span>(fileName)</span><br><span class="line">  <span class="keyword">var</span> rl = readline.<span class="title function_">createInterface</span>(&#123;</span><br><span class="line">    <span class="attr">input</span>: readStream</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line">  rl.<span class="title function_">on</span>(<span class="string">&#x27;line&#x27;</span>, <span class="keyword">function</span>(<span class="params">lineData</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lineData.<span class="title function_">indexOf</span>(<span class="string">&#x27;2018-10-30 14:00&#x27;</span>) &gt;= <span class="number">0</span> &amp;&amp; lineData.<span class="title function_">indexOf</span>(<span class="string">&#x27;user.html&#x27;</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      num++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 监听读取完成</span></span><br><span class="line">  rl.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;num: &#x27;</span>, num)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(doReadLine, <span class="number">5000</span>)</span><br></pre></td></tr></table></figure>

<hr>
<p>stream就是数据一点一点地流动起来，那么每次流动的数据是什么呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> readStream = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;./file.txt&#x27;</span>)</span><br><span class="line">readStream.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span>(<span class="params">chunk</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>冯诺依曼结构，其核心内容之一就是：计算机使用二进制形式存储计算。</p>
<p>计算机内存由若干个存储单元组成，每个存储单元只能存储0或1（因为内存是硬件，计算机硬件本质上就是一个一个的电子元件，只能识别充电和放电的状态，充电代表1，放电代表0），即二进制单元（bit）。但是这一个单元所能存储的信息太少，因此约定将8个二进制单元为一个基本存储单元，叫做字节（byte）。一个字节所能存储的最大整数就是(2^8 &#x3D; 256)，也正好是16^2，因此也常常使用两位的16进制数代表一个字节。例如css常见的颜色值就是6位16进制数字，它占用3个字节的空间。</p>
<p>二进制是计算机最底层的数据格式，也是一种通用格式。计算机中的任何数据格式，字符串、数字、视频、音频、程序、网络包等，在最底层都是用二进制来进行存储的。这些高级格式和二进制之间，都可通过固定的编码格式进行相互转换。例如，C语言中int32类型的十进制数，就占用32bit即4byte。总之，计算机底层存储的数据都是二进制格式，各种高级类型都有对应的编码规则，和二进制进行相互转化。</p>
<h2 id="nodejs表示二进制"><a href="#nodejs表示二进制" class="headerlink" title="nodejs表示二进制"></a>nodejs表示二进制</h2><p>Buffer就是nodejs中二进制的表述形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;学习nodejs stream&#x27;</span></span><br><span class="line"><span class="keyword">var</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(str, <span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>以上代码，先通过 Buffer.from 将一段字符串转化为二进制形式，其中utf-8是一个编码规则。二进制打印出来之后是一个类数组的对象，每个元素都是两位的16进制数字，即代表一个byte，打印出来的buf一共有20byte。即根据utf-8的编码规则，这段字符串需要20byte进行存储，最后再通过utf-8规则将二进制转换为字符串并打印出来</p>
<h3 id="流动的数据是二进制格式"><a href="#流动的数据是二进制格式" class="headerlink" title="流动的数据是二进制格式"></a>流动的数据是二进制格式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> readStrem = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;./file.txt&#x27;</span>)</span><br><span class="line">readStream.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span>(<span class="params">chunk</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(chunk <span class="keyword">instanceof</span> <span class="title class_">Buffer</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;chunk: &#x27;</span>, chunk)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以看到stream中流动的数据就是Buffer类型。因此，在使用stream chunk时，需要将这些二进制数据转换为相应的格式。例如之前讲解post请求是，从request中接收数据就是这样。再回归一下之前的代码，就能明白了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dataStr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span>(<span class="params">chunk</span>) &#123;</span><br><span class="line">  <span class="comment">// 将二进制数据先转化为字符串</span></span><br><span class="line">  <span class="keyword">var</span> chunkStr = chunk.<span class="title function_">toString</span>()</span><br><span class="line">  dataStr += chunkStr</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>stream中为何要“流动”二进制格式的数据呢？</p>
<p>为了优化IO操作。无论是文件IO还是网络IO，其中包含的数据格式是未知的，如字符串、音频、视频、网络包等。即便这些字符串，其编码规则也是未知的，如ASC编码、utf-8编码。再这么多未可知的情况下，只能是以不变应万变，直接用最通过的二进制格式，谁都能认识，且二进制格式进行流动和传输，效率是最高的。</p>
<h3 id="Buffer带来的性能提升"><a href="#Buffer带来的性能提升" class="headerlink" title="Buffer带来的性能提升"></a>Buffer带来的性能提升</h3><p>略</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li>二进制和字节的基本认识</li>
<li>node.js中Buffer表示二进制</li>
<li>stream中的chunk是二进制格式，以及和字符串格式的转换</li>
<li>二进制格式在http请求中的性能提升</li>
</ul>
<hr>
<h2 id="stream常用类型总结"><a href="#stream常用类型总结" class="headerlink" title="stream常用类型总结"></a>stream常用类型总结</h2><p>再次回顾这张图 source通过一个管道流向了dest，如下图：</p>
<p>这里的source可能是http请求中的request，也可能是读取文件的stream对象，也可能是process.stdin；这里的dest可能是请求中的response，也可能是写入文件的stream对象，也可能是process.stdout；这里的管道就是pipe函数。</p>
<p>先不管pipe函数。source和dest完全就是两个不同的类型，一个是读取数据的，叫做readable stream，一个是写入数据的，叫作Writeable stream。除了这两种类型之外，还有一种类型叫作duplex stream（双工流），即有读取又有写入能力。示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> zlib = <span class="built_in">require</span>(<span class="string">&#x27;zlib&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> readStream = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;./file.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> writeStream = fs.<span class="title function_">createWriteStream</span>(<span class="string">&#x27;./file.txt&#x27;</span>)</span><br><span class="line">readStream.<span class="title function_">pipe</span>(zlib.<span class="title function_">createGzip</span>()).<span class="title function_">pipe</span>(writeStream)</span><br></pre></td></tr></table></figure>

<h3 id="readable-stream"><a href="#readable-stream" class="headerlink" title="readable stream"></a>readable stream</h3><p>http请求中的request和读取文件的stream对象都是readable stream。它有两种常用操作方式，第一种是直接将数据pipe到一个Writeable stream</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fileName = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;data.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> stream = fs.<span class="title function_">createReadStream</span>(fileName)</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">stream.<span class="title function_">pipe</span>(res)</span><br></pre></td></tr></table></figure>

<p>第二种是通过监听on end自定义事件来获取数据再手动处理，例如之前讲解post请求时的代码示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dataStr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span>(<span class="params">chunk</span>) &#123;</span><br><span class="line">  <span class="comment">// 接收到数据先存储起来</span></span><br><span class="line">  <span class="keyword">var</span> chunkStr = chunk.<span class="title function_">toString</span>()</span><br><span class="line">  dataStr += chunkStr</span><br><span class="line">&#125;)</span><br><span class="line">req.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 接收完数据将数据写入文件</span></span><br><span class="line">  <span class="keyword">var</span> fileName = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;post.txt&#x27;</span>)</span><br><span class="line">  fs.<span class="title function_">writeFile</span>(fileName, dataStr)</span><br><span class="line">  res.<span class="title function_">end</span>(<span class="string">&#x27;OK&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以上说的两个例子，都是已经分装好的readable stream，那么它本来的面目是怎样的？如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Readable</span> = <span class="built_in">require</span>(<span class="string">&#x27;stream&#x27;</span>).<span class="property">Readable</span></span><br><span class="line"><span class="comment">// 构造一个readable stream并往里添数据</span></span><br><span class="line"><span class="keyword">var</span> rs = <span class="keyword">new</span> <span class="title class_">Readable</span></span><br><span class="line">rs.<span class="title function_">push</span>(<span class="string">&#x27;learn&#x27;</span>)</span><br><span class="line">rs.<span class="title function_">push</span>(<span class="string">&#x27;nodejs&#x27;</span>)</span><br><span class="line">rs.<span class="title function_">push</span>(<span class="string">&#x27;stream&#x27;</span>)</span><br><span class="line">rs.<span class="title function_">push</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="comment">// pipe到一个Writeable stream</span></span><br><span class="line">rs.<span class="title function_">pipe</span>(process.<span class="property">stdout</span>)</span><br></pre></td></tr></table></figure>

<p>从上代码可看出，nodejs提供了readable stream的构造函数，可以new出一个新的readable stream对象。然后通过push函数往里灌入完成，即可输入了。最后pipe到了一个Writeable stream</p>
<h3 id="Writeable-stream"><a href="#Writeable-stream" class="headerlink" title="Writeable stream"></a>Writeable stream</h3><p>根据之前的分析，http请求中的response和写入文件的stream对象都是Writeable stream，它可以作为参数传入pipe函数，以读取上游的数据。例如之前讲解文件操作时拷贝文件的代码示例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fileName = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;post.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> writeStream = fs.<span class="title function_">createWriteStream</span>(fileName)</span><br><span class="line">res.<span class="title function_">pipe</span>(writeStream)</span><br></pre></td></tr></table></figure>

<p>以上代码中 writeStream 是已经封装好了的 Writeable stream ，下面再来看看它的真实面目。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Writeable</span> = <span class="built_in">require</span>(<span class="string">&#x27;stream&#x27;</span>).<span class="property">Writeable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ws = <span class="title class_">Writeable</span>()</span><br><span class="line">ws.<span class="property">_write</span> = <span class="keyword">function</span>(<span class="params">chunk, enc, next</span>) &#123;</span><br><span class="line">  <span class="comment">// 输出流动的数据</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(chunk.<span class="title function_">toString</span>())</span><br><span class="line">  <span class="comment">// 继续监听下一次输出</span></span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 作为参数传递到pipe函数中</span></span><br><span class="line">process.<span class="property">stdin</span>.<span class="title function_">pipe</span>(ws)</span><br></pre></td></tr></table></figure>

<p>根据以上代码得知，nodejs提供了Writeable构造函数可以new一个新的Writeable stream。通过实现它的_write方法即可监听到每次流动的数据，运行next()可继续监听.</p>
<h3 id="再谈pipe"><a href="#再谈pipe" class="headerlink" title="再谈pipe"></a>再谈pipe</h3><p>之前一直是用<code>source.pipe(dest)</code>这种模式来用pipe的，其实pipe可以链式调用。例如上文演示的duplex stream示例代码<code>readStream.pipe(zlib.createGzip()).pipe(writeStream)</code>，还有之前讲解文件操作最后列举的gulp配置文件~</p>
<p>之前讲解<code>source.pipe(dest)</code>模式是为了方便理解和使用，现在我们更新一个更严谨的pipe用法：</p>
<ul>
<li>调用pipe的对象必须是readable stream或者duplex stream，即具有读取数据的功能，如req.pipe(…)</li>
<li>传入pipe的参数必须是writeable stream或者duplex stream, 即具有写入数据的功能，如req.pipe(res)</li>
<li>pipe支持链式调用</li>
</ul>
<p>更新了pipe的最新规则，再来看就不会有困惑了。</p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>这里主要讲解了stream的常用类型和pipe函数的规则：</p>
<ul>
<li>stream的常见类型：readable stream和writeable stream</li>
<li>readable stream的本质和用法</li>
<li>writeable stream的本质和用法</li>
<li>pipe的新规则</li>
</ul>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>stream</tag>
      </tags>
  </entry>
  <entry>
    <title>【React】从基础开始再来温习React，相关学习整理</title>
    <url>/2017/12/20/8dd238a0-af90-11ee-9aaa-cb16a28eef0e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>React虽然从14版就在学习使用了，- - 换公司之后一直在用Vue，以前用Redux，服务端渲染总是觉得很坑，虽然跟着前辈写似懂非懂的，业务逻辑也能做，但Redux那块始终用得不好。也算是曲线救国，Vue、Vuex的使用让我慢慢理解了React的核心和优美之处。正好现在新版发布了，再来重学一次吧</p>
</blockquote>
<span id="more"></span>

<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><p>前端UI本质问题是： 如何将来源于服务器的动态数据和用户的交互行为高效地反映复杂的用户界面上。React通过引入虚拟DOM、状态、单向数据流等设计理念，形成以组件为核心，用组件搭建UI的开发模式，完美地将数据、组件状态和UI映射到一起，极大提高了开发大型Web应用的效率。</p>
<p>React的特点：</p>
<ol>
<li>声明式的视图层</li>
</ol>
<p>使用React不用担心数据、状态和视图交错。</p>
<ol start="2">
<li>简单的更新流程</li>
</ol>
<p>定义UI状态，React框架会复杂把它渲染成最终的UI。当状态数据发生变化时，React也会根据最新的状态渲染出最新的UI</p>
<ol start="3">
<li>灵活地渲染实现</li>
</ol>
<p>先渲染成虚拟DOM，简单的JS对象然后渲染成对应UI</p>
<ol start="4">
<li>高效的DOM操作</li>
</ol>
<p>操作JS对象比起操作真实DOM在效率上有了巨大提升。基于Diff算法，React可以尽量减少虚拟DOM到真实DOM的渲染次数</p>
<p>尽管如此，React并不是MVC框架，从分层上看，React属于V层，关注如何根据状态创建可复用UI组件。当应用复杂时，需结合Redux等才能最大发挥</p>
<h2 id="React新特性相关"><a href="#React新特性相关" class="headerlink" title="React新特性相关"></a>React新特性相关</h2><p>这里介绍了16的新特性，包括render方法新支持的返回类型、新的错误处理机制和Error Boundary组件，可以将组件挂载到任意DOM树的Portals特性以及自定义DOM属性的支持。</p>
<p>基于新的fiber架构。还有如 setState传入null不触发组件更新，更加高效的服务端渲染等方式等。</p>
<h3 id="render新的返回类型"><a href="#render新的返回类型" class="headerlink" title="render新的返回类型"></a>render新的返回类型</h3><p>返回数组</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;a&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;b&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;c&quot;</span>&gt;</span>c<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回字符串</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Just a strings</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>App 组件的render方法渲染 ListComponent 和 StringComponent</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ListComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span>,</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">StringComponent</span> /&gt;</span></span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>16版本前，组件运行期间执行错误会阻塞应用渲染。16引入新的错误处理机制，组件抛错时，会就爱你个组件从组件树中卸载，从而避免整个应用的崩溃。</p>
<p>16还提供了一种更友好的错误处理方式——错误边界。错误边界是能够捕获子组件的错误并对其优雅处理的组件，输出错误日志、显示出错提示等这比卸载组件更友好</p>
<p>定义了 componentDidCatch(error, info) 方法的组件将成为一个错误边界，现在我们创建一个组件ErrorBoundary</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">hasError</span>: <span class="literal">false</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidCatch</span>(<span class="params">error, info</span>) &#123;</span><br><span class="line">    <span class="comment">// 显示错误UI</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    <span class="comment">// 同时输出错误日志</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error, info)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">hasError</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Oopts, something went wrong.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在App中使用ErrorBoundary</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">user</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;react&#x27;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将user置为null，模拟异常</span></span><br><span class="line">  onClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">user</span>: <span class="literal">null</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Profile</span> <span class="attr">user</span>=<span class="string">&#123;this.state.user&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.onClick&#125;</span>&gt;</span>更新<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Profile</span> = (<span class="params">&#123;user&#125;</span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>name: &#123;user.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>点击更新按钮后，Profile接受的属性user为null，程序会抛错TypeError，这个错误被ErrorBoundary捕获，并在界面上显示出错提示</p>
<h3 id="Portals"><a href="#Portals" class="headerlink" title="Portals"></a>Portals</h3><p>Portals特性让我们可以把组件渲染到当前组件树以外的DOM节点上。该特性的典型应用场景是，渲染应用的全局弹框，使用Portals后，任意组件都可以将弹框组件渲染到根节点上，以方便弹框的显示。Portals的实现依赖于ReactDOM的一个新API</p>
<pre><code>ReactDOM.createPortal(child, container)
</code></pre>
<p>第一个参数child是可以被渲染的React节点，例如React元素、由React元素组成的数组、字符串等。<br>container是一个DOM元素，child将被挂载到这个DOM节点</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Modal</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="comment">// 根节点下创建一个div节点</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">container</span> = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="variable language_">this</span>.<span class="property">container</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">ReactDOM</span>.<span class="title function_">createPortal</span>(</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;modal&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;close&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.props.onClose&#125;</span>&gt;</span><span class="symbol">&amp;times;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;this.props.children&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">container</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(<span class="variable language_">this</span>.<span class="property">container</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在App中使用Modal</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">showModal</span>: <span class="literal">true</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  closeModal = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">showModal</span>: <span class="literal">false</span>&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Dashboard<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.state.showModal &amp;&amp; (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Modal</span> <span class="attr">onClose</span>=<span class="string">&#123;this.closeModal&#125;</span>&gt;</span>Modal Dialog<span class="tag">&lt;/<span class="name">Modal</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        )&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义DOM属性"><a href="#自定义DOM属性" class="headerlink" title="自定义DOM属性"></a>自定义DOM属性</h3><p>16版 React会把不识别的属性传递给DOM元素。例如， 在16前，下面的React元素</p>
<pre><code>&lt;div custom-attribute=&quot;something&quot; /&gt;
</code></pre>
<p>在浏览器中渲染出的DOM节点为：</p>
<pre><code>&lt;div /&gt;
</code></pre>
<p>而React16版渲染出的DOM节点为：</p>
<pre><code>&lt;div custom-attribute=&quot;something&quot; /&gt;
</code></pre>
<hr>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>组件从创建到被销毁的过程称为组件的生命周期。通常，有以下三个阶段：</p>
<h3 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h3><ul>
<li><p>constructor</p>
</li>
<li><p>componentWillMount 用得较少，因为此阶段的都可移到constructor里，该方法调用this.setState不会引起重渲</p>
</li>
<li><p>render 根据组件的props和state返回一个React元素。需注意，render并不负责组件的实际渲染，它只是返回一个UI描述，真正渲染DOM由React本身负责，该阶段不能执行有副作用的操作</p>
</li>
<li><p>componentDidMount 组件被挂载后只调用一次，依赖DOM节点操作可放该阶段中，还有服务端请求等操作，this.setState会引起重渲</p>
</li>
</ul>
<h3 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h3><ul>
<li>componentWillReceiveProps(nextProps) 引起组件更新过程调用。state引起组件更新不会触发该方法的执行。nextProps是父组件传递给当前组件的新props. 因此往往需比较nextProps和this.props来决定是否执行props发生变化后的逻辑</li>
</ul>
<blockquote>
<p>(1)在componentWillReceiveProps中调用setState，只有在组件render及其之后的方法中，this.setState指向的才是更新后的state。在render之前的方法shouldComponentUpdate、componentWillUpdate中，this.setState依然指向的是更新前的state</p>
</blockquote>
<blockquote>
<p>(2)通过调用setState更新组件状态并不会触发componentWillReceiveProps的调用，否则会进入一个死循环 componentWillReceiveProps -&gt; this.setState -&gt; componentWillReceiveProps …</p>
</blockquote>
<ul>
<li><p>shouldComponentUpdate(nextProps, nextState) 该方法决定组件是否继续执行更新过程。当方法返回true时(默认)，组件会继续更新过程。当返回false，组件的更新过程停止，后续的componentWillUpdate、render、componentDidUpdate也不会被调用，这是优化性能的一个重要钩子</p>
</li>
<li><p>componentWillUpdate(nextProps, nextState) 在组件render前调用，可作为组件更新前执行某些工作的地方</p>
</li>
</ul>
<blockquote>
<p>shouldComponentUpdate和componentWillUpdate中都不能调用setState，否则会引起循环调用问题</p>
</blockquote>
<ul>
<li><p>render 同上，省略了</p>
</li>
<li><p>componentDidUpdate(prevProps, prevState) 组件更新后被调用，可作为更新后操作DOM的地方，其参数prevProps, prevState代表组件更新前的props和state</p>
</li>
</ul>
<h3 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h3><p>组件从DOM中被卸载的过程，只有一个声明周期方法</p>
<ul>
<li>componentWillUnmount 在组件卸载前调用，可在这里执行一些清理工作。如定时器或手动创建的DOM元素等，以避免内存泄漏</li>
</ul>
<blockquote>
<p>只有类才具有生命周期方法，函数组件是没有生命周期钩子的。</p>
</blockquote>
<h2 id="ref相关"><a href="#ref相关" class="headerlink" title="ref相关"></a>ref相关</h2><p>绝大部分场景应避免使用ref，因为它破坏了React中以props为数据传递介质的典型数据流。</p>
<p>下面介绍下ref的常用使用场景</p>
<h2 id="在DOM上使用ref"><a href="#在DOM上使用ref" class="headerlink" title="在DOM上使用ref"></a>在DOM上使用ref</h2><p>ref接受一个回调函数作为值，在组件被挂载或卸载时，回调函数会被调用，在组件被挂载时，回调函数会接受当前DOM元素作为参数；组件被卸载时回调函数会接受null作为参数</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AutoFocusTextInput</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;input</span> =&gt;</span> this.textInput = input&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 通过ref让input自动获取焦点</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">textInput</span>.<span class="title function_">focus</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AutoFocusTextInput中为input定义ref，在组件挂载后，通过ref获取input元素，让其自动获取焦点，否则就很难实现该功能</p>
<h3 id="在组件上使用ref"><a href="#在组件上使用ref" class="headerlink" title="在组件上使用ref"></a>在组件上使用ref</h3><p>例，在使用AutoFocusTextInput组件的外部组件Containter中控制：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AutoFocusTextInput</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  blur = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">textInput</span>.<span class="title function_">blur</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;input</span> =&gt;</span> this.textInput = input&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AutoFocusTextInputContainer.jsx</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AutoFocusTextInputContainer</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 通过ref调用 组件的方法</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">inputInstance</span>.<span class="title function_">blur</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">AutoFocusTextInput</span> <span class="attr">ref</span>=<span class="string">&#123;this.inputInstance</span> = <span class="string">input&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>失去焦点<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过ref获取到了AutoFocusTextInput组件的实例对象，并把它赋值给Container的inputInstance属性，这样就可以通过inputInstance调用AutoFocusTextInput中的blur方法，让已经处于获取焦点状态的input失去焦点。</p>
<h3 id="父组件访问子组件的DOM节点"><a href="#父组件访问子组件的DOM节点" class="headerlink" title="父组件访问子组件的DOM节点"></a>父组件访问子组件的DOM节点</h3><p>某些场景可能会需要。例如父组件需知道这个DOM元素的尺寸或位置信息，直接使用ref是无法实现的。</p>
<p>这时，可在子组件的DOM元素上定义ref，ref的值是父组件传递给子组件的一个回调函数，回调函数可以通过一个自定义的属性传递，例如inputRef, 这样父组件的回调函数中就能获取到这个DOM元素</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Children</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="comment">// 子组件使用父组件传递的inputRef, 为input的ref赋值</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;props.inputRef&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 自定义一个属性inputRef，值是一个函数</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Children</span> <span class="attr">inputRef</span>=<span class="string">&#123;el</span> =&gt;</span> this.inputElement = el&#125; /&gt;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从该例中还可发现，即时子组件是函数组件，这种方式同样有效。</p>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><ul>
<li>React的事件命名采用驼峰命名</li>
<li>处理事件的响应函数要以对象形式赋值给事件属性</li>
</ul>
<hr>
<p>React事件是合成事件，并不是原生DOM事件。在React事件中必须显式调用事件对象的preventDefault方法来阻止事件的默认行为。</p>
<p>在 React组件中处理事件最容易出错的是事件处理函数中this指向问题，因为ES6 Class不会为方法自动绑定到当前对象。</p>
<ol>
<li>使用箭头函数</li>
</ol>
<p>箭头函数的this指向的是函数定义时的对象，可保证this总是指向当前组件的实例对象。<br>直接在render方法为元素事件定义事件处理函数，最大问题是每次render调用时都会重新创建一个新的事件处理函数，带来额外的性能开销，组件所处层级越低，开销就越大</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;e</span> =&gt;</span> this.handleClick(e)&#125;&gt;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用组件方法</li>
</ol>
<p>直接将组件的方法赋值给元素的事件属性，同时在类的构造函数中，将这个方法的this绑定当当前对象</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick(e)&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好处是每次render不会重新创建一个回调函数，没有额外的性能损失。但模版较为繁琐，还有下一种改良：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick.bind(this)&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用bind会创建一个新函数，因此该写法毅然存在每次render都会创建一个新函数问题</p>
<p><strong>3. 属性初始化语法</strong> property initializer syntax</p>
<p>使用ES7的property initializers会自动为class中定义的方法绑定this：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">num</span>: <span class="number">0</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ES7的属性初始化方法，实际上也是使用了箭头函数</span></span><br><span class="line">  handleClick = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> num = ++<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">num</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      num</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;this.state.num&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式既不需要在构造函数中手动绑定this，也不需要担心组件重复渲染导致的函数重复创建问题。</p>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>【React】进阶React的重要知识点</title>
    <url>/2017/12/28/7968d950-af90-11ee-8337-957f241819c8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>这里只是React的相关知识点整理，也算是老生常谈了吧，通过这样的整理让自己温故知新。说是进阶，其实也算是基础的重要知识点。好了，于是我们一起来看看吧：</p>
</blockquote>
<ul>
<li>组件<ul>
<li>组件与state</li>
<li>几种组件通信</li>
<li>ref</li>
</ul>
</li>
<li>虚拟DOM相关</li>
<li>性能优化</li>
<li>高阶组件</li>
</ul>
<span id="more"></span>



<h2 id="组件间的通信"><a href="#组件间的通信" class="headerlink" title="组件间的通信"></a>组件间的通信</h2><p>React里的组件通信方式大致有以下几种情况：</p>
<h3 id="父子组件的通信通过props"><a href="#父子组件的通信通过props" class="headerlink" title="父子组件的通信通过props"></a>父子组件的通信通过props</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UserList.jsx</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserList</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">className</span>=<span class="string">&quot;user-list&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;this.props.users.map(user =&gt; (</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;user.id&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;user.name&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          ))&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserListContainer.jsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">UserList</span> <span class="keyword">from</span> <span class="string">&#x27;./UserList&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserListContainer</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">users</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &#123;<span class="comment">/* 通过props传递users */</span>&#125;</span><br><span class="line">      &lt;<span class="title class_">UserList</span> users=&#123;<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">users</span>&#125; /&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;/path/api&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      res.<span class="title function_">json</span>().<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">          <span class="attr">users</span>: data</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子向父组件通信"><a href="#子向父组件通信" class="headerlink" title="子向父组件通信"></a>子向父组件通信</h3><p>父组件可以通过子组件的props传递给子组件一个回调函数，子组件在需要改变父组件数据时，调用该回调即可。下面为UserList增加一个添加新用户功能：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserList</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">newUser</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  handleChange = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">newUser</span>: e.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">newUser</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">newUser</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">onAddUser</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">newUser</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">className</span>=<span class="string">&quot;user-list&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;this.props.users.map(user =&gt; (</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;user.id&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;user.name&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          ))&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.newUser&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>add uesr<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h3><p>兄弟组件不能直接相互传送数据，需要通过状态提升的方式实现兄弟组件的通信：即把组件之间需要共享的state保存到距离它们最近的共同父组件内，任意一个兄弟组件都可以通过父组件传递的回调修改共享状态。</p>
<p>组件从服务器上获取数据，不包含组件向服务器提交数据的情况。</p>
<h3 id="组件挂载阶段通信"><a href="#组件挂载阶段通信" class="headerlink" title="组件挂载阶段通信"></a>组件挂载阶段通信</h3><p>React组件的正常运转本质上是组件不同生命周期方法的有序执行，因此组件与服务器的通信也必定依赖组件的声明周期方法。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">UserListContainer</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="comment">// 省略无关代码</span></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>UserListContainer<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;/path/api&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      res.<span class="title function_">json</span>().<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">          <span class="attr">users</span>: data</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>componentDidMount是官方推荐的通信周期，当然componentWillMount也是可以的。</p>
<ol>
<li><p>componentDidMount中执行服务器通信可以保证获取数据时，组件已经处于挂载状态，即便操作DOM也是安全的，而componentWillMount无法保证</p>
</li>
<li><p>当组件在服务端渲染时，componentWillMount会被调用两次，一次是服务端，一次是浏览器端，而componentDidMount能保证在任何情况下只调用一次，从而不会发送多余的请求</p>
</li>
</ol>
<h3 id="组件更新阶段通信"><a href="#组件更新阶段通信" class="headerlink" title="组件更新阶段通信"></a>组件更新阶段通信</h3><p>componentWillReceiveProps非常适合做更新阶段的服务器通信。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserListContainer</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="comment">// 省略</span></span><br><span class="line">  <span class="title function_">componentWillReceiveProps</span>(<span class="params">nextProps</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextProps.<span class="property">category</span> !== <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">category</span>) &#123;</span><br><span class="line">      <span class="title function_">fetch</span>(<span class="string">`/path/api?category=<span class="subst">$&#123;nextProps.category&#125;</span>`</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        res.<span class="title function_">json</span>().<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            <span class="attr">users</span>: data</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需注意：在执行fetch请求时，要先对新老props中的category作比较，有不一致才进行更新。componentWillReceiveProps并不能保证props一定发生了修改</p>
<h2 id="深入理解组件"><a href="#深入理解组件" class="headerlink" title="深入理解组件"></a>深入理解组件</h2><p>state所代表的一个组件UI呈现的完整状态又可以分成两类数据：用作渲染组件时使用到的数据的来源以及用作组件UI展现形式的判断依据。</p>
<hr>
<h3 id="如何定义state"><a href="#如何定义state" class="headerlink" title="如何定义state"></a>如何定义state</h3><p>在组件中需要用到一个变量，且与组件的渲染无关时，就应该把这个变量定义为组件的普通属性，直接挂载到this下，而不是作为组件的state。还有就是看render方法有无用到该变量，没有就同样挂载到this下</p>
<p>state和props都直接和组件的UI渲染有关，它们的变化会触发组件的重新渲染，但props对于使用它的组件来说是只读的，是通过父组件传递过来的，想要修改props，只能在父组件中修改，而state是组件内部自己维护的状态，是可变的</p>
<p>总结一下，组件中用到一个变量是不是应该作为state可通过下面4条依据进行判断：</p>
<ol>
<li>该变量是否通过props从父组件中获取？若是，则不是state</li>
<li>该变量是否在组件的整个生命周期中保持不变？若是，则不是state</li>
<li>该变量是否可通过其他state或props计算得到？若是，则不是state</li>
<li>该变量是否在render方法中使用？若是，则为state，反之则不是，该情况下，变量更适合定义为组件的一个普通属性</li>
</ol>
<hr>
<ul>
<li>不能直接修改state，需要用setState</li>
<li>state的更新是异步的</li>
</ul>
<p>调用setState时，组件的state不会立即改变，setState只是把要修改的状态放入一个队列中，React会优化真正的执行时机，出于性能考虑，可能会将多次setState状态修改合并成一次状态修改。所以不要依赖当前state去计算下一个state。当真正执行修改时，依赖的this.state并不能保证是最新的state。同样不能依赖当前props计算下一状态，因为props的更新也是异步的。</p>
<hr>
<h3 id="state-与不可变对象"><a href="#state-与不可变对象" class="headerlink" title="state 与不可变对象"></a>state 与不可变对象</h3><ol>
<li>state类型是不可变类型（数字、字符串、布尔值、null、undefined）</li>
</ol>
<p>因state是不可变类型，所以直接给要修改的状态赋一个新值即可</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;React&#x27;</span>,</span><br><span class="line">  <span class="attr">success</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>state类型是数组</li>
</ol>
<p>法一：使用preState、concat创建新数组</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">books</span>: preState.<span class="property">books</span>.<span class="title function_">concat</span>([<span class="string">&#x27;React Guide&#x27;</span>])</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<p>法二：ES6 spread syntax</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">books</span>: [...preState.<span class="property">books</span>, <span class="string">&#x27;React Guide&#x27;</span>]</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<p>当从books中截取部分元素作为新状态时，可使用数组的slice方法</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">books</span>: preState.<span class="property">books</span>.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<p>当从books中过滤部分元素后作为新状态，可使用数组的filter方法</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">books</span>: preState.<span class="property">books</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item !== <span class="string">&#x27;React&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<p>注意，不要使用push、pop、shift、unshift、splice等方法修改数组类型的状态，因为这些方法都是在原数组的基础上修改的，而concat、slice、filter会返回一个新的数组</p>
<h3 id="state的类型是普通对象-不包含字符串、数组"><a href="#state的类型是普通对象-不包含字符串、数组" class="headerlink" title="state的类型是普通对象(不包含字符串、数组)"></a>state的类型是普通对象(不包含字符串、数组)</h3><ol>
<li>使用ES6的Object.assign</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">owner</span>: <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, preState.<span class="property">owner</span>, &#123;<span class="attr">name</span>: <span class="string">&#x27;Jason&#x27;</span>&#125;)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用对象扩展语法 Object spread properties</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">owner</span>: &#123;...preState.<span class="property">owner</span>, <span class="attr">name</span>: <span class="string">&#x27;Jason&#x27;</span>&#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<p>总结下，创建新的state的关键是，避免使用会直接修改原对象的方法，而是使用可以返回一个新对象的方法。当然也可以使用一些Immutable的JS库来实现</p>
<p><code>React状态为什么要是不可变对象呢？</code> 一方面是因为不可变对象的修改会返回一个新对象，不用担心原有对象在不小心情况下被修改导致的错误，方便程序管理与调试。另一方面是出于性能考虑，当对象组件状态都是不可变对象时，在组件的shouldComponentUpdate方法中仅需要比较前后两次状态引用就可以判断状态是否真的改变，从而避免不必要的render调用。</p>
<p>React之所以执行效率高，其重要原因是虚拟DOM机制。React应用常用的性能优化也与虚拟DOM机制有关。</p>
<h2 id="虚拟DOM相关"><a href="#虚拟DOM相关" class="headerlink" title="虚拟DOM相关"></a>虚拟DOM相关</h2><p>在Web环境中，DOM也就是对HTML文本的一种抽象描述。在传统开发中，通过调用浏览器提供API对DOM执行增删查改操作。这些操作看似只执行了一条JS语法，但其效率要慢得多。因为对DOM的修改会引起页面的重布局和重渲染，这过程很耗时，这也是前端性能优化的一条原则，尽量减少DOM操作。</p>
<p>虚拟DOM是一层抽象（对真实DOM），建立在真实的DOM上。（虚拟DOM是一项独立的技术）</p>
<pre><code>&lt;div class=&quot;foo&quot;&gt;
  &lt;h1&gt;Hello React&lt;/h1&gt;
&lt;/div&gt;
</code></pre>
<p>可以用JS对象来描述</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">className</span>: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">      <span class="attr">props</span>: &#123;</span><br><span class="line">        <span class="attr">children</span>: <span class="string">&#x27;Hello React&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了虚拟DOM这一层，当我们需要操作DOM时，就可以操作虚拟DOM而不是操作真实DOM。</p>
<h3 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h3><p>React采用声明式地API描述UI结构，每次组件的状态或属性更新，组件的render方法都会返回一个新的虚拟DOM对象，用来表述新的UI结构。如果每次render都直接使用新的虚拟DOM来生成真实DOM结构，那么会带来大量对真实DOM的操作，影响执行效率。</p>
<p>事实上，React通过比较两次虚拟DOM的变化找出差异部分，更新到真实DOM上，从而减少最终要在真实DOM上执行的操作，提高程序执行效率。这一过程就是React的调和过程Reconcliliation，其中的关键就是比较两个树型结构的diff算法。</p>
<blockquote>
<p>在diff算法中，比较的两方是新的虚拟DOM和旧的虚拟DOM，而表示虚拟DOM和真实DOM，只不过Diff的结果会更新到真实的DOM上。</p>
</blockquote>
<p>正常情况下，比较两个树形结构差异的算法时间复杂度是O(N^3)。React通过总结DOM的实际使用场景提出了两个在绝大多数实践场景下都成立的假设，基于这两个假设，React实现了O(N)时间复杂度内完整两棵虚拟DOM树的比较：</p>
<ol>
<li>如果两个元素的类型不同，那么它们将生成两棵不同的树</li>
<li>为列表中的元素设置key，用key标识对应的元素在多次render过程中是否发生变化</li>
</ol>
<h3 id="当根节点是不同类型时"><a href="#当根节点是不同类型时" class="headerlink" title="当根节点是不同类型时"></a>当根节点是不同类型时</h3><p>从div变成p，ComponentA变成ComponentB，或者从ComponentA变成div这些都是节点类型发生变化的情况。</p>
<p>根节点类型变化，React会认为新的树和旧的树完全不同，不会再继续比较其他属性和子节点，而是把整棵树拆掉重建（包括虚拟DOM树和真实DOM树）。需要注意的是，虚拟DOM节点类型分为两类：一类是DOM元素类型，一类是React组件类型。</p>
<p>在旧的虚拟DOM树被拆除过程中，旧的DOM元素类型的节点会被销毁，旧的React组件的实例componentWillUnmount会被调用，在重建过程中，新的DOM元素会被插入到DOM树中，新的组件实例的componentWillMount和componentDidMount方法会被调用。重建后的新的虚拟DOM树会被整体更新到真实DOM树中，这种情况需要大量DOM操作，更新效率最低。</p>
<h3 id="当根节点是相同的DOM元素类型时"><a href="#当根节点是相同的DOM元素类型时" class="headerlink" title="当根节点是相同的DOM元素类型时"></a>当根节点是相同的DOM元素类型时</h3><p>React会保留根节点，而比较根节点的属性，然后只更新那些变化了的属性。</p>
<h3 id="当根节点是相同的组件类型时"><a href="#当根节点是相同的组件类型时" class="headerlink" title="当根节点是相同的组件类型时"></a>当根节点是相同的组件类型时</h3><p>对应的组件实例不会被销毁，只是会执行更新操作，同步变化的属性到虚拟DOM树上，这一过程组件实例的componentWillReceiveProps和componentWillUpdate会被调用。注意，对于组件类型的节点，React是无法直接知道如何更新真实DOM树的，需要在组件更新并且render方法执行完成后，根据render返回的虚拟DOM结构决定如何更新真实DOM树。</p>
<p>比较完根节点后，React会以同样的原则继续递归比较子节点，每一个子节点相对于其层级以下的节点来说又是一个根节点。如此递归比较，直到比较完两棵树上的所有节点，计算得到最终差异，更新到DOM树中。</p>
<h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><p>高阶组件是React中一个重要而复杂的概念。主要用来实现组件逻辑的抽象和复用，在很多第三方库被使用到。合理使用高阶组件也能显著提高代码质量。</p>
<p><strong>基本概念</strong> 高阶函数是函数作为参数，并且返回值也是函数的函数。类似地，高阶组件简称（HOC）接受React组件作为参数，并且返回一个新的React组件。高阶组件本质上也是一个函数，并不是一个组件，高阶组件的函数形式如下：</p>
<pre><code>const EnhancedComponent = higherOrderComponent(WrappedComponent)
</code></pre>
<p>从例子来看。MyComponent组件需要从LocalStorage中读取数据然后渲染到界面，一般来说：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; data &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但当其他组件也需要从LocalStorage中获取同样的数据展示时，每个组件都需要重写一次componentWillMount中的代码，这是很冗余的。于是用高阶组件来改写这部分：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">withPersistentData</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> data = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; data &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 通过 &#123;...this.props&#125;把传递给当前组件的属性传递给被包装的组件</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">data</span>=<span class="string">&#123;this.state.data&#125;</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyComponentWithPersistenData</span> = <span class="title function_">withPersistentData</span>(<span class="title class_">MyComponent</span>)</span><br></pre></td></tr></table></figure>

<p>withPersistenData就是一个高阶组件，它返回一个新的组件，在新组件的componentWillMount中统一处理从localStorage中获取数据的逻辑，然后将获取到的数据通过props传递给被包装的租金啊WrappedComponent。这样在WrappedComponent中就可以直接使用this.props.data获取需要展示的数据。</p>
<p>高阶组件的主要功能是封装被分离组件的通用逻辑，让通用逻辑在组件间更好地被复用。高阶组件的这种实现方式的本质其实就是装饰者设计模式。</p>
<hr>
<p><strong>使用场景</strong></p>
<ol>
<li>操作props</li>
<li>通过ref访问组件实例</li>
<li>组件状态提升</li>
<li>从其他元素包装组件</li>
</ol>
<h3 id="操作props"><a href="#操作props" class="headerlink" title="操作props"></a>操作props</h3><p>在被包装组件接受props前，高阶组件可以先拦截props，对props执行增、删、改等操作，然后将处理后的props再传递给被包装组件。</p>
<h3 id="通过ref访问组件实例"><a href="#通过ref访问组件实例" class="headerlink" title="通过ref访问组件实例"></a>通过ref访问组件实例</h3><p>高阶组件通过ref获取被包装组件实例的引用，然后高阶组件就具备了直接操作被包装组件的属性或方法的能力。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">withRef</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    someMehod = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">wrappedInstance</span> = <span class="variable language_">this</span>.<span class="title function_">someMethodInWrappedComponent</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 为被包装组件添加ref ， 从而获取该组件实例并赋值给this.wrappedInstance</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">ref</span>=<span class="string">&#123;instance</span> =&gt;</span> this.wrappedInstance = instance&#125; &#123;...this.props&#125; /&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当WrappedComponent被渲染时，执行ref的回调函数，高阶组件通过this.wrappedInstance保存WrappedComponent实例的引用，在someMethod方法中，通过this.wrappedInstance调用WrappedComponent实例中的方法。</p>
<h3 id="组件状态提升"><a href="#组件状态提升" class="headerlink" title="组件状态提升"></a>组件状态提升</h3><p>无状态组件更容易被复用。高阶组件可以通过将被包装组件的状态及相应的状态处理方法提升到高阶组件自身内部实现被包装组件的无状态化。一个典型场景是，利用高阶组件将原本受控组件需要自己维护的状态统一提升到高阶组件中：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">withControlledState</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>()</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleValueChange = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">value</span>: e.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// newProps保存受控组件需要使用的属性和事件处理函数</span></span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        <span class="attr">controlledProps</span>: &#123;</span><br><span class="line">          <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">value</span>,</span><br><span class="line">          <span class="attr">onChange</span>: <span class="variable language_">this</span>.<span class="property">handleValueChange</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...newProps</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子把受控组件的value属性用到的状态和处理value变化的回调都提升到了高阶组件中，当我们再使用受控组件时，可以这么使用：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleControlledComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 此时的SimpleControlledComponent 为无状态组件，状态由高阶组件维护</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">nmae</span>=<span class="string">&quot;simple&quot;</span> &#123;<span class="attr">...this.props.controlledProps</span>&#125; /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ComponentWithControlledState</span> = <span class="title function_">withControlledState</span>(<span class="title class_">SimpleControlledComponent</span>)</span><br></pre></td></tr></table></figure>

<h3 id="用其他元素包装组件"><a href="#用其他元素包装组件" class="headerlink" title="用其他元素包装组件"></a>用其他元素包装组件</h3><p>我们还可以在高阶组件渲染 WrappedComponent时添加额外的元素，这种情况通常用于为 WrappedCompoent增加布局或修改样式</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">withRedBackground</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;backgroundColor:</span> &#x27;<span class="attr">red</span>&#x27;&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>高阶组件的参数并非只是一个组件，它还可以接受其他参数。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">withPersistentData</span>(<span class="params">WrappedComponent, key</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> data = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(key)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        [<span class="string">`local/<span class="subst">$&#123;key&#125;</span>`</span>]: data</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 通过&#123;...this.props&#125;把传递给当前组件的属性继续传递给被包装的组件</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">data</span>=<span class="string">&#123;this.state.data&#125;</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><code>HOC(...params)</code>返回值是一个高阶组件，高阶组件需要的参数是先传递给HOC函数的。用这种形式改写withPersistentData如下</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">withPersistentData</span> = key =&gt; <span class="function"><span class="params">WrappedCompnent</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> data = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(key)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; data &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 通过 &#123;...this.props&#125; 把传递给当前组件的属性继续传递给被包装的组件</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">data</span>=<span class="string">&#123;this.state.data&#125;</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取key=&#x27;data&#x27;的数据</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyComponentPersistentData</span> = <span class="title function_">withPersistentData</span>(<span class="string">&#x27;data&#x27;</span>)(<span class="title class_">MyCompoent</span>)</span><br></pre></td></tr></table></figure>

<p>实际上，这种形式的高阶组件大量出现在第三方库中，如react-redux的connect函数就是一个典型的例子。connect的简化定义如下：</p>
<pre><code>connect(mapStateToProps, mapDispatchToProps)(WrappedComponent)
</code></pre>
<p>这个函数会将一个React组件连接到Redux的store上，在连接的过程中，connect通过函数参数mapStateToProps从全局store中取出当前组件需要的state，并把state转化成当前组件的props，传递给当前组件。 connect并不会修改传递进去的组件的定义，而是会返回一个新的组件。</p>
<blockquote>
<p>connect的参数mapStateToProps、mapDispatchToProps是函数类型，说明高阶组件的参数也可以是函数类型。</p>
</blockquote>
<pre><code>const connectedComponentA = connect(mapStateToProps, mapDispatchToProps)(ComponentA)
</code></pre>
<p>我们可以把它拆分来看</p>
<pre><code>// connect是一个函数，返回值 enhance也是一个函数
const enhance = connect(mapState, mapDispatch)
// enhance是一个高阶组件
const ConnectedComponentA = enhance(ComponentA)
</code></pre>
<p>这种形式的高阶组件易组合使用。因为当多个函数的输出和它的输入类型相同时，这些函数易组合到一起。</p>
<pre><code>// connect的参数是可选参数，这里省略了mapDispatch参数
const ConnectedComponentA = connect(mapStateToProps)(withLog(ComponentA))
</code></pre>
<p>我们还可以定义一个工具函数 compose(…funcs)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params">...fns</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (fns.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">  <span class="keyword">if</span> (fns.<span class="property">length</span> === <span class="number">1</span>) <span class="keyword">return</span> fns[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">return</span> fns.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="title function_">acc</span>(<span class="title function_">cur</span>(args)))</span><br></pre></td></tr></table></figure>

<p>调用<code>compose(f, g, h)</code> 等价于 <code>(...args) =&gt; f(g(h(...args)))</code></p>
<p>用compose函数可以把高阶组件嵌套的写法打平：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> enhance = <span class="title function_">compose</span>(</span><br><span class="line">  <span class="title function_">connect</span>(mapState),</span><br><span class="line">  <span class="title function_">withLog</span>()</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ConnectedComponentA</span> = <span class="title function_">enhance</span>(<span class="title class_">ComponentA</span>)</span><br></pre></td></tr></table></figure>

<p>像Redux等第三方库都提供了compose的实现，compose结合高阶组件使用可以显著提高代码的可读性和逻辑的清晰度</p>
<hr>
<h3 id="继承方式实现高阶组件"><a href="#继承方式实现高阶组件" class="headerlink" title="继承方式实现高阶组件"></a>继承方式实现高阶组件</h3><p>上面这类由高阶组件处理通用逻辑，然后再将相关属性传递给被包装组件，我们称这种实现方式为<code>属性代理</code>。</p>
<p>除此外，还可以通过继承方式实现高阶组件，通过继承被包装组件实现逻辑的复用。继承方式实现的高阶组件常用于渲染劫持。例如：当用户处于登录状态，允许组件渲染，否则渲染一个空组件：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">withAuth</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">WrappedComponent</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">loggedIn</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">render</span>()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据WrappedComponent的<code>this.props.loggedIn</code>判断用户是否已经登录，若登录就通过super.render()调用WrappedComponent的render方法正常渲染，否则返回null。</p>
<p>继承方式实现的高阶组件对被包装组件具有侵入性，当组合多个高阶组件使用时，很容易因为子类组件忘记通过super调用父类组件方法而导致逻辑丢失。因此，在使用高阶组件时，应尽量通过代理方式实现高阶组件。</p>
<hr>
<p><strong>注意事项</strong></p>
<h3 id="1-为了在开发和调试阶段更好地区别包装了不同组件的高阶组件，需要对高阶组件的显示名称做自定义处理。"><a href="#1-为了在开发和调试阶段更好地区别包装了不同组件的高阶组件，需要对高阶组件的显示名称做自定义处理。" class="headerlink" title="1. 为了在开发和调试阶段更好地区别包装了不同组件的高阶组件，需要对高阶组件的显示名称做自定义处理。"></a>1. 为了在开发和调试阶段更好地区别包装了不同组件的高阶组件，需要对高阶组件的显示名称做自定义处理。</h3><p>常用的处理方式是，把被包装组件的显示名称也包到高阶组件的显示名称中：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">withPersistentData</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="comment">// 结合被包装组件的名称，自定义高阶组件的名称</span></span><br><span class="line">    <span class="keyword">static</span> displayName = <span class="string">`HOC(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>  <span class="comment">// 省略</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDisplayName</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">WrappedComponent</span>.<span class="property">displayName</span> || <span class="title class_">WrappedComponent</span>.<span class="property">name</span> || <span class="string">&#x27;Component&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-不要在组件的render方法中使用高阶组件，尽量也不要在组件的其他生命周期方法中使用高阶组件。"><a href="#2-不要在组件的render方法中使用高阶组件，尽量也不要在组件的其他生命周期方法中使用高阶组件。" class="headerlink" title="2. 不要在组件的render方法中使用高阶组件，尽量也不要在组件的其他生命周期方法中使用高阶组件。"></a>2. 不要在组件的render方法中使用高阶组件，尽量也不要在组件的其他生命周期方法中使用高阶组件。</h3><p>因为调用高阶组件，每次都会返回一个新的组件，于是每次render前一次高阶组件创建的组件都会被卸载unmount，然后重新挂载(mount)本次创建的新组件，影响效率又丢失子组件状态，如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 每次render, enhance都会创建一个新租金啊，尽管被包装的组件没有变</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">EnhancedComponent</span> = <span class="title function_">enhance</span>(<span class="title class_">MyComponent</span>)</span><br><span class="line">  <span class="comment">// 因为是新的组件，所以会经历旧组件的卸载和新组件的重新挂载</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">EnhancedComopnent</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以高阶组件最适合的地方是在组件定义的外部，这样就不会收到组件生命周期的影响。</p>
<h3 id="3-如果需要使用被包装组件的静态方法，那么必须手动复制这些静态方法。"><a href="#3-如果需要使用被包装组件的静态方法，那么必须手动复制这些静态方法。" class="headerlink" title="3. 如果需要使用被包装组件的静态方法，那么必须手动复制这些静态方法。"></a>3. 如果需要使用被包装组件的静态方法，那么必须手动复制这些静态方法。</h3><p>因为高阶组件返回的新组件不包含被包装组件的静态方法，如：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WrappedComponent组件定义了一个静态方法staticMethod</span></span><br><span class="line"><span class="title class_">WrappedComponent</span>.<span class="property">staticMethod</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">withHOC</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Enhance</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 手动复制静态方法到Enhance上</span></span><br><span class="line">  <span class="title class_">Enhance</span>.<span class="property">staticMethod</span> = <span class="title class_">WrappedComponent</span>.<span class="property">staticMethod</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-refs不会被传递给被包装组件"><a href="#4-refs不会被传递给被包装组件" class="headerlink" title="4. refs不会被传递给被包装组件"></a>4. refs不会被传递给被包装组件</h3><p>尽管在定义高阶组件时，我们会把所有的属性都传递给被包装组件，但是ref并不会传递给被包装组件。如果在高阶组件的返回数组中定义了ref，那么它指向的是这个返回的新组件，而不是内部被包装的组件。如果希望获取被包装组件的引用，那么可以自定义一个属性，属性的值是一个函数，传递给被包装的ref。下面的例子就是用inputRef这个属性名替代常规的ref命名：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FocusInput</span>(<span class="params">&#123;inputRef, ...rest&#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用高阶组件传递的inputRef作为ref的值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> &#123;<span class="attr">...rest</span>&#125; /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// enhance是一个高阶组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">EnhanceInput</span> = <span class="title function_">enhance</span>(<span class="title class_">FocusInput</span>)</span><br><span class="line"><span class="comment">// 在一个组件的render方法中，自定义属性inputRef代替ref</span></span><br><span class="line"><span class="comment">// 保证inputRef可以传递给被包装组件</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">EnhanceInput</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">inputRef</span>=<span class="string">&#123;input</span> =&gt;</span> this.input = input&#125;</span></span><br><span class="line"><span class="language-xml">  /&gt;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 组件内 让FocusInput自动获取焦点</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">input</span>.<span class="title function_">focus</span>()</span><br></pre></td></tr></table></figure>

<h3 id="5-与父组件的区别"><a href="#5-与父组件的区别" class="headerlink" title="5. 与父组件的区别"></a>5. 与父组件的区别</h3><p>高阶组件在一些方面与父组件类似。我们可以把高阶组件中的逻辑放到一个父组件中执行，执行完成的结果再传递给子组件，但是高阶组件强调的是逻辑的抽象。</p>
<p>高阶组件是一个函数，函数关注的是逻辑；父组件是一个组件，组件主要关注的是UI&#x2F;DOM。如果逻辑是与DOM直接相关的，那么这部分逻辑适合放到父组件中实现；如果逻辑是与DOM不直接相关的，那么这部分逻辑使用用高阶组件抽象，如数据校验、请求发送等。</p>
<hr>
<p>高阶组件用于封装组件的通用逻辑，常用在操作组件props、通过ref访问组件实例、组件状态提升和用其他元素包装组件等场景中。</p>
<p>高阶组件可以接受被包装组件以外的其他参数，多个高阶组件还可以组合使用。高阶组件一般通过代理实现，少量场景中也会使用继承等方式实现。灵活地使用高阶组件可以显著提高代码质量和效率。</p>
<hr>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>【TS】使用vuex-class</title>
    <url>/2018/05/01/621e2c00-af90-11ee-ae03-510b5eb8604b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p><code>vuex-class</code>是<code>vue-class-component</code>作者写的，质量有保证。且目前这类的库也不多，用法和之前的vue-property-decorator差不多，主要是通过装饰器模式，一来支持ts里的vuex，二来减少冗余的代码量。</p>
</blockquote>
<span id="more"></span>

<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>我们直接来看官方的例子就好，引入相关依赖</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Component</span> <span class="keyword">from</span> <span class="string">&#x27;vue-class-component&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="title class_">State</span>,</span><br><span class="line">  <span class="title class_">Getter</span>,</span><br><span class="line">  <span class="title class_">Action</span>,</span><br><span class="line">  <span class="title class_">Mutation</span>,</span><br><span class="line">  namespace</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex-class&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> someModule = <span class="title function_">namespace</span>(<span class="string">&#x27;path/to/module&#x27;</span>)</span><br><span class="line"></span><br><span class="line">@<span class="title class_">Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">MyComp</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  @<span class="title class_">State</span>(<span class="string">&#x27;foo&#x27;</span>) stateFoo</span><br><span class="line">  @<span class="title class_">State</span>(<span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">bar</span>) stateBar</span><br><span class="line">  @<span class="title class_">Getter</span>(<span class="string">&#x27;foo&#x27;</span>) getterFoo</span><br><span class="line">  @<span class="title class_">Action</span>(<span class="string">&#x27;foo&#x27;</span>) actionFoo</span><br><span class="line">  @<span class="title class_">Mutation</span>(<span class="string">&#x27;foo&#x27;</span>) mutationFoo</span><br><span class="line">  @someModule.<span class="title class_">Getter</span>(<span class="string">&#x27;foo&#x27;</span>) moduleGetterFoo</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 若省略参数，直接使用参数名称</span></span><br><span class="line">  @<span class="title class_">State</span> foo</span><br><span class="line">  @<span class="title class_">Getter</span> bar</span><br><span class="line">  @<span class="title class_">Action</span> baz</span><br><span class="line">  @<span class="title class_">Mutation</span> qux</span><br><span class="line"></span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stateFoo</span> <span class="comment">// -&gt; store.state.foo</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stateBar</span> <span class="comment">// -&gt; store.state.bar</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getterFoo</span> <span class="comment">// -&gt; store.getters.foo</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">actionFoo</span>(&#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; store.dispatch(&#x27;foo&#x27;, &#123; value: true &#125;)</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">mutationFoo</span>(&#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; store.commit(&#x27;foo&#x27;, &#123; value: true &#125;)</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">moduleGetterFoo</span> <span class="comment">// -&gt; store.getters[&#x27;path/to/module/foo&#x27;]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看着非常简单… 好像懂了 大概就是这种感觉？！</p>
<p>然而 namespace 这个就找不到，需要自己在 <code>*.d.ts</code>文件里定义接口</p>
<p>和我们之前用的vuex提供的 mapMutations mapGetters 这些一样，只是换了种形式进来了而已。</p>
<p>源码也更少，增加点信心一探究竟吧~</p>
<p>vuex-class&#x2F;src&#x2F;index.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  <span class="title class_">State</span>,</span><br><span class="line">  <span class="title class_">Getter</span>,</span><br><span class="line">  <span class="title class_">Action</span>,</span><br><span class="line">  <span class="title class_">Mutation</span>,</span><br><span class="line">  <span class="keyword">namespace</span></span><br><span class="line">&#125; from &#x27;./bindings&#x27;</span><br></pre></td></tr></table></figure>

<p>vuex-class&#x2F;src&#x2F;bindings.ts</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;createDecorator&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-class-component&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  mapState,</span><br><span class="line">  mapGetters,</span><br><span class="line">  mapActions,</span><br><span class="line">  mapMutations</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们在使用时，ts有各种烦人的检查，若类型不一致报错是无法运行的</span></span><br><span class="line"><span class="comment">// 把其他的省略了- - 只保留了看得懂和我们关心，使用的那几个</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">BindingHelpers</span> &#123;</span><br><span class="line">  <span class="title class_">State</span>: <span class="title class_">StateBindingHelper</span></span><br><span class="line">  <span class="title class_">Getter</span>: <span class="title class_">BindingHelper</span></span><br><span class="line">  <span class="title class_">Mutation</span>: <span class="title class_">BindingHelper</span></span><br><span class="line">  <span class="title class_">Action</span>: <span class="title class_">BindingHelper</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有了这几个方法后，我们就可以在ts里使用了 那具体是怎么实现的？</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">State</span> = <span class="title function_">createBindingHelper</span>(<span class="string">&#x27;computed&#x27;</span>, mapState) <span class="keyword">as</span> <span class="title class_">StateBindingHelper</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Getter</span> = <span class="title function_">createBindingHelper</span>(<span class="string">&#x27;computed&#x27;</span>, mapGetters)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Action</span> = <span class="title function_">createBindingHelper</span>(<span class="string">&#x27;methods&#x27;</span>, mapActions)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Mutation</span> = <span class="title function_">createBindingHelper</span>(<span class="string">&#x27;methods&#x27;</span>, mapMutations)</span><br></pre></td></tr></table></figure>

<p>核心处理函数 <code>createBindingHelper</code>单独拿出来分析了</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createBindingHelper</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="comment">// 方法或者属性，它已经告诉我们了 在computed或methods上</span></span></span><br><span class="line"><span class="params">  bindTo: <span class="string">&#x27;computed&#x27;</span> | <span class="string">&#x27;methods&#x27;</span>,</span></span><br><span class="line"><span class="params">  <span class="comment">// 这个后面再说，用过应该能想个大概</span></span></span><br><span class="line"><span class="params">  mapFn: MapHelper</span></span><br><span class="line"><span class="params"></span>) <span class="title class_">BindingHelper</span>: &#123;</span><br><span class="line">  <span class="comment">// 返回类型因属于 BindingHelper</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">makeDecorator</span>(<span class="params">may: <span class="built_in">any</span>, <span class="keyword">namespace</span>: <span class="built_in">string</span> | <span class="literal">undefined</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createDecorator</span>(<span class="function">(<span class="params">componentOptions, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 初次处理, 初始化为对象</span></span><br><span class="line">      <span class="keyword">if</span> (!componentOptions[bindTo]) &#123;</span><br><span class="line">        componentOptions[bindTo] = &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> mapObject = &#123;[key]: map&#125;</span><br><span class="line">      <span class="comment">// 这个!号突如其来，没懂…</span></span><br><span class="line">      componentOptions[bindTo]![key] = <span class="keyword">namespace</span> !== undefined</span><br><span class="line">        ? mapFn(<span class="keyword">namespace</span>, mapObject)[key]</span><br><span class="line">        : mapFn(mapObject)[key]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只能大致说下意思了…</p>
<p>可耻地写个 Todo 了，我去看TypeScript最新的官方文档了。。。</p>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>【TS】vue与typescript集成</title>
    <url>/2018/04/25/1cc3f5e0-af90-11ee-87d1-11afd3d83f2c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>一直想找个机会试试typescript，正好看到一个小项目练手，于是直接开始吧</p>
</blockquote>
<p>正文分两部分：</p>
<ul>
<li>vue与ts集成 </li>
<li>项目实战</li>
</ul>
<p>转自<a href="https://segmentfault.com/a/1190000012486378">Vue-TypeScript-DpApp-Demo</a><br><a href="https://juejin.im/post/59f29d28518825549f7260b6">Vue + TypeScript 新项目起手式</a></p>
<span id="more"></span>

<h2 id="Vue与TypeScript集成相关配置"><a href="#Vue与TypeScript集成相关配置" class="headerlink" title="Vue与TypeScript集成相关配置"></a>Vue与TypeScript集成相关配置</h2><p>此demo就是用了 typescript 改的~~ <a href="https://github.com/Fridolph/colorful-gallery.git">https://github.com/Fridolph/colorful-gallery.git</a></p>
<p><code>vue init SimonZhangITer/vue-typescript-template &lt;project-name&gt;</code></p>
<p>npm i ts-loader -D</p>
<p>使用别人造好轮子就好。当然，我们还是要看看前人踩了哪些坑</p>
<h3 id="配置rules"><a href="#配置rules" class="headerlink" title="配置rules"></a>配置rules</h3><p>接着在Webpack的module.rules里面添加对ts的支持</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">  <span class="attr">loader</span>: <span class="string">&#x27;vue-loader&#x27;</span>,</span><br><span class="line">  <span class="attr">options</span>: vueLoaderConfig</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">  <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">  <span class="attr">enforce</span>: <span class="string">&#x27;pre&#x27;</span>,</span><br><span class="line">  <span class="attr">loader</span>: <span class="string">&#x27;tslint-loader&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">  <span class="attr">loader</span>: <span class="string">&#x27;ts-loader&#x27;</span>,</span><br><span class="line">  <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">  <span class="attr">options</span>: &#123;</span><br><span class="line">    <span class="attr">appendTsSuffixTo</span>: [<span class="regexp">/\.vue$/</span>],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ts-loader</code>会检索当前目录下的 <code>tsconfig.json</code>文件，根据里面定义的规则来解析<code>.ts</code>文件，就跟<code>.babelrc的作用一样</code></p>
<blockquote>
<p>tslint-loader 作用等同于 eslint-loader</p>
</blockquote>
<h3 id="配置extensions"><a href="#配置extensions" class="headerlink" title="配置extensions"></a>配置extensions</h3><p>添加可识别文件后缀对ts的支持，如：</p>
<p><code>extensions: [&#39;.js&#39;, &#39;.vue&#39;, &#39;.json&#39;, &#39;.ts&#39;]</code></p>
<h3 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h3><p>创建tsconfig.json文件，放在根目录下，和package.json同级</p>
<p>配置内容主要也看个人需求，具体可以去typescript的官网查看，但是有一点需要注意：</p>
<blockquote>
<p>在Vue中，你需要引入 strict: true (或者至少 noImplicitThis: true，这是 strict 模式的一部分) 以利用组件方法中 this 的类型检查，否则它会始终被看作 any 类型。</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="comment">// 只对src下面的文件生效</span></span><br><span class="line">    <span class="string">&quot;src/*&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;src/**/*&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;node_modules&quot;</span> <span class="comment">// 排除node_modules 加快速度</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 类型选项之前已经配置好了</span></span><br><span class="line">    <span class="attr">&quot;types&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="comment">// 添加Node作为选项</span></span><br><span class="line">      <span class="string">&quot;node&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// typeRoots选项之前已经配置好了</span></span><br><span class="line">    <span class="attr">&quot;typeRoots&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;node_modules/@types&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 以严格模式解析</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 在.tsx文件里支持JSX</span></span><br><span class="line">    <span class="attr">&quot;jsx&quot;</span><span class="punctuation">:</span> <span class="string">&quot;preserve&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 使用的JSX工厂函数 createElement</span></span><br><span class="line">    <span class="attr">&quot;jsxFactory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;h&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 允许从没有设置默认导出的模块中默认导入</span></span><br><span class="line">    <span class="attr">&quot;allowSyntheticDefaultImports&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 启用装饰器</span></span><br><span class="line">    <span class="attr">&quot;experimentalDecorators&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;strictFunctionTypes&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 允许编译javascript文件</span></span><br><span class="line">    <span class="attr">&quot;allowJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 采用的模块系统</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;esnext&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 编译输出目标 ES 版本</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es5&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 如何处理模块</span></span><br><span class="line">    <span class="attr">&quot;moduleResolution&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 在表达式和声明上有隐含的any类型时报错</span></span><br><span class="line">    <span class="attr">&quot;noImplicitAny&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lib&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;dom&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;es5&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;es6&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;es7&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;es2015.promise&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sourceMap&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pretty&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="修改main-js"><a href="#修改main-js" class="headerlink" title="修改main.js"></a>修改main.js</h3><p>把项目主文件main.js修改成main.ts，里面的写法基本不变，但是有一点需要注意：</p>
<p>引入Vue文件的时候需要加上.vue后缀,否则编辑器识别不到</p>
<p>把webpack的entry文件也修改成<code>main.ts</code></p>
<h3 id="vue-shims-d-ts"><a href="#vue-shims-d-ts" class="headerlink" title="vue-shims.d.ts"></a>vue-shims.d.ts</h3><p>TypeScript并不支持Vue文件，所以需要告诉TypeScript*.vue文件交给vue编辑器来处理。解决方案就是在创建一个vue-shims.d.ts文件，建议放在src目录下再创建一个typings文件夹，把这个声明文件放进去，如：src&#x2F;typings&#x2F;vue-shims.d.ts，文件内容：</p>
<blockquote>
<p>*.d.ts类型文件不需要手动引入，TypeScript会自动加载</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;*.vue&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Vue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>意思是告诉 TypeScript <code>*.vue</code>后缀的文件可以交给vue模块来处理</p>
<p>而在代码中导入<code>*.vue</code>文件时，需要写上.vue后缀，原因还是因为TypeScript默认只识别 *.ts 文件，不识别 *.vue 文件</p>
<p>到这里TypeScript在Vue中配置就完成了，可以愉快的撸代码了~</p>
<h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><p>引入第三方库需要额外声明文件</p>
<p>比如说我想引入vue-lazyload,虽然已经在本地安装，但是typescript还是提示找不到模块。原因是typescript是从node_modules&#x2F;@types目录下去找模块声明，有些库并没有提供typescript的声明文件，所以就需要自己去添加</p>
<blockquote>
<p>解决办法： 在src&#x2F;typings目前下建一个tools.d.ts文件，声明这个模块即可</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;vue-awesome-swiper&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">swiper</span>: any</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">swiperSlide</span>: any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;vue-lazyload&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="改造-vue-文件"><a href="#改造-vue-文件" class="headerlink" title="改造 .vue 文件"></a>改造 .vue 文件</h3><h4 id="vue-class-component"><a href="#vue-class-component" class="headerlink" title="vue-class-component"></a>vue-class-component</h4><p>vue-class-component是官方维护的TypeScript装饰器，写法比较扁平化。Vue对其做到完美兼容，如果你在声明组件时更喜欢基于类的 API，这个库一定不要错过</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>msg: &#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>computed msg: &#123;&#123;computedMsg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;greet&quot;</span>&gt;</span>Greet<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">Component</span> <span class="keyword">from</span> <span class="string">&#x27;vue-class-component&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">@<span class="title class_">Component</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 初始化数据 不用写 data return 了</span></span></span><br><span class="line"><span class="language-javascript">  msg = <span class="number">123</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 计算属性</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">get</span> <span class="title function_">computedMsg</span>() &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="string">`computed <span class="subst">$&#123;<span class="variable language_">this</span>.msg&#125;</span>`</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 相同于 methods 里写 方法</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">greet</span>(): <span class="keyword">void</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">`greeting <span class="subst">$&#123;<span class="variable language_">this</span>.msg&#125;</span>`</span>)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 生命周期钩子 - 像普通函数一样写就好</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="title function_">greet</span>()</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="vuex-class"><a href="#vuex-class" class="headerlink" title="vuex-class"></a>vuex-class</h4><p>vuex-class是基于基于vue-class-component对Vuex提供的装饰器。它的作者同时也是vue-class-component的主要贡献者，质量还是有保证的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Component</span> <span class="keyword">from</span> <span class="string">&#x27;vue-class-component&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">State</span>, <span class="title class_">Action</span>, <span class="title class_">Getter</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex-class&#x27;</span></span><br><span class="line"></span><br><span class="line">@<span class="title class_">Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: string = <span class="string">&#x27;fu yinsheng&#x27;</span></span><br><span class="line"></span><br><span class="line">  @<span class="title class_">State</span> <span class="attr">login</span>: boolean</span><br><span class="line">  @<span class="title class_">Action</span> <span class="attr">initAjax</span>: <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line">  @<span class="title class_">Getter</span> <span class="attr">load</span>: boolean</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">isLogin</span>(): boolean &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">login</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">initAjax</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="vue-property-decorator"><a href="#vue-property-decorator" class="headerlink" title="vue-property-decorator"></a>vue-property-decorator</h4><p>这是在<code>vue-class-component</code>上增强了更多结合vue特性的装饰器，新增了7个装饰器</p>
<ul>
<li>@Emit</li>
<li>@Inject</li>
<li>@Model</li>
<li>@Prop</li>
<li>@Provide</li>
<li>@Watch</li>
<li>@Component (从vue-class-component中继承)</li>
</ul>
<p>这里列举几个常用的 <code>@Prop、@Watch、@Component</code></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Component</span>, <span class="title class_">Emit</span>, <span class="title class_">Inject</span>, <span class="title class_">Model</span>, <span class="title class_">Prop</span>, <span class="title class_">Provide</span>, <span class="title class_">Vue</span>, <span class="title class_">Watch</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  <span class="meta">@Prop</span>()</span><br><span class="line">  <span class="attr">propA</span>: <span class="built_in">number</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Prop</span>(&#123;<span class="attr">default</span>: <span class="string">&#x27;default value&#x27;</span>&#125;)</span><br><span class="line">  <span class="attr">propB</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Prop</span>([<span class="title class_">String</span>, <span class="title class_">Boolean</span>])</span><br><span class="line">  <span class="title class_">PropC</span>: <span class="built_in">string</span> | <span class="built_in">boolean</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Prop</span>(&#123;<span class="attr">type</span>: <span class="literal">null</span>&#125;)</span><br><span class="line">  <span class="attr">propD</span>: <span class="built_in">any</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Watch</span>(<span class="string">&#x27;child&#x27;</span>)</span><br><span class="line">  <span class="title function_">onChildChanged</span>(<span class="params">val: <span class="built_in">string</span>, oldVal: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码相当于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">propA</span>: <span class="title class_">Number</span>,</span><br><span class="line">    <span class="attr">propB</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="string">&#x27;default value&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">propC</span>: [<span class="title class_">String</span>, <span class="title class_">Boolean</span>],</span><br><span class="line">    <span class="attr">propD</span>: &#123;<span class="attr">type</span>: <span class="literal">null</span>&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">child</span>: &#123;</span><br><span class="line">      <span class="attr">handler</span>: <span class="string">&#x27;onChildChanged&#x27;</span>,</span><br><span class="line">      <span class="attr">immediate</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">deep</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">onChildChanged</span>(<span class="params">val, oldVal</span>) &#123;</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>【TS】装饰模式与vue-property-decorator</title>
    <url>/2018/04/26/46df8830-af90-11ee-9c6b-3368a08d2284/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>在用typescript时，vue-property-decorator 是在 vue-class-component 上增强了更多的结合 Vue 特性的装饰器，新增了这 7 个装饰器：</p>
<ul>
<li>@Emit</li>
<li>@Inject</li>
<li>@Model</li>
<li>@Prop</li>
<li>@Provide</li>
<li>@Watch</li>
<li>@Component (从 vue-class-component 继承)</li>
</ul>
<p>源码也就200来行，于是就有信心来慢慢读了</p>
<span id="more"></span>

<p>为什么需要vue-class-component？ 在typescript里写vue 每次都需要写很多额外的形式代码：</p>
<p>而装饰器就是解决这些冗余代码的（实质上并没有减少，只是用一层函数包装了，后面有源码会讲解）</p>
<blockquote>
<p>可自行了解一下<a href="http://blog.csdn.net/zhshulin/article/details/38665187">装饰模式</a></p>
</blockquote>
<h2 id="AOP-面向切面编程"><a href="#AOP-面向切面编程" class="headerlink" title="AOP 面向切面编程"></a>AOP 面向切面编程</h2><p>示例：</p>
<ul>
<li>首先创建一个普通的Man类，它的抵御值 2，攻击力为 3，血量为 3；</li>
<li>然后我们让其带上钢铁侠的盔甲，这样他的抵御力增加 100，变成 102；</li>
<li>让其带上光束手套，攻击力增加 50，变成 53；</li>
<li>最后让他增加“飞行”能力</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">def = <span class="number">2</span>, atk = <span class="number">3</span>, hp = <span class="number">3</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">init</span>(def, atk, hp)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">init</span>(<span class="params">def, atk, hp</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">def</span> = def <span class="comment">//防御</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">atk</span> = atk <span class="comment">// 攻击</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hp</span> = hp</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`防御力: <span class="subst">$&#123;<span class="variable language_">this</span>.def&#125;</span>，攻击力: <span class="subst">$&#123;<span class="variable language_">this</span>.atk&#125;</span>，血量：<span class="subst">$&#123;<span class="variable language_">this</span>.hp&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tony = <span class="keyword">new</span> <span class="title class_">Man</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`当前状态 ===&gt; <span class="subst">$&#123;tony&#125;</span>`</span>)</span><br><span class="line"><span class="comment">// 输出：当前状态 ===&gt; 防御力:2,攻击力:3,血量:3</span></span><br></pre></td></tr></table></figure>

<p>然后 创建 decorateArmour 方法，为钢铁侠装配盔甲——注意 decorateArmour 是装饰在方法init上的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">decorateArmour</span>(<span class="params">target, key, descriptor</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> method = descriptor.<span class="property">value</span></span><br><span class="line">  <span class="keyword">let</span> moreDef = <span class="number">100</span></span><br><span class="line">  <span class="keyword">let</span> ret</span><br><span class="line">  descriptor.<span class="property">value</span> = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    args[<span class="number">0</span>] += moreDef</span><br><span class="line">    ret = method.<span class="title function_">apply</span>(target, args)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> descriptor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">def = <span class="number">2</span>, atk = <span class="number">3</span>, hp = <span class="number">3</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">init</span>(def, atk, hp)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @decorateArmour</span><br><span class="line">  <span class="title function_">init</span>(<span class="params">def, atk, hp</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">def</span> = def</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">atk</span> = atk</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hp</span> = hp</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`防御力:<span class="subst">$&#123;<span class="variable language_">this</span>.def&#125;</span>,攻击力:<span class="subst">$&#123;<span class="variable language_">this</span>.atk&#125;</span>,血量:<span class="subst">$&#123;<span class="variable language_">this</span>.hp&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tony = <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`当前状态 ===&gt; <span class="subst">$&#123;tony&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// 输出：当前状态 ===&gt; 防御力:102,攻击力:3,血量:3</span></span><br></pre></td></tr></table></figure>

<p>Decorators 的本质是利用了 ES5 的 Object.defineProperty 属性，这三个参数其实是和 Object.defineProperty 参数一致的，因此不能更改，详细分析请见 <a href="http://greengerong.com/blog/2015/09/24/es7-javascript-decorators/">细说 ES7 JavaScript Decorators</a></p>
<p>同样的代码复制一份，增加攻击力：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">decorateLight</span>(<span class="params">target, key, descriptor</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> method = descriptor.<span class="property">value</span>;</span><br><span class="line">  <span class="keyword">let</span> moreAtk = <span class="number">50</span>;</span><br><span class="line">  <span class="keyword">let</span> ret;</span><br><span class="line">  descriptor.<span class="property">value</span> = <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">    args[<span class="number">1</span>] += moreAtk;</span><br><span class="line">    ret = method.<span class="title function_">apply</span>(target, args);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">def = <span class="number">2</span>,atk = <span class="number">3</span>,hp = <span class="number">3</span></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">init</span>(def,atk,hp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @decorateArmour</span><br><span class="line">  @decorateLight</span><br><span class="line">  <span class="title function_">init</span>(<span class="params">def,atk,hp</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">def</span> = def; <span class="comment">// 防御值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">atk</span> = atk;  <span class="comment">// 攻击力</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hp</span> = hp;  <span class="comment">// 血量</span></span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> tony = <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`当前状态 ===&gt; <span class="subst">$&#123;tony&#125;</span>`</span>);</span><br><span class="line"><span class="comment">//输出：当前状态 ===&gt; 防御力:102,攻击力:53,血量:3</span></span><br></pre></td></tr></table></figure>

<hr>
<p>按装饰模式所言，装饰模式有：纯粹装饰模式和半透明装饰模式</p>
<p>上面两个属于纯粹装饰模式，它不增加对原有类的接口。而下面给普通人增加飞行能力，给类增加新方法，属于半透明的装饰模式，类似适配器模式：</p>
<ol>
<li>增加一个方法</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addFly</span>(<span class="params">canFly</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    target.<span class="property">canFly</span> = canFly</span><br><span class="line">    <span class="keyword">let</span> extra = canFly ? <span class="string">&#x27;(技能加成：飞行能力)&#x27;</span> : <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">let</span> method = target.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span></span><br><span class="line"></span><br><span class="line">    target.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> method.<span class="title function_">apply</span>(target.<span class="property"><span class="keyword">prototype</span></span>, args) + extra</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>用这个方法去直接装饰类</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addFly</span>(<span class="params">canFly</span>) &#123;</span><br><span class="line">  <span class="comment">// 接上， 省略了</span></span><br><span class="line">&#125;</span><br><span class="line">@<span class="title function_">addFly</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">def = <span class="number">2</span>, atk = <span class="number">3</span>, hp = <span class="number">3</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">init</span>(def, atk, hp)</span><br><span class="line">  &#125;</span><br><span class="line">  @decorateArmour</span><br><span class="line">  @decorateLight</span><br><span class="line">  <span class="title function_">init</span>(<span class="params">def, atk, hp</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">def</span> = def</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">atk</span> = atk</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hp</span> = hp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`当前状态 ===&gt; <span class="subst">$&#123;tony&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// 输出：当前状态 ===&gt; 防御力:102,攻击力:53,血量:3(技能加成:飞行能力)</span></span><br></pre></td></tr></table></figure>

<p>作用在方法上的decorator接收第一个参数(target)是类的prototype；如果把一个decorator作用到类上，则它的第一个参数target是类本身</p>
<h2 id="经典实现-Logger"><a href="#经典实现-Logger" class="headerlink" title="经典实现 Logger"></a>经典实现 Logger</h2><p>有了上面的基础，下面我们来写一个简易版<code>日志系统</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">log</span> = type =&gt; <span class="function">(<span class="params">target, name, descriptor</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> method = descriptor.<span class="property">value</span></span><br><span class="line">  descriptor.<span class="property">value</span> = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">`(<span class="subst">$&#123;type&#125;</span> 正在执行：<span class="subst">$&#123;name&#125;</span>(<span class="subst">$&#123;args&#125;</span>) = ?`</span>)</span><br><span class="line">    <span class="keyword">let</span> ret</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ret = method.<span class="title function_">apply</span>(target, args)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">`(<span class="subst">$&#123;tytpe&#125;</span> 成功：<span class="subst">$&#123;name&#125;</span>(<span class="subst">$&#123;args&#125;</span>) =&gt; <span class="subst">$&#123;ret&#125;</span>)`</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`(<span class="subst">$&#123;tytpe&#125;</span> 失败：<span class="subst">$&#123;name&#125;</span>(<span class="subst">$&#123;args&#125;</span>) =&gt; <span class="subst">$&#123;error&#125;</span>)`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IronMan</span> &#123;</span><br><span class="line">  @<span class="title function_">log</span>(<span class="string">&#x27;IronMan 自检阶段&#x27;</span>)</span><br><span class="line">  <span class="title function_">check</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;检查完毕&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @<span class="title function_">log</span>(<span class="string">&#x27;IronMan 攻击阶段&#x27;</span>)</span><br><span class="line">  <span class="title function_">attack</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;击倒敌人&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @<span class="title function_">log</span>(<span class="string">&#x27;IronMan 机体报错&#x27;</span>)</span><br><span class="line">  <span class="title function_">error</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;something is wrong!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tony = <span class="keyword">new</span> <span class="title class_">IronMan</span>()</span><br><span class="line">tony.<span class="title function_">check</span>();</span><br><span class="line">tony.<span class="title function_">attack</span>();</span><br><span class="line">tony.<span class="title function_">error</span>();</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// (IronMan 自检阶段) 正在执行: check() = ?</span></span><br><span class="line"><span class="comment">// (IronMan 自检阶段) 成功 : check() =&gt; 检查完毕</span></span><br><span class="line"><span class="comment">// (IronMan 攻击阶段) 正在执行: attack() = ?</span></span><br><span class="line"><span class="comment">// (IronMan 攻击阶段) 成功 : attack() =&gt; 击倒敌人</span></span><br><span class="line"><span class="comment">// (IronMan 机体报错) 正在执行: error() = ?</span></span><br><span class="line"><span class="comment">// (IronMan 机体报错) 失败: error() =&gt; Something is wrong!</span></span><br></pre></td></tr></table></figure>

<p>Logger方法的关键在于：</p>
<ul>
<li>首先使用 <code>const method = descriptor.value</code> 将原有的方法提取出来，保障原有方法的纯净</li>
<li>在<code>try catch</code>语句是调用 <code>ret = method.apply(target, args)</code> 在调用之前之后分别进行日志汇报</li>
<li>最后返回 <code>return ret</code> 原始的调用结果</li>
</ul>
<h3 id="vue-property-decorator"><a href="#vue-property-decorator" class="headerlink" title="vue-property-decorator"></a>vue-property-decorator</h3><p>vue-property-decorator 是在 vue-class-component 上增强了更多的结合 Vue 特性的装饰器，新增了这 7 个装饰器：</p>
<ul>
<li>@Emit</li>
<li>@Inject</li>
<li>@Model</li>
<li>@Prop</li>
<li>@Provide</li>
<li>@Watch</li>
<li>@Component (从 vue-class-component 继承)</li>
</ul>
<p>我们来读读源码上是怎样来实现的吧：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span>, &#123;<span class="title class_">PropOptions</span>, <span class="title class_">WatchOptions</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Component</span>, &#123;createDecorator&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-class-component&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;reflect-metadata&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Constructor</span> = &#123;</span><br><span class="line">  <span class="title function_">new</span>(...<span class="attr">args</span>: <span class="built_in">any</span>[]): <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们在 vue-property-decorator 可调用 Vue 和 Component 是这样继承下来的</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="title class_">Component</span>, <span class="title class_">Vue</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of an inject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> <span class="variable">PropertyDecorator</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Inject</span>(<span class="params">key?: <span class="built_in">string</span> | <span class="built_in">symbol</span></span>): <span class="title class_">PropertyDecorator</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createDecorator</span>(<span class="function">(<span class="params">componentOptions, k</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> componentOptions.<span class="property">inject</span> === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// inject默认为 空对象</span></span><br><span class="line">      componentOptions.<span class="property">inject</span> = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(componentOptions.<span class="property">inject</span>)) &#123;</span><br><span class="line">      <span class="comment">// 第二个参数 就是我们对 inject的注入</span></span><br><span class="line">      componentOptions.<span class="property">inject</span>[k] = key || k</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of an provide</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> <span class="variable">PropertyDecorator</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Provide</span>(<span class="params">key?: <span class="built_in">string</span> | <span class="built_in">symbol</span></span>): <span class="title class_">PropertyDecorator</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createDecorator</span>(<span class="function">(<span class="params">componentOptions, k</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">provide</span>: <span class="built_in">any</span> = componentOptions.<span class="property">provide</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> provide !== <span class="string">&#x27;function&#x27;</span> || !provide.<span class="property">managed</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> original = componentOptions.<span class="property">provide</span></span><br><span class="line">      provide = componentOptions.<span class="property">provide</span> = <span class="keyword">function</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> rv = <span class="title class_">Object</span>.<span class="title function_">create</span>((<span class="keyword">typeof</span> original === <span class="string">&#x27;function&#x27;</span> ? original.<span class="title function_">call</span>(<span class="variable language_">this</span>) : original) || <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> provide.<span class="property">managed</span>) rv[provide.<span class="property">managed</span>[i]] = <span class="variable language_">this</span>[i]</span><br><span class="line">        <span class="keyword">return</span> rv</span><br><span class="line">      &#125;</span><br><span class="line">      provide.<span class="property">managed</span> = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    provide.<span class="property">managed</span>[k] = key || k</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of model</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  event event name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> <span class="variable">PropertyDecorator</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Model</span>(<span class="params">event?: <span class="built_in">string</span>, options: (PropOptions | Constructor[] | Constructor) = &#123;&#125;</span>): <span class="title class_">PropertyDecorator</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target: Vue, key: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(options) &amp;&amp; <span class="keyword">typeof</span> (options <span class="keyword">as</span> <span class="title class_">PropOptions</span>).<span class="property">type</span> === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">      (options <span class="keyword">as</span> <span class="title class_">PropOptions</span>).<span class="property">type</span> = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&#x27;design:type&#x27;</span>, target, key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">createDecorator</span>(<span class="function">(<span class="params">componentOptions, k</span>) =&gt;</span> &#123;</span><br><span class="line">      (componentOptions.<span class="property">props</span> || (componentOptions.<span class="property">props</span> = &#123;&#125;) <span class="keyword">as</span> <span class="built_in">any</span>)[k] = options</span><br><span class="line">      componentOptions.<span class="property">model</span> = &#123; <span class="attr">prop</span>: k, <span class="attr">event</span>: event || k &#125;</span><br><span class="line">    &#125;)(target, key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of a prop</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  options the options for the prop</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> PropertyDecorator | void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Prop</span>(<span class="params">options: (PropOptions | Constructor[] | Constructor) = &#123;&#125;</span>): <span class="title class_">PropertyDecorator</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target: Vue, key: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(options) &amp;&amp; <span class="keyword">typeof</span> (options <span class="keyword">as</span> <span class="title class_">PropOptions</span>).<span class="property">type</span> === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">      (options <span class="keyword">as</span> <span class="title class_">PropOptions</span>).<span class="property">type</span> = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&#x27;design:type&#x27;</span>, target, key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">createDecorator</span>(<span class="function">(<span class="params">componentOptions, k</span>) =&gt;</span> &#123;</span><br><span class="line">      (componentOptions.<span class="property">props</span> || (componentOptions.<span class="property">props</span> = &#123;&#125;) <span class="keyword">as</span> <span class="built_in">any</span>)[k] = options</span><br><span class="line">    &#125;)(target, key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of a watch function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  path the path or the expression to observe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  <span class="variable">WatchOption</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> <span class="variable">MethodDecorator</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Watch</span>(<span class="params">path: <span class="built_in">string</span>, options: WatchOptions = &#123;&#125;</span>): <span class="title class_">MethodDecorator</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; deep = <span class="literal">false</span>, immediate = <span class="literal">false</span> &#125; = options</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createDecorator</span>(<span class="function">(<span class="params">componentOptions, handler</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> componentOptions.<span class="property">watch</span> !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">      componentOptions.<span class="property">watch</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    (componentOptions.<span class="property">watch</span> <span class="keyword">as</span> <span class="built_in">any</span>)[path] = &#123; handler, deep, immediate &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Code copied from Vue/src/shared/util.js</span></span><br><span class="line"><span class="keyword">const</span> hyphenateRE = <span class="regexp">/\B([A-Z])/g</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">hyphenate</span> = (<span class="params">str: <span class="built_in">string</span></span>) =&gt; str.<span class="title function_">replace</span>(hyphenateRE, <span class="string">&#x27;-$1&#x27;</span>).<span class="title function_">toLowerCase</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of an event-emitter function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  event The name of the event</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> <span class="variable">MethodDecorator</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Emit</span>(<span class="params">event?: <span class="built_in">string</span></span>): <span class="title class_">MethodDecorator</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target: Vue, key: <span class="built_in">string</span>, descriptor: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    key = <span class="title function_">hyphenate</span>(key)</span><br><span class="line">    <span class="keyword">const</span> original = descriptor.<span class="property">value</span></span><br><span class="line">    descriptor.<span class="property">value</span> = <span class="keyword">function</span> <span class="title function_">emitter</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (original.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args) !== <span class="literal">false</span>)</span><br><span class="line">        <span class="variable language_">this</span>.$emit(event || key, ...args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of $off</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> event The name of the event</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method The name of the method</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Off</span>(<span class="params">event?: <span class="built_in">string</span>, method?: <span class="built_in">string</span></span>): <span class="title class_">MethodDecorator</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target: Vue, key: <span class="built_in">string</span>, descriptor: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    key = <span class="title function_">hyphenate</span>(key)</span><br><span class="line">    <span class="keyword">const</span> original = descriptor.<span class="property">value</span></span><br><span class="line">    descriptor.<span class="property">value</span> = <span class="keyword">function</span> <span class="title function_">offer</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (original.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args) !== <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (method) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span>[method] === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.$off(event || key, <span class="variable language_">this</span>[method])</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;must be a method name&#x27;</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.$off(event || key)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="variable language_">this</span>.$off()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of $on</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> event The name of the event</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">On</span>(<span class="params">event?: <span class="built_in">string</span></span>): <span class="title class_">MethodDecorator</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createDecorator</span>(<span class="function">(<span class="params">componentOptions, k</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="title function_">hyphenate</span>(k)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> componentOptions.<span class="property">created</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      componentOptions.<span class="property">created</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> original = componentOptions.<span class="property">created</span></span><br><span class="line">    componentOptions.<span class="property">created</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">original</span>()</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> componentOptions.<span class="property">methods</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.$on(event || key, componentOptions.<span class="property">methods</span>[k])</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of $once</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> event The name of the event</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Once</span>(<span class="params">event?: <span class="built_in">string</span></span>): <span class="title class_">MethodDecorator</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createDecorator</span>(<span class="function">(<span class="params">componentOptions, k</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="title function_">hyphenate</span>(k)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> componentOptions.<span class="property">created</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      componentOptions.<span class="property">created</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> original = componentOptions.<span class="property">created</span></span><br><span class="line">    componentOptions.<span class="property">created</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">original</span>()</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> componentOptions.<span class="property">methods</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.$once(event || key, componentOptions.<span class="property">methods</span>[k]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * decorator of $nextTick</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@export</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">method</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">MethodDecorator</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">NextTick</span>(<span class="params">method: <span class="built_in">string</span></span>): <span class="title class_">MethodDecorator</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target: Vue, key: <span class="built_in">string</span>, descriptor: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> original = descriptor.<span class="property">value</span></span><br><span class="line">    descriptor.<span class="property">value</span> = <span class="keyword">function</span> <span class="title function_">emitter</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (original.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args) !== <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span>[method] === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.$nextTick(<span class="variable language_">this</span>[method])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;must be a method name&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>【Vue】iview按需引入相关配置</title>
    <url>/2017/10/14/cff15d70-af8f-11ee-8dd9-a9f70086acad/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>iview 是一套基于 Vue.js 的高质量 UI 组件库。在项目中使用虽然直接引入整个包挺好的，但打包出来 vendor 非常大，并没必要。所以加入了 iview 按需引入的相关配置，减小包的体积从而提升点性能。</p>
</blockquote>
<span id="more"></span>

<p>首先通过 npm 安装 iview-loader</p>
<pre><code>npm install iview-loader --save-dev
</code></pre>
<p>配置 webpack，改写平时 vue-loader 的配置，之前是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;vue-loader&#x27;</span>,</span><br><span class="line">      <span class="attr">options</span>: vueLoaderConfig</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/iview.src.*?js$/</span>,</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&#x27;vue-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: vueLoaderConfig</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&#x27;iview-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">prefix</span>: <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>, <span class="comment">// 注：wepback 3等高版本 loader名称必须写完整</span></span><br><span class="line">      <span class="attr">include</span>: [</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;test&#x27;</span>),</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;/node_modules/iview/src&#x27;</span>)</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 更多</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>借助插件 babel-plugin-import可以实现按需加载组件，减少文件体积。首先安装，并在文件 .babelrc 中配置：</p>
<pre><code>npm install babel-plugin-import --save-dev
</code></pre>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: [[<span class="string">&quot;import&quot;</span>, &#123;</span><br><span class="line">    <span class="string">&quot;libraryName&quot;</span>: <span class="string">&quot;iview&quot;</span>,</span><br><span class="line">    <span class="string">&quot;libraryDirectory&quot;</span>: <span class="string">&quot;src/components&quot;</span></span><br><span class="line">  &#125;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后这样按需引入组件，就可以减小体积了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Button</span>, <span class="title class_">Table</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;iview&#x27;</span>;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;Button&#x27;</span>, <span class="title class_">Button</span>);</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;Table&#x27;</span>, <span class="title class_">Table</span>);</span><br></pre></td></tr></table></figure>

<p>可以直接写 <Switch> 和 <Circle> 这两个标签；<br>参数 prefix 设置为 true 后，所有 iView 组件标签名都可以使用前缀 i-，例如 <i-row>、<i-select></p>
<p>注： 按需引用仍然需要导入样式，即在 main.js 或根组件执行 <code>import &#39;iview/dist/styles/iview.css&#39;</code>;</p>
<hr>
<p><strong>routes 里同样可以异步加载组件</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&#x27;/home&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    <span class="comment">// component: Situation,</span></span><br><span class="line">    <span class="attr">component</span>: <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">&#x27;@/views/home&#x27;</span>], resolve),</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在组件 template 中 <code>import &#123;Button&#125; from &#39;iview&#39;</code>， 然后在 components 里注册相应组件即可使用了</p>
<p>使用 :prop传递数据格式为 数字、布尔值或函数时，必须带:(兼容String除外，具体看组件文档)</p>
<p>在非 template&#x2F;render 模式下（例如使用 CDN 引用时），组件名要分隔，例如 DatePicker 必须要写成 date-picker</p>
<p>注：</p>
<p>locale，Message，Modal 等全局组件需要在主入口文件中引入或声明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">VueI18</span>n <span class="keyword">from</span> <span class="string">&#x27;vue-i18n&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="variable constant_">ZH</span> <span class="keyword">from</span> <span class="string">&#x27;locale/local/zh_CN&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="variable constant_">EN</span> <span class="keyword">from</span> <span class="string">&#x27;locale/local/en_US&#x27;</span></span><br><span class="line"><span class="keyword">import</span> zhLocale <span class="keyword">from</span> <span class="string">&#x27;iview/dist/locale/zh-CN&#x27;</span></span><br><span class="line"><span class="keyword">import</span> enLocale <span class="keyword">from</span> <span class="string">&#x27;iview/dist/locale/en-US&#x27;</span></span><br><span class="line"><span class="comment">// 依赖包</span></span><br><span class="line"><span class="keyword">import</span> &#123; locale, <span class="title class_">Modal</span>, <span class="title class_">Message</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;iview&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;iview/dist/styles/iview.css&#x27;</span></span><br><span class="line"><span class="keyword">let</span> lang = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;language&#x27;</span>)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">lang</span> = lang</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueI18</span>n)</span><br><span class="line"><span class="comment">// 这里的locale国际化组件引入后，需将其声明为方法</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">locale</span> = <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> messages = &#123;</span><br><span class="line">  <span class="attr">zh</span>: <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="variable constant_">ZH</span>, zhLocale),</span><br><span class="line">  <span class="attr">en</span>: <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="variable constant_">EN</span>, enLocale)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> i18n = <span class="keyword">new</span> <span class="title class_">VueI18</span>n(&#123;</span><br><span class="line">  <span class="attr">locale</span>: <span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">lang</span>,</span><br><span class="line">  messages</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(locale, &#123;</span><br><span class="line">  <span class="title function_">i18n</span>(<span class="params">path, options</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = i18n.<span class="title function_">t</span>(path, options)</span><br><span class="line">    <span class="keyword">if</span> (value !== <span class="literal">null</span> &amp;&amp; value !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$Modal</span> = <span class="title class_">Modal</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$Message</span> = <span class="title class_">Message</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>代码相关</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>iView</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>【Vue】vue-cli改多页配置及踩坑笔记</title>
    <url>/2017/08/24/b78d77f0-af8f-11ee-9d17-0129dcec5983/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>vue写起项目来很爽，效率也着实高，加上官方的vue-cli脚手架也是各种爽。不过直接搭出来是单页，在最近的项目实践上加上网上的参考。弄了套demo出来，可以参考我的项目，要是感兴趣记得start+fork下，谢谢</p>
</blockquote>
<span id="more"></span>

<p>那么还是一步步来来吧，也算是记下笔记，方便以后搭建新项目。</p>
<p>npm install vue-cli -g</p>
<p>vue init webpack my-project</p>
<p>注意，<code>node</code>和<code>npm</code>的版本，越高越好。vue-cli的配置就跳过不说了，根据需要选择ESLint，在这里单元测试就先去掉了，router记得选上</p>
<p>npm install<br>npm run dev</p>
<p>然后可以看到Hello Vue</p>
<p>怎么写我们知道了，这是一个单页组件。那么接下来，我们开始正式配置我们的多页路由项目吧</p>
<h2 id="开始配置我们的多页路由项目吧"><a href="#开始配置我们的多页路由项目吧" class="headerlink" title="开始配置我们的多页路由项目吧"></a>开始配置我们的多页路由项目吧</h2><h3 id="第一步-调整项目结构"><a href="#第一步-调整项目结构" class="headerlink" title="第一步 调整项目结构"></a>第一步 调整项目结构</h3><p>|– build<br>|– config<br>|– node_modules<br>|– src<br>|– static<br>|– … 省略了<br>|– … index.html</p>
<p>既然是多页，我们把 index.html 换个地方吧。这是我目前的vue项目架构（不够好，但慢慢提升学习吧，以后会更改）</p>
<p>你们参考下图片吧… 大致是这样</p>
<h3 id="第二步-修改webpack配置："><a href="#第二步-修改webpack配置：" class="headerlink" title="第二步 修改webpack配置："></a>第二步 修改webpack配置：</h3><p>需要安装一个很重要的包</p>
<pre><code>npm install glob --save-dev
</code></pre>
<p>接着配置config下面的index.js文件：(增加的地方我下面标注了)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> glob = <span class="built_in">require</span>(<span class="string">&#x27;glob&#x27;</span>)  <span class="comment">// - add -</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> build = &#123;</span><br><span class="line">  <span class="attr">env</span>: <span class="built_in">require</span>(<span class="string">&#x27;./prod.env&#x27;</span>),</span><br><span class="line">  <span class="comment">// - remove - index: path.resolve(__dirname, &#x27;../dist/index.html&#x27;),</span></span><br><span class="line">  <span class="attr">assetsRoot</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../dist&#x27;</span>),</span><br><span class="line">  <span class="attr">assetsSubDirectory</span>: <span class="string">&#x27;static&#x27;</span>,</span><br><span class="line">  <span class="attr">assetsPublicPath</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  <span class="attr">productionSourceMap</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">productionGzip</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">productionGzipExtensions</span>: [<span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;css&#x27;</span>],</span><br><span class="line">  <span class="attr">bundleAnalyzerReport</span>: process.<span class="property">env</span>.<span class="property">npm_config_report</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据getEntry获取所有入口主页面</span></span><br><span class="line"><span class="keyword">var</span> pages = <span class="title function_">getEntry</span>(<span class="string">&#x27;src/pages/**/*.html&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个入口页面生成一个入口添加到build中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> pathname <span class="keyword">in</span> pages) &#123;</span><br><span class="line">  build[pathname] = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../dist/&#x27;</span> + pathname + <span class="string">&#x27;.html&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">build</span>: build,<span class="comment">//生成的配置build</span></span><br><span class="line">  <span class="attr">dev</span>: &#123;</span><br><span class="line">    <span class="attr">env</span>: <span class="built_in">require</span>(<span class="string">&#x27;./dev.env&#x27;</span>),</span><br><span class="line">    <span class="attr">port</span>: <span class="number">8080</span>,</span><br><span class="line">    <span class="attr">autoOpenBrowser</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">assetsSubDirectory</span>: <span class="string">&#x27;static&#x27;</span>,</span><br><span class="line">    <span class="attr">assetsPublicPath</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">proxyTable</span>: &#123;</span><br><span class="line">      <span class="comment">// 设置代理跨域 - 根据需要来就好</span></span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">        <span class="comment">// 我用了 easy-mock 意思为 项目/api 的请求实际上 会转发到 target的地址上</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;https://www.easy-mock.com/mock/597a9bf0a1d30433d8401855/api/edr3/api&#x27;</span>,</span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">cssSourceMap</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取所有入口文件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getEntry</span>(<span class="params">globPath</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> entries = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> basename;</span><br><span class="line"></span><br><span class="line">  glob.<span class="title function_">sync</span>(globPath).<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">entry</span>) &#123;</span><br><span class="line">    basename = path.<span class="title function_">basename</span>(entry, path.<span class="title function_">extname</span>(entry));</span><br><span class="line">    entries[basename] = entry;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> entries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就配置完了index.js了。然后是配置 <code>build/webpack.base.conf.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> glob = <span class="built_in">require</span>(<span class="string">&#x27;glob&#x27;</span>) <span class="comment">//  - add -</span></span><br><span class="line"><span class="keyword">var</span> utils = <span class="built_in">require</span>(<span class="string">&#x27;./utils&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> config = <span class="built_in">require</span>(<span class="string">&#x27;../config&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> vueLoaderConfig = <span class="built_in">require</span>(<span class="string">&#x27;./vue-loader.conf&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> entries = <span class="title function_">getEntry</span>(<span class="string">&#x27;./src/pages/**/*.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">dir</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;..&#x27;</span>, dir)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// entry: &#123;</span></span><br><span class="line">  <span class="comment">//  app: &#x27;./src/main.js&#x27;</span></span><br><span class="line">  <span class="comment">// &#125;,</span></span><br><span class="line">  <span class="attr">entry</span>: entries,  <span class="comment">// 改成这样</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: config.<span class="property">build</span>.<span class="property">assetsRoot</span>,</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">    <span class="attr">publicPath</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span> ? config.<span class="property">build</span>.<span class="property">assetsPublicPath</span> : config.<span class="property">dev</span>.<span class="property">assetsPublicPath</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>],</span><br><span class="line">    <span class="attr">modules</span>: [</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&#x27;node_modules&#x27;</span>)</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;vue$&#x27;</span>: <span class="string">&#x27;vue/dist/vue.common.js&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;@&#x27;</span>: <span class="title function_">resolve</span>(<span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">      <span class="comment">// 可自行来配， 比如若配了src的alias话， vue里 写 地址可 &#x27;src/*.js&#x27; 就是 /src/*.js了</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [&#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;vue-loader&#x27;</span>,</span><br><span class="line">      <span class="attr">options</span>: vueLoaderConfig</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">      <span class="attr">include</span>: [<span class="title function_">resolve</span>(<span class="string">&#x27;src&#x27;</span>), <span class="title function_">resolve</span>(<span class="string">&#x27;test&#x27;</span>)]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">      <span class="attr">query</span>: &#123;</span><br><span class="line">        <span class="attr">limit</span>: <span class="number">10000</span>,</span><br><span class="line">        <span class="attr">name</span>: utils.<span class="title function_">assetsPath</span>(<span class="string">&#x27;img/[name].[hash:7].[ext]&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.(woff2?|eot|ttf|otf)(\?.*)?$/</span>,</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">      <span class="attr">query</span>: &#123;</span><br><span class="line">        <span class="attr">limit</span>: <span class="number">10000</span>,</span><br><span class="line">        <span class="attr">name</span>: utils.<span class="title function_">assetsPath</span>(<span class="string">&#x27;fonts/[name].[hash:7].[ext]&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取入口js文件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getEntry</span>(<span class="params">globPath</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> entries = &#123;&#125;,</span><br><span class="line">    basename, tmp, pathname;</span><br><span class="line"></span><br><span class="line">  glob.<span class="title function_">sync</span>(globPath).<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">entry</span>) &#123;</span><br><span class="line">    basename = path.<span class="title function_">basename</span>(entry, path.<span class="title function_">extname</span>(entry));</span><br><span class="line">    pathname = basename.<span class="title function_">split</span>(<span class="string">&quot;_&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">    entries[pathname] = entry;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> entries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个文件主要是配置entry: entries入口，剩下的两个配置文件类似。直接复制了，参考以下代码：</p>
<p>build&#x2F;webpack.dev.conf.js文件的配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> utils = <span class="built_in">require</span>(<span class="string">&#x27;./utils&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> config = <span class="built_in">require</span>(<span class="string">&#x27;../config&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> merge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> baseWebpackConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.base.conf&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">FriendlyErrorsPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;friendly-errors-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> glob = <span class="built_in">require</span>(<span class="string">&#x27;glob&#x27;</span>) <span class="comment">// 新增这两行</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(baseWebpackConfig.<span class="property">entry</span>).<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  baseWebpackConfig.<span class="property">entry</span>[name] = [<span class="string">&#x27;./build/dev-client&#x27;</span>].<span class="title function_">concat</span>(baseWebpackConfig.<span class="property">entry</span>[name])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">merge</span>(baseWebpackConfig, &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: utils.<span class="title function_">styleLoaders</span>(&#123; <span class="attr">sourceMap</span>: config.<span class="property">dev</span>.<span class="property">cssSourceMap</span> &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">devtool</span>: <span class="string">&#x27;#cheap-module-eval-source-map&#x27;</span>,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">DefinePlugin</span>(&#123;</span><br><span class="line">      <span class="string">&#x27;process.env&#x27;</span>: config.<span class="property">dev</span>.<span class="property">env</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">HotModuleReplacementPlugin</span>(),</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">NoEmitOnErrorsPlugin</span>(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">FriendlyErrorsPlugin</span>(),</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getEntry</span>(<span class="params">globPath</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> entries = &#123;&#125;,</span><br><span class="line">    basename;</span><br><span class="line"></span><br><span class="line">  glob.<span class="title function_">sync</span>(globPath).<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">entry</span>) &#123;</span><br><span class="line"></span><br><span class="line">    basename = path.<span class="title function_">basename</span>(entry, path.<span class="title function_">extname</span>(entry));</span><br><span class="line">    entries[basename] = entry;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> entries;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pages = <span class="title function_">getEntry</span>(<span class="string">&#x27;src/pages/**/*.html&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> pathname <span class="keyword">in</span> pages) &#123;</span><br><span class="line">  <span class="comment">// 配置生成的html文件，定义路径等</span></span><br><span class="line">  <span class="keyword">var</span> conf = &#123;</span><br><span class="line">    <span class="attr">filename</span>: pathname + <span class="string">&#x27;.html&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>: pages[pathname], <span class="comment">// 模板路径</span></span><br><span class="line">    <span class="attr">inject</span>: <span class="literal">true</span>, <span class="comment">// js插入位置</span></span><br><span class="line">    <span class="attr">chunks</span>: [pathname]</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">plugins</span>.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(conf));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>webpack.prod.conf.js文件的配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> glob = <span class="built_in">require</span>(<span class="string">&#x27;glob&#x27;</span>) <span class="comment">// - add - </span></span><br><span class="line"><span class="keyword">var</span> utils = <span class="built_in">require</span>(<span class="string">&#x27;./utils&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> config = <span class="built_in">require</span>(<span class="string">&#x27;../config&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> merge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> baseWebpackConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.base.conf&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">CopyWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;copy-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ExtractTextPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;extract-text-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">OptimizeCSSPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> env = config.<span class="property">build</span>.<span class="property">env</span></span><br><span class="line"><span class="comment">// 增加的</span></span><br><span class="line"><span class="keyword">var</span> plugins = [</span><br><span class="line">  <span class="keyword">new</span> webpack.<span class="title class_">DefinePlugin</span>(&#123;</span><br><span class="line">    <span class="string">&#x27;process.env&#x27;</span>: env</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> webpack.<span class="property">optimize</span>.<span class="title class_">UglifyJsPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">compress</span>: &#123;</span><br><span class="line">      <span class="attr">warnings</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">sourceMap</span>: <span class="literal">true</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">ExtractTextPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">filename</span>: utils.<span class="title function_">assetsPath</span>(<span class="string">&#x27;css/[name].[contenthash].css&#x27;</span>)</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">OptimizeCSSPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">cssProcessorOptions</span>: &#123;</span><br><span class="line">      <span class="attr">safe</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> webpack.<span class="property">optimize</span>.<span class="title class_">CommonsChunkPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;vendor&#x27;</span>,</span><br><span class="line">    <span class="attr">minChunks</span>: <span class="keyword">function</span> (<span class="params"><span class="variable language_">module</span>, count</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="variable language_">module</span>.<span class="property">resource</span> &amp;&amp;</span><br><span class="line">        <span class="regexp">/\.js$/</span>.<span class="title function_">test</span>(<span class="variable language_">module</span>.<span class="property">resource</span>) &amp;&amp;</span><br><span class="line">        <span class="variable language_">module</span>.<span class="property">resource</span>.<span class="title function_">indexOf</span>(</span><br><span class="line">          path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;../node_modules&#x27;</span>)</span><br><span class="line">        ) === <span class="number">0</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> webpack.<span class="property">optimize</span>.<span class="title class_">CommonsChunkPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;manifest&#x27;</span>,</span><br><span class="line">    <span class="attr">chunks</span>: [<span class="string">&#x27;vendor&#x27;</span>]</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">CopyWebpackPlugin</span>([</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">from</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../static&#x27;</span>),</span><br><span class="line">      <span class="attr">to</span>: config.<span class="property">build</span>.<span class="property">assetsSubDirectory</span>,</span><br><span class="line">      <span class="attr">ignore</span>: [<span class="string">&#x27;.*&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ])</span><br><span class="line">];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getEntry</span>(<span class="params">globPath</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> entries = &#123;&#125;,</span><br><span class="line">    basename;</span><br><span class="line"></span><br><span class="line">  glob.<span class="title function_">sync</span>(globPath).<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">entry</span>) &#123;</span><br><span class="line"></span><br><span class="line">    basename = path.<span class="title function_">basename</span>(entry, path.<span class="title function_">extname</span>(entry));</span><br><span class="line">    entries[basename] = entry;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> entries;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> pages = <span class="title function_">getEntry</span>(<span class="string">&#x27;src/pages/**/*.html&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> pathname <span class="keyword">in</span> pages) &#123;</span><br><span class="line">  <span class="keyword">var</span> conf = &#123;</span><br><span class="line">    <span class="attr">filename</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;testing&#x27;</span> ? pathname + <span class="string">&#x27;.html&#x27;</span> : config.<span class="property">build</span>[pathname],</span><br><span class="line">    <span class="attr">template</span>: pages[pathname],</span><br><span class="line">    <span class="attr">inject</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">minify</span>: &#123;</span><br><span class="line">      <span class="attr">removeComments</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">collapseWhitespace</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">removeAttributeQuotes</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 关键一行 加上，不错到时会报 webpackJsonp not defin的错</span></span><br><span class="line">    <span class="attr">chunks</span>: [<span class="string">&#x27;manifest&#x27;</span>, <span class="string">&#x27;vendor&#x27;</span>, pathname]</span><br><span class="line">  &#125;</span><br><span class="line">  plugins.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(conf));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ----------增加的--</span></span><br><span class="line"><span class="keyword">var</span> webpackConfig = <span class="title function_">merge</span>(baseWebpackConfig, &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: utils.<span class="title function_">styleLoaders</span>(&#123;</span><br><span class="line">      <span class="attr">sourceMap</span>: config.<span class="property">build</span>.<span class="property">productionSourceMap</span>,</span><br><span class="line">      <span class="attr">extract</span>: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">devtool</span>: config.<span class="property">build</span>.<span class="property">productionSourceMap</span> ? <span class="string">&#x27;#source-map&#x27;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: config.<span class="property">build</span>.<span class="property">assetsRoot</span>,</span><br><span class="line">    <span class="attr">filename</span>: utils.<span class="title function_">assetsPath</span>(<span class="string">&#x27;js/[name].[chunkhash].js&#x27;</span>),</span><br><span class="line">    <span class="attr">chunkFilename</span>: utils.<span class="title function_">assetsPath</span>(<span class="string">&#x27;js/[id].[chunkhash].js&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: plugins</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> (config.<span class="property">build</span>.<span class="property">productionGzip</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="title class_">CompressionWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;compression-webpack-plugin&#x27;</span>)</span><br><span class="line">  webpackConfig.<span class="property">plugins</span>.<span class="title function_">push</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CompressionWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">asset</span>: <span class="string">&#x27;[path].gz[query]&#x27;</span>,</span><br><span class="line">      <span class="attr">algorithm</span>: <span class="string">&#x27;gzip&#x27;</span>,</span><br><span class="line">      <span class="attr">test</span>: <span class="keyword">new</span> <span class="title class_">RegExp</span>(</span><br><span class="line">        <span class="string">&#x27;\\.(&#x27;</span> +</span><br><span class="line">        config.<span class="property">build</span>.<span class="property">productionGzipExtensions</span>.<span class="title function_">join</span>(<span class="string">&#x27;|&#x27;</span>) +</span><br><span class="line">        <span class="string">&#x27;)$&#x27;</span></span><br><span class="line">      ),</span><br><span class="line">      <span class="attr">threshold</span>: <span class="number">10240</span>,</span><br><span class="line">      <span class="attr">minRatio</span>: <span class="number">0.8</span></span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (config.<span class="property">build</span>.<span class="property">bundleAnalyzerReport</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="title class_">BundleAnalyzerPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;webpack-bundle-analyzer&#x27;</span>).<span class="property">BundleAnalyzerPlugin</span></span><br><span class="line">  webpackConfig.<span class="property">plugins</span>.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">BundleAnalyzerPlugin</span>())</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = webpackConfig</span><br></pre></td></tr></table></figure>

<p>好了，所有配置文件写完。但现在还跑不起来，我们再把 <code>src/pages</code> <code>src/router</code> 目录下的文件改一改，具体参考我的项目</p>
<p>就可以跑起来我们的vue多页项目了</p>
]]></content>
      <categories>
        <category>代码相关</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Webpack</tag>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>【Vue】vue-i18n踩坑记录</title>
    <url>/2017/09/05/a37fcd30-af8f-11ee-afca-a154cc9cc56d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>跟着官网来看着并不难，放项目里，这出错那不行的… 慢慢看文档一边整理一边尝试，最终得到了我想要的效果。暂时记下来写成博客，可能不是最好的，但目前先把问题解决了来后面再谈细节和优化的事儿吧</p>
</blockquote>
<span id="more"></span>

<p>折腾了一上午，犯了很多错… 最终捣鼓出来，算是完成了需求。这里说下自己的理解。Vue里的国际化，其实只是把 所谓的静态内容，标题，文字段落，提示说明等等用vue的响应式data来存储，再根据我们的配置，动态改变这些data，从而实现无刷新语言切换，这和vue自身的响应式数据是一个道理。</p>
<h2 id="渲染原理"><a href="#渲染原理" class="headerlink" title="渲染原理"></a>渲染原理</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">VueI18</span>n.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_t</span> = <span class="keyword">function</span> <span class="title function_">_t</span> (key, _locale, messages, host) &#123;</span><br><span class="line">  <span class="keyword">var</span> values = [], len = <span class="variable language_">arguments</span>.<span class="property">length</span> - <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">while</span> ( len-- &gt; <span class="number">0</span> ) values[ len ] = <span class="variable language_">arguments</span>[ len + <span class="number">4</span> ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!key) &#123; <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> parsedArgs = parseArgs.<span class="title function_">apply</span>(<span class="keyword">void</span> <span class="number">0</span>, values);</span><br><span class="line">  <span class="keyword">var</span> locale = parsedArgs.<span class="property">locale</span> || _locale;</span><br><span class="line">  <span class="keyword">var</span> ret = <span class="variable language_">this</span>.<span class="title function_">_translate</span>(</span><br><span class="line">    messages, locale, <span class="variable language_">this</span>.<span class="property">fallbackLocale</span>, key,</span><br><span class="line">    host, <span class="string">&#x27;string&#x27;</span>, parsedArgs.<span class="property">params</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">_isFallbackRoot</span>(ret)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;development&quot;</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !<span class="variable language_">this</span>.<span class="property">_silentTranslationWarn</span>) &#123;</span><br><span class="line">      <span class="title function_">warn</span>((<span class="string">&quot;Fall back to translate the keypath &#x27;&quot;</span> + key + <span class="string">&quot;&#x27; with root locale.&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_root</span>) &#123; <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;unexpected error&#x27;</span>) &#125;</span><br><span class="line">    <span class="keyword">return</span> (ref = <span class="variable language_">this</span>.<span class="property">_root</span>).<span class="property">t</span>.<span class="title function_">apply</span>(ref, [ key ].<span class="title function_">concat</span>( values ))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_warnDefault</span>(locale, key, ret, host)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> ref;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$t</span> = <span class="keyword">function</span> (<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> values = [], len = <span class="variable language_">arguments</span>.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ( len-- &gt; <span class="number">0</span> ) values[ len ] = <span class="variable language_">arguments</span>[ len + <span class="number">1</span> ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> i18n = <span class="variable language_">this</span>.<span class="property">$i18n</span>;</span><br><span class="line">  <span class="keyword">return</span> i18n.<span class="property">_t</span>.<span class="title function_">apply</span>(i18n, [ key, i18n.<span class="property">locale</span>, i18n.<span class="title function_">_getMessages</span>(), <span class="variable language_">this</span> ].<span class="title function_">concat</span>( values ))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这是目前用到的一个重要函数，从源码里复制出来。这里Vue原型里添加了一个$t方法，它可传入一个key参数，最后连同信息一起返回。</p>
<p>我们使用的$t即将想要的key 拿到写好的 locale目录下的data中查询，返回对应value这样一个过程，理解了这个思路后后面的就要好办多了。</p>
<hr>
<h2 id="项目运用"><a href="#项目运用" class="headerlink" title="项目运用"></a>项目运用</h2><p>首先安装依赖 npm install vue-i18n -D</p>
<p>先贴一下我的配置，然后慢慢说：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueI18</span>n <span class="keyword">from</span> <span class="string">&#x27;vue-i18n&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./index&#x27;</span>;</span><br><span class="line"><span class="comment">// import router from &#x27;../../router/edrPage&#x27;;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;../../store/index&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;../../router/edrPage/index&#x27;</span>;</span><br><span class="line"><span class="comment">// 依赖包</span></span><br><span class="line"><span class="keyword">import</span> iView <span class="keyword">from</span> <span class="string">&#x27;iview&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> en <span class="keyword">from</span> <span class="string">&#x27;locale/local/en_US&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> zh <span class="keyword">from</span> <span class="string">&#x27;locale/local/zh_CN&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> zhLocale <span class="keyword">from</span> <span class="string">&#x27;locale/iviewLocale/zh-CN&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> enLocale <span class="keyword">from</span> <span class="string">&#x27;locale/iviewLocale/en-US&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;iview/dist/styles/iview.css&#x27;</span>;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">lang</span> = <span class="string">&#x27;en&#x27;</span>;  <span class="comment">// 语言控制的开关</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueI18</span>n);        <span class="comment">// Vue实例中注册</span></span><br><span class="line"><span class="comment">// 定义数据</span></span><br><span class="line"><span class="keyword">const</span> messages = &#123;</span><br><span class="line">    <span class="attr">en</span>: <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, en, enLocale),  <span class="comment">// 这里浅拷贝也可</span></span><br><span class="line">    <span class="attr">zh</span>: <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, zh, zhLocale)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新生成i18n实例，并写入相应配置</span></span><br><span class="line"><span class="keyword">const</span> i18n = <span class="keyword">new</span> <span class="title class_">VueI18</span>n(&#123;</span><br><span class="line">    <span class="attr">locale</span>: <span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">lang</span>, <span class="comment">// 语言</span></span><br><span class="line">    <span class="attr">fallbackLocale</span>: <span class="string">&#x27;en&#x27;</span>,    <span class="comment">// 这是iView用到的</span></span><br><span class="line">    messages                 <span class="comment">// 把上面定义好的数据传入i18n</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 注册iView的同时，把i18n的配置一同传入</span></span><br><span class="line"><span class="comment">// 这样就可以在vue中无缝使用i18n和iView的国际化组件了, element同理</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(iView, &#123;</span><br><span class="line">    <span class="title function_">i18n</span>(<span class="params">path, options</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> value = i18n.<span class="title function_">t</span>(path, options);</span><br><span class="line">      <span class="keyword">if</span> (value !== <span class="literal">null</span> &amp;&amp; value !== <span class="literal">undefined</span>) <span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="comment">// i18n已有上面定义的messages了，这里在Vue实例中注入</span></span><br><span class="line">  <span class="comment">// 就可以在组件中 this.$i18n 这样来用了(这一步是i18n已帮我们做的)</span></span><br><span class="line">  i18n,</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;App/&gt;&#x27;</span>,</span><br><span class="line">  <span class="attr">components</span>: &#123; <span class="title class_">App</span> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我用的iView 2.2版本i18n版本只支持到5.0+明显不成，各种问了之后看到了一个解决方案挺不错，就是上面这个。思路很简单，就是本地创建自己的语言包，然后与iView提供的包合并，其他流程走i18n自己的流程即可</p>
<hr>
<p>在单文件组件的模版中:  (用来测试的随便写了)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;login&quot;</span> <span class="attr">class</span>=<span class="string">&quot;bg&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;switchLang&quot;</span>&gt;</span>切换语言<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;$t(&#x27;edr.footer.copyright&#x27;)&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">name</span>: <span class="string">&#x27;page-login&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">locale</span>: <span class="string">&#x27;en&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">locale</span> = <span class="variable language_">this</span>.<span class="property">$i18n</span>.<span class="property">locale</span> = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;language&#x27;</span>) <span class="comment">// 从 localStorage 中获取语言状态</span></span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">switchLang</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">locale</span> === <span class="string">&#x27;en&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">this</span>.<span class="property">locale</span> = <span class="variable language_">this</span>.<span class="property">$i18n</span>.<span class="property">locale</span> = <span class="string">&#x27;zh&#x27;</span></span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;language&#x27;</span>, <span class="string">&#x27;zh&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">this</span>.<span class="property">locale</span> = <span class="variable language_">this</span>.<span class="property">$i18n</span>.<span class="property">locale</span> = <span class="string">&#x27;en&#x27;</span></span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;language&#x27;</span>, <span class="string">&#x27;en&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在，点击切换按钮，语言就可实时更改了~ </p>
<p>好了，其他的同理，在locale目录下，把我们需要切换的中英文数据管理好即可~ 如果内容多拆开来管理更好</p>
<hr>
<p>但感觉很麻烦的是，以后写静态数据都不能直接写在模版里了… 也算是长姿势了<br>至于后端返回的数据…… 暂时不知道，让后端自己先折腾吧</p>
<p>还有一个问题…  整个template里， 全是$t()这样的…  也不知道写了什么，占位符谁是谁… 于是，之前写好的最好还是来一层注释，或者利用良好的class命名来避免开发时的尴尬… 不然拿到同事手中只有两眼懵比了…</p>
]]></content>
      <categories>
        <category>代码相关</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>vue-i18n</tag>
        <tag>国际化</tag>
      </tags>
  </entry>
  <entry>
    <title>【Vue】理解Vue生命周期</title>
    <url>/2018/04/14/062ba8a0-af90-11ee-859d-0938b0d9220d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>早上刷手机在思否上看到 闰土大叔的这篇<a href="https://segmentfault.com/a/1190000014376915?_ea=3615607">如何解释vue的生命周期才能令XXX满意？</a>，觉得挺好就老套路了。当然，看别人的文章，在此基础上注释，添加自己的东西，才有写博客的价值，希望能站在大佬的肩膀上往前走得更快吧！</p>
<span id="more"></span>

<p>这张图肯定是必上的，说得相当详尽和清楚了。</p>
<img src="https://segmentfault.com/img/bV4xju?w=1200&h=3039">

<p>在理解上，一直觉得Vue生命周期就是四个阶段 创建 -&gt; 挂载 -&gt; 更新 -&gt; 销毁，每个阶段对应2个钩子函数 <code>beforeCreate</code> <code>created</code> ， 带 before 和 ed 的，同时也写过demo，无非就是以下： <a href="https://jsfiddle.net/0dzvcf4d/10495/">https://jsfiddle.net/0dzvcf4d/10495/</a> 可看下官网的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#editor&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">input</span>: <span class="string">&#x27;# hello&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="attr">compiledMarkdown</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">marked</span>(<span class="variable language_">this</span>.<span class="property">input</span>, &#123; <span class="attr">sanitize</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">update</span>: _.<span class="title function_">debounce</span>(<span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">input</span> = e.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">    &#125;, <span class="number">300</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;created&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">beforeMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeMount&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;render&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">input</span> = <span class="string">&#x27;vue lifecycle&#x27;</span></span><br><span class="line">    &#125;, <span class="number">2000</span>)    </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">beforeUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">updated</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;updated&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">beforeDestory</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeDestory&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">destroyed</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;destroyed&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>控制台会依次输出 </p>
<p>beforeCreate<br>created<br>beforeMount<br>render<br>mounted</p>
<p>过了两秒后，再打印<br>beforeUpdate<br>updated</p>
<p>那么，信息量还是挺多的，Vue的生命周期描述不是说8个钩子函数，这显然也不是问题的本质。</p>
<hr>
<p>那么我们来理一理这个过程吧，请关注随时对比大图：</p>
<p>在一开始，我们创建了一个Vue的实例对象 vm，在控制台打印 beforeCreate 之前，首先执行了 <code>_init</code> 方法  （正好之前写了篇 【Vue】实现原生双向绑定 可参考一下） <code>_init</code> 就是将我们所传入的 el、data、methods等等各种属性绑定到Vue原型对象上。 而在init的过程中首先调用<code>beforeCreate</code>钩子。然后在<code>injections</code>[注射]和<code>reactivity</code>[反应作用]时，它会再去调用<code>created</code>钩子。</p>
<p>也就是说在init时，事件已经被调用了。所以，我们在<code>beforeCreate</code>时千万别去修改data里面的赋值，最早也要放在<code>created</code>里去做。</p>
<p>在created完成后，它会去判断<code>instance</code>实例里是否含有 <code>el</code> 属性 ，若没有 就会调用 vm.$mount(el)这个方法，然后继续执行后续逻辑；</p>
<p>若有el属性，则会判断是否有 <code>template</code>属性，并将template解析成一个 <code>render function</code></p>
<hr>
<p>这里插播一下 render function 相关的科普</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params">createElement</span>) &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * param &#123;String&#125; tagName</span></span><br><span class="line"><span class="comment">   * param &#123;Object&#125; element properties</span></span><br><span class="line"><span class="comment">   * param &#123;String&#125; text node content</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>, &#123;&#125;, <span class="variable language_">this</span>.<span class="property">text</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们经常看到的 h 的写法，其实就是代表 createElement 的一个实参而已。 可传入三个参数， 参考代码方法注释。其中，如果要渲染更多子节点的话，可在 properties 中继续传入 createElement。</p>
<p>最终我们的template将被解析为 render 函数所返回的内容，也就是 Virtial DOM。关于Virtial DOM相关的下次会在了解后再写。</p>
<hr>
<p>回到生命周期的话题中，render 函数发生在 <code>beforeMount</code> 和 <code>mounted</code>之间的，这也侧面说明在<code>beforeMount</code>时，$el还只是我们在HTML里面写的节点。（可自行 在生命周期函数中添加 console.log(this.$el) ） <code>beforeMount</code> 和 <code>render</code>都打印了节点内容，到<code>mounted</code>时已被渲染出来并将之挂载到了DOM节点上。在此间经历的过程其实是执行了 render funcion的内容。</p>
<p>在使用.vue文件开发的过程当中，我们在里面写了template模板，在经过了vue-loader的处理之后，就变成了render function，最终放到了vue-loader解析过的文件里面。这样做有什么好处呢？原因是由于在解析template变成render function的过程，是一个非常耗时的过程，vue-loader帮我们处理了这些内容之后，当我们在页面上执行vue代码的时候，效率会变得更高。</p>
<p><code>beforeMount</code>在有了render function的时候才会执行，当执行完render function之后，就会调用<code>mounted</code>这个钩子，在<code>mounted</code>挂载完毕之后，这个实例就算是走完流程了。</p>
<p>后续的钩子函数执行的过程都是需要外部的触发才会执行。比如说有数据的变化，会调用beforeUpdate，然后经过Virtual DOM，最后updated更新完毕。当组件被销毁的时候，它会调用beforeDestory，以及destoryed。</p>
<p><strong>这就是vue实例从新建到销毁的一个完整流程</strong></p>
<hr>
<p>说点题外话：</p>
<p>钩子函数是什么意思？ 特别是在学习 React生命周期，Vue生命周期这一词频繁出现。那么，看到此相信你大致有感觉了。<br>没错，钩子函数可理解为回调函数，当代码执行到某处时，检查是否有回调，简单代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">gouzi1</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;g1&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">gouzi2</span> () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;g2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="title function_">gouzi1</span>()    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; <span class="number">100</span> &amp;&amp; i &lt; <span class="number">105</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="title function_">gouzi2</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(i === <span class="number">9999</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// g1</span></span><br><span class="line"><span class="comment">// 101</span></span><br><span class="line"><span class="comment">// 102</span></span><br><span class="line"><span class="comment">// 103</span></span><br><span class="line"><span class="comment">// 104</span></span><br><span class="line"><span class="comment">// g2</span></span><br><span class="line"><span class="comment">// end</span></span><br></pre></td></tr></table></figure>

<p>当然JS的执行环境不是这么简单的。这里大致了解一下就好，最后的最后，再简单总结收个尾吧</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Vue的完整生命周期流程：</p>
<ol>
<li>new Vue(options) 时执行 init初始化将options的值绑到Vue原型中</li>
<li>从init起，生命周期已开始，beforeCreate 调用后通过注入等方式拿到值后走到created钩子，data重赋值等操作最早在该钩子中进行</li>
<li>检查实例是否传入el来解析template或是执行vm.$mount，其实质是一个render function，将template写的节点，变成Virtial DOM</li>
<li>beforeMount较早于render，一旦进入mounted钩子，虚拟节点将生成真正的DOM节点并被挂载</li>
<li>之后的数据改变 会触发 beforeUpdate 和 updated 钩子</li>
<li>通过路由移入移出组件等可触发 destroy destroyed 钩子</li>
</ol>
<p>这就是Vue实例的完整声明周期流程！ 完~</p>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>【Vue】实现原生双向绑定</title>
    <url>/2018/04/11/eb4efaf0-af8f-11ee-86a6-7fca542c6cb3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>逛掘金看到篇讲<a href="https://juejin.im/post/5acc17cb51882555745a03f8">Vue双向绑定的文章</a>，很不错，就拿过来了，里面的代码抄了一遍，当然不是初抄啦，加入我自己的理解和总结。虽然看了几次这类文章，但真不嫌多，温故而知新嘛。</p>
<span id="more"></span>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Vue的双向绑定通过 Object对象的defineProperty属性，重写data的set和get函数来实现。</p>
<img src="https://user-gold-cdn.xitu.io/2018/4/10/162ad3d5be3e5105?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">

<p>简单实现</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>  <span class="attr">v-model</span>=<span class="string">&quot;number&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">v-click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span> <span class="attr">v-bind</span>=<span class="string">&quot;number&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>一个input，使用v-model指令</li>
<li>一个button，使用v-click指令</li>
<li>一个h3，使用v-bind指令。</li>
</ol>
<p>通过类似于vue的方式来使用我们的双向数据绑定，结合我们的数据结构添加注释</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">MyVue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">number</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">number</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>首先定义一个MyVue构造函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyVue</span>(<span class="params">options</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>为了初始化这个构造函数，给它添加一 个_init属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyVue</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_init</span>(options)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">MyVue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$options</span> = options <span class="comment">// options为上面使用时传入的结构体，包括el data methods</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$el</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(options.<span class="property">el</span>) <span class="comment">// this.$el 即 id为app的 dom元素</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span> <span class="comment">// this.$data = &#123;number: 0&#125;</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$methods</span> = options.<span class="property">methods</span> <span class="comment">// &#123; increment() &#123;this.number++&#125; &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来实现_observe函数，对data进行处理，重写data的set和get函数，并改造 _init函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">MyVue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_observe</span> = <span class="keyword">function</span>(<span class="params">obj</span>) &#123; <span class="comment">// 将要实现监听的对象 obj = &#123;number: 0&#125;</span></span><br><span class="line">  <span class="keyword">var</span> value</span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      value = obj[key]</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span>) &#123; <span class="comment">// 若值还是 object类型，则继续遍历</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">_observe</span>(value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>.<span class="property">$data</span>, key, &#123; <span class="comment">// 关键</span></span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">          <span class="keyword">return</span> value</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`更新<span class="subst">$&#123;newVal&#125;</span>`</span>)</span><br><span class="line">          <span class="keyword">if</span> (value !== newValue) &#123;</span><br><span class="line">            value = newVal</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyVue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$options</span> = options</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$el</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(options.<span class="property">el</span>)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$methods</span> = options.<span class="property">methods</span></span><br><span class="line">  </span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_observe</span>(<span class="variable language_">this</span>.<span class="property">$data</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们写一个指令类 Watcher 用来绑定更新函数，实现对DOM元素的更新</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Watcher</span>(<span class="params">name, el, vm, exp, attr</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name  <span class="comment">// 指令名称，例如文件节点，该值设为 text</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">el</span> = el      <span class="comment">// 指令对应的DOM元素</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">vm</span> = vm      <span class="comment">// 指令所属的MyVue实例</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">exp</span> = exp    <span class="comment">// 指令对应的值，本例为 number</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">attr</span> = attr  <span class="comment">// 绑定的属性值，本例为 innerHTML</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_update</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Watcher</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_update</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">el</span>[<span class="variable language_">this</span>.<span class="property">attr</span>] = <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">$data</span>[<span class="variable language_">this</span>.<span class="property">exp</span>]</span><br><span class="line">  <span class="comment">// 比如 h3.innerHTML = this.data.number</span></span><br><span class="line">  <span class="comment">// 当number改变时，会触发_update函数，保证对应的DOM进行更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新_init函数以及observe函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">MyVue</span>.<span class="property">ptototype</span>.<span class="property">_init</span> = <span class="keyword">function</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="comment">/* 省略 */</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_binding</span> = &#123;&#125;</span><br><span class="line">  <span class="comment">// _binding保存着model与view的映射关系, 也就是我们前面定义的Watcher的实例</span></span><br><span class="line">  <span class="comment">// 当model改变时，我们会触发其中的指令类更新，保证view也能实时更新</span></span><br><span class="line">  <span class="comment">/* ... */</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyVue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_observe</span> = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="comment">/* 省略 */</span></span><br><span class="line">  <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_binding</span>[key] = &#123;</span><br><span class="line">      <span class="attr">_directives</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">var</span> binding = <span class="variable language_">this</span>.<span class="property">_binding</span>[key]</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>.<span class="property">$data</span>, key, &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`更新<span class="subst">$&#123;newVal&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">if</span> (value !== newVal) &#123;</span><br><span class="line">          value = newVal</span><br><span class="line">          binding.<span class="property">_directives</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">            <span class="comment">// 当number改变时，触发_binding[number]._directives 中绑定的Watcher类的更新</span></span><br><span class="line">            item.<span class="title function_">_update</span>()</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么如何将 view 与 model进行绑定呢？ 接下来我们定义一个_compiler函数，用来解析我们的指令（v-bind, v-model, v-click）等，并在这个过程中与view与model进行绑定</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">MyVue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="comment">// 省略</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_compile</span>(<span class="variable language_">this</span>.<span class="property">$el</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyVue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_compile</span> = <span class="keyword">function</span>(<span class="params">root</span>) &#123; <span class="comment">// root为 id为app的element，即根元素</span></span><br><span class="line">  <span class="keyword">var</span> _this = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">var</span> nodes = root.<span class="property">children</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nodes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> node = nodes[i]</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">chilren</span>.<span class="property">length</span>) &#123; <span class="comment">// 若存在子元素则进行递归处理</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">_compile</span>(node)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有v-click属性，我们监听它的onclick事件，触发increment事件，即number++</span></span><br><span class="line">    <span class="keyword">if</span> (node.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;v-click&#x27;</span>)) &#123;</span><br><span class="line">      node.<span class="property">onclick</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> attrVal = nodes[i].<span class="title function_">getAttribute</span>(<span class="string">&#x27;v-click&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> _this.<span class="property">$methods</span>[attrVal].<span class="title function_">bind</span>(_this.<span class="property">$data</span>)</span><br><span class="line">        <span class="comment">// bind是使data的作用域与method函数的作用域保持一致</span></span><br><span class="line">      &#125;)()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有v-model属性，且元素是input或textarea，就监听它的input事件</span></span><br><span class="line">    <span class="keyword">if</span> (node.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;v-model&#x27;</span>) &amp;&amp; (node.<span class="property">tagName</span> === <span class="string">&#x27;input&#x27;</span> || node.<span class="property">target</span> === <span class="string">&#x27;textarea&#x27;</span>)) &#123;</span><br><span class="line">      node.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, (<span class="keyword">function</span>(<span class="params">key</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> attrVal = node.<span class="title function_">getAttribute</span>(<span class="string">&#x27;v-model&#x27;</span>)</span><br><span class="line">        <span class="comment">// _this._binding[number]._directives = [一个Watcher的实例]</span></span><br><span class="line">        <span class="comment">// 其中Watcher.prototype.update = functoin() &#123;</span></span><br><span class="line">        <span class="comment">//   node[&#x27;value&#x27;] = _this.$data[&#x27;number&#x27;]</span></span><br><span class="line">        <span class="comment">//   这就将node的值保持与number一致了</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        _this.<span class="property">_bniding</span>[attrVal].<span class="property">_directives</span>.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Watcher</span>(</span><br><span class="line">          <span class="string">&#x27;input&#x27;</span>,  <span class="comment">// 结合上面的 Watcher构造函数来看 </span></span><br><span class="line">          node,     <span class="comment">// 分别传参 指令名, dom</span></span><br><span class="line">          _this,    <span class="comment">// Vue绑定的实例</span></span><br><span class="line">          attrVal,  <span class="comment">// 指令对应值</span></span><br><span class="line">          <span class="string">&#x27;value&#x27;</span>   <span class="comment">// 绑定的对应属性</span></span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">          _this.<span class="property">$data</span>[attrVal] = nodes[key].<span class="property">value</span></span><br><span class="line">          <span class="comment">// 使number的值与node的value保持一致，这就实现了双向绑定</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)(i))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有v-bind属性，我们只要使node的值及时更新为data中的number值即可</span></span><br><span class="line">    <span class="keyword">if</span> (node.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;v-bind&#x27;</span>)) &#123;</span><br><span class="line">      <span class="keyword">var</span> attrVal = node.<span class="title function_">getAttribute</span>(<span class="string">&#x27;v-bind&#x27;</span>)</span><br><span class="line">      _this.<span class="property">_binding</span>[attrVal].<span class="property">_directives</span>.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Watcher</span>(</span><br><span class="line">        <span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">        node,</span><br><span class="line">        _this,</span><br><span class="line">        attrVal,</span><br><span class="line">        <span class="string">&#x27;innerHTML&#x27;</span></span><br><span class="line">      ))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="附上完整代码"><a href="#附上完整代码" class="headerlink" title="附上完整代码"></a>附上完整代码</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>  <span class="attr">v-model</span>=<span class="string">&quot;number&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">v-click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span> <span class="attr">v-bind</span>=<span class="string">&quot;number&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">MyVue</span>(<span class="params">options</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="title function_">_init</span>(options)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title class_">MyVue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span>(<span class="params">options</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="property">$options</span> = options</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="property">$el</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(options.<span class="property">el</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="property">$methods</span> = options.<span class="property">methods</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="property">_binding</span> = &#123;&#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="title function_">_observe</span>(<span class="variable language_">this</span>.<span class="property">$data</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="title function_">_compile</span>(<span class="variable language_">this</span>.<span class="property">$el</span>)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title class_">MyVue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_observe</span> = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> value</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">for</span> (key <span class="keyword">in</span> obj) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span> (obj.<span class="title function_">hasOwnproperty</span>(key)) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">_binding</span>[key] = &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">_directives</span>: []</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        value = obj[key]</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">this</span>.<span class="title function_">_observe</span>(value)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> binding = <span class="variable language_">this</span>.<span class="property">_binding</span>[key]</span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>.<span class="property">$data</span>, key, &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">enumerable</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">configurable</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">get</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取<span class="subst">$&#123;value&#125;</span>`</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> value</span></span><br><span class="line"><span class="language-javascript">          &#125;,</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`更新<span class="subst">$&#123;newVal&#125;</span>`</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (value !== newVal) &#123;</span></span><br><span class="line"><span class="language-javascript">              value = newVal</span></span><br><span class="line"><span class="language-javascript">              binding.<span class="property">_directives</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                item.<span class="title function_">update</span>()</span></span><br><span class="line"><span class="language-javascript">              &#125;)</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title class_">MyVue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_compile</span> = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> _this = <span class="variable language_">this</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> nodes = root.<span class="property">children</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nodes.<span class="property">length</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> node = nodes[i]</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span> (node.<span class="property">children</span>.<span class="property">length</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="title function_">_compile</span>(node)</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span> (node.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;v-click&#x27;</span>)) &#123;</span></span><br><span class="line"><span class="language-javascript">        node.<span class="property">onclick</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">var</span> attrVal = nodes[i].<span class="title function_">getAttribute</span>(<span class="string">&#x27;v-click&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">return</span> _this.<span class="property">$methods</span>[attrVal].<span class="title function_">bind</span>(_this.<span class="property">$data</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;)()</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span> (node.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;v-model&#x27;</span>) &amp;&amp; (node.<span class="property">tagName</span> === <span class="string">&#x27;input&#x27;</span> || node.<span class="property">tagName</span> === <span class="string">&#x27;textarea&#x27;</span>)) &#123;</span></span><br><span class="line"><span class="language-javascript">        node.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, (<span class="keyword">function</span>(<span class="params">key</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">var</span> attrVal = node.<span class="title function_">getAttribute</span>(<span class="string">&#x27;v-model&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">          _this.<span class="property">_binding</span>[attrVal].<span class="property">_directives</span>.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Watcher</span>(</span></span><br><span class="line"><span class="language-javascript">            <span class="string">&#x27;input&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            node,</span></span><br><span class="line"><span class="language-javascript">            _this,</span></span><br><span class="line"><span class="language-javascript">            attrVal,</span></span><br><span class="line"><span class="language-javascript">            <span class="string">&#x27;value&#x27;</span></span></span><br><span class="line"><span class="language-javascript">          ))</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            _this.<span class="property">$data</span>[attrVal] = nodes[key].<span class="property">value</span></span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)(i))</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span> (node.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;v-bind&#x27;</span>)) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> attrVal = node.<span class="title function_">getAttribute</span>(<span class="string">&#x27;v-bind&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        _this.<span class="property">_binding</span>[attrVal].<span class="property">_directives</span>.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Watcher</span>(</span></span><br><span class="line"><span class="language-javascript">          <span class="string">&#x27;text&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">          node,</span></span><br><span class="line"><span class="language-javascript">          _this,</span></span><br><span class="line"><span class="language-javascript">          attrVal,</span></span><br><span class="line"><span class="language-javascript">          <span class="string">&#x27;innerHTML&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        ))</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">Watcher</span>(<span class="params">name, el, vm, exp, attr</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="property">name</span> = name    <span class="comment">//指令名称，例如文本节点，该值设为&quot;text&quot;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="property">el</span> = el        <span class="comment">//指令对应的DOM元素</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm        <span class="comment">//指令所属myVue实例</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="property">exp</span> = exp      <span class="comment">//指令对应的值，本例如&quot;number&quot;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="property">attr</span> = attr    <span class="comment">//绑定的属性值，本例为&quot;innerHTML&quot;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="title function_">update</span>()</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title class_">Wathcer</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">update</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="property">el</span>[<span class="variable language_">this</span>.<span class="property">attr</span>] = <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">$data</span>[<span class="variable language_">this</span>.<span class="property">exp</span>]</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">MyVue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">number</span>: <span class="number">0</span></span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">increment</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">this</span>.<span class="property">number</span>++</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后来梳理一下逻辑：</p>
<ol>
<li>写一个构造函数 MyVue 可传入一个options参数，实例化时执行其 _init方法</li>
<li>_init 其核心是将 options的各种属性 放到其实例上，并执行 _observe 和 _compile 方法</li>
<li>_observe 作为一个代理方法，监听传入的options.data属性的改变，（这里会将data里的每个key放入 _bingding 对象中，然后用Object.defineProperty对每一个key进行监听, 若属性值改变了，就实时改变）</li>
<li>上面说的实时改变就是 update 方法，那观察的对象从哪来？ 指令上对应的值？ 这一过程其实就是 _compile做的. 让 MyVue能知道 el 上的指令代表什么</li>
<li>_compile让我们知道了指令是干嘛的，具体触发改变就是由Watcher来做的了，我们传入name(指令名), el(对应dom), vm(MyVue实例), exp(指令对应值), attr(绑定的属性)，然后调用其原型上的update方法。 触发了 _observe其最终是执行 update方法来更改值</li>
</ol>
<p>说得好像很啰嗦，但这就是双向绑定的过程了，知根知底，这样又往前进了一小步咯。以上就实现了文本与input的双向绑定</p>
<hr>
<p>4.17更新~ 添加完整可运行的 es6版</p>
<p>理下思路：</p>
<ol>
<li>MyVue实例时将传入的options的给实例，完成初始化</li>
<li>_binding 进行依赖收集，每次设置会触发 Watcher 实例的update</li>
<li>_observe 监听data数据，实现数据响应式化</li>
<li>_compile 将模版编译为抽象语法树AST</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyVue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$options</span> = options</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$el</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(options.<span class="property">el</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$methods</span> = options.<span class="property">methods</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_binding</span> = &#123;&#125;           <span class="comment">// 依赖收集</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_observe</span>(<span class="variable language_">this</span>.<span class="property">$data</span>)    <span class="comment">// 观察data数据添加到Watcher中</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_compile</span>(<span class="variable language_">this</span>.<span class="property">$el</span>)      <span class="comment">// 编译为抽象语法树AST 这里要简单得多</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">_observe</span>(<span class="params">obj</span>) &#123;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span>(obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_binding</span>[key] = &#123;</span><br><span class="line">          <span class="attr">_directives</span>: []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this._binding[key]&#x27;</span>, <span class="variable language_">this</span>.<span class="property">_binding</span>[key])</span><br><span class="line">        <span class="keyword">let</span> value = obj[key]</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">_observe</span>(value)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> binding = <span class="variable language_">this</span>.<span class="property">_binding</span>[key]</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>.<span class="property">$data</span>, key, &#123;</span><br><span class="line">          <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>获取<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>设置<span class="subst">$&#123;newVal&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">if</span> (value !== newVal) &#123;</span><br><span class="line">              value = newVal</span><br><span class="line">              binding.<span class="property">_directives</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="title function_">update</span>())</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">_compile</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">// root为根节点，传入的el</span></span><br><span class="line">    <span class="keyword">let</span> _this = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">let</span> nodes = root.<span class="property">children</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nodes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> node = nodes[i]</span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">children</span>.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">_compile</span>(node)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (node.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;v-click&#x27;</span>)) &#123;</span><br><span class="line">        node.<span class="property">onclick</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">let</span> attrVal = nodes[i].<span class="title function_">getAttribute</span>(<span class="string">&#x27;v-click&#x27;</span>)</span><br><span class="line">          <span class="keyword">return</span> _this.<span class="property">$methods</span>[attrVal].<span class="title function_">bind</span>(_this.<span class="property">$data</span>)</span><br><span class="line">        &#125;)()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (node.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;v-model&#x27;</span>) &amp;&amp; (node.<span class="property">tagName</span> === <span class="string">&#x27;INPUT&#x27;</span> || node.<span class="property">tagName</span> === <span class="string">&#x27;TEXTAREA&#x27;</span>)) &#123;</span><br><span class="line">        node.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, (<span class="keyword">function</span>(<span class="params">key</span>) &#123;</span><br><span class="line">          <span class="keyword">let</span> attrVal = nodes[i].<span class="title function_">getAttribute</span>(<span class="string">&#x27;v-model&#x27;</span>)</span><br><span class="line">          _this.<span class="property">_binding</span>[attrVal].<span class="property">_directives</span>.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Watcher</span>(</span><br><span class="line">            <span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">            node,</span><br><span class="line">            _this,</span><br><span class="line">            attrVal,</span><br><span class="line">            <span class="string">&#x27;value&#x27;</span></span><br><span class="line">          ))</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            _this.<span class="property">$data</span>[attrVal] = nodes[key].<span class="property">value</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)(i))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (node.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;v-bind&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">let</span> attrVal = nodes[i].<span class="title function_">getAttribute</span>(<span class="string">&#x27;v-bind&#x27;</span>)</span><br><span class="line">        _this.<span class="property">_binding</span>[attrVal].<span class="property">_directives</span>.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Watcher</span>(</span><br><span class="line">          <span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">          node,</span><br><span class="line">          _this,</span><br><span class="line">          attrVal,</span><br><span class="line">          <span class="string">&#x27;innerHTML&#x27;</span></span><br><span class="line">        ))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, el, vm, exp, attr</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name    <span class="comment">// 指令名</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">el</span> = el        <span class="comment">// 指令对应dom</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm        <span class="comment">// 指令所属实例</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">exp</span> = exp      <span class="comment">// 指令对应值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">attr</span> = attr    <span class="comment">// 绑定属性值</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">update</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">el</span>[<span class="variable language_">this</span>.<span class="property">attr</span>] = <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">$data</span>[<span class="variable language_">this</span>.<span class="property">exp</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习TailWindCSS】TailWindCSS+Vite+Vue3+TS+Pinia打造个性化在线简历项目，欢迎Fork</title>
    <url>/2024/02/15/9a8fb720-bf76-11ee-bb1f-d5e564f5accf/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>祝大家在新的一年：大吉大利，身体健康，迎大运，发大财！吐槽随便侃侃，无感请直接跳过到正文。</p>
</blockquote>
<p>注册了快 7 年的账号，终于发了第一篇文 你敢信 ~~ 哈哈，今天开张了。至于契机嘛… <code>司倒，失业之</code> T_T。<br>最近刷看到类似的帖子也挺多的，ORZ 放心，真不是来输出负面情绪的 ~ 主菜马上就到。</p>
<p>y 情后各行各业都不容易啊，待了六年的公司也熬不住去年末倒下了（还有 3 个月工资拖欠着，希望仲裁给力吧）。个人也长时间呆在舒适区，也没经历社会毒打（只面过别人，凭良心说你背的我还真不会），大环境每况愈下，时常感到焦虑。经过了几天的 emo 期（并没有，疯狂打球笑嘻嘻 … 但心里苦）调整好了，生活终归是要继续的。</p>
<p>给自己放放假，顺便补补（哥们调整好了），为了找到新工作，自己制定了如下小目标：</p>
<ul>
<li>✅ 1. 重启技术博客 <a href="https://blog.fridolph.top/">https://blog.fridolph.top</a>，坚持输出</li>
<li>✅ 2. 做几个实战项目（于是这篇文就诞生了）</li>
<li>⏰ 3. 整理前端知识大纲，形成思维导图</li>
<li>⏰ 4. 逛掘金，刷面经 + 整理（有些想法，于是开了新坑，再过几天就 OK）</li>
<li>💊 5. 找到工作前<code>封印Steam</code> - “你算什么男人算什么男人，眼睁睁看帕鲁走却不闻不问” T_T</li>
</ul>
<p>我原本是想重构一下我之前写的在线简历，采用 Vue3 + TS + Pinia 来实现。几下敲完代码，我自己都觉得没啥东西。简历上个人作品，开源那两栏空空如也 &#x3D; &#x3D; 之前老刷到<code>tailwind</code>的文章，遂决定学习换个心态尝试学习，加到项目中，<code>现切现做，这瓜绝对保熟</code>。</p>
<blockquote>
<p>之前刷到 前端发展趋势的预测 之类文，很赞同一些观点。学历，简历只是敲门砖，在这个越来越卷的环境，竞争力不足，以后还是要多关注学习下 Node、Next.js，伪全栈万金油是个可选方向。</p>
</blockquote>
<h1 id="通过这篇文章你可以"><a href="#通过这篇文章你可以" class="headerlink" title="通过这篇文章你可以"></a>通过这篇文章你可以</h1><ul>
<li>📖 学会在项目中灵活使用 TailWindCSS</li>
<li>📮 <strong>了解 TailWindCSS 的核心概念</strong></li>
<li>📝 获得我整理的一份 <code>Tss 速记指南</code></li>
<li>⬆️ 随我一起学习 CSS “新” 特性</li>
<li>🚀 本项目 Vite + Vue3 实践及相关优化</li>
<li>🌹 <strong>Fork + Star 即得一份在线简历模板</strong>，现改现用</li>
</ul>
<p>github： <a href="https://github.com/Fridolph/my-resume" target="_blank">https://github.com/Fridolph/my-resume</a><br>在线浏览：<a href="https://resume.fridolph.top/" target="_blank">https://resume.fridolph.top/</a></p>
<blockquote>
<p>注：本项目使用 pnpm 作为包管理工具，请升级 Node 版本到 16.22.2 以上</p>
</blockquote>
<p>下面是我学习 TailWindCSS 的过程，本文不会先上来讲大段概念，而是通过实际项目入手，获得正反馈后再反思、理解，并思考总结写出该篇文章。</p>
<h1 id="为什么想学-TailWindCSS"><a href="#为什么想学-TailWindCSS" class="headerlink" title="为什么想学 TailWindCSS"></a>为什么想学 TailWindCSS</h1><p>之前也看到过类似的文章推送，我大致的印象就是这不就是 BootStrap 嘛。毕竟，人的精力是有限的，现有的 BEM 定义 class 一把梭就挺快的，为什么还要用这种过于<code>原子化</code>的 CSS mixin，import 肯定又是 几百 k。 不知道屏幕前的你有没这些疑问。</p>
<p>每一个能够流行起来的高 Star 项目内涵都不会简单，反正练手，正好了解一番，毕竟<code>实践过后,才有发言权</code>不是嘛</p>
<p>而巧合的是，我有一个现成的案例。以前为了找工作，我也做过在线简历项目。做完新版简历后，不论是代码的提炼还是规范性方面都有了很大的提升。这也算是对过去几年的努力有个交代吧，各个方面有了一个明显的对比。</p>
<p><strong>本文中我简称 TailWindCSS 为 Tss</strong>。<code>可能会有误导，因此在其他地方请不要使用这个名词</code>。</p>
<p>在比较的同时，我会插入一些 TailWindCSS 文档中的概念，这样更容易让我们理解和体会到 Tss 的特性。</p>
<p>最重要的是切入点，本文通过实际案例让你快速了解 Tss，对感兴趣的部分可以对照文档自行学习，可谓事半功倍。废话不多说，<code>show you the code</code>!</p>
<h1 id="新旧项目对比"><a href="#新旧项目对比" class="headerlink" title="新旧项目对比"></a>新旧项目对比</h1><p>下面开始差生示范，只对比 HTML 结构和 CSS，JS 代码就暂省略了</p>
<h2 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h2><p><img src="/2024/02/15/9a8fb720-bf76-11ee-bb1f-d5e564f5accf/template-old.png" alt="公共样式的维护是个问题"></p>
<p>老项目的 app.vue style 没有加 scoped，我们编写的 css，比如 <code>.page-resume p &#123; margin: 10px 0; &#125;</code> 这类代码，一不小心就会应用到其他模块中，而很难发现。命名是门学问，诸如 BEM 之类的规范有很多，这也是业界主流吧，但随着项目内容增多，样式会越来越多臃肿。</p>
<p>我正好遇到过项目中三人同时写一个路由下的三个子页面，都有查询和表格，另个页面是以图文为主，很多链接，提示说明。 有个同事下了如下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.xxx-page</span> <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: <span class="built_in">var</span>(--text-link) <span class="meta">!important</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.xxx-page</span> <span class="selector-class">.title</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>: <span class="number">12px</span> <span class="meta">!important</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="comment">/* 页面相关样式 */</span></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>template 都是复制粘贴，page 名还没改，一旦切到这页面再切到其他页面就会覆盖某些样式 …… 产生极其强大的魔法</p>
<p><img src="/2024/02/15/9a8fb720-bf76-11ee-bb1f-d5e564f5accf/template-new.png" alt="使用Tss，不用写CSS非常干净"></p>
<p>虽然标签里的 class 会变得很臃肿。但单看 DOM 结构，这是良好符合 WAI-ARIA 规范的。有以下好处：</p>
<ul>
<li><p>不用纠结命名，从此告别 <code>xxx-wrapper</code>、 <code>xxx-title</code>、 <code>xxx-list</code>、 <code>xxx-item</code></p>
</li>
<li><p>避免潜在的样式冲突。因为框架都给你定义好了</p>
</li>
</ul>
<blockquote>
<p>你可能会吐槽，这 html 一大堆很难维护，css 是好了可 html 又病了</p>
</blockquote>
<p>关于这点，后续章节 @apply 或者 tailwind.config.js 可能解决，但注定要在<code>灵活性</code>上做一定取舍</p>
<h2 id="Hobby-movie-过渡"><a href="#Hobby-movie-过渡" class="headerlink" title="Hobby &gt; movie 过渡"></a>Hobby &gt; movie 过渡</h2><p>如果上面的不能说服你，那这个例子可以补充一些论据。</p>
<p>Hobby 模块里都是一些简单的动画实现，其中 movie 在旧模块中是这么实现的：</p>
<p><img src="/2024/02/15/9a8fb720-bf76-11ee-bb1f-d5e564f5accf/movie-old.png" alt="过渡有很多重复样式，但我们第一时间很难去抽取公共样式"></p>
<p>这只是其中一个组件，我们给了不同命名来加以区分。最开始写这块的时候没想太多，也没拆分组件，一个文件几百行 css 代码出现了（屎山就是这么炼成的）</p>
<p>项目中 &#x3D; &#x3D; 动辄几百行的还算好，经常 template、js 代码加起来几百行，若是再来上千行的 css，加上项目赶工期，就更头大。项目完给时间大家自觉优化还好，但现实情况，经常继续改 bug，同时又要做新功能 … 看着那座”山”，不由得一声叹息</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 神奇，我真的没写css代码，也不用去想 wrapper item box 之类的命名了 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flex flex-wrap justify-content&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;group overflow-hidden relative ring-1 ring-slate-200 rounded flex items-center justify-center size-12 mr-3 mb-3 origin-center align-center&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Iconfont</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;size-12 absolute left-0 top-0 translate-x-[10px] translate-y-1 transition-transform ease-linear duration-500 group-hover:-translate-y-12&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Iconfont</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;size-12 absolute left-0 top-0 translate-x-[10px] translate-y-1 transition-transform ease-linear duration-500 group-hover:-translate-y-12&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上手 Tss 后，最大的一个变化和惊喜就是，只要你知道你想实现什么，都可以直接用 class 实现最终效果。</p>
<p>没有写一行样式，完美实现了相同的效果，而且复用性强。当你把这串 template 丢给同事，只要有 tailwind 不需要引入 css 文件，不用担心 scoped 和样式覆盖就能得到一样的效果。</p>
<p>并不是说 BEM 不好，我们甚至可以两者结合，如果 Tss 提供的类名不足以实现你想要的效果，可把大致布局文字颜色等先写好，再另起一个 class 继续写 CSS 即可。</p>
<p>对 Tss 动画感兴趣的小伙伴可参考文档，玩出更多花样 <a href="https://www.tailwindcss.cn/docs/transition-property">https://www.tailwindcss.cn/docs/transition-property</a></p>
<h2 id="Hobby-shake-动画"><a href="#Hobby-shake-动画" class="headerlink" title="Hobby &gt; shake 动画"></a>Hobby &gt; shake 动画</h2><p>上面的例子可实现过渡效果了，那动画了？ 在 class 里写@keyframe 嘛？</p>
<p>这里就延伸出 Tss 可配置文件，<code>tailwind.config.js</code>。不仅仅是 动画，其他类似断点，和一些自定义类名，mixin 等，我们都可根据实际情况自行添加。</p>
<p>原则上，能通过 base core 完成的功能就尽量别放到配置中，因为打包会生成额外的代码，除非你确定这部分会多处使用和利于抽象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">import(&#x27;tailwindcss&#x27;).Config</span>&#125; */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">theme</span>: &#123;</span><br><span class="line">    <span class="attr">extend</span>: &#123;</span><br><span class="line">      <span class="attr">animation</span>: &#123;</span><br><span class="line">        <span class="attr">singerShake</span>: <span class="string">&#x27;singerShake linear infinite&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">keyframes</span>: &#123;</span><br><span class="line">        <span class="attr">singerShake</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;0%, 100%&#x27;</span>: &#123; <span class="attr">transform</span>: <span class="string">&#x27;translateX(0)&#x27;</span> &#125;,</span><br><span class="line">          <span class="string">&#x27;10%, 30%, 50%, 70%, 90%&#x27;</span>: &#123; <span class="attr">transform</span>: <span class="string">`translateX(-2px) scale(1.05)`</span> &#125;,</span><br><span class="line">          <span class="string">&#x27;20%, 40%, 60%, 80%&#x27;</span>: &#123; <span class="attr">transform</span>: <span class="string">`translateY(2px) scale(1)`</span> &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码中直接 <code>animate-[singerShake_3s_ease-in-out_infinite]</code> 即可使用。至于细节和命名等看文档就好，后面的 Tss 实用指南会提到。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;transition-all duration-300 ease-linear origin-center hover:bg-slate-500 hover:rounded-full hover:text-white&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Iconfont</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;size-12 absolute left-0 top-1 rotate-0 text-center transition-all origin-center group-hover:animate-[singerShake_3s_ease-in-out_infinite]&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:size</span>=<span class="string">&quot;28&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&quot;changge&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="CSS-更可控"><a href="#CSS-更可控" class="headerlink" title="CSS 更可控"></a>CSS 更可控</h2><p>为了最快实现一个公共列表的样式，写出这么一串样式。如果要优化，在前期，可以通过定义 class，把公共样式抽离出来。</p>
<p>本简历的标题 - 内容（行） - 左 label 右 text，结构也大致如此。上述样式可实现该结构，但随着项目内容变多，需求变得繁杂：</p>
<ol>
<li>label 应自适应，可以给一个最小宽度，但在移动端如果太长能换行</li>
<li>行结构只有内容，没有 label。或 行结构只展示标题（粗体）没有 text，支持 icon</li>
<li>作为子组件时，应该统一对齐 padding</li>
</ol>
<p>这不，html 越来越多，很多样式感觉能公共，但又不好复用。（实现开发经常遇到这类情况）与其花时间做优化，不如直接新撸来得更快</p>
<p>而用 Tss 这些布局-排版-文字 相关样式类名可直接写到 class 中，复用性大大增强。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;magic-wrapper gird-cols-3 bg-white gap-3 font-bold text-sm leading-5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line">  .magic-wrapper &#123;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样的好处是我们通过 TW 抽离了很多公共样式，而真正额外的样式则是 scoped 里的，不会污染其他作用域，这部分样式代码会比一开始少很多。若其他人接手，看到这部分样式能更快知道改动效果。</p>
<p>到这里相信很多朋友会发问：</p>
<ul>
<li><p>这和 Bootstrap 有什么区别？</p>
</li>
<li><p>css 是好维护了，但 html 结构混乱得不堪入目，10 行简单结构，给你能搞出 20 行？</p>
</li>
</ul>
<p>别急，优化的事一步步来，下个章节会结合项目实践，慢慢解释</p>
<h2 id="从布局开始，更高效的响应式支持"><a href="#从布局开始，更高效的响应式支持" class="headerlink" title="从布局开始，更高效的响应式支持"></a>从布局开始，更高效的响应式支持</h2><p>如果一个结构细节多，需要针对更多断点情况，媒体查询的代码很更让人头疼了</p>
<p><img src="/2024/02/15/9a8fb720-bf76-11ee-bb1f-d5e564f5accf/media-old.png" alt="为了响应式布局，会引入更多的css代码"></p>
<p>Tss 实现起来非常简单快速，手敲示例代码：</p>
<blockquote>
<p>wrapper 这类命名不需要，这里只为了大家能看清楚结构和上述 css 进行对比<br>非常建议手敲代码，能更快上手。这里实现下图片的 CSS，放心，绝对没有添加剂！</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;page-resume lg:py-[5vh] lg:px-[5%]&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;group side-wrapper md:h-screen lg:h-[90vh] p-5 pr-[21px] hover:pr-[15px]&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;list-wrapper md:h-[calc(100%-262px)] overflow-hidden group-hover:oerflow-y-auto&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hero-box pr-[6px]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;main-wrapper lg:h-[90vh] overflow-hidden pr-[26px] hover:overflow-y-auto hover:pr-5&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/15/9a8fb720-bf76-11ee-bb1f-d5e564f5accf/tooltip.png" alt="vscode安装插件后上手更佳，放心写不会错"></p>
<p>你可以试着安装 VScode 插件 <code>Tailwind CSS IntelliSense</code></p>
<p>看到这里如果你对 <code>md</code>、 <code>lg</code> 这些名称感到似曾相识，那么文档是最终的归途</p>
<p><a href="https://www.tailwindcss.cn/docs/responsive-design">https://www.tailwindcss.cn/docs/responsive-design</a></p>
<h1 id="TailWindCSS-核心概念"><a href="#TailWindCSS-核心概念" class="headerlink" title="TailWindCSS 核心概念"></a>TailWindCSS 核心概念</h1><p>简历很简单，但这并不就是 Tss 最佳实践，还很多东西等待着我们挖掘<br>有了这样一个开局，如果你已经对 Tss 产生了兴趣，那么接下来的官网概念相信会容易接受得多</p>
<ul>
<li>效用第一 Utility-First Fundamentals</li>
<li>处理状态 Handling Hover, Focus, and Other States</li>
<li>响应式设计 Responsive Design</li>
<li>深色模式 Dark Mode</li>
<li>重用样式 Reusing Styles</li>
<li>添加自定义样式 Adding Custom Styles</li>
<li>功能和指令 Functions &amp; Directives</li>
</ul>
<h2 id="效用第一"><a href="#效用第一" class="headerlink" title="效用第一"></a>效用第一</h2><p>引用下文档内容：</p>
<ul>
<li>您不会浪费精力发明类名。不再需要添加像 sidebar-inner-wrapper 这样的愚蠢的类名只是为了能够设计某些东西，也不再为实际上只是一个 Flex 容器的东西的完美抽象名称而烦恼。</li>
<li>你的 CSS 停止增长。使用传统方法，每次添加新功能时，您的 CSS 文件都会变得更大。有了实用程序，一切都可以重用，因此您很少需要编写新的 CSS。</li>
<li>做出改变感觉更安全。 CSS 是全局性的，当你做出改变时你永远不知道你会破坏什么。 HTML 中的类是本地的，因此您可以更改它们，而不必担心其他内容会被破坏。</li>
</ul>
<h2 id="处理状态"><a href="#处理状态" class="headerlink" title="处理状态"></a>处理状态</h2><p>Tss 包含几乎所有的修饰器，包括：</p>
<ul>
<li>伪类，例如 <code>:hover</code>、<code>:focus</code>、<code>:first-child</code> 和 <code>:required</code></li>
<li>伪元素，例如 <code>::before</code>、<code>::after</code>、<code>::placeholder</code> 和 <code>::selection</code></li>
<li>媒体和功能查询，例如响应式断点、深色模式和偏好减少模式</li>
<li>属性选择器，例如 <code>[dir=&quot;rtl&quot;]</code> 和 <code>[open]</code></li>
</ul>
<p>我们平常写样式的思路是: 1. 定义 class； 2. 添加状态； 3. 添加对应样式代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: black;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.container</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: white;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">而Tss 则是编译成： ```css .hover\:bg-white:hover &#123; --tw-bg-opacity: 1; background-color:</span><br><span class="line">rgb(255 255 255 / var(--tw-bg-opacity)); &#125;</span><br></pre></td></tr></table></figure>

<p>在 Tailwind 中，您不是将 hover 状态的样式添加到现有类，而是向仅在 hover 时执行某些操作的元素添加另一个类。</p>
<p><a href="https://www.tailwindcss.cn/docs/hover-focus-and-other-states#quick-reference">https://www.tailwindcss.cn/docs/hover-focus-and-other-states#quick-reference</a></p>
<p>更多可参考文档，原则就是，在我们需要时再看</p>
<h2 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h2><p>上一快状态里也有响应式标记，这里就不多提，记住一点就好</p>
<ul>
<li>移动优先</li>
</ul>
<p>默认情况下，Tss 使用移动优先断点系统，类似于您在 Bootstrap 等其他框架中可能使用的系统。<br>这意味着无前缀的实用程序（如 uppercase）对所有屏幕尺寸都有效，而带前缀的实用程序（如 md:uppercase）仅在指定的断点及以上位置生效。</p>
<h2 id="深色模式"><a href="#深色模式" class="headerlink" title="深色模式"></a>深色模式</h2><p><del>暂略过，核心就是通过改变状态标记，这里挖个坑吧，后续会为简历添加深色模式。敬请期待</del></p>
<h2 id="（新增内容）快速实现主题切换"><a href="#（新增内容）快速实现主题切换" class="headerlink" title="（新增内容）快速实现主题切换"></a>（新增内容）快速实现主题切换</h2><p>不用后续，克服困难，现在开码。</p>
<h3 id="提前定义好变量，便于维护"><a href="#提前定义好变量，便于维护" class="headerlink" title="提前定义好变量，便于维护"></a>提前定义好变量，便于维护</h3><p>说干就干。为了更好地使用主题模式，我建议提前定义好主题相关的变量，并为这些变量添加一个 dark 的前缀（根据实际情况自行调整）。</p>
<p>其实官方文档就是最好的示例。当我们要实现深色模式或者多主题时，需要考虑需要改变哪些内容？我简单总结如下：</p>
<ul>
<li>页面的大背景色（如果有的话）</li>
<li>布局模块（如：header、main、aside、section、footer 等）的背景色</li>
<li>模块的常态样式，如：边框（内边框、外边框还是 background-image 等）圆角等</li>
<li>文字的颜色</li>
<li>阴影效果</li>
<li>其他等等…</li>
</ul>
<p>当我们考虑到以上内容之后，再来思考状态改变时的颜色，例如 hover、focus、active 等。这只是一个思路，具体设计主题系统还需要 UI 设计同学的参与，还有许多细节值得我们深入研究。这里只是一个简单的参考。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* src/styles/var.css */</span></span><br><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="comment">/* theme-light */</span></span><br><span class="line">  <span class="attr">--page-bg</span>: <span class="number">#c5dae2</span>;</span><br><span class="line">  <span class="attr">--bg-hover</span>: <span class="number">#f5f5f5</span>;</span><br><span class="line">  <span class="attr">--text</span>: <span class="number">#607d8b</span>;</span><br><span class="line">  <span class="attr">--text-hover</span>: <span class="number">#00bdea</span>;</span><br><span class="line">  <span class="attr">--main-bg</span>: white;</span><br><span class="line">  <span class="attr">--aside-bg</span>: <span class="number">#f5f5f5</span>;</span><br><span class="line">  <span class="attr">--scroll-piece</span>: <span class="built_in">rgba</span>(<span class="number">218</span>, <span class="number">230</span>, <span class="number">238</span>, <span class="number">0.9</span>);</span><br><span class="line">  <span class="attr">--scroll-thumb</span>: <span class="built_in">rgba</span>(<span class="number">188</span>, <span class="number">198</span>, <span class="number">223</span>, <span class="number">0.8</span>);</span><br><span class="line">  <span class="attr">--border</span>: <span class="number">#e5e7eb</span>;</span><br><span class="line">  <span class="attr">--focus-border</span>: <span class="number">#bae6fd</span>;</span><br><span class="line">  <span class="attr">--card-bg</span>: <span class="number">#f0f9ff</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* dark-mode */</span></span><br><span class="line">  <span class="attr">--dark-page-bg</span>: <span class="number">#1f2635</span>;</span><br><span class="line">  <span class="attr">--dark-bg-hover</span>: <span class="number">#151e31</span>;</span><br><span class="line">  <span class="attr">--dark-text</span>: <span class="built_in">rgb</span>(<span class="number">145</span>, <span class="number">158</span>, <span class="number">175</span>);</span><br><span class="line">  <span class="attr">--dark-text-hover</span>: <span class="built_in">rgb</span>(<span class="number">185</span>, <span class="number">196</span>, <span class="number">212</span>);</span><br><span class="line">  <span class="attr">--dark-main-bg</span>: <span class="number">#151e29</span>;</span><br><span class="line">  <span class="attr">--dark-aside-bg</span>: <span class="number">#131822</span>;</span><br><span class="line">  <span class="attr">--dark-scroll-piece</span>: <span class="built_in">rgba</span>(<span class="number">18</span>, <span class="number">40</span>, <span class="number">54</span>, <span class="number">0.9</span>);</span><br><span class="line">  <span class="attr">--dark-scroll-thumb</span>: <span class="built_in">rgba</span>(<span class="number">82</span>, <span class="number">86</span>, <span class="number">95</span>, <span class="number">0.8</span>);</span><br><span class="line">  <span class="attr">--dark-border</span>: <span class="built_in">rgb</span>(<span class="number">13</span>, <span class="number">39</span>, <span class="number">53</span>);</span><br><span class="line">  <span class="attr">--dark-focus-border</span>: <span class="built_in">rgb</span>(<span class="number">21</span>, <span class="number">53</span>, <span class="number">70</span>);</span><br><span class="line">  <span class="attr">--dark-card-bg</span>: <span class="number">#0a2c42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我把使用到的色彩变量，都加了对应的 dark 副本，在用到这些的地方提醒自己写一个 <code>dark:xxx</code> 即可</p>
<h3 id="tailwind-主题配置"><a href="#tailwind-主题配置" class="headerlink" title="tailwind 主题配置"></a>tailwind 主题配置</h3><p>根据文档，我们需要先配置 <code>tailwind.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">import(&#x27;tailwindcss&#x27;).Config</span>&#125; */</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">darkMode</span>: <span class="string">&#x27;class&#x27;</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 名称可自行改动，具体参考文档，这里不多赘述</span></span><br></pre></td></tr></table></figure>

<p>配置好后，只要我们在 html 标签上添加 <code>class=&quot;dark&quot;</code> 并为要改变的元素上按下面的方式增加对应类名即可</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Dark mode enabled --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">class</span>=<span class="string">&quot;dark&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Will be black --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bg-white dark:bg-black&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：我们的页面是 create(App).mount(‘#app’) 为了实现上述对 html class 的添加，我们还需要进行额外的 DOM 操作</p>
</blockquote>
<p>我添加了一个 <code>PageTool / ThemeChange</code> （小项目其实用不上状态管理，这里只为展示<code>Pinia</code>用法请勿吐槽 ）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCommonStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;common&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">theme</span>: <span class="string">&#x27;light&#x27;</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="attr">isDark</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> state.<span class="property">theme</span> === <span class="string">&#x27;dark&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">switchTheme</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">isDark</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">theme</span> = <span class="string">&#x27;dark&#x27;</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;dark&#x27;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">theme</span> = <span class="string">&#x27;light&#x27;</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;dark&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>现在我们绑定好方法就可以快速切换主题了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;switch-wrap&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handleSwitch&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Iconfont</span> <span class="attr">v-show</span>=<span class="string">&quot;isDark&quot;</span> <span class="attr">name</span>=<span class="string">&quot;night-mode-fill&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Iconfont</span> <span class="attr">v-show</span>=<span class="string">&quot;!isDark&quot;</span> <span class="attr">name</span>=<span class="string">&quot;light-bulb&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; useCommonStore &#125; <span class="keyword">from</span> <span class="string">&#x27;../../../store/common&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> <span class="title class_">Iconfont</span> <span class="keyword">from</span> <span class="string">&#x27;../../Iconfont/Iconfont.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> store = <span class="title function_">useCommonStore</span>()</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> &#123; isDark &#125; = <span class="title function_">toRefs</span>(store)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> <span class="title function_">handleSwitch</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">    store.<span class="title function_">switchTheme</span>()</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>综上所述，这个简历项目，在 App.vue 的结构清晰明了，只需要在 wrapper、main、aside 等地方填入相应的 dark:xxxx 即可，比如 <code>&lt;main class=&quot;... dark:bg-[var(--dark-main-bg)] &quot;&gt;</code>。</p>
<h3 id="优化-添加平滑过渡"><a href="#优化-添加平滑过渡" class="headerlink" title="优化 - 添加平滑过渡"></a>优化 - 添加平滑过渡</h3><p>这部分代码可能会变得很冗长，慢慢地，tailwind 的这一缺点就凸显出来了。不过这并非大问题，通过使用 <code>@layer</code>，我们可以将这些公共样式抽离出来，这是我在项目开发过程中一点点进行优化的成果。</p>
<p>感兴趣可点击切换，试下效果。会了黑白主题，再添加其他自定义主题不在话下。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@tailwind</span> base;</span><br><span class="line"><span class="keyword">@tailwind</span> components;</span><br><span class="line"><span class="keyword">@tailwind</span> utilities;</span><br><span class="line"><span class="keyword">@layer</span> components &#123;</span><br><span class="line">  <span class="selector-class">.dark-transition</span> &#123;</span><br><span class="line">    <span class="keyword">@apply</span> transition-colors duration-<span class="number">1000</span> ease-in-out;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样再切换，我们的主题就拥有良好的过渡效果了。</p>
<h2 id="重用样式"><a href="#重用样式" class="headerlink" title="重用样式"></a>重用样式</h2><p>上文提到实现 Hobby 模块的 movie 效果时，对 item 写了一堆样式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flex flex-wrap justify-content&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;group overflow-hidden relative ring-1 ring-slate-200 rounded flex items-center justify-center size-12 mr-3 mb-3 origin-center align-center&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;group overflow-hidden relative ring-1 ring-slate-200 rounded flex items-center justify-center size-12 mr-3 mb-3 origin-center align-center&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;group overflow-hidden relative ring-1 ring-slate-200 rounded flex items-center justify-center size-12 mr-3 mb-3 origin-center align-center&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 很多重复结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在项目中有 8 个 item，需要将相同的东西复制八遍吗？起初可能是这样，尽管看起来有些<code>辣眼睛</code>，但至少功能已经实现了。无意中翻看文档时，我发现了以下的信息：</p>
<blockquote>
<p>很多时候，类似这样的重复甚至不是真正的问题，因为它们通常都可以集中在一个地方，甚至实际上根本不存在，因为您正在迭代一组项目并且只编写一次标记。如果您只需要在单个文件中重用需要重用的样式，那么多光标编辑和循环是管理任何重复内容的最简单方法。 —— 官方文档</p>
</blockquote>
<p>好的，给我我笑了 … 于是继续编码。 额，额 …… 当然不止是这样，我们有几种方式来优化</p>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="*: 选择器"></a>*: 选择器</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;parent-comp flex flex-wrap justify-start *:overflow-hidden *:relative *:ring-1 *:ring-slate-200 *:rounded *:flex *:items-center *:justify-center *:size-12 *:mr-3 *:mb-3&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child-comp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child-comp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child-comp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child-comp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child-comp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-apply-提取类"><a href="#使用-apply-提取类" class="headerlink" title="使用@apply 提取类"></a>使用@apply 提取类</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@tailwind</span> base;</span><br><span class="line"><span class="keyword">@tailwind</span> components;</span><br><span class="line"><span class="keyword">@tailwind</span> utilities;</span><br><span class="line"><span class="keyword">@layer</span> components &#123;</span><br><span class="line">  <span class="selector-class">.hobby-item</span> &#123;</span><br><span class="line">    <span class="keyword">@apply</span> overflow-hidden relative ring-<span class="number">1</span> ring-slate-<span class="number">200</span> rounded flex items-center justify-center size-<span class="number">12</span> mr-<span class="number">3</span> mb-<span class="number">3</span> origin-center align-cente;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>笔者也只是初窥门径，还有更多用法学习，尽在官方文档（再次强调）</p>
<h2 id="添加自定义样式-Adding-Custom-Styles"><a href="#添加自定义样式-Adding-Custom-Styles" class="headerlink" title="添加自定义样式 Adding Custom Styles"></a>添加自定义样式 Adding Custom Styles</h2><p>如果您想更改调色板、间距比例、排版比例或断点等内容，请将自定义添加到 tailwind.config.js 文件的主题部分：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">import(&#x27;tailwindcss&#x27;).Config</span>&#125; */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">content</span>: [<span class="string">&#x27;./index.html&#x27;</span>, <span class="string">&#x27;./src/**/*.&#123;ts,tsx,vue&#125;&#x27;</span>],</span><br><span class="line">  <span class="attr">theme</span>: &#123;</span><br><span class="line">    <span class="attr">container</span>: &#123;</span><br><span class="line">      <span class="attr">padding</span>: <span class="string">&#x27;1rem&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">screens</span>: &#123;</span><br><span class="line">      <span class="attr">sm</span>: <span class="string">&#x27;640px&#x27;</span>,</span><br><span class="line">      <span class="attr">md</span>: <span class="string">&#x27;1024px&#x27;</span>,</span><br><span class="line">      <span class="attr">lg</span>: <span class="string">&#x27;1376px&#x27;</span>,</span><br><span class="line">      <span class="attr">xl</span>: <span class="string">&#x27;1920px&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="项目中如何优化-Tss-代码"><a href="#项目中如何优化-Tss-代码" class="headerlink" title="项目中如何优化 Tss 代码"></a>项目中如何优化 Tss 代码</h2><p><img src="/2024/02/15/9a8fb720-bf76-11ee-bb1f-d5e564f5accf/v-if-old.png" alt="效果基本完成，可以开始优化"></p>
<p>我新建了一个 <code>styles/tailwind.css</code> 专门存放 Tss 相关代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@tailwind</span> base;</span><br><span class="line"><span class="keyword">@tailwind</span> components;</span><br><span class="line"><span class="keyword">@tailwind</span> utilities;</span><br><span class="line"><span class="keyword">@layer</span> components &#123;</span><br><span class="line">  <span class="selector-class">.hobby-fromBottom</span> &#123;</span><br><span class="line">    <span class="keyword">@apply</span> translate-y-full transition-transform ease-in-out duration-<span class="number">500</span> <span class="attribute">group-hover</span>:translate-y-<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.hobby-fromTop</span> &#123;</span><br><span class="line">    <span class="keyword">@apply</span> -translate-y-full transition-transform ease-in-out duration-<span class="number">500</span> <span class="attribute">group-hover</span>:translate-y-<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.hobby-fromLeft</span> &#123;</span><br><span class="line">    <span class="keyword">@apply</span> -translate-x-full transition-transform ease-in-out duration-<span class="number">500</span> <span class="attribute">group-hover</span>:translate-x-<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.hobby-fromRight</span> &#123;</span><br><span class="line">    <span class="keyword">@apply</span> translate-x-full transition-transform ease-in-out duration-<span class="number">500</span> <span class="attribute">group-hover</span>:translate-x-<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.hobby-fadeIn</span> &#123;</span><br><span class="line">    <span class="keyword">@apply</span> transition-opacity ease-in-out duration-<span class="number">500</span> opacity-<span class="number">0</span> <span class="attribute">group-hover</span>:opacity-<span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构简洁多了，把布局颜色等样式代码单独写 css，过渡相关样式写到了单独的文件中便于维护。</p>
<blockquote>
<p>需要注意的是：hobby-fromBottom 这种用法在打包后会有编译开销，实际我们只用到一次的话没必要这样使用。这里只是方便展示</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;absolute w-full h-full p-2 z-10 left-0 right-0 top-0 bottom-0 rounded bg-sky-50&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:class</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">    &#x27;hobby-fromBottom&#x27;: transitionType === &#x27;fromBottom&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">    &#x27;hobby-fromTop&#x27;: transitionType === &#x27;fromTop&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">    &#x27;hobby-fromLeft&#x27;: transitionType === &#x27;fromLeft&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">    &#x27;hobby-fromRight&#x27;: transitionType === &#x27;fromRight&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">    &#x27;hobby-fadeIn&#x27;: transitionType === &#x27;fadeIn&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">  &#125;&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>至此已经可以回答之前的疑问了，和 Bootstrap 像吗，是的。但不仅仅是这些，Tss 不仅可定制样式，而且更加灵活，而库体积却更小。</p>
<h2 id="功能和指令-Functions-Directives"><a href="#功能和指令-Functions-Directives" class="headerlink" title="功能和指令 Functions &amp; Directives"></a>功能和指令 Functions &amp; Directives</h2><h3 id="Directives"><a href="#Directives" class="headerlink" title="Directives"></a>Directives</h3><p>指令是自定义 Tss 特定的规则，您可以在 CSS 中使用，为项目提供特殊功能。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这会注入 Tailwind 的基本样式以及插件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@tailwind</span> base;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这会注入 Tailwind 的组件类和任何组件类通过插件注册</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@tailwind</span> components;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这会注入 Tailwind 的实用程序类和注册的任何实用程序类通过插件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@tailwind</span> utilities;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用此指令来控制 Tailwind 注入悬停、焦点、响应式、深色模式以及其他变体</span></span><br><span class="line"><span class="comment"> * 如果省略，Tailwind 会将这些类附加到默认情况下您的样式表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@tailwind</span> variants;</span><br></pre></td></tr></table></figure>

<h1 id="Tss-速记指南"><a href="#Tss-速记指南" class="headerlink" title="Tss 速记指南"></a>Tss 速记指南</h1><p>一个新的东西需要学习成本。看到这的你，我相信已接受 Tss，并想投入使用了。这里结合笔者的经验，整理了一些速成技巧</p>
<p>编写 Tss 建议遵循着以下思路和顺序来：</p>
<ul>
<li>布局</li>
<li>间隔 margin、padding</li>
<li>背景</li>
<li>边框</li>
<li>尺寸 width、height</li>
<li>排版（文字相关）</li>
<li>过渡、动画</li>
<li>其他交互<ul>
<li>cursor</li>
<li>hover</li>
</ul>
</li>
</ul>
<p>这里以组件 TitleDesc.vue 为例。简历项目中在 ProjectWrap 用到来展示标题 + 内容，结构如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;flex flex-between flex-nowrap border-b-2 my-3 py-2 gap-x-5 text-lg&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text-justify&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Iconfont</span> <span class="attr">v-if</span>=<span class="string">&quot;showIcon&quot;</span> <span class="attr">class</span>=<span class="string">&quot;align-middle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Iconfont</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;ml-1 font-bold align-middle text-[#333]&quot;</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;extra&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bg-gray pl-3 text-base text-[#777]&quot;</span>&gt;</span>&#123;&#123; description &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>思路有了一切都很简单，Tss 很多 Class 和原生缩写一样，很容易记，看一遍基本就会了</p>
<p>这里整理一些常用 和 容易错误的：</p>
<h2 id="布局相关"><a href="#布局相关" class="headerlink" title="布局相关"></a>布局相关</h2><p><strong>display</strong></p>
<table>
<thead>
<tr>
<th>Class</th>
<th>Properties</th>
</tr>
</thead>
<tbody><tr>
<td>block</td>
<td>display: block;</td>
</tr>
<tr>
<td>hidden</td>
<td>display: none;</td>
</tr>
<tr>
<td>inline-block</td>
<td>display: inline-block;</td>
</tr>
<tr>
<td>inline</td>
<td>display: inline;</td>
</tr>
<tr>
<td>flex</td>
<td>display: flex;</td>
</tr>
<tr>
<td>grid</td>
<td>display: grid;</td>
</tr>
</tbody></table>
<p>container 在当前断点下都处于 width: 100%</p>
<blockquote>
<p>gap 是真的好用，前提是在 flex 或 grid 下生效</p>
</blockquote>
<p><strong>overflow</strong></p>
<table>
<thead>
<tr>
<th>Class</th>
<th>Properties</th>
</tr>
</thead>
<tbody><tr>
<td>overflow-auto</td>
<td>overflow: auto;</td>
</tr>
<tr>
<td>overflow-hidden</td>
<td>overflow: hidden;</td>
</tr>
<tr>
<td>overflow-clip</td>
<td>overflow: clip;</td>
</tr>
<tr>
<td>overflow-visible</td>
<td>overflow: visible;</td>
</tr>
<tr>
<td>overflow-scroll</td>
<td>overflow: scroll;</td>
</tr>
</tbody></table>
<p><strong>position</strong></p>
<table>
<thead>
<tr>
<th>Class</th>
<th>Properties</th>
</tr>
</thead>
<tbody><tr>
<td>static</td>
<td>position: static;</td>
</tr>
<tr>
<td>fixed</td>
<td>position: fixed;</td>
</tr>
<tr>
<td>absolute</td>
<td>position: absolute;</td>
</tr>
<tr>
<td>relative</td>
<td>position: relative;</td>
</tr>
<tr>
<td>sticky</td>
<td>position: sticky;</td>
</tr>
</tbody></table>
<h2 id="size-尺寸这里单独说一下"><a href="#size-尺寸这里单独说一下" class="headerlink" title="size 尺寸这里单独说一下"></a>size 尺寸这里单独说一下</h2><p><strong>Tss 里的基本单位 1rem &#x3D; 16px</strong> 这点非常重要，请记住。对于尺寸，1 TSS 标准单位大小 &#x3D; 4px (0.25rem)</p>
<p>后面跟的 left-1、size-10 看到这种默默乘 4 就可以换算出 left-1（left:4px）、w-8(width: 32px)、mb-4(margin-bottom: 16px)</p>
<table>
<thead>
<tr>
<th>Class</th>
<th>Properties</th>
</tr>
</thead>
<tbody><tr>
<td>m-0</td>
<td>margin: 0;</td>
</tr>
<tr>
<td>w-px</td>
<td>width: 1px;</td>
</tr>
<tr>
<td>mx-auto</td>
<td>margin-left: auto;margin-right:auto;</td>
</tr>
<tr>
<td>py-auto</td>
<td>padding-top: auto;padding-bottom:auto</td>
</tr>
<tr>
<td>h-full</td>
<td>height: 100%;</td>
</tr>
<tr>
<td>left-1&#x2F;2</td>
<td>left: 50%;</td>
</tr>
</tbody></table>
<h2 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h2><ul>
<li>0 就是 0px</li>
<li>px 一般都是 1px</li>
<li>full 表示 100%</li>
<li>x 横坐标，如<code>mx</code>就是 margin-left、margin-right</li>
<li>y 纵坐标，同上 <code>py</code> 就是 padding-top、padding-bottom</li>
<li>加入 1&#x2F;3 这样的，表示百分比，具体看文档</li>
<li>若想精确的，可以自定义 <code>-[x]</code>，如 <code>w-[66px]</code>、 <code>h-[calc(100vh-50px)</code></li>
</ul>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Tss 的写这类复合样式，都是要拆开写的，虽麻烦，但本质上也算是解耦嘛</p>
<p>后续 flex、border、transition 这类属性也类似，我们只要知道大致 value 即可，这么一想也挺好，对 CSS 越熟悉就越容易上手 Tss。</p>
<p>background 本身是 background-color、background-image、background-position、background-repeat、background-size 多个属性的缩写。</p>
<table>
<thead>
<tr>
<th>Class</th>
<th>Properties</th>
<th>Desc</th>
</tr>
</thead>
<tbody><tr>
<td>bg-none</td>
<td>background-image: none;</td>
<td>-</td>
</tr>
<tr>
<td>bg-white</td>
<td>background-color: white;</td>
<td>颜色</td>
</tr>
<tr>
<td>bg-center</td>
<td>background-position: center;</td>
<td>位置</td>
</tr>
<tr>
<td>bg-cover</td>
<td>background-size: cover;</td>
<td>尺寸</td>
</tr>
<tr>
<td>bg-contain</td>
<td>background-size: contain;</td>
<td>尺寸</td>
</tr>
<tr>
<td>bg-no-repeat</td>
<td>background-repeat: no-repeat;</td>
<td>重复</td>
</tr>
</tbody></table>
<p>用这类属性，需要根据 <code>bg-[效果]</code> 带来的实际效果提炼关键点。这么想就容易上手了</p>
<h2 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h2><p>常用的都在这里，知道这几个即可：</p>
<ul>
<li>translate 同 left right ，直接写</li>
<li>scale 同 opacity，需注意 Tss 里的像百分比的值都乘了 100</li>
<li>rotate 官方只制定了几个常用的，这类自己写就好，如<code>rotate-[46deg]</code></li>
<li>skew 同上</li>
<li>origin <code>origin-center</code>为 transform-origin: center;</li>
</ul>
<p><code>transform-gpu</code> 就是面试中常考的的开启 gpu 加速</p>
<blockquote>
<p>但没看到对 translate-z 的支持，<code>perspective</code>只能手动添加了<br>若有错误麻烦指正下，谢谢</p>
</blockquote>
<h2 id="来记点不一样的"><a href="#来记点不一样的" class="headerlink" title="来记点不一样的"></a>来记点不一样的</h2><p>上面说了关键点在于应用 CSS 带来的实际效果。再来看下面这些，你就会容易理解得多：</p>
<table>
<thead>
<tr>
<th>Class</th>
<th>Properties</th>
<th>Desc</th>
</tr>
</thead>
<tbody><tr>
<td>bg-white</td>
<td>background-color: white;</td>
<td>颜色</td>
</tr>
<tr>
<td>text-base</td>
<td>font-size: 1rem; line-height: 1.5rem;</td>
<td>字体和行高</td>
</tr>
<tr>
<td>truncate</td>
<td>overflow、text-ellipsis、white-space</td>
<td>三剑客文字省略你懂的</td>
</tr>
<tr>
<td>italic</td>
<td>font-style: italic;</td>
<td>斜体</td>
</tr>
<tr>
<td>font-bold</td>
<td>font-weight: 700;</td>
<td>加粗</td>
</tr>
<tr>
<td>leading-5</td>
<td>line-height: 20px;</td>
<td>行高</td>
</tr>
<tr>
<td>text-center</td>
<td>text-align: center;</td>
<td>文字居中</td>
</tr>
<tr>
<td>align-middle</td>
<td>vertical-align: middle;</td>
<td>内联垂直对齐</td>
</tr>
<tr>
<td>rounded</td>
<td>border-radius: 4px;</td>
<td>-</td>
</tr>
<tr>
<td>divide-x &gt; +</td>
<td>border-right-width: 0px; border-left-width: 1px;</td>
<td>不用单独写边框了</td>
</tr>
<tr>
<td>divide-y-2 &gt; +</td>
<td>border-top-width: 2px; border-bottom-width: 0px;</td>
<td>不用单独写边框了</td>
</tr>
<tr>
<td>outline-1</td>
<td>outline-width: 1px;</td>
<td>外边框，这几种根据实际需要选择即可</td>
</tr>
<tr>
<td>ring-1</td>
<td>太多省略</td>
<td>本质为 box-shadow 模拟的边框</td>
</tr>
<tr>
<td>opacity-0</td>
<td>opacity: 0;</td>
<td>透明</td>
</tr>
<tr>
<td>opacity-100</td>
<td>opacity: 1;</td>
<td>不透明</td>
</tr>
<tr>
<td>visible</td>
<td>visibility: visible;</td>
<td>典，虽隐藏了但保留 DOM 位置，影响回流</td>
</tr>
<tr>
<td>invisible</td>
<td>visibility: hidden;</td>
<td>本质为 box-shadow 模拟的边框</td>
</tr>
<tr>
<td>cursor-pointer</td>
<td>cursor: pointer;</td>
<td>聚焦</td>
</tr>
<tr>
<td>cursor-not-allowed</td>
<td>cursor: not-allowed;</td>
<td>禁止</td>
</tr>
<tr>
<td>pointer-events-none</td>
<td>pointer-events: none;</td>
<td>阻止浏览器事件</td>
</tr>
<tr>
<td>select-none</td>
<td>user-select: none;</td>
<td>禁止选中</td>
</tr>
</tbody></table>
<blockquote>
<p>注：用 text 千万要注意<code>line-height</code>，虽然很想吐槽 明明是 font-size ，但整个 text 很异类.<br>如果只想使用 font-size 的话，直接 <code>text-[14px]</code> 这样就好了</p>
</blockquote>
<p>上述这些浏览一遍就可快速上手，遇到不会的再查文档就是。</p>
<h1 id="学到的-CSS-新特性"><a href="#学到的-CSS-新特性" class="headerlink" title="学到的 CSS 新特性"></a>学到的 CSS 新特性</h1><h2 id="1-display-flow-root"><a href="#1-display-flow-root" class="headerlink" title="1. display: flow-root;"></a>1. display: flow-root;</h2><p><code>flow-root</code> 该元素生成一个块级元素盒，其会建立一个新的块级格式化上下文，定义格式化上下文的根元素。</p>
<p><del>IE8 启动 …… 额，不是</del> 还在用 clear 清楚浮动嘛？ float 毕竟是针对内联图文的，</p>
<p>如果想让之后的元素不受到浮动影响，可以直接新建一个元素，并使用该属性</p>
<h2 id="2-grid-布局快速上手"><a href="#2-grid-布局快速上手" class="headerlink" title="2. grid 布局快速上手"></a>2. grid 布局快速上手</h2><p>四列布局是吧？ 来了，瀑布流？不在话下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;grid grid-cols-4 gap-4&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>01<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>09<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>更多参考：<a href="https://www.tailwindcss.cn/docs/grid-template-columns">https://www.tailwindcss.cn/docs/grid-template-columns</a></p>
<h2 id="3-scroll-behavior-smooth"><a href="#3-scroll-behavior-smooth" class="headerlink" title="3. scroll-behavior: smooth;"></a>3. scroll-behavior: smooth;</h2><p>论回到顶部的四种写法：</p>
<ul>
<li>jQuery.animate({scrollTop:0})</li>
<li>window.scrollTo(0, 0)</li>
<li>document.body.scrollTop &#x3D; 0</li>
</ul>
<p>如果想丝滑滚动还要写一堆 js 代码，防抖啊，<code>requestAnimationFrame</code> 又给整出来了，现在不要 998，只需一句 css <code>scroll-behavior: smooth</code>，结合 <code>&lt;a&gt;</code>锚点即可实现，浏览器更懂浏览器。</p>
<blockquote>
<p>此时一位路过的朋友提出兼容 IE8（大哥现在 2024 React 都 18 了，vue 都 3 了，全民 AI 时代您还搁这 IE。抗击旧世界残党我辈义不容辞）掘金内外又瞬间充满了快活的空气</p>
</blockquote>
<h2 id="4-caret-color"><a href="#4-caret-color" class="headerlink" title="4. caret-color"></a>4. caret-color</h2><p>用于控制文本输入光标颜色 <code>caret-color: orange;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;caret-orange-200 ...&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="5-background-clip"><a href="#5-background-clip" class="headerlink" title="5. background-clip"></a>5. background-clip</h2><p>设置元素的背景（背景图片或颜色）是否延伸到边框、内边距盒子、内容盒子下面，在这里，头像下的文字就是<code>	background-clip: text</code> 和 <code>linear-gradient</code> 实现的。</p>
<p>更多可看文档 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-clip">https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-clip</a>。</p>
<h2 id="6-will-change"><a href="#6-will-change" class="headerlink" title="6. will-change"></a>6. will-change</h2><p>用于优化即将发生变化的元素的动画。官方建议慎用，在明确 transition perproties 的情况下可以提升性能</p>
<h2 id="7-postcss"><a href="#7-postcss" class="headerlink" title="7. postcss"></a>7. postcss</h2><p>我发现两者结合已能满足大部分功能和场景，什么 sass（安装就像买彩票） scss、stylus 我都不需要了</p>
<h2 id="8-更多选择器和修饰符"><a href="#8-更多选择器和修饰符" class="headerlink" title="8. 更多选择器和修饰符"></a>8. 更多选择器和修饰符</h2><p>再帖一遍文档，真的很好用</p>
<p><a href="https://www.tailwindcss.cn/docs/hover-focus-and-other-states#quick-reference">https://www.tailwindcss.cn/docs/hover-focus-and-other-states#quick-reference</a></p>
<p>一个好的优化原则就是，能用 css 的尽量用 css 实现。 合理选择器和好处在于 它的权重和 class 都是相同的，知道这点，就可以让我们可以少写很多没必要的高权重选择器</p>
<h2 id="9-了解到-WAI-ARIA"><a href="#9-了解到-WAI-ARIA" class="headerlink" title="9. 了解到 WAI-ARIA"></a>9. 了解到 WAI-ARIA</h2><p>感兴趣可看我之前的一篇文，如果需要，可以向标签添加 data 和 aria 属性，结合 role，提供更好的用户可访问性。</p>
<p><a href="https://blog.fridolph.top/2024/01/26/32647990-bc5d-11ee-b11d-1ddb3fe7683d/">https://blog.fridolph.top/2024/01/26/32647990-bc5d-11ee-b11d-1ddb3fe7683d/</a></p>
<h2 id="还有更多等待发掘"><a href="#还有更多等待发掘" class="headerlink" title="还有更多等待发掘"></a>还有更多等待发掘</h2><p>HTML、CSS，简单和立即反馈，通过这次学习感觉找回了初学前端时的快乐，这算是一个意外之喜吧。<br>在写博客时，也发现一些可尝试的新东西，预计就随便写写 2000 字不能再多，没想到码了这么多字</p>
<blockquote>
<p>这篇文章真是从 2000 字 -&gt; 想着扩展点吧写到 5000 字 -&gt; 好人做到底完善到 1W 字 ~ 骄傲，原来我不是文废，语文老师可以放心了！</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>考虑到这一章节，这实质上也是对过往经验的一种总结。在我早期的项目开发中，往往采用一种即兴的方式编写 css 和模板，导致组件粒度不够细，复用性不高，同时也存在一定程度的未提取冗余样式的问题。随着项目复杂度的增加，势必出现一些无法解决的样式问题，不得不通过全局样式甚至使用“important”来进行覆盖。</p>
<p>随着对 Tss 的学习，加上最近也是在复习，想到就会尝试添加新的特性，不知不觉 2 天搞定的项目断断续续码了十多天，但这一过程非常享受，我重新找回了对编码的好奇心和热情。</p>
<h2 id="关于技术选型"><a href="#关于技术选型" class="headerlink" title="关于技术选型"></a>关于技术选型</h2><ul>
<li>项目中添加 TSS 有一定的学习成本</li>
</ul>
<p>刷到些评论，感觉更多的困难是能否让同事接受 TSS 的核心概念。刷文档做 demo 实际 1 天即可上手。</p>
<p>还有另一好处是让平时不太关注 CSS 的小伙伴，（不考虑兼容性情况下）能用到一些新特性。</p>
<ul>
<li>对于灵活性的取舍</li>
</ul>
<p>我理解熟悉 TSS 带来的高效开发和其带来的 html 臃肿问题，<code>@apply</code>(tailwind.config.js) 如何使用决定了我们需要牺牲怎样的灵活性以换来更高的可维护性</p>
<ul>
<li>代码体积小，灵活度高，推荐一试</li>
</ul>
<p>从下面可看到打包后 css 代码部分很小（只编译打包了我们用到的部分）这也是与其他写好 <code>.xs .md .m-1 .m-2 .p-b-1 .p-t-2</code> 样式的 UI 的不同之处。</p>
<h2 id="个人总结的一些开发实践"><a href="#个人总结的一些开发实践" class="headerlink" title="个人总结的一些开发实践"></a>个人总结的一些开发实践</h2><ol>
<li><p>对于入口文件 app.vue，应确保其作为容器组件，尽量减少业务逻辑的耦合。</p>
</li>
<li><p>在划分组件和视图时，要遵循<code>components</code>和 <code>views</code> 的原则，以减小粒度并分离业务逻辑。</p>
</li>
<li><p>善用 <code>hooks</code>，尤其在项目中逻辑较为简单时，例：我抽了个 <code>useLocale</code> hook，供参考。</p>
</li>
<li><p>在划分视图时，要保持与入口的清晰一致， 如<code>App.vue</code> 它会为你带来意想不到的好处。</p>
</li>
<li><p>在组件开发时不要刻意进行优化。我的建议是，待一个大的 <code>page/view</code> 开发结束后再考虑优化的事情</p>
</li>
</ol>
<blockquote>
<p>过早的优化属于浪费精力。但如果优化过晚，特别是在多人合作时，一些未提取的模板可能会被他人复制，然后进行修改，一旦变得不可控，进行优化就会需要更多的精力。</p>
</blockquote>
<ol start="6">
<li>布局、文字等细节不应等到 UI 设计确定后再考虑，而应从决定支持响应式、i18n 时开始考虑。</li>
</ol>
<blockquote>
<p>我前公司的项目中，基本上都需要支持国际化。对于布局，务必要考虑文本所带来的影响，例如文字不固定长度，中文切换到英文长度变化带来的影响等，这些细节可以尽早地写入到 common.css 中作为公共样式。</p>
</blockquote>
<ol start="7">
<li>过渡和动画可以起到画龙点睛的作用，但如果使用，尽量多尝试不同的 cubic-bezier。</li>
</ol>
<blockquote>
<p>在可控的情况下，要减少 transition-all 的使用，而以 transition-opacity、transition-transform 为例。否则，这与 TypeScript 中使用 any 有何区别呢？</p>
</blockquote>
<p>我们的项目很简单，在实际开发中远不止这些，推荐参考 dev.to 、MDN 等</p>
<h2 id="终于上线啦！别高兴太早"><a href="#终于上线啦！别高兴太早" class="headerlink" title="终于上线啦！别高兴太早"></a>终于上线啦！别高兴太早</h2><p>网站既然都放到了生产环境，F12 是常有的事 … <del>那有必要 print 秀一波 console.log 了，啊，不是!</del></p>
<p>小红红：停停停！兄弟，你是来捣乱的嘛？</p>
<p>性能才是我们要关注的重点好吧。先来一波分析 performance. 这是我自己网站的加载情况</p>
<blockquote>
<p>实际可自行 performance API 或运用 lighthouse 等工具。这里就简单示范下</p>
</blockquote>
<p><img src="/2024/02/15/9a8fb720-bf76-11ee-bb1f-d5e564f5accf/per2.png" alt="让人头发发麻"><br><img src="/2024/02/15/9a8fb720-bf76-11ee-bb1f-d5e564f5accf/per1.png" alt="让人头发发麻"></p>
<p>呵呵，有点搞笑？！就这么少的文件，只有一个单页，怎么会加载得如此缓慢呢？代码写出来了，也在本地运行了，但放到生产环境后才发现问题如此突出。</p>
<p>没错，你也许以为这个项目已经完成了，但实际上，这只是一个开始。还有很长的路要走，兄弟们，我们的任务尚且艰巨。</p>
<h3 id="构建优化"><a href="#构建优化" class="headerlink" title="构建优化"></a>构建优化</h3><p>也是为了面试，正好实践一下 &#x3D; &#x3D; 以前也没配过这些，vue-cli 直接搞定，反正需要啥用啥，直接看文档即可 <a href="https://cn.vitejs.dev/">https://cn.vitejs.dev/</a>.</p>
<p>大方向嘛无外乎两点：<code>减少构建和打包耗时，减小打包资源体积</code></p>
<ol>
<li><a href="https://github.com/nonzzz/vite-plugin-compression">vite-plugin-compression</a></li>
</ol>
<p>这点 vite 默认配置就有了，不用担心。这里我加了一个插件 <code>compression</code>，它的作用是打包压缩且生成 gzip，感兴趣的小伙伴自行文档</p>
<p><img src="/2024/02/15/9a8fb720-bf76-11ee-bb1f-d5e564f5accf/build.png" alt="build后哪怕压缩都还是很大"></p>
<ol start="2">
<li><a href="https://github.com/sanyuan0704/vite-plugin-chunk-split">vite-plugin-chunk-split</a></li>
</ol>
<p>Vite 代码拆包插件。支持多种拆包策略，可避免手动操作 <code>manualChunks</code> 潜在的循环依赖问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">vue</span>(),</span><br><span class="line">    <span class="title function_">compression</span>(),</span><br><span class="line">    <span class="title function_">chunkSplitPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">strategy</span>: <span class="string">&#x27;default&#x27;</span>,</span><br><span class="line">      <span class="attr">customSplitting</span>: &#123;</span><br><span class="line">        <span class="comment">// vue相关会被打包到一个名为`render-vendor`的 chunk 里面(包括它们的一些依赖，如 object-assign)</span></span><br><span class="line">        <span class="string">&#x27;vue-vendor&#x27;</span>: [<span class="regexp">/vue/</span>, <span class="regexp">/pinia/</span>],</span><br><span class="line">        <span class="string">&#x27;tailwind-vendor&#x27;</span>: [<span class="regexp">/tailwindcss/</span>],</span><br><span class="line">        <span class="string">&#x27;fri-vendor&#x27;</span>: [<span class="regexp">/fri-element-plus/</span>],</span><br><span class="line">        <span class="comment">// 源码中目录的代码都会打包进 [name] 这个 chunk 中</span></span><br><span class="line">        <span class="attr">styles</span>: [<span class="regexp">/src\/styles/</span>],</span><br><span class="line">        <span class="attr">locales</span>: [<span class="regexp">/src\/locales/</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/15/9a8fb720-bf76-11ee-bb1f-d5e564f5accf/build-after.png" alt="build后哪怕压缩都还是很大"></p>
<p>原来是之前的练手项目导致了这些问题。动态导入却没有实现只导入所需的组件和样式，导致页面大小异常庞大。(如果有时间的话，可以对这个项目进行构建) 实现代码拆分（split-chunks），来减少页面加载体积。</p>
<p>对于使用开源 UI 库的情况，大多数都会支持这样的特性，比如 <code>ElementPlusResolver</code> 等，以此来解决该问题</p>
<ol start="3">
<li><a href="https://github.com/Geocld/vite-plugin-importus">vite-plugin-importus</a></li>
</ol>
<p>这里假装已经优化了：囧 （如果 UI 库支持，可实现按需加载）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="title function_">vitePluginImportus</span>([</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">libraryName</span>: <span class="string">&#x27;ElementPlus&#x27;</span>,</span><br><span class="line">        <span class="attr">libraryDirectory</span>: <span class="string">&#x27;es&#x27;</span>,</span><br><span class="line">        <span class="attr">style</span>: <span class="string">&#x27;css&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ]),</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实你还可以考虑，在你的项目中并不一定需要那么大而全的 UI 或工具库。既然已经开始着手进行优化，那就一丝不苟地将这些练手用的 UI 库移除吧。<br>同时，在此时可以思考一下，这些库、UI 组件等<code>是否真的是你项目中所必需</code>的，是否存在其他更优的替代方案，是否支持按需加载等功能。<br>我又开始进行一番调整，将这些添加的”玩具”组件库一一移除了。</p>
</blockquote>
<ol start="4">
<li><a href="https://github.com/dreambo8563/vite-plugin-bundle-prefetch">Vite-plugin-bundle-prefetch</a></li>
</ol>
<ul>
<li>获取所有包含 assetDir 的包</li>
<li>过滤目标文件（rm .map 文件或忽略旧版本）</li>
<li>获取最终输出的 html 文件内容</li>
<li>在头部附加 <code>&lt;link rel=&quot;prefetch&quot; href=&quot;xxxx&quot;&gt;</code></li>
</ul>
<p>通过 prefetch 也能尽早渲染页面，从而达到优化的效果</p>
<ol start="5">
<li>路由按需加载 （这里没用到就略过了）</li>
</ol>
<blockquote>
<p>构建上还有很多，主要是根据自身实际需求来就好。<strong>适合的就是最好的</strong></p>
</blockquote>
<p><img src="/2024/02/15/9a8fb720-bf76-11ee-bb1f-d5e564f5accf/opt-1.png" alt="vite相关优化后"></p>
<p>优化后快多了不是，但还没完，别急，马上就好了，虽然我们打包了 gz 后缀，但其实还没生效呢。</p>
<p><img src="/2024/02/15/9a8fb720-bf76-11ee-bb1f-d5e564f5accf/opt-2.png" alt="vite相关优化后"></p>
<h2 id="请求优化"><a href="#请求优化" class="headerlink" title="请求优化"></a>请求优化</h2><p>由于近期正在找工作，我发现简历内容可能会需要频繁更新。为了确保浏览器不会缓存旧的信息，我采用以下缓存策略：（仅供参考，可根据你的情况调整）</p>
<ul>
<li>index.html 不使用任何缓存策略，因为文件体积本身很小</li>
<li>js、css、pdf、md 等可能频繁变动的文件，缓存 1 天</li>
<li>svg、jpg、pdf 和字体文件等不会经常更改的文件，缓存 7 天</li>
<li>同时，我也开启了 gzip 压缩功能。</li>
</ul>
<p>下面是我的 nginx 配置，供大家参考：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">server_name</span> resume.fridolph.top;</span><br><span class="line">  <span class="comment"># ssl和证书相关配置省略了</span></span><br><span class="line"></span><br><span class="line">  <span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">index</span> index.html;</span><br><span class="line">    <span class="attribute">add_header</span> Cache-Control <span class="string">&quot;private, no-store, no-cache, must-revalidate, proxy-revalidate&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="section">location</span> <span class="regexp">~* ^.+\.(jpg|png|svg|ico|woff|woff2)$</span> &#123;</span><br><span class="line">    <span class="attribute">log_not_found</span> <span class="literal">off</span>; <span class="comment"># 关闭日志</span></span><br><span class="line">    <span class="attribute">expires</span> <span class="number">7d</span>; <span class="comment"># 缓存时间7天</span></span><br><span class="line">    <span class="attribute">add_header</span> Cache-Control  max-age=<span class="number">604800</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="section">location</span> <span class="regexp">~* ^.+\.(css|js|md|pdf|)$</span> &#123;</span><br><span class="line">    <span class="attribute">expires</span> <span class="number">1d</span>; <span class="comment"># 可能会频繁变动的资源只缓存1天</span></span><br><span class="line">    <span class="attribute">add_header</span> Cache-Control  max-age=<span class="number">86400</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 开启gzip</span></span><br><span class="line">  <span class="attribute">gzip</span>  <span class="literal">on</span>;</span><br><span class="line">  <span class="comment"># 启用gzip压缩的最小文件，小于设置值的文件将不会压缩</span></span><br><span class="line">  <span class="attribute">gzip_min_length</span> <span class="number">1k</span>;</span><br><span class="line">  <span class="comment"># gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间。一般设置1和2</span></span><br><span class="line">  <span class="attribute">gzip_comp_level</span> <span class="number">2</span>;</span><br><span class="line">  <span class="comment"># 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。</span></span><br><span class="line">  <span class="attribute">gzip_types</span> text/plain application/javascript application/x-javascript text/css application/xml image/jpeg image/png;</span><br><span class="line">  <span class="comment"># 是否在http header中添加Vary: Accept-Encoding，建议开启</span></span><br><span class="line">  <span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/02/15/9a8fb720-bf76-11ee-bb1f-d5e564f5accf/opt-3.png" alt="最终优化效果 - 秒开，搞定"></p>
<p>总体来看，作为一个“简单”的项目，我相信它应该达标了吧！<del>呜呜呜，简历兄你完成了自己的使命，一路走好。</del></p>
<p>当然，优化远不止这么简单，这里只例举了一些常见方式，可根据需要将这些优化技巧运用到你的项目中。</p>
<h2 id="再强调一下-Tss-四大核心概念："><a href="#再强调一下-Tss-四大核心概念：" class="headerlink" title="再强调一下 Tss 四大核心概念："></a>再强调一下 Tss 四大核心概念：</h2><ul>
<li>效用第一</li>
<li>处理状态</li>
<li>响应式设计</li>
<li>重用样式</li>
</ul>
<p>这才是我们在项目中使用的目的，tss 只是其中一个手段。感谢您看到这里。文章内容基本结束，本文只是引子，Tss 本身不仅仅这些内容。若通过本文能引起你的兴趣并学习这也是我的荣幸。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p><code>实践才是最好的老师</code>，通过这段时间的实践，通过不断地思考和优化项目结构、组件，以及功能的实现。尽管这只是一个简单的项目，但我已经不再是简单的复制粘贴，而是把它当成一件新鲜的事物，用来检验自己的学习成果。我发现 <code>Tss 非常适合模块化开发</code>，随着熟练度提高用起来也越来越顺手。</p>
<p>如果有同学不需要国际化的版本，可以切换到 <a href="https://github.com/Fridolph/my-resume">https://github.com/Fridolph/my-resume</a> <code>分支的dev/无国际化看这分支</code>。但这个分支比较早，缺少很多细节和后续的优化，再贴一下项目地址：</p>
<p>github： <a href="https://github.com/Fridolph/my-resume">https://github.com/Fridolph/my-resume</a><br>在线浏览：<a href="https://resume.fridolph.top/">https://resume.fridolph.top</a></p>
<p>如果您觉得这对您有所帮助，求个 Star 不过分吧！~ 如果有不足之处或者观点不一致的地方，欢迎指出和讨论 ~</p>
<p>本来想拆成几篇来写，感觉没必要。一步到位，您的点赞对我来说将是最大的认可。支持一下”萌新”吧！在春节期间写文章确实不容易，感谢大家的关注和支持。</p>
<p>恭祝大家工作顺利，平安健康，万事如意，一帆风顺！和我一样没工作的小伙伴在新的一年能找到自己满意的工作，生活不易，共勉之！</p>
]]></content>
      <categories>
        <category>代码相关</category>
      </categories>
      <tags>
        <tag>TailWindCSS</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习】underscore源码学习（一）——核心架构</title>
    <url>/2017/06/02/7c02da90-af8f-11ee-ab49-f9a704749fc6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>读源码是一个提升自己编码和架构的有效方式，明明知道但一直没敢尝试，就算是学习jQuery的源码也是跟着大神的视频，博客一点点填坑的，之前也苦于写的博客没什么技术含量，要不就是自己都知道的，要不就是摘录书中的一些经验，久之反倒没了写博客的兴趣。underscore.js是个优秀的工具库，总代码行也就1600行+ 每天读50行+的速度一个月也能搞定，这么一想完全就不怕了。</p>
</blockquote>
<p>多点信心，不怕犯错，多记录和搜索这样利于自己巩固，嗯嗯… 也为后面看Vue、React、Redux源码什么的打点基础，当然那是后话了… 希望这个系列能把坑填完就好</p>
<span id="more"></span>

<hr>
<p><code>注：underscore 叫着太啰嗦- - 下文都用 _ 来指代了， 既然是读underscore想必也能接受</code></p>
<p>那么直接开始正文吧~~</p>
<h2 id="命名空间管理"><a href="#命名空间管理" class="headerlink" title="命名空间管理"></a>命名空间管理</h2><p>最外层是一个IIFE(立即调用函数)，各大框架常用，如jQuery就是典型，这是为了模拟块级作用域，防止污染全局命名空间。具体的好处和由来可以去谷歌一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">((<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)());</span><br></pre></td></tr></table></figure>

<h2 id="变量声明-14-168行"><a href="#变量声明-14-168行" class="headerlink" title="变量声明 14-168行"></a>变量声明 14-168行</h2><h3 id="巧妙地变量声明"><a href="#巧妙地变量声明" class="headerlink" title="巧妙地变量声明"></a>巧妙地变量声明</h3><p>巧妙地变量声明可以让程序执行地更加效率，关于这些点，在后文中我会力所能及地表达清楚<br>在说这点前，大家可以看看JS高级程序的第7章函数部分有提到</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> root = <span class="keyword">typeof</span> self == <span class="string">&#x27;object&#x27;</span> &amp;&amp; self.<span class="property">self</span> === self &amp;&amp; self ||</span><br><span class="line">  <span class="keyword">typeof</span> <span class="variable language_">global</span> == <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="variable language_">global</span>.<span class="property">global</span> === <span class="variable language_">global</span> &amp;&amp; <span class="variable language_">global</span> ||</span><br><span class="line">  <span class="variable language_">this</span> ||</span><br><span class="line">  &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="了解运算符优先级"><a href="#了解运算符优先级" class="headerlink" title="了解运算符优先级"></a>了解运算符优先级</h3><p>声明root变量，首先我们要了解JS的运算符优先级，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">运算符优先级</a></p>
<p>以下运算符从高到低:</p>
<ul>
<li>16  typeof</li>
<li>10  &#x3D;&#x3D;、&#x3D;&#x3D;&#x3D; </li>
<li>6   逻辑与 &amp;&amp;</li>
<li>5   逻辑或 ||</li>
</ul>
<p>那么我们重新审视这串代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> root = </span><br><span class="line">  ((<span class="keyword">typeof</span> self == <span class="string">&#x27;object&#x27;</span>) &amp;&amp; (self.<span class="property">self</span> === self) &amp;&amp; self) ||</span><br><span class="line">  ((<span class="keyword">typeof</span> <span class="variable language_">global</span> == <span class="string">&#x27;object&#x27;</span>) &amp;&amp; (<span class="variable language_">global</span>.<span class="property">global</span> === <span class="variable language_">global</span>) &amp;&amp; <span class="variable language_">global</span>) ||</span><br><span class="line">  <span class="variable language_">this</span> ||</span><br><span class="line">  &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>这样会好理解一些了，把root定义为全局对象，如果不是在浏览器或者Node.js环境中就设为一个空对象</p>
<pre><code>var previousUnderscore = root._;
</code></pre>
<p>previousUnderscore作为全局对象的属性存储，其名为 <code>_</code> ，说不清，但很简单，举个例：</p>
<pre><code>((function() &#123;
  var root = window || &#123;&#125;;
  var pu = root._;

  pu = &#123;
    &#39;name&#39;: &#39;fri&#39;,
    &#39;age&#39;: 24
  &#125;

&#125;)());

console.log(_);
</code></pre>
<p>内部作用域的私有变量是pu，但通过root._ 的形式暴露给了全局对象，所以在全局通过 <code>_</code> 变量就能访问到内部pu对象了</p>
<p><code>注：这段代码在严格模式下会报错 ReferenceError: _ is not defined</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">ArrayProto</span> = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>, </span><br><span class="line">    <span class="title class_">ObjProto</span> = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">SymbolProto</span> = <span class="keyword">typeof</span> <span class="title class_">Symbol</span> !== <span class="string">&#x27;undefined&#x27;</span> ? <span class="title class_">Symbol</span>.<span class="property"><span class="keyword">prototype</span></span> : <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> push = <span class="title class_">ArrayProto</span>.<span class="property">push</span>,</span><br><span class="line">    slice = <span class="title class_">ArrayProto</span>.<span class="property">slice</span>,</span><br><span class="line">    toString = <span class="title class_">ObjProto</span>.<span class="property">toString</span>,</span><br><span class="line">    hasOwnProperty = <span class="title class_">ObjProto</span>.<span class="property">hasOwnProperty</span>;</span><br><span class="line"><span class="keyword">var</span> nativeIsArray = <span class="title class_">Array</span>.<span class="property">isArray</span>,</span><br><span class="line">    nativeKeys = <span class="title class_">Object</span>.<span class="property">keys</span>,</span><br><span class="line">    nativeCreate = <span class="title class_">Object</span>.<span class="property">create</span>;</span><br></pre></td></tr></table></figure>

<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>这里的用处差不多，我就放到一块了，之前我提到过作用域链，而JS是没有类这一说的，其实是通过对象，对象的原型这样一层一层建立起对象的引用关系从而拿到活动对象上的值。</p>
<p>我们看几个原型变量的声明，其实就是简化原型链的查找过程，还是举个例子：</p>
<pre><code>var arr = [];
arr.push(&#39;a&#39;);
</code></pre>
<p>声明arr变量为一个空数组，添加一个元素’a’，这个push方法是在arr上的吗？并不是，arr变量上找不到push方法，会搜索arr的原型prototype(arr的constructor指向的对象 -&gt; 这里是Array)。<br>通过原型链一层层往上找，最终在Array.prototype上找到了push方法，也就是说程序执行 arr.push(‘a’)时，检索到push方法经历了3次搜索即 <code>arr本身 -&gt; Array对象 -&gt; Array.prototype</code><br>执行效率并不高，所以 var ArrPro &#x3D; Array.prototype 这样的声明就是减少了搜索过程，从而提升了最终的运行速度</p>
<pre><code>var SymbolProto = typeof Symbol !== &#39;undefined&#39; ? Symbol.prototype : null;
</code></pre>
<p>这里顺便提一下，是对ES6新增的基本数据类型Symbol进行兼容处理</p>
<p>我们接着读</p>
<pre><code>var Ctor = function()&#123;&#125;;    
</code></pre>
<p>这里声明了<code>Ctor</code>对象 为一个匿名函数，用于代理原型交换</p>
<h3 id="安全引用"><a href="#安全引用" class="headerlink" title="安全引用"></a>安全引用</h3><p>这里为 <code>_</code> 创建一个安全的引用，这里 <code>_</code> 是作为一个方法存在，我们结合后面的例子再来说这块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> _) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="variable language_">this</span> <span class="keyword">instanceof</span> _)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">_</span>(obj);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_wrapped</span> = obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">exports</span> != <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; !<span class="built_in">exports</span>.<span class="property">nodeType</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">module</span> != <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; !<span class="variable language_">module</span>.<span class="property">nodeType</span> &amp;&amp; <span class="variable language_">module</span>.<span class="property">exports</span>) &#123;</span><br><span class="line">    <span class="built_in">exports</span> = <span class="variable language_">module</span>.<span class="property">exports</span> = _;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exports</span>.<span class="property">_</span> = _;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  root.<span class="property">_</span> = _;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用于支持Node.js，若在浏览器中就让<code>_</code>成为全局对象<br>xxx &amp;&amp; xxx 这样的语句其实有断句，首先 typeof exports !&#x3D; ‘undefinded’ 若为false 函数将直接跳过这段语句</p>
<pre><code>_.VERSION = &#39;1.8.3&#39;;
</code></pre>
<p><code>_</code> 的属性， 存储版本号，你看到这里可能很奇怪，之前不是让 <code>var _ = function() &#123; ... &#125;</code>了吗，这并不冲突，因为在JS这门语言中一切皆对象，函数也是对象仅此而已<code>(Function instanceof Object  // true)</code>  <code>_</code> 本身声明为一个匿名函数，但它本身是一个引用类型的数据(对象)，所以继续声明其他属性，或是删除属性也是没有问题的。</p>
<p>68-87行</p>
<h3 id="optimizeCb-与-函数柯里化"><a href="#optimizeCb-与-函数柯里化" class="headerlink" title="optimizeCb 与 函数柯里化"></a>optimizeCb 与 函数柯里化</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> optimizeCb = <span class="keyword">function</span>(<span class="params">func, context, argCount</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (context === <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">return</span> func;</span><br><span class="line">  <span class="keyword">switch</span> (argCount) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> func.<span class="title function_">call</span>(context, value);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// The 2-parameter case has been omitted only because no current consumers</span></span><br><span class="line">    <span class="comment">// made use of it.</span></span><br><span class="line">    <span class="keyword">case</span> <span class="attr">null</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">value, index, collection</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> func.<span class="title function_">call</span>(context, value, index, collection);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">accumulator, value, index, collection</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> func.<span class="title function_">call</span>(context, accumulator, value, index, collection);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> func.<span class="title function_">apply</span>(context, <span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>optimizeCb</code>是<code>_</code>的一个内部函数，该框架内的函数都是以变量的形式来声明，这么做的好处有几点：</p>
<ol>
<li>避免了不必要的函数声明提升，流程控制性更强</li>
<li>更利于实现内存的回收</li>
</ol>
<p>我们先暂时跳过流程控制语句，该函数会返回一个匿名函数（闭包），该匿名函数执行并返回第一个参数func，<code>这个func就是要进行柯里化的函数</code>，此时的func作为 optimizeCb的一个参数，其this指向会上一层寻找，即整个 <code>_</code> 的内部作用域，这显然是不行的，所以func.apply的作用即是将func的作用域绑定到所传的context中，arguments为剩下的argCount</p>
<p>参考 高级程序设计198页</p>
<p><code>optimizeCb</code>若执行，所传参数，都将作为optimizeCb内部的活动对象，函数执行完毕所返回的匿名函数是一个闭包，它能访问到当前活动对象上的参数，即函数传参。</p>
<p>比如在 case 4 里的代码段</p>
<pre><code>...
return function(accumulator, value, index, collection) &#123;
  return func.call(context, accumulator, value, index, collection);
&#125;;
</code></pre>
<p>function(accumulator, value, index, collection) 能访问到上层，传参进行活动对象，执行后返回的func是之前传入，这里调用call方法，以传入的<code>context</code>来替换当前的活动对象，并将 accumulator, value, index, collection 作为参数传递给 当前传入的 <code>context</code> ，这里有点绕，大家最好自己写点代码在浏览器中测试</p>
<h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p>这里顺便理一下这个话题，因为下面会用到，且强行克服一下这个一直没攻破的难关。<br>函数柯里化<code>用于创建</code>已经设置好了一个或多个参数的<code>函数</code>，其基本方法与函数绑定一样：使用闭包返回一个函数。<br>与apply,call,bind等绑定方法的区别在于：返回的函数还需要设置一些传入的参数</p>
<p>柯里化函数通常由以下步骤动态创建：<code>调用另一个函数</code>并为它<code>传入</code>要<code>柯里化的函数</code>和<code>必要参数</code>，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fn 表示要柯里化的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回一个闭包，这个闭包能够访问当前的函数作用域</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="comment">// args包含了来自外部函数的参数</span></span><br><span class="line">  <span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// innerArgs 用于存放所有传入的参数</span></span><br><span class="line">    <span class="keyword">var</span> innerArgs = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="comment">// finalArgs 将内外参数合并到一起</span></span><br><span class="line">    <span class="keyword">var</span> finalArgs = args.<span class="title function_">concat</span>(innerArgs)</span><br><span class="line">    <span class="comment">// 使用apply将结果传递给该函数，这里由于没考虑执行环境所以传了null</span></span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="literal">null</span>, finalArgs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="cb-安全的上下文环境"><a href="#cb-安全的上下文环境" class="headerlink" title="cb 安全的上下文环境"></a>cb 安全的上下文环境</h3><p>这个cb函数用于生成可以应用到集合中的每个元素的回调函数，返回想要的结果或标识<code>（一个任意的回调，一个属性matcher，或者一个属性访问器）</code><br>iteratee和builtinIteratee赋值为一个匿名函数，返回了在这个执行环境中的一个标识<br>要注意的是 <code>Infinity</code>这是一个系统常量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> builtinIteratee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cb = <span class="keyword">function</span>(<span class="params">value, context, argCount</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (_.<span class="property">iteratee</span> !== builtinIteratee) <span class="keyword">return</span> _.<span class="title function_">iteratee</span>(value, context);</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="literal">null</span>) <span class="keyword">return</span> _.<span class="property">identity</span>;</span><br><span class="line">  <span class="keyword">if</span> (_.<span class="title function_">isFunction</span>(value)) <span class="keyword">return</span> <span class="title function_">optimizeCb</span>(value, context, argCount);</span><br><span class="line">  <span class="keyword">if</span> (_.<span class="title function_">isObject</span>(value) &amp;&amp; !_.<span class="title function_">isArray</span>(value)) <span class="keyword">return</span> _.<span class="title function_">matcher</span>(value);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> _.<span class="title function_">property</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.<span class="property">iteratee</span> = builtinIteratee = <span class="keyword">function</span>(<span class="params">value, context</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">cb</span>(value, context, <span class="title class_">Infinity</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>内部作用域是 4个 if语句，若继续执行会 返回 <code>_.property(value)</code>(1408行) 这里还是贴一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="property">property</span> = <span class="keyword">function</span>(<span class="params">path</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!_.<span class="title function_">isArray</span>(path)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">shallowProperty</span>(path);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">deepGet</span>(obj, path);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们来具体分析一下：</p>
<pre><code>if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
</code></pre>
<p>也就是说上一句 <code>_.iterate = builtinIteratee = function(value, context) &#123;...&#125;</code> 未生效就重新赋值一次，</p>
<pre><code>if (value == null) return _.identity;
</code></pre>
<p>没有传value就默认返回最大</p>
<pre><code>if (_.isFunction(value)) return optimizeCb(value, context, argCount);
</code></pre>
<p><code>_</code>自己实现的方法，判断传入对象的引用类型是否为 function 是就用optimizeCb函数柯里化处理所传value</p>
<pre><code>if (_.isObject(value) &amp;&amp; !_.isArray(value)) return _.matcher(value);
</code></pre>
<p>同上，若判断成功则用 matcher方法来处理（1429行）<br>通过这样的判断及调用，可保证我们处理的value值是合法且可控的</p>
<h3 id="restArgs方法"><a href="#restArgs方法" class="headerlink" title="restArgs方法"></a>restArgs方法</h3><p>该方法作用类似于ES6的 function(…args) {…} 展开符，注释上是这么说的：（来自我的渣翻译）<br>这些剩余的参数会进到一个数组，并对应给一个索引，我们还是来看代码吧</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> restArgs = <span class="keyword">function</span>(<span class="params">func, startIndex</span>) &#123;</span><br><span class="line">  startIndex = startIndex == <span class="literal">null</span> ? func.<span class="property">length</span> - <span class="number">1</span> : +startIndex;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> length = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="variable language_">arguments</span>.<span class="property">length</span> - startIndex, <span class="number">0</span>),</span><br><span class="line">        rest = <span class="title class_">Array</span>(length),</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; index &lt; length; index++) &#123;</span><br><span class="line">      rest[index] = <span class="variable language_">arguments</span>[index + startIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (startIndex) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> func.<span class="title function_">call</span>(<span class="variable language_">this</span>, rest);</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> func.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>[<span class="number">0</span>], rest);</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> func.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>[<span class="number">0</span>], <span class="variable language_">arguments</span>[<span class="number">1</span>], rest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="title class_">Array</span>(startIndex + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; startIndex; index++) &#123;</span><br><span class="line">      args[index] = <span class="variable language_">arguments</span>[index];</span><br><span class="line">    &#125;</span><br><span class="line">    args[startIndex] = rest;</span><br><span class="line">    <span class="keyword">return</span> func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<pre><code>startIndex = startIndex == null ? func.length - 1 : +startIndex;
</code></pre>
<p><code>startIndex</code>是第二个参数， startIndex &#x3D;&#x3D; null 这一句很有意思，很多框架里都喜欢这么用，我们可能经常听说要用 &#x3D;&#x3D;&#x3D; 少用 &#x3D;&#x3D; 吗，这里有个隐式转换， 这里判断了startIndex变量是否为空对象，毕竟进入函数作用域，startIndex作为参数是定义过的，这个函数会返回一个匿名函数（闭包），其作用是循环传递的func，将其作用域作为参数传递给调用者</p>
<h3 id="baseCreate"><a href="#baseCreate" class="headerlink" title="baseCreate"></a>baseCreate</h3><p>用于创建新对象的内部函数，该对象继承自另一个对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> baseCreate = <span class="keyword">function</span>(<span class="params">prototype</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!_.<span class="title function_">isObject</span>(prototype)) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (nativeCreate) <span class="keyword">return</span> <span class="title function_">nativeCreate</span>(prototype);</span><br><span class="line">  <span class="title class_">Ctor</span>.<span class="property"><span class="keyword">prototype</span></span> = prototype;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="title class_">Ctor</span>;</span><br><span class="line">  <span class="title class_">Ctor</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>_.isObject(prototype)</code> 这是 <code>_</code> 的一个内置方法用于判断传入参数是否为对象，这里加上!就是说，若不是对象则返回一个空对象 {}。<br>nativeCreate之前已声明过，这是ES5原生的创建对象方法，我们把之前匿名函数的原型赋给了传入的prototype，然后把这里的结果赋给一个新对象result并返回出来。<br>这里的 Ctor.prototype &#x3D; null 是精髓，用于内存回收，<code>简单说一下，函数运行会创建自己的活动对象，执行环境，运行结束后会自行销毁，但闭包中的变量和方法将存于内存中得不到回收，具体可读一下高级程序设计</code><br>这样Ctor这个匿名函数我们重复使用且不会造成内存泄漏了。</p>
<h3 id="shallowProperty"><a href="#shallowProperty" class="headerlink" title="shallowProperty"></a>shallowProperty</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shallowProperty = <span class="keyword">function</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj == <span class="literal">null</span> ? <span class="keyword">void</span> <span class="number">0</span> : obj[key];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>意同名，浅属性~ shallowProperty返回了一个匿名函数，该匿名函数根据所传入的key的有无来决定是返回一个空对象还是对象的值</p>
<h3 id="deepGet"><a href="#deepGet" class="headerlink" title="deepGet"></a>deepGet</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> deepGet = <span class="keyword">function</span>(<span class="params">obj, path</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> length = path.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">    obj = obj[path[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> length ? obj : <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>内部辅助方法，这里要说下第二个参数path，比如一个 <code>var arr = [1, [2,3]]</code> 二维数组，要拿到3，只能通过arr[1][1]来完成，再看下上面的代码是不是懂了呢？</p>
<h3 id="isArrayLike"><a href="#isArrayLike" class="headerlink" title="isArrayLike"></a>isArrayLike</h3><p>一个处理类数组的方法，注释上说 —— 根据所传参数<code>collection</code>确定是否应该将一个集合作为数组或对象进行迭代<br>该方法返回一个布尔值，该判断结果用于后续的执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">MAX_ARRAY_INDEX</span> = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> getLength = <span class="title function_">shallowProperty</span>(<span class="string">&#x27;length&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> isArrayLike = <span class="keyword">function</span>(<span class="params">collection</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> length = <span class="title function_">getLength</span>(collection);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> length == <span class="string">&#x27;number&#x27;</span> &amp;&amp; length &gt;= <span class="number">0</span> &amp;&amp; length &lt;= <span class="variable constant_">MAX_ARRAY_INDEX</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Math.pow()方法可返回 x 的 y 次幂的值。这里是一个安全值的处理，防止内存溢出<br>这里的isArrayLike将传入的collection类数组进行这样的处理：<br>通过getLength辅助函数拿到collection的长度，之前的shallowProperty就是用于此处，getLength返回一个闭包，从而拿到 collection.length</p>
<pre><code>return typeof length == &#39;number&#39; &amp;&amp; length &gt;= 0 &amp;&amp; length &lt;= MAX_ARRAY_INDEX;
</code></pre>
<p>根据之前的经验，这里 &amp;&amp; 优先级平级，即 <code>typeof length == &#39;number&#39; &amp;&amp; length &gt;= 0</code> 比较完后的结果 再拿去和 <code>length &lt;= MAX_ARRAY_INDEX</code> 进行逻辑与运算即可</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      <categories>
        <category>代码相关</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>underscore</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习】underscore源码学习（三）——Array方法</title>
    <url>/2017/06/09/64b7b0b0-af92-11ee-9da9-718fb8244e62/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>这一篇到了源码488行，主要是<code>underscore</code>对原生Array.prototype的一些扩展，arguments<code>参数</code>对象将在所有数组函数中工作 。然而, <code>_</code> 函数的设计并不只是针对稀疏（”sparse”）数组的。在下面的阅读学习中，我们会慢慢了解到</p>
</blockquote>
<span id="more"></span>

<h2 id="数组函数-488-747行"><a href="#数组函数-488-747行" class="headerlink" title="数组函数 488 - 747行"></a>数组函数 488 - 747行</h2><h3 id="first"><a href="#first" class="headerlink" title="first"></a>first</h3><p><code>first_.first(array, [n])</code> 返回array（数组）的第一个元素。传递 n参数将返回数组中从第一个元素开始的n个元素（返回数组中前 n 个元素）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get the first element of an array. Passing **n** will return the first N</span></span><br><span class="line"><span class="comment">// values in the array. Aliased as `head` and `take`. The **guard** check</span></span><br><span class="line"><span class="comment">// allows it to work with `_.map`.</span></span><br><span class="line">_.<span class="property">first</span> = _.<span class="property">head</span> = _.<span class="property">take</span> = <span class="keyword">function</span>(<span class="params">array, n, guard</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (array == <span class="literal">null</span> || array.<span class="property">length</span> &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="literal">null</span> || guard) <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> _.<span class="title function_">initial</span>(array, array.<span class="property">length</span> - n);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Returns everything but the last entry of the array. Especially useful on</span></span><br><span class="line"><span class="comment">// the arguments object. Passing **n** will return all the values in</span></span><br><span class="line"><span class="comment">// the array, excluding the last N.</span></span><br><span class="line">_.<span class="property">initial</span> = <span class="keyword">function</span>(<span class="params">array, n, guard</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> slice.<span class="title function_">call</span>(array, <span class="number">0</span>, <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">0</span>, array.<span class="property">length</span> - (n == <span class="literal">null</span> || guard ? <span class="number">1</span> : n)));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>作用域内有三个同名方法，前两个if判断用于安全检测，若参数参数正确，则返回 _.initial(array, array.length - n)的调用结果，于是我们继续来看看这个initial方法</p>
<p>这里是slice在之前声明过，为原生数组的slice方法，参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" target="_blank">MDN - Array.prototype.slice</a><br>知道这个后也很简单了——对传递array的一个副本，返回前n个~</p>
<h3 id="last"><a href="#last" class="headerlink" title="last"></a>last</h3><p><code>_.last(array, n, guard)</code> 返回array（数组）的最后一个元素。传递 n参数将返回数组中从最后一个元素开始的n个元素（愚人码头注：返回数组里的后面的n个元素）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get the last element of an array. Passing **n** will return the last N</span></span><br><span class="line"><span class="comment">// values in the array.</span></span><br><span class="line">_.<span class="property">last</span> = <span class="keyword">function</span>(<span class="params">array, n, guard</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (array == <span class="literal">null</span> || array.<span class="property">length</span> &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="literal">null</span> || guard) <span class="keyword">return</span> array[array.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">return</span> _.<span class="title function_">rest</span>(array, <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">0</span>, array.<span class="property">length</span> - n));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns everything but the first entry of the array. Aliased as `tail` and `drop`.</span></span><br><span class="line"><span class="comment">// Especially useful on the arguments object. Passing an **n** will return</span></span><br><span class="line"><span class="comment">// the rest N values in the array.</span></span><br><span class="line">_.<span class="property">rest</span> = _.<span class="property">tail</span> = _.<span class="property">drop</span> = <span class="keyword">function</span>(<span class="params">array, n, guard</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> slice.<span class="title function_">call</span>(array, n == <span class="literal">null</span> || guard ? <span class="number">1</span> : n);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>last方法也差不多，只不过这里n是slice的第二个参数，也就是说从n开始，到array剩余的元素</p>
<h3 id="compact"><a href="#compact" class="headerlink" title="compact"></a>compact</h3><p><code>compact_.compact(array)</code> 返回一个除去所有false值的 array副本。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Trim out all falsy values from an array.</span></span><br><span class="line">_.<span class="property">compact</span> = <span class="keyword">function</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> _.<span class="title function_">filter</span>(array, <span class="title class_">Boolean</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从传入的数组中过滤掉“错误值”，虽然很短，但很有意思，filter方法我们在之前已经知道了，这里把Boolean作为参数直接传进去，隐式转换为false的值都会被过滤掉，即 null, 0, “”, undefined 和 NaN</p>
<h3 id="flatten"><a href="#flatten" class="headerlink" title="flatten"></a>flatten</h3><p><code>_.flatten(array, shallow)</code><br>将一个嵌套多层的数组 array（数组） (嵌套可以是任何层数)转换为只有一层的数组。 如果你传递 shallow参数，数组将只减少一维的嵌套。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Internal implementation of a recursive `flatten` function.</span></span><br><span class="line"><span class="keyword">var</span> flatten = <span class="keyword">function</span>(<span class="params">input, shallow, strict, output</span>) &#123;</span><br><span class="line">  output = output || [];</span><br><span class="line">  <span class="keyword">var</span> idx = output.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = <span class="title function_">getLength</span>(input); i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = input[i];</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isArrayLike</span>(value) &amp;&amp; (_.<span class="title function_">isArray</span>(value) || _.<span class="title function_">isArguments</span>(value))) &#123;</span><br><span class="line">      <span class="comment">// Flatten current level of array or arguments object.</span></span><br><span class="line">      <span class="keyword">if</span> (shallow) &#123;        </span><br><span class="line">        <span class="keyword">var</span> j = <span class="number">0</span>, len = value.<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; len) output[idx++] = value[j++];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">flatten</span>(value, shallow, strict, output);</span><br><span class="line">        idx = output.<span class="property">length</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strict) &#123;</span><br><span class="line">      output[idx++] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Flatten out an array, either recursively (by default), or just one level.</span></span><br><span class="line">_.<span class="property">flatten</span> = <span class="keyword">function</span>(<span class="params">array, shallow</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">flatten</span>(array, shallow, <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里很有意思，说下我的理解。<code>var flatten = function() &#123;&#125;</code>这里是在作用域里声明了一个私有变量，然后 <code>_.flatten</code>是给 _ 添加属性方法，在函数作用域内，返回的 flatten是在上下文环境中的 var flatten 这个私有变量。</p>
<p>flatten 接受四个参数：</p>
<ul>
<li>input：待展开数组</li>
<li>shallow：是否是浅展开，反之为深度展开</li>
<li>strict：是否为严格模式</li>
<li>output：可以指定输出数组，如果指定了输出数组，则将展开后的数组添加至输出数组尾部</li>
</ul>
<p>对传入数组 input 进行遍历，对于遍历到的元素 value：<br>如果 value 为数组，则需要展开，浅展开很简单，只是展开该元素最外一层数组，深度展开则需要递归调用 flatten。<br>如果 value 不为数组，则只有在非严格模式下该 value 才会被赋值到新的数组中。</p>
<p>如果不是深度展开，只是从value(数组)中不断抽出元素赋值output中，否则进行递归</p>
<h3 id="without"><a href="#without" class="headerlink" title="without"></a>without</h3><p><code>_.without(array, otherArrays)</code> 返回一个删除所有values值后的 array副本</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Return a version of the array that does not contain the specified value(s).</span></span><br><span class="line">_.<span class="property">without</span> = <span class="title function_">restArgs</span>(<span class="keyword">function</span>(<span class="params">array, otherArrays</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> _.<span class="title function_">difference</span>(array, otherArrays);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 这里为了便于观看，我把 _.difference也拿到这里一起说了</span></span><br><span class="line"><span class="comment">// Take the difference between one array and a number of other arrays.</span></span><br><span class="line"><span class="comment">// Only the elements present in just the first array will remain.</span></span><br><span class="line">_.<span class="property">difference</span> = <span class="title function_">restArgs</span>(<span class="keyword">function</span>(<span class="params">array, rest</span>) &#123;</span><br><span class="line">  rest = <span class="title function_">flatten</span>(rest, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span> _.<span class="title function_">filter</span>(array, <span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> !_.<span class="title function_">contains</span>(rest, value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>至于为什么能返回新的array副本，我们来看看这个方法。<br>之前介绍过了restArgs，就相当于es6的 …args 函数里的展开参数。 rest就是我们的 …args 在函数内部赋值给 rest变量。 这里返回的都是封装好的两个方法的调用，所以在直接代码中的封装为后续节省了很多代码量可读性也更高，所以我们在日常开发中，也应该学习。</p>
<p>_.contains 返回包含的参数在之前加上<code>!</code>即转为了 Boolean型，布尔型为true才会通过filter方法，所以该方法是这样拿到最后结果的。</p>
<h3 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h3><p><code>_.uniq(array, isSorted, iteratee, context)</code></p>
<p>返回 array去重后的副本, 使用 &#x3D;&#x3D;&#x3D; 做相等测试. 如果您确定 array 已经排序, 那么给 isSorted 参数传递 true值, 此函数将运行的更快的算法. 如果要处理对象元素, 传递 iteratee函数来获取要对比的属性.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Produce a duplicate-free version of the array. If the array has already</span></span><br><span class="line"><span class="comment">// been sorted, you have the option of using a faster algorithm.</span></span><br><span class="line"><span class="comment">// Aliased as `unique`.</span></span><br><span class="line">_.<span class="property">uniq</span> = _.<span class="property">unique</span> = <span class="keyword">function</span>(<span class="params">array, isSorted, iteratee, context</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!_.<span class="title function_">isBoolean</span>(isSorted)) &#123;</span><br><span class="line">    context = iteratee;</span><br><span class="line">    iteratee = isSorted;</span><br><span class="line">    isSorted = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (iteratee != <span class="literal">null</span>) iteratee = <span class="title function_">cb</span>(iteratee, context);</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">var</span> seen = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = <span class="title function_">getLength</span>(array); i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = array[i],</span><br><span class="line">        computed = iteratee ? <span class="title function_">iteratee</span>(value, i, array) : value;</span><br><span class="line">    <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!i || seen !== computed) result.<span class="title function_">push</span>(value);</span><br><span class="line">      seen = computed;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iteratee) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!_.<span class="title function_">contains</span>(seen, computed)) &#123;</span><br><span class="line">        seen.<span class="title function_">push</span>(computed);</span><br><span class="line">        result.<span class="title function_">push</span>(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!_.<span class="title function_">contains</span>(result, value)) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>条件判断我们先略过，从for循环来看。如果排好序了, 直接通过比较操作!&#x3D;&#x3D; 。<br>如果已经排序, seen 只需要反映最近一次见到的元素；<br>如果尚未排序, 且存在比较函数, 亦即不能直接通过 &#x3D;&#x3D;&#x3D; 判断；<br>否则直接通过 contains 进行判断</p>
<h3 id="union"><a href="#union" class="headerlink" title="union"></a>union</h3><p><code>_.union(arrays)</code> 返回传入的 arrays（数组）并集：按顺序返回，返回数组的元素是唯一的，可以传入一个或多个 arrays（数组）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Produce an array that contains the union: each distinct element from all of</span></span><br><span class="line"><span class="comment">// the passed-in arrays.</span></span><br><span class="line">_.<span class="property">union</span> = <span class="title function_">restArgs</span>(<span class="keyword">function</span>(<span class="params">arrays</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> _.<span class="title function_">uniq</span>(<span class="title function_">flatten</span>(arrays, <span class="literal">true</span>, <span class="literal">true</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="intersection"><a href="#intersection" class="headerlink" title="intersection"></a>intersection</h3><p><code>_.intersection(arrays)</code> 返回传入 arrays（数组）交集。结果中的每个值是存在于传入的每个arrays（数组）里。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Produce an array that contains every item shared between all the</span></span><br><span class="line"><span class="comment">// passed-in arrays.</span></span><br><span class="line">_.<span class="property">intersection</span> = <span class="keyword">function</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">var</span> argsLength = <span class="variable language_">arguments</span>.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = <span class="title function_">getLength</span>(array); i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = array[i];</span><br><span class="line">    <span class="keyword">if</span> (_.<span class="title function_">contains</span>(result, item)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">var</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argsLength; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!_.<span class="title function_">contains</span>(<span class="variable language_">arguments</span>[j], item)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j === argsLength) result.<span class="title function_">push</span>(item);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>数组交集的求取思路为：遍历第一个数组的每个元素，在之后的所有数组中找寻是否有该元素，有则放入结果数组。</p>
<h3 id="difference"><a href="#difference" class="headerlink" title="difference"></a>difference</h3><p><code>_.difference(...array)</code> 求取数组差集</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Take the difference between one array and a number of other arrays.</span></span><br><span class="line"><span class="comment">// Only the elements present in just the first array will remain.</span></span><br><span class="line">_.<span class="property">difference</span> = <span class="title function_">restArgs</span>(<span class="keyword">function</span>(<span class="params">array, rest</span>) &#123;</span><br><span class="line">  rest = <span class="title function_">flatten</span>(rest, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span> _.<span class="title function_">filter</span>(array, <span class="keyword">function</span>(<span class="params">value</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> !_.<span class="title function_">contains</span>(rest, value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>数组差集的求取思路为：令剩余的数组为 rest，flatten方法在之前有提到过，相当于ES6里的…args。然后用filter方法对array进行处理， <code>_.contains</code>返回的是布尔值，再取反，也就是最终返回array中存在的，而 rest 中不存在的值。</p>
<h3 id="unzip-和-zip"><a href="#unzip-和-zip" class="headerlink" title="unzip 和 zip"></a>unzip 和 zip</h3><p><code>uniq_.uniq(array)</code> 数组解压就是将多个数组的对应位置的元素抽离出来，组成新的数组：</p>
<pre><code>[[&#39;moe&#39;, 18, &#39;male&#39;], [&#39;larry&#39;, 23, &#39;female&#39;], [&#39;curly&#39;, 30, &#39;male&#39;]]
</code></pre>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Complement of _.zip. Unzip accepts an array of arrays and groups</span></span><br><span class="line"><span class="comment">// each array&#x27;s elements on shared indices.</span></span><br><span class="line">_.<span class="property">unzip</span> = <span class="keyword">function</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> length = array &amp;&amp; _.<span class="title function_">max</span>(array, getLength).<span class="property">length</span> || <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="title class_">Array</span>(length);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">    result[index] = _.<span class="title function_">pluck</span>(array, index);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>length为array.length，在其中做了安全校验，我们暂时省略。之后又声明了变量result，这是原生数组其长度为length。接下来进行循环，重组result，至于这个_.pluck怎么实现的我们放到后面来说… （还没看到那，说早了怕后面又忘了）</p>
<p>于是加上例子，更好地说明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">&#x27;fri&#x27;</span>, <span class="string">&#x27;yk&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> ages = [<span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>];</span><br><span class="line"><span class="keyword">var</span> hobby = [<span class="string">&#x27;LOL&#x27;</span>, <span class="string">&#x27;Dota2&#x27;</span>, [<span class="string">&#x27;毒奶粉&#x27;</span>, <span class="string">&#x27;亡者荣耀&#x27;</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> students = _.<span class="title function_">unzip</span>([names, ages, hobby]);</span><br><span class="line"><span class="comment">// =&gt; students: [[&#x27;fri&#x27;, 22, &#x27;LOL&#x27;], [&#x27;yk&#x27;, 23, &#x27;dota2&#x27;], [&#x27;wb&#x27;, 24, [&#x27;毒奶粉&#x27;, &#x27;亡者荣耀&#x27;]]]</span></span><br></pre></td></tr></table></figure>

<p>_.zip(array)：压缩 array ~ 同字面意思</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Zip together multiple lists into a single array -- elements that share</span></span><br><span class="line"><span class="comment">// an index go together.</span></span><br><span class="line">_.<span class="property">zip</span> = <span class="title function_">restArgs</span>(_.<span class="property">unzip</span>);</span><br></pre></td></tr></table></figure>

<p>就是上面 unzip方法的逆过程</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一章的学习主要是操作Array的相关函数。可发现，其实最主要都是第一章里介绍的主要方法，很多都是方法的封装与实现，可见我们有一个好的封装是多么重要。</p>
]]></content>
      <categories>
        <category>代码相关</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>underscore</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习】underscore源码学习（二）——集合函数</title>
    <url>/2017/06/05/4fca2d40-af92-11ee-a728-89de40cfaa78/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>这一篇到了源码170行以后，主要是<code>underscore(下文用下划线代替- -)</code>向外暴露的一些核心API， <code>_</code> 扩展了很多原生JS拥有的方法，有很多优秀地设计思想值得我们学习和探究。我们在用的过程中，了解到底层的实现更有利于我们将来的选择及性能优化</p>
</blockquote>
<span id="more"></span>

<h2 id="集合函数-170-486行"><a href="#集合函数-170-486行" class="headerlink" title="集合函数 170 - 486行"></a>集合函数 170 - 486行</h2><h3 id="each"><a href="#each" class="headerlink" title="each"></a>each</h3><p>_.each(obj, iteratee, [context]) </p>
<p><code>_</code> 的each方法遍历所传obj（这里可看作一个列表，数组或类数组）中的所有元素，按顺序用遍历输出每个元素。如果传递了context参数，则把iteratee绑定到context对象上。每次调用iteratee都会传递三个参数：(element, index, list)。如果list是个JavaScript对象，iteratee的参数是 (value, key, list))。返回list以方便链式调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="property">each</span> = _.<span class="property">forEach</span> = <span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) &#123;</span><br><span class="line">  iteratee = <span class="title function_">optimizeCb</span>(iteratee, context);</span><br><span class="line">  <span class="keyword">var</span> i, length;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isArrayLike</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, length = obj.<span class="property">length</span>; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="title function_">iteratee</span>(obj[i], i, obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> keys = _.<span class="title function_">keys</span>(obj);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, length = keys.<span class="property">length</span>; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="title function_">iteratee</span>(obj[keys[i]], keys[i], obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="title function_">each</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function"><span class="params">i</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i));  </span><br><span class="line">=&gt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  注，返回的是每个迭代对象自身</span><br><span class="line">_.<span class="title function_">each</span>(&#123;<span class="attr">a</span>: <span class="string">&#x27;1&#x27;</span>, <span class="attr">b</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="attr">c</span>:&#123;<span class="attr">name</span>: <span class="string">&#x27;fri&#x27;</span>&#125;&#125;, <span class="function"><span class="params">item</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(item))</span><br><span class="line">=&gt; <span class="number">1</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], &#123;<span class="attr">name</span>: <span class="string">&#x27;fri&#x27;</span>&#125;  注：返回的是迭代对象的每一项，拿到的是value值</span><br></pre></td></tr></table></figure>

<p><code>iteratee = optimizeCb(iteratee, context)形成一个递归调用</code>，if分支用于控制是迭代数组还是对象，最后返回的是迭代的自身。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>_.map(obj, iteratee, [context]) </p>
<p>通过转换函数(iteratee迭代器)映射列表中的每个值产生价值的新数组。该方法接收三个参数，循环对象，迭代器和环境参数。后两个参数作为活动对象传到了cb方法中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="property">map</span> = _.<span class="property">collect</span> = <span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) &#123;</span><br><span class="line">  iteratee = <span class="title function_">cb</span>(iteratee, context);</span><br><span class="line">  <span class="keyword">var</span> keys = !<span class="title function_">isArrayLike</span>(obj) &amp;&amp; _.<span class="title function_">keys</span>(obj),</span><br><span class="line">      length = (keys || obj).<span class="property">length</span>,</span><br><span class="line">      results = <span class="title class_">Array</span>(length);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentKey = keys ? keys[index] : index;</span><br><span class="line">    results[index] = <span class="title function_">iteratee</span>(obj[currentKey], currentKey, obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="title function_">map</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="function"><span class="params">num</span> =&gt;</span> num * <span class="number">2</span>);</span><br><span class="line">=&gt; [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>] 注：返回的是results这是一个数组</span><br><span class="line"></span><br><span class="line">_.<span class="title function_">map</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;fri&#x27;</span>, <span class="attr">age</span>: <span class="number">24</span>&#125;, <span class="function">(<span class="params">k, v</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;k&#125;</span>: <span class="subst">$&#123;v&#125;</span>`</span>);</span><br><span class="line">=&gt; [<span class="string">&quot;fri: name&quot;</span>, <span class="string">&quot;24: age&quot;</span>] map一个对象，返回的是由key,val组成的数组</span><br></pre></td></tr></table></figure>

<ul>
<li>keys, length, results这三个变量的声明很精髓，(后面也有很多地方用到) !有隐式转换变为布尔型，所以keys &#x3D; <code>布尔</code> &amp;&amp; _.keys(obj) 因为逻辑与，表达式成立的条件是，前面部分会为真，即这句直接拿到了 _.key(obj)。</li>
<li>数组中才有length这一属性，普通对象中是没有定义的</li>
<li>Array(length)会创建一个长度为length的数组这么再来看循环体中的results[index]就清楚多了</li>
</ul>
<h3 id="reduce-reduceRight"><a href="#reduce-reduceRight" class="headerlink" title="reduce reduceRight"></a>reduce reduceRight</h3><p>_.reduce(list, iteratee, [memo], [context])<br>_.reduceRight(list, iteratee, memo, [context])</p>
<p>reduce方法把list中元素归结为一个单独的数值。<br>Memo是reduce函数的初始值，reduce的每一步都需要由iteratee返回。这个迭代传递4个参数：memo,value 和 迭代的index（或者 key）和最后一个引用的整个 list。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> createReduce = <span class="keyword">function</span>(<span class="params">dir</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> reducer = <span class="keyword">function</span>(<span class="params">obj, iteratee, memo, initial</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> keys = !<span class="title function_">isArrayLike</span>(obj) &amp;&amp; _.<span class="title function_">keys</span>(obj),</span><br><span class="line">        length = (keys || obj).<span class="property">length</span>,</span><br><span class="line">        index = dir &gt; <span class="number">0</span> ? <span class="number">0</span> : length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!initial) &#123;</span><br><span class="line">      memo = obj[keys ? keys[index] : index];</span><br><span class="line">      index += dir;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; index &gt;= <span class="number">0</span> &amp;&amp; index &lt; length; index += dir) &#123;</span><br><span class="line">      <span class="keyword">var</span> currentKey = keys ? keys[index] : index;</span><br><span class="line">      memo = <span class="title function_">iteratee</span>(memo, obj[currentKey], currentKey, obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">obj, iteratee, memo, context</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> initial = <span class="variable language_">arguments</span>.<span class="property">length</span> &gt;= <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reducer</span>(obj, <span class="title function_">optimizeCb</span>(iteratee, context, <span class="number">4</span>), memo, initial);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_.<span class="property">reduce</span> = _.<span class="property">foldl</span> = _.<span class="property">inject</span> = <span class="title function_">createReduce</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">_.<span class="property">reduceRight</span> = _.<span class="property">foldr</span> = <span class="title function_">createReduce</span>(-<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="title function_">reduce</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="function">(<span class="params">memo, num</span>) =&gt;</span> memo + num)</span><br><span class="line">=&gt; <span class="number">6</span>  这里只传了memo和num, 因为传入的是数组initial默认为<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>如果没有memo传递给reduce的初始调用，iteratee不会被列表中的第一个元素调用。第一个元素将取代 传递给列表中下一个元素调用iteratee的memo参数。</p>
<p>最外层的匿名函数中的dir传到了 <code>index = dir &gt; 0 ? 0 : length - 1 </code> 由dir来判断是reduce还是reduceRight，这里高度抽象的思想值得我们学习</p>
<p>createReduce是 <code>_</code> 作用域中的私有变量，外部访问不到，这里 _.reduce 是向外暴露的接口，我们调用的api 其实是调用craeteReduce()所返回的函数</p>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>_.find(obj, predicate, [context]) </p>
<p>keyFinder的结果由传入obj是数组(下标)还是对象(key)决定，这里的key是一个递归调用。在obj中逐项查找，返回第一个通过predicate迭代函数真值检测的元素值，如果没有值传递给测试迭代器将返回undefined。 如果找到匹配的元素，函数将立即返回，不会遍历整个list。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="property">find</span> = _.<span class="property">detect</span> = <span class="keyword">function</span>(<span class="params">obj, predicate, context</span>) &#123;</span><br><span class="line">  <span class="comment">// _.findIndex() 652行</span></span><br><span class="line">  <span class="comment">// _.findKey() 1093行</span></span><br><span class="line">  <span class="keyword">var</span> keyFinder = <span class="title function_">isArrayLike</span>(obj) ? _.<span class="property">findIndex</span> : _.<span class="property">findKey</span>;</span><br><span class="line">  <span class="keyword">var</span> key = <span class="title function_">keyFinder</span>(obj, predicate, context);</span><br><span class="line">  <span class="keyword">if</span> (key !== <span class="keyword">void</span> <span class="number">0</span> &amp;&amp; key !== -<span class="number">1</span>) <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="title function_">find</span>([<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], <span class="function"><span class="params">num</span> =&gt;</span> num % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">=&gt; <span class="number">5</span>， 找到<span class="number">5</span>就不会继续找<span class="number">7</span>了</span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>_.filter(obj, predicate, [context]) </p>
<p>遍历所传obj中的每个值，返回包含所有通过predicate真值检测的元素值。（如果存在原生filter方法，则用原生的filter方法。）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="property">filter</span> = _.<span class="property">select</span> = <span class="keyword">function</span>(<span class="params">obj, predicate, context</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> results = [];</span><br><span class="line">  predicate = <span class="title function_">cb</span>(predicate, context);</span><br><span class="line">  _.<span class="title function_">each</span>(obj, <span class="keyword">function</span>(<span class="params">value, index, list</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">predicate</span>(value, index, list)) results.<span class="title function_">push</span>(value);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_.<span class="property">reject</span> = <span class="keyword">function</span>(<span class="params">obj, predicate, context</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> _.<span class="title function_">filter</span>(obj, _.<span class="title function_">negate</span>(<span class="title function_">cb</span>(predicate)), context);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="title function_">filter</span>([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>], <span class="function"><span class="params">num</span> =&gt;</span> num % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line">=&gt; [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>] <span class="number">3</span>被过滤掉</span><br><span class="line">_.<span class="title function_">filter</span>([&#123;<span class="attr">name</span>:<span class="string">&#x27;fri&#x27;</span>&#125;,&#123;<span class="attr">name</span>: <span class="string">&#x27;yk&#x27;</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">&#x27;hhh&#x27;</span>&#125;], <span class="function"><span class="params">item</span> =&gt;</span> item[<span class="string">&#x27;name&#x27;</span>] == <span class="string">&#x27;fri&#x27;</span>)</span><br><span class="line">=&gt; [&#123;<span class="attr">name</span>: <span class="string">&#x27;fri&#x27;</span>&#125;]</span><br></pre></td></tr></table></figure>

<p>这里额外说两句，其实暴露的API写法大同小异，主要是理解核心方法中的 <code>cb</code> <code>optimizeCb</code> 知道 <code>_</code> 是怎么通过高阶函数传参，拿到传入对象（函数）的作用域 <code>func.apply(context, arguments);</code></p>
<h3 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h3><p>_.reject(list, predicate, [context]) 返回list中没有通过predicate真值检测的元素集合，与filter相反</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="property">reject</span> = <span class="keyword">function</span>(<span class="params">obj, predicate, context</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> _.<span class="title function_">filter</span>(obj, _.<span class="title function_">negate</span>(<span class="title function_">cb</span>(predicate)), context);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对_.filter的一个封装， <code>_.negate(916行)</code>可见到，返回的是结果为false的集合</p>
<h3 id="every"><a href="#every" class="headerlink" title="every"></a>every</h3><p>_.every(obj, [predicate], [context])  如果list中的所有元素都通过predicate的真值检测就返回true。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="property">every</span> = _.<span class="property">all</span> = <span class="keyword">function</span>(<span class="params">obj, predicate, context</span>) &#123;</span><br><span class="line">  predicate = <span class="title function_">cb</span>(predicate, context);</span><br><span class="line">  <span class="keyword">var</span> keys = !<span class="title function_">isArrayLike</span>(obj) &amp;&amp; _.<span class="title function_">keys</span>(obj),</span><br><span class="line">      length = (keys || obj).<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentKey = keys ? keys[index] : index;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">predicate</span>(obj[currentKey], currentKey, obj)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="title function_">every</span>([<span class="literal">false</span>, <span class="number">0</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="title class_">NaN</span>, <span class="number">1</span>], <span class="function"><span class="params">item</span> =&gt;</span> item != <span class="literal">true</span>) </span><br><span class="line">=&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure>


<h3 id="some"><a href="#some" class="headerlink" title="some"></a>some</h3><p>_.some(obj, [predicate], [context])  如果obj中有任何一个元素通过 predicate 的真值检测就返回true。一旦找到了符合条件的元素, 就直接中断对obj的遍历. </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="property">some</span> = _.<span class="property">any</span> = <span class="keyword">function</span>(<span class="params">obj, predicate, context</span>) &#123;</span><br><span class="line">  predicate = <span class="title function_">cb</span>(predicate, context);</span><br><span class="line">  <span class="keyword">var</span> keys = !<span class="title function_">isArrayLike</span>(obj) &amp;&amp; _.<span class="title function_">keys</span>(obj),</span><br><span class="line">      length = (keys || obj).<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentKey = keys ? keys[index] : index;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">predicate</span>(obj[currentKey], currentKey, obj)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="title function_">some</span>([<span class="literal">false</span>, <span class="number">0</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="title class_">NaN</span>, <span class="number">1</span>], <span class="function"><span class="params">item</span> =&gt;</span> item == <span class="literal">true</span>) </span><br><span class="line">=&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h3><p>_.contains(obj, value, [fromIndex])  如果obj包含指定的value则返回true。如果obj 是数组，内部使用indexOf判断。使用fromIndex来给定开始检索的索引位置。这个方法ES6已有实现 参考<code>Array.prototype.includes</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="property">contains</span> = _.<span class="property">includes</span> = _.<span class="property">include</span> = <span class="keyword">function</span>(<span class="params">obj, item, fromIndex, guard</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isArrayLike</span>(obj)) obj = _.<span class="title function_">values</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fromIndex != <span class="string">&#x27;number&#x27;</span> || guard) fromIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> _.<span class="title function_">indexOf</span>(obj, item, fromIndex) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="title function_">contains</span>([a,b,c], <span class="number">3</span>)</span><br><span class="line">=&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="invoke"><a href="#invoke" class="headerlink" title="invoke"></a>invoke</h3><p>_.invoke(list, methodName, *arguments) 在list的每个元素上执行methodName方法。 任何传递给invoke的额外参数，invoke都会在调用methodName方法的时候传递给它</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="property">invoke</span> = <span class="title function_">restArgs</span>(<span class="keyword">function</span>(<span class="params">obj, path, args</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> contextPath, func;</span><br><span class="line">  <span class="keyword">if</span> (_.<span class="title function_">isFunction</span>(path)) &#123;</span><br><span class="line">    func = path;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_.<span class="title function_">isArray</span>(path)) &#123;</span><br><span class="line">    contextPath = path.<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    path = path[path.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _.<span class="title function_">map</span>(obj, <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> method = func;</span><br><span class="line">    <span class="keyword">if</span> (!method) &#123;</span><br><span class="line">      <span class="keyword">if</span> (contextPath &amp;&amp; contextPath.<span class="property">length</span>) &#123;</span><br><span class="line">        context = <span class="title function_">deepGet</span>(context, contextPath);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (context == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">      method = context[path];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> method == <span class="literal">null</span> ? method : method.<span class="title function_">apply</span>(context, args);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="title function_">invoke</span>([[<span class="number">5</span>, <span class="number">1</span>, <span class="number">7</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]], <span class="string">&#x27;sort&#x27;</span>);</span><br><span class="line">=&gt; [[<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br></pre></td></tr></table></figure>

<h3 id="pluck"><a href="#pluck" class="headerlink" title="pluck"></a>pluck</h3><p>_.pluck(list, propertyName)  萃取数组对象中某属性值，返回一个数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="property">pluck</span> = <span class="keyword">function</span>(<span class="params">obj, key</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> _.<span class="title function_">map</span>(obj, _.<span class="title function_">property</span>(key));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stooges = [&#123;<span class="attr">name</span>: <span class="string">&#x27;moe&#x27;</span>, <span class="attr">age</span>: <span class="number">40</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">&#x27;larry&#x27;</span>, <span class="attr">age</span>: <span class="number">50</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">&#x27;curly&#x27;</span>, <span class="attr">age</span>: <span class="number">60</span>&#125;];</span><br><span class="line">_.<span class="title function_">pluck</span>(stooges, <span class="string">&#x27;name&#x27;</span>);</span><br><span class="line">=&gt; [<span class="string">&quot;moe&quot;</span>, <span class="string">&quot;larry&quot;</span>, <span class="string">&quot;curly&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>这是对 _.map用法的一个封装</p>
<h3 id="where、findWhere"><a href="#where、findWhere" class="headerlink" title="where、findWhere"></a>where、findWhere</h3><p>_.where(obj, attrs) 遍历obj中的每一个值，返回一个数组，这个数组包含attrs所列出的属性的所有的 键 - 值对。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="property">where</span> = <span class="keyword">function</span>(<span class="params">obj, attrs</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> _.<span class="title function_">filter</span>(obj, _.<span class="title function_">matcher</span>(attrs));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>_.findWhere(obj, attrs) 遍历整个obj，返回匹配 properties参数所列出的所有 键 - 值 对的第一个值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="property">findWhere</span> = <span class="keyword">function</span>(<span class="params">obj, attrs</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> _.<span class="title function_">find</span>(obj, _.<span class="title function_">matcher</span>(attrs));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="max-和-min"><a href="#max-和-min" class="headerlink" title="max 和 min"></a>max 和 min</h3><p>_.max(obj, [iteratee], [context]) 返回list中的最大值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> _.<span class="property">max</span> = <span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = -<span class="title class_">Infinity</span>, </span><br><span class="line">    lastComputed = -<span class="title class_">Infinity</span>,</span><br><span class="line">    value, </span><br><span class="line">    computed;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (iteratee == <span class="literal">null</span> || (<span class="keyword">typeof</span> iteratee == <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> obj[<span class="number">0</span>] != <span class="string">&#x27;object&#x27;</span>) &amp;&amp; obj != <span class="literal">null</span>) &#123;</span><br><span class="line">    obj = <span class="title function_">isArrayLike</span>(obj) ? obj : _.<span class="title function_">values</span>(obj);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = obj.<span class="property">length</span>; i &lt; length; i++) &#123;</span><br><span class="line">      value = obj[i];</span><br><span class="line">      <span class="keyword">if</span> (value != <span class="literal">null</span> &amp;&amp; value &gt; result) &#123;</span><br><span class="line">        result = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    iteratee = <span class="title function_">cb</span>(iteratee, context);</span><br><span class="line">    _.<span class="title function_">each</span>(obj, <span class="keyword">function</span>(<span class="params">v, index, list</span>) &#123;</span><br><span class="line">      computed = <span class="title function_">iteratee</span>(v, index, list);</span><br><span class="line">      <span class="keyword">if</span> (computed &gt; lastComputed || computed === -<span class="title class_">Infinity</span> &amp;&amp; result === -<span class="title class_">Infinity</span>) &#123;</span><br><span class="line">        result = v;</span><br><span class="line">        lastComputed = computed;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里是实现看起来挺复杂，不要畏惧，一行一行来。 第一段if做了安全检测，防止内存溢出，虽然一般人用不会乱传数字，但xx就不一定了是吧。 让我们继续来断句</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  iteratee == <span class="literal">null</span> || (<span class="keyword">typeof</span> iteratee == <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> obj[<span class="number">0</span>] != <span class="string">&#x27;object&#x27;</span>) </span><br><span class="line">    &amp;&amp; obj != <span class="literal">null</span></span><br><span class="line">) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过条件为 第2行 的 逻辑或 || 成立<br>1  iteratee &#x3D;&#x3D; null<br>2  typeof iteratee &#x3D;&#x3D; ‘number’ &amp;&amp; typeof obj[0] !&#x3D; ‘object’<br>两句任其一为真即可，1.8.3与1.8.2中唯一的变化就是对obj类型检测提炼了，让其能对对象或数组都能安全迭代，最后返回的 result 即为安全的value值</p>
<p>那么当安全检测未通过时，<code>_</code>是这么来处理的，<code>iteratee = cb(iteratee, context)</code> 让其提供安全的作用域，然后对传入的obj进行迭代（_.each） computed拿到了迭代对象的作用域，进行自处理，把拿到的值进行安全处理（赋值）</p>
<p>继续断句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  (computed &gt; lastComputed) || </span><br><span class="line">  (computed === -<span class="title class_">Infinity</span> &amp;&amp; result === -<span class="title class_">Infinity</span>)</span><br><span class="line">) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样看就容易多了，-Infinity限制了所传或最终得到的结果会在js允许的安全范围内</p>
<p>_.min(obj, [iteratee], [context]) 返回list中的最小值。如果传递iteratee参数，iteratee将作为list中每个值的排序依据，如果list为空，将返回-Infinity，所以你可能需要事先用isEmpty检查 list 。</p>
<p>这里和 _.max 差不多就不做过多解释了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="property">min</span> = <span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="title class_">Infinity</span>, lastComputed = <span class="title class_">Infinity</span>,</span><br><span class="line">      value, computed;</span><br><span class="line">  <span class="keyword">if</span> (iteratee == <span class="literal">null</span> || (<span class="keyword">typeof</span> iteratee == <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> obj[<span class="number">0</span>] != <span class="string">&#x27;object&#x27;</span>) &amp;&amp; obj != <span class="literal">null</span>) &#123;</span><br><span class="line">    obj = <span class="title function_">isArrayLike</span>(obj) ? obj : _.<span class="title function_">values</span>(obj);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = obj.<span class="property">length</span>; i &lt; length; i++) &#123;</span><br><span class="line">      value = obj[i];</span><br><span class="line">      <span class="keyword">if</span> (value != <span class="literal">null</span> &amp;&amp; value &lt; result) &#123;</span><br><span class="line">        result = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    iteratee = <span class="title function_">cb</span>(iteratee, context);</span><br><span class="line">    _.<span class="title function_">each</span>(obj, <span class="keyword">function</span>(<span class="params">v, index, list</span>) &#123;</span><br><span class="line">      computed = <span class="title function_">iteratee</span>(v, index, list);</span><br><span class="line">      <span class="keyword">if</span> (computed &lt; lastComputed || computed === <span class="title class_">Infinity</span> &amp;&amp; result === <span class="title class_">Infinity</span>) &#123;</span><br><span class="line">        result = v;</span><br><span class="line">        lastComputed = computed;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="sample-和-shuffle"><a href="#sample-和-shuffle" class="headerlink" title="sample 和 shuffle"></a>sample 和 shuffle</h3><p>_.sample(obj, [n], [guard]) 从 obj中产生一个随机样本。传递一个数字表示从obj中返回n个随机元素。否则将返回一个单一的随机项</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="property">sample</span> = <span class="keyword">function</span>(<span class="params">obj, n, guard</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="literal">null</span> || guard) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">isArrayLike</span>(obj)) obj = _.<span class="title function_">values</span>(obj);</span><br><span class="line">    <span class="keyword">return</span> obj[_.<span class="title function_">random</span>(obj.<span class="property">length</span> - <span class="number">1</span>)];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> sample = <span class="title function_">isArrayLike</span>(obj) ? _.<span class="title function_">clone</span>(obj) : _.<span class="title function_">values</span>(obj);</span><br><span class="line">  <span class="keyword">var</span> length = <span class="title function_">getLength</span>(sample);</span><br><span class="line">  n = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="title class_">Math</span>.<span class="title function_">min</span>(n, length), <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">var</span> last = length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; n; index++) &#123;</span><br><span class="line">    <span class="keyword">var</span> rand = _.<span class="title function_">random</span>(index, last);</span><br><span class="line">    <span class="keyword">var</span> temp = sample[index];</span><br><span class="line">    sample[index] = sample[rand];</span><br><span class="line">    sample[rand] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sample.<span class="title function_">slice</span>(<span class="number">0</span>, n);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们先看if段，当n或guard未传时返回所传时，返回obj中的一个随机项。<br>若传了n和guard时，用<code>私有变量sample</code>存储了对obj的处理——数组浅拷贝，对象就创建一个副本。然后遍历sample将其内容打乱并返回。</p>
<p>_.shuffle(obj) 返回一个随机乱序的 list 副本</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="property">shuffle</span> = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> _.<span class="title function_">sample</span>(obj, <span class="title class_">Infinity</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上懂了sample方法这里就很简单了，shuffle方法即是对sample的一种应用，传入obj，n取无限大（即obj.length）这样返回的是打乱后的obj</p>
<h3 id="sortBy"><a href="#sortBy" class="headerlink" title="sortBy"></a>sortBy</h3><p>_.sortBy(obj, iteratee, [context]) 返回一个排序后的list拷贝副本。如果传递iteratee参数，iteratee将作为list中每个值的排序依据。迭代器也可以是字符串的属性的名称进行排序的(比如 length)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="property">sortBy</span> = <span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">  iteratee = <span class="title function_">cb</span>(iteratee, context);</span><br><span class="line">  <span class="keyword">return</span> _.<span class="title function_">pluck</span>(_.<span class="title function_">map</span>(obj, <span class="keyword">function</span>(<span class="params">value, key, list</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">value</span>: value,</span><br><span class="line">      <span class="attr">index</span>: index++,</span><br><span class="line">      <span class="attr">criteria</span>: <span class="title function_">iteratee</span>(value, key, list)</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;).<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = left.<span class="property">criteria</span>;</span><br><span class="line">    <span class="keyword">var</span> b = right.<span class="property">criteria</span>;</span><br><span class="line">    <span class="keyword">if</span> (a !== b) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a &gt; b || a === <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (a &lt; b || b === <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left.<span class="property">index</span> - right.<span class="property">index</span>;</span><br><span class="line">  &#125;), <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们直接看return就好， _.pluck()返回由obj的某些值所组成的’数组’(当然，1.8.3扩展后也可以是对象)，然后再对这个’数组’进行原生的sort()排序，并将结果返回</p>
<h3 id="group"><a href="#group" class="headerlink" title="group"></a>group</h3><p>这是用于聚合group by操作的内部函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> group = <span class="keyword">function</span>(<span class="params">behavior, partition</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = partition ? [[], []] : &#123;&#125;;</span><br><span class="line">    iteratee = <span class="title function_">cb</span>(iteratee, context);</span><br><span class="line">    _.<span class="title function_">each</span>(obj, <span class="keyword">function</span>(<span class="params">value, index</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> key = <span class="title function_">iteratee</span>(value, index, obj);</span><br><span class="line">      <span class="title function_">behavior</span>(result, value, key);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所传的behavior其实是一个回调函数，只是这里表现得很语义化，我们读源码要根据上下文来看，不然很容易迷糊。这里的group是一个高阶函数，对内层进行了封装，group执行后返回一个闭包，该闭包执行后返回处理结果。<br>在闭包用变量<code>result</code>对partition进行兼容处理，若数组则[[], []]分隔开，对象的话默认处理为空对象，iteratee我们见得很多了，即返回一个安全的执行环境。然后迭代所传对闭包所传的参数obj，内部有声明一个变量key用于返回新的执行环境<br>这里有点绕，允许我啰嗦一下（以后水平上来了会精简，这里我尽量用自己的话说清楚）iteratee()后返回的执行环境在 group执行返回的闭包中，这个闭包里进行的迭代由于绑定了obj，就由group的调用 _ 这个环境跳到了 所要迭代的对象 obj 中了~ 然后此时的回调 behavior再来对result进行处理</p>
<p>有点把自己绕进去了，我们先来看看实际运用，就知道为什么要进行这个封装了</p>
<p><strong>groupBy</strong> _.groupBy(result, value, key) 把一个集合分组为多个集合，通过 value 返回的结果进行分组. 如果 value 是一个字符串而不是函数, 那么将使用 value 作为各元素的属性名来对比进行分组.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="property">groupBy</span> = <span class="title function_">group</span>(<span class="keyword">function</span>(<span class="params">result, value, key</span>) &#123;</span><br><span class="line">  <span class="comment">// _.has()方法在1369行  用于对象是否包含给定的键</span></span><br><span class="line">  <span class="keyword">if</span> (_.<span class="title function_">has</span>(result, key)) result[key].<span class="title function_">push</span>(value); </span><br><span class="line">  <span class="keyword">else</span> result[key] = [value];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>indexBy</strong> </p>
<p>_.indexBy(result, value, key) 给定一个集合(对象)，和 一个用来返回一个在列表中的每个元素键 的iterator 函数（或属性名）， 返回一个每一项索引的对象。和groupBy非常像，但是当你知道你的键是唯一的时候可以使用indexBy 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="property">indexBy</span> = <span class="title function_">group</span>(<span class="keyword">function</span>(<span class="params">result, value, key</span>) &#123;</span><br><span class="line">  result[key] = value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>countBy</strong>  countBy_.countBy(list, iteratee, [context]) 排序一个列表组成一个组，并且返回各组中的对象的数量的计数。类似groupBy，但是不是返回列表的值，而是返回在该组中值的数目。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="property">countBy</span> = <span class="title function_">group</span>(<span class="keyword">function</span>(<span class="params">result, value, key</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (_.<span class="title function_">has</span>(result, key)) result[key]++; <span class="keyword">else</span> result[key] = <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h3><p>_.toArray(obj) 把obj(任何可以迭代的对象)转换成一个数组，在转换 arguments 对象时非常有用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="property">toArray</span> = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!obj) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">if</span> (_.<span class="title function_">isArray</span>(obj)) <span class="keyword">return</span> slice.<span class="title function_">call</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (_.<span class="title function_">isString</span>(obj)) &#123;</span><br><span class="line">    <span class="comment">// Keep surrogate pair characters together</span></span><br><span class="line">    <span class="keyword">return</span> obj.<span class="title function_">match</span>(reStrSymbol);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isArrayLike</span>(obj)) <span class="keyword">return</span> _.<span class="title function_">map</span>(obj, _.<span class="property">identity</span>);</span><br><span class="line">  <span class="keyword">return</span> _.<span class="title function_">values</span>(obj);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>.size(obj) 返回所传合法对象的长度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="property">size</span> = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">isArrayLike</span>(obj) ? obj.<span class="property">length</span> : _.<span class="title function_">keys</span>(obj).<span class="property">length</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这其实是一个扩展处理，我们知道对象是没有length属性的。这里进行了处理，返回 由对象的key值所组成数组的长度~</p>
<h3 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h3><p>_.partition(array, predicate) 拆分一个数组（array）为两个数组：  第一个数组其元素都满足predicate迭代函数， 而第二个的所有元素均不能满足predicate迭代函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.<span class="property">partition</span> = <span class="title function_">group</span>(<span class="keyword">function</span>(<span class="params">result, value, pass</span>) &#123;</span><br><span class="line">  result[pass ? <span class="number">0</span> : <span class="number">1</span>].<span class="title function_">push</span>(value);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>group的第一个参数是个回调没异议，第二个传了一个true是什么呢？ 我们可翻到上面看看，<code>partition</code>的值决定了如何处理result 这里变成了 [[], []] 的形式。那么很简单了，根据回调的pass结果，通过放到 [[], []][0]中， 未通过则放到[[], []][1]中</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>随着 underscore.js 源码的阅读与学习深入，我们可以了解到很多底层封装的原理与细节。在阅读源码时，不要害怕自己看不懂，理解错，不清楚的地方可以单独拎出来，自己写写或者代码跑起来看看效果以便加深理解。</p>
<p>Collections Function中，其实很多都是对第一章核心函数的一些封装和重复使用，如cb optimizeCb这类用得多的，向外暴露的API又可以让封装的其他API来使用，如 where findWhere就是对filter的运用， pluck是对map的二次封装。</p>
]]></content>
      <categories>
        <category>代码相关</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>underscore</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习】什么是Accessibility - 无障碍</title>
    <url>/2024/01/26/32647990-bc5d-11ee-b11d-1ddb3fe7683d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>最近在学习TailWindCSS，读和整理文档准备拿去做个项目（就决定拿来重构之前的简历项目了）了解到了无障碍 Accessibility 这个概念，很多指导性概念值得学习，就写篇文章了</p>
</blockquote>
<h1 id="Accessibility-无障碍"><a href="#Accessibility-无障碍" class="headerlink" title="Accessibility - 无障碍"></a>Accessibility - 无障碍</h1><p>当有人将一个网站描述为“无障碍”时，他们的意思是，任何用户都可以使用其所有的功能和内容，无论用户是如何访问网络的——甚至特别是有身体或精神障碍的用户。</p>
<p>默认情况下，HTML 在使用正确的时候是可以实现无障碍的。Web 无障碍涉及确保内容保持无障碍，无论访问 web 的人员或方式。</p>
<p>无障碍是一种让尽可能多的用户可以使用你的网站的做法。传统上我们认为这只与残疾人士有关，但提升网站的无障碍也可以让其他用户群体受益。比如使用移动设备的人群，那些使用低速网络连接的人群。</p>
<p>你也可以把无障碍看成是同等地对待每一个人，给他们平等的机会，无论他们的能力或所处的环境如何。就像不能让坐轮椅的人可以进入大楼是错误的 (现代公共建筑通常有轮椅坡道或电梯)；不能让视觉有障碍的人士可以浏览我们的网站同样不正确。我们都是不同的，但我们都是人，因此享有同等的人权。</p>
<p>使网站具备无障碍才是正确的做法。它也是一些国家法律的一部分，它打开了一些重要的市场，否则那些市场的用户无法使用你的服务或者购买你的产品。</p>
<p>建立可访问的网站能让每个人都受益</p>
<p><strong>无障碍 API</strong></p>
<p>不同的操作系统有不同的无障碍 API：</p>
<ul>
<li>Windows: MSAA&#x2F;IAccessible, UIAExpress, IAccessible2</li>
<li>Mac OS X: NSAccessibility</li>
<li>Linux: AT-SPI</li>
<li>Android: Accessibility framework</li>
<li>iOS: UIAccessibility</li>
</ul>
<p>在 WAI-ARIA basics 文章中了解有关 WAI-ARIA 的更多详细信息。 </p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Accessibility/WAI-ARIA_basics">https://developer.mozilla.org/zh-CN/docs/Learn/Accessibility/WAI-ARIA_basics</a></p>
<h2 id="HTML-无障碍的良好基础"><a href="#HTML-无障碍的良好基础" class="headerlink" title="HTML 无障碍的良好基础"></a>HTML 无障碍的良好基础</h2><ul>
<li>良好的语义 （HTML 结构）<ul>
<li>更便于开发 — 如上所述，你可以使 HTML 更易于理解，并且可以毫不费力的获得一些功能。</li>
<li>更适配移动端 — 语义化的 HTML 文件比非语义化的 HTML 文件更加轻便，并且更易于响应式开发。</li>
<li>更便于 SEO 优化 — 比起使用非语义化的<code>&lt;div&gt;</code>标签，搜索引擎更加重视在“标题、链接等”里面的关键字，使用语义化可使网页更容易被用户搜索到。</li>
</ul>
</li>
<li>使用通俗易懂的语言</li>
<li>页面布局（同上，HTML5 新标签 - 语义化）</li>
<li>UI 控制<ul>
<li>重新建立键盘的无障碍</li>
</ul>
</li>
<li>有意义的文字标签</li>
<li>可访问的表格<ul>
<li>表头使用 <code>&lt;th&gt;</code>元素定义 - 你还可以使用 scope 属性指定它们是行还是列的标题。这提供给了屏幕阅读器可以理解的完整数据组。</li>
<li><code>&lt;caption&gt;</code> 元素和 <code>&lt;table&gt;</code> summary 属性都执行类似的工作 - 它们充当表格的替代文本，为屏幕阅读器用户提供有用的表格内容快速摘要。<code>&lt;caption&gt;</code>通常是首选，因为它使内容可供视力良好的用户访问，而且他们也可能会发现它很有用。你并不需要两者都使用！。</li>
</ul>
</li>
<li>图片拥有可替代文本<ul>
<li>title</li>
<li>alt</li>
</ul>
</li>
</ul>
<p>你现在应该精通编写大多数场合可访问的 HTML。我们的 WAI-ARIA 基础知识文章也将填补这些知识中的一些空白，但本文已经关注了此基础知识。接下来，我们将探索 CSS 和 JavaScript，以及无障碍如何受其好坏影响。</p>
<h2 id="CSS-无障碍"><a href="#CSS-无障碍" class="headerlink" title="CSS 无障碍"></a>CSS 无障碍</h2><ul>
<li><p>正确的语义和用户期望，对<code>h1</code> <code>span</code>等</p>
</li>
<li><p>选择合理的字体大小、行高、字母间距等，使文本具有逻辑性、清晰性和阅读舒适性。</p>
</li>
<li><p>确保标题从正文文本中脱颖而出，通常像默认样式一样大而粗壮。你的列表应类似于列表。</p>
</li>
<li><p>文本颜色应与背景颜色形成良好对比。</p>
</li>
<li><p>强调的文本</p>
</li>
<li><p><code>b</code> <code>strong</code> <code>i</code></p>
</li>
<li><p>缩写</p>
<ul>
<li><code>&lt;abbr&gt;</code></li>
</ul>
</li>
<li><p>超链接 a</p>
</li>
<li><p>表单元素</p>
</li>
<li><p>表格</p>
</li>
<li><p>颜色和颜色对比度</p>
<ul>
<li>为网站选择配色方案时，请确保文本（前景）颜色与背景颜色对比度良好。你的设计可能看起来很酷，但如果有视觉障碍（如色盲）的人无法阅读你的内容，则设计就无一好可做。</li>
</ul>
</li>
<li><p>接受用户覆盖样式</p>
</li>
</ul>
<h2 id="JavaScript-无障碍"><a href="#JavaScript-无障碍" class="headerlink" title="JavaScript 无障碍"></a>JavaScript 无障碍</h2><p>JavaScript 还可能会中断无障碍，具体取决于其使用方式。简单的内容和功能可以说是很容易使访问——例如文本，图像，表格，窗体和按钮，激活功能。正如我们在 HTML：辅助功能的良好基础一文中提到的，主要注意事项包括：</p>
<ul>
<li>良好的语义：为正确的工作使用正确的元素。例如，确保你使用标题和段落，以及 <code>&lt;button&gt;</code> 和 <code>&lt;a&gt;</code> 元素</li>
<li>确保内容以文本形式提供，要么直接作为文本内容、表单元素的良好文本标签，也可以确保替代文本（例如图像的 alt 文本）。</li>
</ul>
<h3 id="太多-JavaScript-导致的问题"><a href="#太多-JavaScript-导致的问题" class="headerlink" title="太多 JavaScript 导致的问题"></a>太多 JavaScript 导致的问题</h3><p>过于依赖 JavaScript 会导致许多问题。有时你会看到一个网站，其中一切都已经用 JavaScript 完成——JavaScript 生成 HTML，CSS 等等。随之而来的会是各种访问性问题，因此这样做是不建议的。</p>
<h3 id="保持别抢眼"><a href="#保持别抢眼" class="headerlink" title="保持别抢眼"></a>保持别抢眼</h3><p>在创建内容时，应牢记不唐突的（unobtrusive）JavaScript 原则。不唐突的 JavaScript 的想法是，它应该尽可能用于增强功能，而不是完全构建它——基本功能最好在没有 JavaScript 的情况下正常工作，尽管人们认识到，这并不总是一个选项。但同样，它的大部分是尽可能使用内置的浏览器功能。</p>
<ul>
<li>提供客户端表单验证，它快速提醒用户表单条目出现的问题，而无需等待服务器检查数据。如果表单不可用，则窗口仍然有效，但验证速度可能较慢。</li>
<li>为 HTML5 <code>&lt;video&gt;</code> 提供自定义控件，这些控件仅供键盘用户访问，以及如果 JavaScript 不可用 (默认 <code>&lt;video&gt;</code> 浏览器控件在大多数浏览器中无法使用键盘访问)，就直接通过链接访问视频。</li>
</ul>
<blockquote>
<p>在实现 JavaScript 和考虑无障碍时，还有其他需要注意的事项。一旦发现将会添加更多。</p>
</blockquote>
<p>正如你所知，客户端 JavaScript 使用事件处理程序，实现大多数用户交互，它允许我们运行函数以响应某些事件的发生。某些事件可能有辅助功能问题。你将遇到的主要示例是鼠标特定的事件，如鼠标悬停（mouseover (en-US)）、鼠标划出（mouseout）、双击（dblclick）等。使用其他机制（如键盘控件）无法访问为这些事件而运行的功能。</p>
<p>为了缓解此类问题，你应该将这些事件与可以通过其他方式（所谓的设备独立事件处理程序）激活的类似事件相结合——focus 和 blur 将为键盘用户提供无障碍。</p>
<p>Click 事件很有趣——听起来它依赖于鼠标，但是大多数的浏览器，在有焦点的链接或者表单元素上，按下 enter&#x2F;return 之后，或者在触屏设备上点击一个元素，都将会激活 onclick 事件处理程序。但是，当你允许非默认可聚焦事件使用 tabindex 进行焦点处理时，默认情况下不起作用，在这种情况下，你需要在按下确切键时进行专门检测</p>
<h2 id="何为-WAI-ARIA"><a href="#何为-WAI-ARIA" class="headerlink" title="何为 WAI-ARIA"></a>何为 WAI-ARIA</h2><p>WAI-ARIA 是 W3C 编写的规范，定义了一组可用于其他元素的 HTML 特性，用于提供额外的语义化以及改善缺乏的无障碍。以下是规范中三个主要的特性：</p>
<ul>
<li><p>角色 — 这定义了元素是干什么的。许多「标志性的角色」，其实重复了 HTML5 的结构元素的语义价值。例如 role&#x3D;”navigation” (<code>&lt;nav&gt;</code>) 或者 role&#x3D;”complementary” (<code>&lt;aside&gt;</code>)，这也有一些描述其他页面结构的（角色），例如 role&#x3D;”banner”, role&#x3D;”search”, role&#x3D;”tabgroup”, role&#x3D;”tab” 等等。我们通常能从 UI 层面找到它们。</p>
</li>
<li><p>属性 — 我们能通过定义一些属性给元素，让他们具备更多的语义。例如： aria-required&#x3D;”true” 意味着元素在表单上是必填的。然而 aria-labelledby&#x3D;”label” 允许你在元素上设置一个 ID，用于 labelledby 引用作为屏幕阅读器指定的 label 内容，多个也可以。当然，下面这个代码是不行的： <code>&lt;label for=&quot;input&quot;&gt;</code></p>
</li>
<li><p>状态 — 用于表达元素当前的条件的特殊属性，例如 aria-disabled&#x3D;”true”，屏幕阅读器就会这个表单禁止输入。状态和属性的差异之处就是：属性在应用的生命周期中不会改变，而状态可以，通常我们用编程的方法改变它，例如 Javascript。</p>
</li>
</ul>
<blockquote>
<p>但还是要重申：当你需要的时候再使用无障碍特性！另外，请尝试确保你的真实用户来测试你的网站：普通人，使用屏幕阅读器的用户，使用键盘导航的人。他们会提供你更多的见解。</p>
</blockquote>
<h3 id="实用的-WAI-ARIA-实现"><a href="#实用的-WAI-ARIA-实现" class="headerlink" title="实用的 WAI-ARIA 实现"></a>实用的 WAI-ARIA 实现</h3><p>WAI-ARIA 给浏览器增加了 role 属性，这允许我们给站点中的元素增加我们想要的语义属性。第一个主要区域便是用于为屏幕阅读器提供信息，以便用户可以找到常见的页面元素。</p>
<p>如果由于某种原因，你的网站仅使用<code>&lt;div&gt;</code> 构建，那么你肯定很需要用 ARIA 角色以提供所需的语义！</p>
<h3 id="动态内容更新"><a href="#动态内容更新" class="headerlink" title="动态内容更新"></a>动态内容更新</h3><p>使用屏幕阅读器可以轻松访问读取到 DOM 中的内容，从文本内容到附加到图像的 alt 文本。所以具有大量文本内容的传统静态网站易于为视碍人士提供信息。</p>
<p>WAI-ARIA 提供了一种有效的机制来发起提示——<code>aria-live</code>。将此应用于元素会让屏幕阅读器读出更新的内容。读取内容的紧急程度取决于属性值：</p>
<ul>
<li>off: 默认值，更新不会提醒。</li>
<li>polite: 只有用户空闲的情况下提醒。</li>
<li>assertive: 尽快提醒。</li>
<li>rude: 会以打断用户操作的方式直接提醒。</li>
</ul>
<p>通常来说 assertive 设置足以让你的更新在显示时按时序读出，因此，如果改变多次，那么他只会念出最后一个改变。除非紧急程度高到需要覆盖其他的更新才选择使用 rude 。</p>
<h3 id="优化键盘的无障碍操作"><a href="#优化键盘的无障碍操作" class="headerlink" title="优化键盘的无障碍操作"></a>优化键盘的无障碍操作</h3><p>正如上下文中其他几处讨论的，HTML 在无障碍方面的关键优势之一是按钮，表单控件和链接等功能的内置键盘无障碍。平时你可以使用 Tab 键在控件之间移动，使用 Enter &#x2F; Return 键选择或激活控件，偶尔也可以根据需要使用其他控件（例如上下光标在<code>&lt;select&gt;</code> 框中的选项之间移动）。</p>
<p>但是在一些时候，你最终还是得编写代码去使用非语义元素作为按钮（或其他类型的控件），或者使用可聚焦控件来达到错误的目的。你可能正在尝试修复一些你之前的错误代码，或者你可能正在构建某种需要它的复杂小部件。</p>
<p>在让不可聚焦代码可聚焦这一方面，WAI-ARIA 用一些新的值来扩展了 tabindex 的属性：</p>
<ul>
<li>tabindex&#x3D;”0” — 如上所述，这个值让不能被 tab 的元素变得 tabbable。这是 tabindex 最有用的值。</li>
<li>tabindex&#x3D;”-1” — 这允许通常不可列表的元素以编程方式来接收 focus。例如用：JavaScript，或者作为链接的目标。</li>
</ul>
<h3 id="非语义控件的无障碍"><a href="#非语义控件的无障碍" class="headerlink" title="非语义控件的无障碍"></a>非语义控件的无障碍</h3><p>当一系列嵌套的 <code>&lt;div&gt;</code> 与 CSS &#x2F; JavaScript 一起用于创建复杂的 UI 功能，或者通过 JavaScript 大大地增强或者更改原生的控件，不仅键盘无障碍受损。而且如果没有语义或其他线索，屏幕阅读器用户会发现很难弄清楚该功能的作用。在这种情况下，ARIA 可以帮助提供那些缺失的语义。</p>
<p>你可以在这里看这个在线完成的例子 <a href="https://mdn.github.io/learning-area/accessibility/aria/form-validation-updated.html">form-validation-updated.html</a></p>
<h3 id="描述非语义的-button-是个-button"><a href="#描述非语义的-button-是个-button" class="headerlink" title="描述非语义的 button 是个 button"></a>描述非语义的 button 是个 button</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-message</span>=<span class="string">&quot;This is from the first button&quot;</span> <span class="attr">tabindex</span>=<span class="string">&quot;0&quot;</span> <span class="attr">role</span>=<span class="string">&quot;button&quot;</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注： 别忘了无论如何用正确的语义化元素是最佳选择。如果你想创建一个按钮，你可用 <code>&lt;button&gt;</code> 元素，你应该用 <code>&lt;button&gt;</code> 元素！</p>
</blockquote>
<h3 id="通过复杂的小部件做引导用户"><a href="#通过复杂的小部件做引导用户" class="headerlink" title="通过复杂的小部件做引导用户"></a>通过复杂的小部件做引导用户</h3><p>还有许多其他 roles 可以将非语义元素结构识别为常见的 UI 功能，这些功能超出了标准 HTML 中可用的功能，例如 combobox, slider, tabpanel, tree。</p>
<p>以下刚刚用上的新特性：</p>
<ul>
<li><p>新角色 — tablist, tab, tabpanel — 这些确定几个 tab 表界面的重要区域——tabs 的容器，tabs 自身，还有他们的一致性 tabpanels。</p>
</li>
<li><p>aria-selected — 定义了 tab 当前正在被选中。和 tabs 被用户选中不同，这种值一般是由 JavaScript 修改。</p>
</li>
<li><p>aria-hidden — 对屏幕阅读器隐藏一些元素，和 tabs 被用户选中不同，这种值一般是由 JavaScript 修改。</p>
</li>
<li><p>tabindex&#x3D;”0” — 当我们删除链接时，我们需要为列表项提供此属性，以便为其提供键盘焦点。（为没有 tabindex 特性的元素也提供 tabindex 特性）</p>
</li>
<li><p>aria-setsize — 此属性允许你指定屏幕阅读器元素是某个系列的一部分，以及该系列具有多少项。</p>
</li>
<li><p>aria-posinset — 这个属性允许你设置一个元素在一个系列中的位置，随着 aria-setsize，他告诉屏幕阅读器（用于设置文件目录树视图）足够的信息去告诉你现在在 item “1 of 3” 位置等。</p>
</li>
</ul>
<blockquote>
<p>如果你有不想让屏幕阅读器读出来的东西，你可以给它一个 aria-hidden&#x3D;”true” 属性。</p>
</blockquote>
<h2 id="多媒体无障碍"><a href="#多媒体无障碍" class="headerlink" title="多媒体无障碍"></a>多媒体无障碍</h2><p>可能导致无障碍（accessibility）问题的另一类内容是多媒体——视频、音频和图像内容需要提供适当的文本替代方式，以便辅助技术及其用户能够理解它们</p>
<h3 id="简单图像"><a href="#简单图像" class="headerlink" title="简单图像"></a>简单图像</h3><p>简而言之，应确保在可能的情况下，视觉内容具有替代文本，供屏幕阅读器拾取和读取给其用户。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;白雪公主.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;您正在看的是《白雪公主和七个小矮人》绘图本，白雪公主的图片&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="可访问的音频和视频控件"><a href="#可访问的音频和视频控件" class="headerlink" title="可访问的音频和视频控件"></a>可访问的音频和视频控件</h3><p>HTML5 视频和音频实例甚至附带一组内置控件，允许你直接在盒子控制媒体。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;viper.mp3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/mp3&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;viper.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/ogg&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Your browser doesn&#x27;t support HTML5 audio. Here is a</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;viper.mp3&quot;</span>&gt;</span>link to the audio<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    instead.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;rabbit320.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;rabbit320.webm&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/webm&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Your browser doesn&#x27;t support HTML5 video. Here is a</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;rabbit320.mp4&quot;</span>&gt;</span>link to the video<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    instead.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是，这些控件存在问题：</p>
<ul>
<li>浏览器中，它们不可通过键盘访问。</li>
<li>不同的浏览器为原生控件提供了不同的样式和功能，且不可赋予它们样式，这意味着它们难以遵从网站样式指南。</li>
</ul>
<p>这里是推荐我们根据上文自行实现 role 和 控件细节，补充描述和键盘事件等，这里就不展开了</p>
<h2 id="移动端无障碍"><a href="#移动端无障碍" class="headerlink" title="移动端无障碍"></a>移动端无障碍</h2><p>如今，移动设备一般都可以处理特性齐全的网站了，同时，为了能够让盲人成功的使用网站，主流平台甚至还内置了屏幕阅读器。移动设备也倾向于对“WAI-ARIA”有很好的支持。</p>
<p>你只要需要遵守良好的 web 设计规范和最佳的无障碍实践，就可以让你的网站在手机上无障碍地使用。</p>
<p>移动设备需要特别考虑一些例外情况；主要是：</p>
<ul>
<li>控件交互——确保类似于按钮的 UI 控件可以在移动端（主要是触摸屏）和台式机&#x2F;笔记本电脑（主要是鼠标&#x2F;键盘）无障碍地使用</li>
<li>用户输入——在移动端尽可能的减少用户输入的要求（例如在表单中，尽量少打字）。</li>
<li>响应式设计——确保移动端布局正常的情况下，节省需要下载的图片大小，并考虑为高分辨率的屏幕提供图片。</li>
</ul>
<h3 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h3><p>响应式设计是根据屏幕大小和分辨率等因素动态更改你的应用程序的布局和其他功能的做法，因此对于不同设备类型的用户来说，它们是可用且无障碍的。</p>
<p>特别是，移动端设备需要解决的最常见的问题是：</p>
<ul>
<li><p>移动端设备布局的适用性。例如，在窄屏上多列布局不能很好的工作，需要增加文字大小以提高可读性。这些问题可以通过媒体查询、视口、弹性盒子来解决。</p>
</li>
<li><p>节省下载的图片大小。一般来说，小屏幕设备不需要与桌面设备一样大的图像，而且它们将更可能在慢速网络连接上。因此，适当地缩小屏幕设备以缩小图像是明智的。你可以使用响应式图像技术处理此问题。</p>
</li>
<li><p>考虑高分辨率。许多移动设备具有高分辨率屏幕，因此需要更高分辨率的图像，使得显示器可以继续看起来清晰和锐利。再次，你可以使用响应式图像技术来适当地提供图像。此外，使用 SVG 矢量图像格式可以满足许多图像要求，这些格式在目前的浏览器中得到了很好的支持。SVG 文件较小，且不论以何种大小显示，它都会保持清晰</p>
</li>
</ul>
<h3 id="具体的需要注意的点"><a href="#具体的需要注意的点" class="headerlink" title="具体的需要注意的点"></a>具体的需要注意的点</h3><ul>
<li>不禁用缩放 使用视口可能会禁用缩放。要始终启用缩放，请在 <code>&lt;head&gt;</code> 中将宽度设置为设备宽度：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width; user-scalable=yes&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>但国内行情一般都是禁用这项的。至于具体怎么使用，仁者见仁智者见智吧</p>
<ul>
<li>保持菜单无障碍</li>
</ul>
<p>因为移动设备上的屏幕非常窄，所以使用媒体查询和其他技术使得导航菜单缩小到显示屏顶部的一个小图标，只有在需要的时候才展示菜单，这种方式在移动设备上很常见的。这通常由“三横线”图标表示，并且设计模式因此被称为“汉堡菜单”。</p>
<ul>
<li>用户输入</li>
</ul>
<p>在移动设备上，输入数据往往比在台式计算机上的同等体验更令用户恼火。使用桌面或笔记本电脑键盘输入文本到表单输入比触摸屏虚拟键盘或微小的移动物理键盘更方便。</p>
<p>出于这个原因，值得尽量减少所需的输入量。例如，与其让用户每次使用常规文本输入来填写他们的工作标题，而是可以提供一个 <code>&lt;select&gt;</code> 菜单，其中包含最常见的选项（这也有助于数据输入的一致性），并提供一个“其他”选项，显示一个文本字段来输入任何异常值。</p>
<p>也值得考虑在移动平台上使用 HTML 格式输入类型（如日期），因为它们可以得到很好的处理。例如，Android 和 iOS 都会显示可用于设备体验的可用控件。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，介绍了什么是无障碍，为什么需要无障碍，在HTML、CSS、JavaScript中我们能为无障碍做哪些事情以及移动端下的表现，添加响应式设计。WAI-ARIA为W3C的规范，在使用多媒体元素时，我们可做的事情。</p>
<p>需了解更多可查看官方文档，这里大致做一个了解即可</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Accessibility</tag>
        <tag>WAI-ARIA</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习】前端存储之Cookie、Session</title>
    <url>/2018/07/28/c19e7f20-af92-11ee-a02b-f715c4569001/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Cookie定义"><a href="#Cookie定义" class="headerlink" title="Cookie定义"></a>Cookie定义</h2><p>Cookie 是一小段文本信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递。Cookie 包含每次用户访问站点时 Web 应用程序都可以读取的信息。</p>
<span id="more"></span>

<p>例如，如果在用户请求站点中的页面时应用程序发送给该用户的不仅仅是一个页面，还有一个包含日期和时间的 Cookie，用户的浏览器在获得页面的同时还获得了该 Cookie，并将它存储在用户硬盘上的某个文件夹中。</p>
<p>以后，如果该用户再次请求您站点中的页面，当该用户输入 URL 时，浏览器便会在本地硬盘上查找与该 URL 关联的 Cookie。如果该 Cookie 存在，浏览器便将该 Cookie 与页请求一起发送到您的站点。然后，应用程序便可以确定该用户上次访问站点的日期和时间。您可以使用这些信息向用户显示一条消息，也可以检查到期日期。</p>
<p>Cookie 与网站关联，而不是与特定的页面关联。因此，无论用户请求站点中的哪一个页面，浏览器和服务器都将交换 Cookie 信息。用户访问不同站点时，各个站点都可能会向用户的浏览器发送一个 Cookie；浏览器会分别存储所有 Cookie。</p>
<p>Cookie 帮助网站存储有关访问者的信息。一般来说，Cookie 是一种保持 Web 应用程序连续性（即执行状态管理）的方法。除短暂的实际交换信息的时间外，浏览器和 Web 服务器间都是断开连接的。对于用户向 Web 服务器发出的每个请求，Web 服务器都会单独处理。但是在很多情况下，Web 服务器在用户请求页时识别出用户会十分有用。例如，购物站点上的 Web 服务器跟踪每位购物者，这样站点就可以管理购物车和其他的用户特定信息。因此，Cookie 可以作为一种名片，提供相关的标识信息帮助应用程序确定如何继续执行。</p>
<p>使用 Cookie 能够达到多种目的，所有这些目的都是为了帮助网站记住用户。例如，一个实施民意测验的站点可以简单地将 Cookie 作为一个 Boolean 值，用它来指示用户的浏览器是否已参与了投票，这样用户便无法进行第二次投票。要求用户登录的站点则可以通过 Cookie 来记录用户已经登录，这样用户就不必每次都输入凭据。</p>
<p>分类：一般分为两种形式的Cookie：1.会话型的，2.持久性的。会话型的是浏览器的处理过程中保留的，是暂时性的，当浏览器关闭时则消除了！而持久性的是保存在客户端的硬盘上的，就像论坛的Cookie一样。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：极高的扩展性和可用性</p>
<p>通过良好的编程，控制保存在cookie中的session对象的大小。<br>通过加密和安全传输技术（SSL），减少cookie被破解的可能性。<br>只在cookie中存放不敏感数据，即使被盗也不会有重大损失。<br>控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。</p>
<p>缺点：</p>
<p>Cookie数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。<br>安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。<br>有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。</p>
<h2 id="Session定义"><a href="#Session定义" class="headerlink" title="Session定义"></a>Session定义</h2><p>在Web开发中，服务器可以为每个用户浏览器创建一个会话对象(session对象)。注意：一个浏览器独占一个session对象（默认）。因此，在需要保存用户数据时，服务器可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问时，可以从用户的session中取出该用户的数据。</p>
<p>注：新开浏览器窗口会生成新的Session，子标签页除外。子标签页公用父窗口的Session</p>
<h3 id="Session用途"><a href="#Session用途" class="headerlink" title="Session用途"></a>Session用途</h3><ol>
<li>记录用户登录与行为数据. 考虑到这些数据用户修改随意性大，没必要直接存到数据库</li>
<li>用户执行刷新时，可直接根据session打开上次访问网页的状态，优化体验</li>
<li>通过session把用户行为联系起来，构建出完整模型，进行数据挖掘</li>
</ol>
<blockquote>
<p>session其实就是会话变量的保存地，只要是能使用变量的地方，都能使用session变量。一般地session就是像一个临时容器，来存放临时东西。</p>
</blockquote>
<h3 id="Session和Cookie的区别和联系"><a href="#Session和Cookie的区别和联系" class="headerlink" title="Session和Cookie的区别和联系"></a>Session和Cookie的区别和联系</h3><blockquote>
<p>具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务端保存状态的方案。两者存储的都是用户相关行为信息</p>
</blockquote>
<ul>
<li><p>cookie是把用户的数据写在本地浏览器上，其他网站也可以扫描使用该cookie，容易泄漏自己网站的用户隐私，且一般浏览器对单个网站站点有cookie数量与大小限制</p>
</li>
<li><p>session是把用户数据写在用户独占的session上，存储在服务端，一般只将session的id存储在cookie中。但将数据存储在服务器，成本相对高些</p>
</li>
<li><p>session是由服务端创建，开发人员可以在服务器上通过request对象拿到</p>
</li>
<li><p>一般情况，登录信息等重要信息存储在session中，其他信息存储在cookie中</p>
</li>
</ul>
<p>由于HTTP协议是无状态协议，所以服务端需要记录用户状态时，就需要用某种机制（Session）来识别具体用户。服务端为特定用户创建特定 Session 用于标识这个用户。Session是保存在服务端的，有一个唯一标识。</p>
<p>在服务端保存Session方法很多，内存、数据库、文件都有，集群时也要考虑Session的转移，使用一些缓存服务如Memcached之类来存放。</p>
<p>那么服务端如何识别特定用户？ Cookie，每次HTTP请求时，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用Cookie来实现Session跟踪。第一次创建Session时，服务端会在HTTP协议中告诉客户端，需要在Cookie里记录一个Session ID，以后每次请求都把这个会话ID发送到服务器，这样服务端就能识别客户端了。</p>
<ul>
<li>Session是在服务端保存的一个数据结构，用来跟踪用户的状态，该数据可以保存在集群、数据库、文件中</li>
<li>Cookie是在客户端保存用户信息的一种机制，用来记录用户信息，也是Session的一种实现方式</li>
</ul>
<h3 id="Session的实现原理"><a href="#Session的实现原理" class="headerlink" title="Session的实现原理"></a>Session的实现原理</h3><p>服务器会为每一个访问服务器的用户创建一个session对象，且把session对象的id保存在本地cookie上，只要用户再次访问服务器时，带着session id，服务器就会匹配用户在服务器上的session。根据session中的数据，还原用户上次的浏览状态或提供其他人性化服务。</p>
<h3 id="浏览器禁用Cookie后如何实现Session"><a href="#浏览器禁用Cookie后如何实现Session" class="headerlink" title="浏览器禁用Cookie后如何实现Session"></a>浏览器禁用Cookie后如何实现Session</h3><p><strong>URL地址重写</strong></p>
<p>原理是将用户session的id信息重写到url地址中。服务器能够解析重写后的url以获取sessionId。这样即时客户端不支持Cookie，也可以使用Session来记录用户状态。</p>
<h3 id="Session和Cookie有效时长"><a href="#Session和Cookie有效时长" class="headerlink" title="Session和Cookie有效时长"></a>Session和Cookie有效时长</h3><ul>
<li>session</li>
</ul>
<p>服务器会把长时间没有活动的session从服务器内存中清除，此时session便失效。具体根据服务端设置</p>
<ul>
<li>cookie</li>
</ul>
<p>主要内容包括：Key、value、过期时间、路径和域。路径与域一起构成cookie的作用范围，通过过期时间expires设置cookie的有效时长</p>
<blockquote>
<p>若不设置过期时间，表示这个cookie的生命周期为浏览器的会话期间，关闭访问服务器的浏览器窗口，cookie就消失，一般称为会话cookie。若保存在内存中设置了过期时间，则cookie会存储在硬盘上直到超过有效时间</p>
</blockquote>
<h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>前端 http 里所说的 Token  是指 <code>访问资源的凭据</code>。</p>
<p>例如当调用 google api 需要带上有效的token来表明请求的合法性。 这个token是google给的，代表了有权访问api背后的资源。</p>
<ul>
<li>access token 调用api时携带的token</li>
</ul>
<ol>
<li>首先需要向google api注册应用程序，注册完毕后拿到认证信息（credentials）包括id和secret</li>
<li>接下来向google请求access token。如果想访问用户资源，这里会提醒用户授权</li>
<li>授权完毕，google会返回access token，或者授权代码（authorization code）, 再通过代码取得access token</li>
<li>token获取到后，就能带上token访问api了</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/3/1646088e5837a9a2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="access token流程"></p>
<p>在第3步通过code兑换access token的过程中，google不仅会返回access token，还会返回额外信息，这其中和之后更新相关的就是refresh token</p>
<p>一旦access token过期，就可以通过refresh token再次请求access token。当然这要根据请求方式和访问的资源类型而定，这又会引起两个问题：</p>
<ol>
<li>如果refresh token也过期了怎么办？需要用户重新登录授权</li>
<li>为什么要区分refresh token和access token？如果合并成一个token然后把过期时间调整更长，且每次失效后用户重新登录授权就好？</li>
</ol>
<h2 id="OAuth"><a href="#OAuth" class="headerlink" title="OAuth"></a>OAuth</h2><p>从获取token到使用token访问接口。这其实是标准的OAuth2.0机制下访问api的流程。</p>
<h3 id="SSO-Single-Sign-On"><a href="#SSO-Single-Sign-On" class="headerlink" title="SSO Single Sign-On"></a>SSO Single Sign-On</h3><p>单点登录（公司内部，一个用户登录，可访问所有系统）</p>
<p>SSO是一类解决方案的统称，而在具体实施，我们有两种策略可供选择：</p>
<ol>
<li>SAML 2.0</li>
<li>OAuth 2.0</li>
</ol>
<p><strong>Authentication VS Authorisation</strong></p>
<ul>
<li>Authentication 身份鉴别 认证</li>
<li>Authorisation 授权</li>
</ul>
<p>认证的作用在于认可你有权限访问系统，用于鉴别访问者是否是合法用户；而授权用于决定你有访问哪些资源的权限。作为系统设计者来说，这两者的差别是不同的工作职责。</p>
<p>Authorization Server&#x2F;Identity Provider(IdP) VS Service Provider(SP)&#x2F;Resource Server<br>把负责认证的服务称为 Authorization Server 或者 Identity Provider，以下简称 IdP；而负责提供资源（API调用）的服务称为  Resource Server 或者 Service Provider，以下简称 SP</p>
<h3 id="SMAL-2-0"><a href="#SMAL-2-0" class="headerlink" title="SMAL 2.0"></a>SMAL 2.0</h3><p><img src="https://user-gold-cdn.xitu.io/2018/7/3/16460893ef7a34a4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="SMAL2.0流程图"></p>
<ul>
<li>还未登录的用户打开浏览器访问网站（SP）网站提供服务但是不负责用户认证</li>
<li>SP向IdP发送一个SAML认证请求，同时SP向用户浏览器重定向到IdP</li>
<li>IdP在验证完来自SAML的请求无误后，在浏览器中呈现登录表单让用户进行填写用户名和密码进行登录</li>
<li>一旦用户登录成功，IdP会生成一个包含用户信息（用户名和密码）的SAML token（SAML token 又称为 SAML Assertion，本质上是 XML 节点）IdP向SP返回token，并且将用户重定向到SP（token的返回是在重定向步骤中实现的）</li>
<li>SP对拿到的token进行验证，并且解析用户信息。此时就能够根据这些信息允许用户访问我们网站的内容了</li>
</ul>
<p>当用户在IdP登录成功后，IdP需要将用户再次重定向至SP站点，这一步有两个方法：</p>
<ul>
<li>HTTP重定向（不推荐，因无法携带更长的信息）</li>
<li>HTTP POST请求，当用户登录后渲染表单，点击向SP提交POST</li>
</ul>
<p>如果是应用是基于web，无问题。但若是Android和IOS问题就来了：</p>
<ul>
<li>用户在iphone上打开应用，需要通过IdP认证</li>
<li>应用跳转safari登录认证完毕后，需要通过http post形式将token返回至手机应用</li>
</ul>
<p>虽然post的url可以拉起应用，但无法解析post内容，也就无法获取SAML token</p>
<hr>
<h3 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h3><p><img src="https://user-gold-cdn.xitu.io/2018/7/3/164608b5c33898d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="OAutho2.0流程图"></p>
<ul>
<li>用户通过客户端（也可以是浏览器或手机应用）想要访问SP上的资源，但是SP告诉用户需要认证，将用户重定向至IdP</li>
<li>IdP向用户询问SP是否可以访问用户信息，若用户同意，IdP向客户端返回access code</li>
<li>客户端拿code向IdP换access token，并拿着access token向SP请求资源</li>
<li>SP接受请求后拿着附带token向IdP验证用户身份</li>
</ul>
<p>OAuth本意是一个应用允许另一个应用在用户授权的情况下访问自己的数据，OAuth设计本意更倾向于授权而非认证（当然授权用户信息就间接实现了认证）</p>
<h3 id="OpenID"><a href="#OpenID" class="headerlink" title="OpenID"></a>OpenID</h3><ul>
<li>OpenID只用于身份验证，允许你以同一个账户在多个网站登录。它仅仅是为你的合法身份背书，当你以xx帐号登录某个站点后，该站点无权访问你在xxb上的数据</li>
<li>OAuth用户授权，允许被授权方访问授权方的用户数据</li>
</ul>
<h3 id="Refresh-Token"><a href="#Refresh-Token" class="headerlink" title="Refresh Token"></a>Refresh Token</h3><p>为什么需要？</p>
<p>这样处理是为了职责分离：refresh token负责身份验证， access token负责资源请求。虽然两者都由IdP发出，但access token还要和SP进行数据交换，如果公用会有身份泄漏可能。</p>
<hr>
<p>token其实是为OAuth服务的，它是访问数据的一把钥匙。</p>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JWT 也是token，它是访问资源的凭证。甚至你可以不需要向 Google 索要 access token，而是携带 JWT 作为 HTTP header 里的 bearer token 直接访问 API 也是可以的。</p>
<p>顾名思义，它是json结构的token，由三部分组成：</p>
<ul>
<li>header</li>
</ul>
<p>用于描述元信息，例如产生signature的算法</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>payload</li>
</ul>
<p>用于携带你希望向服务端传递的信息。即可以往里面添加字段，也可以塞入自定义字段</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;userId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;b08f86af-35da-48f2-8fab-cef3904660bd&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>signature</li>
</ul>
<p>创建签名需要分以下几个步骤</p>
<ol>
<li>需要从接口服务端拿到密钥 假设为 <code>secret</code></li>
<li>将header进行base64编码，假设为 <code>headerStr</code></li>
<li>将payload进行base64编码，假设为 <code>payloadStr</code></li>
<li>将headerStr和payloadStr用 <code>.</code> 字符串拼接，成为字符 <code>data</code></li>
<li>以data和secret作为参数，使用哈希算法计算出签名</li>
</ol>
<p>下面是伪代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// signature algorithm</span></span><br><span class="line">data = <span class="title function_">base64URLEncoded</span>(header) + <span class="string">&#x27;.&#x27;</span> + <span class="title function_">base64URLEncoded</span>(payload)</span><br><span class="line">signature = <span class="title class_">Hash</span>(data, secret)</span><br></pre></td></tr></table></figure>

<p>假设我们的原始 JSON 结构是这样的：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Header</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">// Payload:</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;userId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;b08f86af-35da-48f2-8fab-cef3904660bd&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果密钥是字符串secret的话，那么最终 JWT 的结果就是这样的</p>
<pre><code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM
</code></pre>
<p>你可以在 <a href="https://jwt.io/">jwt.io</a> 上验证这个结果</p>
<hr>
<p>JWT的目的不是为了隐藏或者保密数据，而是为了确保数据确实来自被授权的人创建的（不被篡改）</p>
<p>用于接口调用</p>
<h2 id="有状态的会话"><a href="#有状态的会话" class="headerlink" title="有状态的会话"></a>有状态的会话</h2><p>因为HTTP是无状态的，所以客户端和服务端需要解决如何让之间的对话变得有状态。例如只有登录状态的用户才有权限去调用某些接口，那么在用户登录后，需要记住该用户是已经登录的状态。常见的方法是使用session机制。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/3/164608d56ba8fc6e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="常见的session模型"></p>
<ul>
<li>用户在浏览器登录后，服务端为用户生成唯一的session id，存储在服务端的存储服务（mysql redis）</li>
<li>该session id也返回给浏览器以SESSION_ID为key存储在cookie中</li>
<li>如果用户再次访问该站，cookie里的SESSION_ID会随着请求一同发往服务端</li>
<li>服务端通过判断SESSION_ID是否在redis判断用户是否处于登录状态</li>
</ul>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>cookie</tag>
        <tag>session</tag>
        <tag>token</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习】服务端渲染框架Nuxt入门</title>
    <url>/2018/04/17/4bc3eea0-af8f-11ee-a0c0-5b74e3925040/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>对着官方文档一顿敲&#x3D; &#x3D; 看官方文档就好，很简单，相比Vue和React那坑爹的服务端渲染配置，Nuxt简直是良心多了，配置灵活，最重要的是简单！！！于是近期会把 我的个人站首页用nuxt重（折腾）构一番，敬请期待~</p>
</blockquote>
<span id="more"></span>

<h1 id="Nuxt"><a href="#Nuxt" class="headerlink" title="Nuxt"></a>Nuxt</h1><p>Nuxt.js（后文Nuxt）是基于Vue.js的通用应用框架</p>
<p>通过对客户端&#x2F;服务端基础架构的抽象组织，Nuxt主要关注的是应用的UI渲染。其预设了利用Vue开发服务端渲染的应用所需要的各种配置。<br>作为框架，Nuxt.js 为 客户端&#x2F;服务端 这种典型的应用架构模式提供了许多有用的特性，例如异步数据加载、中间件支持、布局支持等。</p>
<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><h3 id="如何运作"><a href="#如何运作" class="headerlink" title="如何运作"></a>如何运作</h3><p>vue2+ vue-router vuex vue-meta<br>以及webpack、vue-loader、babel-loader来处理代码的自动化构建工作</p>
<p><strong>特性</strong></p>
<ul>
<li>基于Vue</li>
<li>自动代码分层</li>
<li>服务端渲染</li>
<li>强大的路由功能，支持异步数据</li>
<li>静态服务文件</li>
<li>ES6+语法支持</li>
<li>打包和压缩JS&#x2F;CSS</li>
<li>HTML头部标签管理</li>
<li>本地开发支持热加载</li>
<li>集成ESLint</li>
<li>支持样式预处理</li>
</ul>
<p>下图阐述了 Nuxt.js 应用一个完整的服务器请求到渲染（或用户通过 <code>&lt;nuxt-link&gt;</code> 切换路由渲染页面）的流程：</p>
<img src="https://zh.nuxtjs.org/nuxt-schema.png">

<p>请求到来 -&gt; nuxt server拦截处理(事件派发store action) -&gt; middleware处理中间件 (先配置，后布局，再页面) -&gt; 验证 -&gt; 获取异步数据 -&gt; render渲染(通过Navigate作路由跳转)</p>
<h3 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h3><p>使用nuxt作UI渲染框架。当运行<code>nuxt</code>命令时会启动一个支持<code>热加载</code>和<code>服务端渲染</code>（基于Vue的vue-server-renderer模块）的开发服务器。</p>
<h3 id="静态化"><a href="#静态化" class="headerlink" title="静态化"></a>静态化</h3><p>nuxt generate </p>
<p>通过CDN缓存静态页面，进行全球CDN节点布局。相对传统的动态网站，静态化分散了对服务器的请求，降低服务器压力。</p>
<p>简而言之，页面静态文件CDN，数据通过API，前后端分离.</p>
<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>vue init nuxt-community/starter-template nuxt-demo
</code></pre>
<p>要注意，<code>服务端渲染</code>是前台服务端用相同组件，一份代码，我们跑的其实是静态文件，所以需要打包出来一份bundle</p>
<p>npm run build </p>
<p>npm run dev </p>
<p>现在浏览器打开 localhost:3000 就可以访问nuxt-demo了</p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ul>
<li><p>assets 组织静态资源 css js等</p>
</li>
<li><p>components 放公共组件。注：nuxt不会扩展该目录下的组件，所以不会有asyncData特性</p>
</li>
<li><p>layouts 用于组织布局，除配置外这个优先级很高</p>
</li>
<li><p>middleware 存放中间件</p>
</li>
<li><p>pages 组织页面及路由，在layouts后读取，配置这个就不用写routes了. 后面介绍很爽</p>
</li>
<li><p>plugins 插件，用于组织需要在根vue.js实例化之前运行的JS插件</p>
</li>
<li><p>static 静态文件目录，不会被nuxt调用构建。服务启动，该目录下文件会被映射到根路径下</p>
</li>
<li><p>store Vuex状态文件</p>
</li>
<li><p>nuxt.config.js nuxt配置，优先级最高，用于覆盖默认配置</p>
</li>
</ul>
<p>更多请参考官方文档 <a href="https://zh.nuxtjs.org/">https://zh.nuxtjs.org</a> ~ </p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>Nuxt根据<code>pages</code>目录结构自动生成vue-router模块路由配置，就问你叼不叼~</p>
<p>在pages下新建一个user文件夹，新建index.vue one.vue</p>
<p>访问 localhost:3000&#x2F;user  localhost:3000&#x2F;user&#x2F;one 就能显示了，简直不要太爽</p>
<p><strong>动态路由</strong></p>
<p>以前path里配置 <code>/:id</code> 这样的，在pages&#x2F;user 里新建 _id.vue即可</p>
<p><strong>路由参数校验</strong></p>
<p>pages&#x2F;users&#x2F;_id.vue</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">validate</span>(<span class="params">&#123;params&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^\d+$/</span>.<span class="title function_">test</span>(params.<span class="property">id</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>嵌套路由</strong></p>
<p>pages&#x2F;<br>–| users&#x2F;<br>—–| _id.vue<br>—–| index.vue<br>–| users.vue</p>
<h3 id="过渡动效"><a href="#过渡动效" class="headerlink" title="过渡动效"></a>过渡动效</h3><p>参考文档 - - 我没跑成功，回头再看看</p>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>允许定义一个自定义函数运行在一个页面或一组页面渲染之前。放在middleware目录下，一个中间件接收<code>context</code>作为第一个参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  context.<span class="property">userAgent</span> = context.<span class="property">isServer</span> </span><br><span class="line">    ? context.<span class="property">req</span>.<span class="property">headers</span>[<span class="string">&#x27;user-agent&#x27;</span>]</span><br><span class="line">    : navigator.<span class="property">userAgent</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中间件执行顺序：</p>
<ol>
<li>nuxt.config.js</li>
<li>匹配布局</li>
<li>匹配页面</li>
</ol>
<p>中间件可异步执行，只需返回一个<code>Promise</code>或使用第二个callback作为第一个参数：</p>
<p>middleware&#x2F;stats.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">&#123;route&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> axios.<span class="title function_">post</span>(<span class="string">&#x27;http://xx.com&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">url</span>: route.<span class="property">fullPath</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 上面3个任意地方使用中间件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">router</span>: &#123;</span><br><span class="line">    <span class="attr">middleware</span>: <span class="string">&#x27;stats&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>stats中间件将在每个路由改变时被调用。</p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p><strong>默认页面</strong></p>
<p>layouts&#x2F;default.vue </p>
<p><strong>错误页面</strong></p>
<p>layouts&#x2F;error.vue</p>
<p><strong>个性化布局</strong></p>
<p>在layouts里添加一个dark.vue文件，然后在pages里的组件写. </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">layout</span>: <span class="string">&#x27;dark&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h3><p>页面的一些api</p>
<table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">asyncData</td>
<td align="left">最重要的一个键, 支持 异步数据处理，另外该方法的第一个参数为当前页面组件的 上下文对象</td>
</tr>
<tr>
<td align="center">fetch</td>
<td align="left">与 asyncData 方法类似，用于在渲染页面之前获取数据填充应用的状态树（store）。不同的是 fetch 方法不会设置组件的数据。详情请参考 关于fetch方法的文档</td>
</tr>
<tr>
<td align="center">head</td>
<td align="left">配置当前页面的 Meta 标签, 详情参考 页面头部配置API</td>
</tr>
<tr>
<td align="center">layout</td>
<td align="left">指定当前页面使用的布局（layouts 根目录下的布局文件）。详情请参考 关于 布局 的文档</td>
</tr>
<tr>
<td align="center">transition</td>
<td align="left">指定当前页面使用的布局（layouts 根目录下的布局文件）。详情请参考 关于 布局 的文档</td>
</tr>
<tr>
<td align="center">scrollToTop</td>
<td align="left">布尔值，默认: false。 用于判定渲染页面前是否需要将当前页面滚动至顶部。这个配置用于 嵌套路由的应用场景</td>
</tr>
<tr>
<td align="center">middleware</td>
<td align="left">指定页面的中间件，中间件会在页面渲染之前被调用， 请参考 路由中间件</td>
</tr>
</tbody></table>
<h3 id="HTML头部"><a href="#HTML头部" class="headerlink" title="HTML头部"></a>HTML头部</h3><p>nuxt使用<code>vue-meta</code>更新应用头部标签和html属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">keyName</span>: <span class="string">&#x27;head&#x27;</span>, <span class="comment">// 设置meta信息的组件对象的字段，vue-meta会根据key值获取meta信息</span></span><br><span class="line">  <span class="attr">attribute</span>: <span class="string">&#x27;n-head&#x27;</span>, <span class="comment">// vue-meta在监听标签时所添加的属性名</span></span><br><span class="line">  <span class="attr">ssrAttribute</span>: <span class="string">&#x27;n-head-ssr&#x27;</span>, <span class="comment">// 让vue-meta获知meta信息已完成服务端渲染的属性名</span></span><br><span class="line">  <span class="attr">tagIDKeyName</span>: <span class="string">&#x27;hid&#x27;</span> <span class="comment">// 让vue-meta用来决定是否覆盖还是追加tag的属性名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异步数据"><a href="#异步数据" class="headerlink" title="异步数据"></a>异步数据</h3><p>Nuxt扩展了Vue增加一个asyncData方法，使得我们可以在设置组件数据前异步获取处理数据</p>
<p><strong>asyncData</strong></p>
<p>该方法会在组件（限于页面组件）每次加载前被调用。它可以在服务端或路由更新之前被调用。在该方法被调用时，第一个参数被设定为<code>当前页面的上下文对象</code>，可利用<code>asyncData</code>方法来获取数据，Nuxt会将asyncData返回的数据融合组件<code>data</code>方法返回的数据一并返回给当前组件。</p>
<blockquote>
<p>由于asyncData方法是在组件初始化前被调用的，所以在方法内是无法通过this来引用组件实例对象的。</p>
</blockquote>
<p>使用：</p>
<ol>
<li>返回Promise</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">asyncData</span>(<span class="params">&#123;params, error&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> axios.<span class="title function_">get</span>(<span class="string">`/api/<span class="subst">$&#123;params.id&#125;</span>`</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">title</span>: res.<span class="property">data</span>.<span class="property">title</span>&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">error</span>(&#123; <span class="attr">statusCode</span>: <span class="number">404</span>, <span class="attr">message</span>: <span class="string">&#x27;not found&#x27;</span> &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用async&#x2F;await</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">asyncData</span>(<span class="params">&#123;params, error&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;data&#125; = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">`/api/<span class="subst">$&#123;params.id&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">title</span>: data.<span class="property">title</span>&#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="title function_">error</span>(&#123; <span class="attr">statusCode</span>: <span class="number">404</span>, <span class="attr">message</span>: <span class="string">&#x27;not found&#x27;</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h3><p>默认Nuxt使用vue-loader、file-loader及url-loader来处理文件的加载和引用。对于不需要通过webpack处理的静态资源文件，可以放置在static目录中</p>
<p><strong>webpack构建</strong></p>
<p>默认情况下, vue-loader自动使用 css-loader 和Vue模板编译器来编译处理vue文件中的样式和模板。在此编译过程中，所有的资源URL例如 <code>&lt;img src=&quot;...&quot;&gt;</code>、 <code>background: url(...)</code> 和 CSS中的 <code>@import</code> 均会被解析成模块通过 require 引用。</p>
<p><strong>静态文件</strong></p>
<p>如果你的静态资源文件需要 Webpack 做构建编译处理，可以放到 assets 目录，否则可以放到 static 目录中去。</p>
<p>Nuxt 服务器启动的时候，该目录下的文件会映射至应用的根路径 &#x2F; 下，像 robots.txt 或 sitemap.xml 这种类型的文件就很适合放到 static 目录中。</p>
<p>你可以在代码中使用根路径 &#x2F; 结合资源相对路径来引用静态资源：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引用 static 目录下的图片 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/my-image.png&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 引用 assets 目录下经过 webpack 构建处理后的图片 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/my-image-2.png&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p><strong>使用第三方模块</strong></p>
<p>在页面内直接 import。但是，如果在另一页面也import相同第三方模块，在打包时该模块会被重复打包，而实际上我们只需要打包一次。该问题可以通过在<code>nuxt.config.js</code>里配置<code>build.vendor</code>来解决：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="attr">vendor</span>: [<span class="string">&#x27;axios&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用Vue插件</strong></p>
<p>plugins里增加相应插件的js文件，如xxx.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// &#x27;~/plugins/xxx&#x27;,</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">src</span>: <span class="string">&#x27;~/plugins/xxx&#x27;</span>,</span><br><span class="line">      <span class="attr">ssr</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有些插件可能只是在浏览器里使用，所以你可以用 ssr: false </span></span><br><span class="line">    <span class="comment">// 来配置插件只从客户端还是服务端运行</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用Vuex"><a href="#使用Vuex" class="headerlink" title="使用Vuex"></a>使用Vuex</h3><p>Nuxt已内置了Vuex，所以不需额外安装和use了。</p>
<p><strong>模块方式</strong></p>
<p>状态树还可以拆分成为模块，store 目录下的每个 .js 文件会被转换成为状态树指定命名的子模块</p>
<p>使用状态树模块化的方式，store&#x2F;index.js 不需要返回 Vuex.Store 实例，而应该直接将 state、mutations 和 actions 暴露出来：</p>
<p><strong>fetch方法</strong></p>
<p>fetch 方法会在渲染页面前被调用，作用是填充状态树 (store) 数据，与 asyncData 方法类似，不同的是它不会设置组件的数据。</p>
<p><strong>nuxtServerInit方法</strong></p>
<p>如果在状态树中指定了<code>nuxtServerInit</code>方法，Nuxt调用它时会将页面的上下文对象作为第2个参数传给它（仅在服务端调用时）。当我们想将服务端数据传到客户端时，就可用此方法。</p>
<p>如，服务端会话状态树可以通过 <code>req.session.user</code> 来访问当前登录用户。将该登录用户信息传给客户端的状态树，只需要更新 <code>store/index.js</code>，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">  <span class="title function_">nuxtServerInit</span>(<span class="params">&#123;commit&#125;, &#123;req&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (req.<span class="property">session</span>.<span class="property">user</span>) &#123;</span><br><span class="line">      <span class="title function_">commit</span>(<span class="string">&#x27;user&#x27;</span>, req.<span class="property">session</span>.<span class="property">user</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你使用状态树模块化的模式，只有主模块（即 store&#x2F;index.js）适用设置该方法（其他模块设置了也不会被调用）。nuxtServerInit 方法接收的上下文对象和 fetch 的一样，但不包括 context.redirect() 和 context.error()。</p>
</blockquote>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">nuxt</td>
<td align="left">启动一个热加载的Web服务器（开发模式） localhost:3000</td>
</tr>
<tr>
<td align="center">nuxt build</td>
<td align="left">利用webpack编译应用，压缩JS和CSS资源（发布用）</td>
</tr>
<tr>
<td align="center">nuxt start</td>
<td align="left">以生成模式启动一个Web服务器 (nuxt build 会先被执行)</td>
</tr>
<tr>
<td align="center">nuxt generate</td>
<td align="left">编译应用，并依据路由配置生成对应的HTML文件 (用于静态站点的部署)</td>
</tr>
</tbody></table>
<hr>
<p>大致就这样了，试着自己折腾一下吧。对了，正好可以把个人网站首页用nuxt重构静态发布~~</p>
<p>生命不息，折腾不止！~</p>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Nuxt</tag>
        <tag>服务端渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>【性能】预渲染技术</title>
    <url>/2017/08/01/f4606c70-af92-11ee-b4b5-bfc5ad7e719f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Prerender-SPA-Plugin"><a href="#Prerender-SPA-Plugin" class="headerlink" title="Prerender SPA Plugin"></a>Prerender SPA Plugin</h2><blockquote>
<p>一个灵活的静态网站构建框架，让你更好地使用webpack为SPA应用打包</p>
</blockquote>
<p>更多请参考官方文档 <a href="https://github.com/chrisvfritz/prerender-spa-plugin">预渲染技术</a></p>
<span id="more"></span>

<p><strong>什么是预渲染？？</strong></p>
<p>服务端渲染在前端界变得越来越主流。在将网页或应用程序发送给客户之前，在服务器就先呈现了我们想展示的内容。这是一个革命性的想法。</p>
<p>然而，对于PHP、ASP、JSP（以及这样的）站点来说，同样的批评对于今天的服务器端呈现是有效的。它很慢，很容易被打破，并且很难正确地实现。问题是，尽管每个人可能会告诉你，你可能不需要SSR。您可以通过使用预先设定来获得几乎所有的优点（没有缺点）。</p>
<p>预渲染的原理是启动一个无头浏览器（如puperteer），加载应用程序的路由，并将结果保存到静态HTML文件中。然后，可使用以前使用的静态文件-文件服务解决方案来服务它。它只适用于HTML5导航和类似的东西。不需要更改代码或添加服务器端渲染工作区。</p>
<hr>
<p><strong>使用场景</strong><br>改善少数营销页面，广告页等的SEO，预渲染就能起到很好的效果.</p>
<p>当然，我们也要承认，在某些场景下，预渲染并不是特别适合：</p>
<ul>
<li>大量的网页和跳转 使用预渲染会很慢，虽然这种场景并没那么多，但不代表不会出现</li>
<li>动态内容 如果网页中有大量的动态内容，Ajax这类，应确保有占位符组件，直到动态内容加载完后才显示出来，否则页面闪动和重绘的开销会得不偿失</li>
</ul>
<h3 id="关于-About-prerender-spa-plugin"><a href="#关于-About-prerender-spa-plugin" class="headerlink" title="关于 About prerender-spa-plugin"></a>关于 About prerender-spa-plugin</h3><p>3.x 版本是基于puppeteer的稳定版本。</p>
<p>该插件的目标是提供一个简单、可扩展的预渲染解决方案，可以用于任何网站或用webpack构建的单页面应用。</p>
<p>当然，前提是其他任务是已构建好并可运行的</p>
<h2 id="Examples-示例"><a href="#Examples-示例" class="headerlink" title="Examples 示例"></a>Examples 示例</h2><p>特定框架例子 可以在源码中找到</p>
<h3 id="Basic-Usage"><a href="#Basic-Usage" class="headerlink" title="Basic Usage"></a>Basic Usage</h3><p>基础用法 webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">PrerenderSPAPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;prerender-spa-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// 省略其他配置</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">PrerenderSPAPlugin</span>(&#123;</span><br><span class="line">      <span class="comment">// 必填，填写output打包出来的路径</span></span><br><span class="line">      <span class="attr">staticDir</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">      <span class="comment">// 必填，需要预渲染的路由</span></span><br><span class="line">      <span class="attr">routes</span>: [<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;/about&#x27;</span>, <span class="string">&#x27;/some/deep/nested/route&#x27;</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Advanced-Usage"><a href="#Advanced-Usage" class="headerlink" title="Advanced Usage"></a>Advanced Usage</h3><p>高级用法 webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">PrerenderSPAPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;prerender-spa-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Renderer</span> = <span class="title class_">PrerenderSPAPlugin</span>.<span class="property">PuppeteerRenderer</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">PrerenderSPAPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">staticDir</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">      <span class="comment">// 可选, 预渲染应该输出到的路径</span></span><br><span class="line">      <span class="attr">outputDir</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;prerendered&#x27;</span>),</span><br><span class="line">      <span class="comment">// 可选，根文档的路径</span></span><br><span class="line">      <span class="attr">indexPath</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>, <span class="string">&#x27;index.html&#x27;</span>),</span><br><span class="line">      <span class="attr">routes</span>: [<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;/about&#x27;</span>, <span class="string">&#x27;/some/deep/nested/route&#x27;</span>],</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 可选 在写入渲染内容到文件之前 允许配置 html和输出路径</span></span><br><span class="line">      <span class="comment">// 可以修改渲染， 也可等待返回。 以下是renderedRoute 的格式：</span></span><br><span class="line">      <span class="comment">// &#123;</span></span><br><span class="line">      <span class="comment">//   route: String, // 输出文件将在何处结束（相对于outputDir)</span></span><br><span class="line">      <span class="comment">//   originalRoute: String, // 在重定向之前，传递给渲染器的路由。.</span></span><br><span class="line">      <span class="comment">//   html: String // 该路由渲染的html</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      <span class="title function_">postProcess</span>(<span class="params">renderedRoute</span>) &#123;</span><br><span class="line">        <span class="comment">// 忽略任何重定向</span></span><br><span class="line">        renderedRoute.<span class="property">path</span> = renderedRoute.<span class="property">originalPath</span></span><br><span class="line">        <span class="comment">// 删除空格. (建议别在生产环境中用)</span></span><br><span class="line">        renderedRoute.<span class="property">html</span> = renderedRoute.<span class="property">html</span>.<span class="title function_">split</span>(<span class="regexp">/&gt;[\s]+&lt;/gmi</span>).<span class="title function_">join</span>(<span class="string">&#x27;&gt;&lt;&#x27;</span>)</span><br><span class="line">        <span class="comment">// 返回renderedRoute, 其实就是对 传入的 对象进行了一次处理，返回的还是该对象</span></span><br><span class="line">        <span class="keyword">return</span> renderedRoute</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 可选，使用 html-minifier  它会压缩html， 更多参考官方</span></span><br><span class="line">      <span class="attr">minify</span>: &#123;</span><br><span class="line">        <span class="attr">collapseBooleanAttributes</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">collapseWhitespace</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">decodeEntities</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">keepClosingSlash</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">sortAttributes</span>: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 服务端配置选项</span></span><br><span class="line">      <span class="attr">server</span>: &#123;</span><br><span class="line">        <span class="comment">// 端口是自动检测的</span></span><br><span class="line">        <span class="attr">port</span>: <span class="number">8001</span></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 渲染器 Renderer的实例，可自行编写</span></span><br><span class="line">      <span class="attr">renderer</span>: <span class="keyword">new</span> <span class="title class_">Renderer</span>(&#123;</span><br><span class="line">        <span class="comment">// 注入到window对象 kv对   window.__PRERENDER_INJECTED 就可以访问到了</span></span><br><span class="line">        <span class="attr">injectProperty</span>: <span class="string">&#x27;__PRERENDER_INJECTED&#x27;</span>,</span><br><span class="line">        <span class="comment">// 可选，可配置想通过 window 对象注入的可访问值</span></span><br><span class="line">        <span class="attr">inject</span>: &#123;</span><br><span class="line">          <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 默认为 0 没有限制 </span></span><br><span class="line">        <span class="comment">// 由于路由是异步加载的，用该属性限制路由的数量</span></span><br><span class="line">        <span class="attr">maxConcurrentRoutes</span>: <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... 更多的看文档吧</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="可用的渲染器"><a href="#可用的渲染器" class="headerlink" title="可用的渲染器"></a>可用的渲染器</h3><ul>
<li>@prerenderer&#x2F;renderer-puppeteer 已经预先准备好了几百页，并希望得到准确的结果 那就是用它吧</li>
<li>@prerenderer&#x2F;renderer-jsdom 你需要提前阅读成千上万页的内容，但是质量并不是那么重要，你愿意为更高级的案例解决问题</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>JS 在 prerender前不运行</li>
</ul>
<p>如果您的代码依赖于“body”的存在，那么只需在domcontent重载事件的回调中运行它：（否则会发现在JS运行之前，预编译-spa-plugin将输出页面的内容）</p>
<pre><code>document.addEventListener(&#39;DOMContentLoaded&#39;, function() &#123;&#125;)
</code></pre>
<p>如果使用 Vue，将 <code>&lt;div id=&quot;root&quot;&gt;</code> mounting 到 body标签上：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123; <span class="comment">/**/</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  app.$mount(<span class="string">&#x27;#root&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>Inline styles 内联样式</strong></p>
<p>如果您依赖于内联CSS，也就是说，您不会从捆绑包中提取CSS，因此，体验重复的CSS样式标签，可以考虑使用 <code>extract-text-webpack-plugin</code> 将CSS提取到单独的文件中。然后将CSS注入到模板中。使用 <code>html-webpack-plugin</code> 的html文件，或者将其称为外部CSS文件。</p>
<p>无论哪种方式，JS中都不会有任何不必要的样式。</p>
<h3 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h3><ul>
<li><p>出于显而易见的原因，预安装-spa-插件只适用于使用HTML5历史API的spa。索引。不幸的是，html&#x2F;hash&#x2F;路由url将无法工作</p>
</li>
<li><p>vue2+ 确保你的根组件与它所替换的预先设计的元素具有相同的id。否则，您将得到重复的内容</p>
</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>预渲染</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】栈、队列、链表及其区别</title>
    <url>/2018/07/20/1225e230-af93-11ee-957d-f9039c72398b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>写这篇是因为之前在群里看到小伙伴在讨论算法相关知识，对于前端来说，这块也是很重要嘛，正好把之前没看完的那本电子书，《学习JavaScript数据结构与算法》复习下~</p>
</blockquote>
<span id="more"></span>

<h2 id="栈数据结构"><a href="#栈数据结构" class="headerlink" title="栈数据结构"></a>栈数据结构</h2><p>栈是一种遵从后进先出(LIFO, Last in First out)原则的有序集合。新添加的或待删除的元素都保存在栈的同一端，称作栈顶，另一端叫作栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。</p>
<hr>
<p>我们只是用ES6的简化语法把Stack函数转换成类。但变量items却是公共的，ES6的类是基于原型的，虽然基于原型的类比基于函数的类更节省内存，也更适合创建多个实例，却不能够声明私有属性或方法，而且，在这种情况下，我们希望Stack类的用户只能访问暴露给类的方法，否则就有可能从栈的中间移除元素（因为我们用数组来存储其值）</p>
<p>以下是ES6方法，创建私有属性的方式：</p>
<ul>
<li>用ES6的限定作用域Symbol实现类</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _items = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>[_items] = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// stack方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法创建了一个假的私有属性，因为 Object.getOwnPropertySymbols能够取到类里面声明的所有Symbols属性</p>
<p>下面是一个破坏Stack类的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">5</span>);</span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">let</span> objectSymbols = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(stack);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objectSymbols.<span class="property">length</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objectSymbols); <span class="comment">// [Symbol()]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objectSymbols[<span class="number">0</span>]); <span class="comment">// Symbol()</span></span><br><span class="line">stack[objectSymbols[<span class="number">0</span>]].<span class="title function_">push</span>(<span class="number">1</span>);</span><br><span class="line">stack.<span class="title function_">print</span>(); <span class="comment">// 5, 8, 1</span></span><br></pre></td></tr></table></figure>

<p>访问stack[objectSymbols[0]]是可以得到_items的，并且_items属性是一个数组，可以进行任意的数组操作，于是还有下面的方案：</p>
<p>用ES6的WeakMap实现类</p>
<p>有一种数据类型可以确保属性是私有的，这就是WeakMap，现在只需要知道WeakMap可以存储键值对，其中键是对象，值可以是任意数据类型。</p>
<p>如果用WeakMap类存储items变量，Stack类就是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    items.<span class="title function_">set</span>(<span class="variable language_">this</span>, [])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">push</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> s = items.<span class="title function_">get</span>(<span class="variable language_">this</span>);</span><br><span class="line">    s.<span class="title function_">push</span>(element);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> s = items.<span class="title function_">get</span>(<span class="variable language_">this</span>);</span><br><span class="line">    r = s.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们知道items在Stack类里是真正的私有属性了，但还有一件事要做。items现在仍然是在Stack类以外声明的，因此谁都可以改动它。我们要用一个闭包（外层函数）把Stack类包起来，这样就只能在这个函数里访问WeakMap：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Stack</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> items = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">      items.<span class="title function_">set</span>(<span class="variable language_">this</span>, []);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Stack</span>;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>完整代码示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向栈添加元素</span></span><br><span class="line">  <span class="title function_">push</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">push</span>(element);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从栈移除元素</span></span><br><span class="line">  <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 查看栈顶元素</span></span><br><span class="line">  <span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 检查栈是否为空</span></span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`当前栈是否为空：<span class="subst">$&#123;<span class="variable language_">this</span>.items.length === <span class="number">0</span>&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清空栈元素</span></span><br><span class="line">  <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`当前栈的元素有<span class="subst">$&#123;<span class="variable language_">this</span>.items.length&#125;</span>个`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 打印栈元素</span></span><br><span class="line">  <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">toString</span>())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line"><span class="comment">// console.log(stack.isEmpty())</span></span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">5</span>)</span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">8</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">peek</span>())</span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">11</span>)</span><br><span class="line">stack.<span class="title function_">size</span>()</span><br><span class="line">stack.<span class="title function_">isEmpty</span>()</span><br><span class="line">stack.<span class="title function_">pop</span>();</span><br><span class="line">stack.<span class="title function_">pop</span>();</span><br><span class="line">stack.<span class="title function_">size</span>()</span><br></pre></td></tr></table></figure>

<h2 id="队列数据结构"><a href="#队列数据结构" class="headerlink" title="队列数据结构"></a>队列数据结构</h2><p>队列是遵循FIFO(First In First Out，先进先出)原则的一组有序的项。<br>队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾。</p>
<h3 id="JS任务队列"><a href="#JS任务队列" class="headerlink" title="JS任务队列"></a>JS任务队列</h3><p>当我们在浏览器中打开新标签时，就会创建一个任务队列。这是因为每个标签都是单线程处理所有的任务，它被称为事件循环。<br>浏览器要负责多个任务，如渲染HTML，执行JS代码，处理用户交互（输入、点击等），执行和处理异步请求。</p>
<p>代码示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建队列</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Queue</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> items = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">      items.<span class="title function_">set</span>(<span class="variable language_">this</span>, []);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向队列添加元素</span></span><br><span class="line">    <span class="title function_">enqueue</span>(<span class="params">elem</span>) &#123;</span><br><span class="line">      items.<span class="title function_">push</span>(elem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向队列移除元素</span></span><br><span class="line">    <span class="title function_">dequeue</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> items.<span class="title function_">shift</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看队列头元素</span></span><br><span class="line">    <span class="title function_">front</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(items[<span class="number">0</span>])</span><br><span class="line">      <span class="keyword">return</span> items[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查队列是否为空</span></span><br><span class="line">    <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`是否为空：<span class="subst">$&#123;items.length === <span class="number">0</span>&#125;</span>`</span>)</span><br><span class="line">      <span class="keyword">return</span> items.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`队列长度为：<span class="subst">$&#123;items.length&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">return</span> items.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印队列元素</span></span><br><span class="line">    <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(items.<span class="title function_">valueOf</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 使用Queue类</span></span><br><span class="line"><span class="keyword">let</span> queue = <span class="keyword">new</span> <span class="title class_">Queue</span>();</span><br><span class="line">queue.<span class="title function_">isEmpty</span>();</span><br><span class="line">queue.<span class="title function_">enqueue</span>(<span class="string">&#x27;John&#x27;</span>);</span><br><span class="line">queue.<span class="title function_">enqueue</span>(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line">queue.<span class="title function_">enqueue</span>(<span class="string">&#x27;Camila&#x27;</span>);</span><br><span class="line">queue.<span class="title function_">print</span>();</span><br></pre></td></tr></table></figure>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表是种动态的数据结构，这意味着我们可以从中任意添加或移除项，它会按需进行扩充。</p>
<p>要存储多个元素，数组（或列表）可能是最常用的数据结构。每种语言都实现了数组，它提供了一个便利的[]语法来访问其元素。然而这种数据结构有一种缺点，其数组大小是固定的。<br>从数组的起点或中间插入或移除项的成本很高，因为它需要移动元素（尽管我们知道JS的Array类可以帮我们做这类事，但情况还是相同）<br>链表存储有序的元素集合，但不同于数组，链表的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称为指针或链接）组成。<br>相对于传统的数组，链表的好处在于，添加或移除元素时不需要移动其他元素。然而，链表需要使用指针，因此实现链表时需要额外注意。数组的另一个细节是可以直接访问任何位置的任何元素。而想要访问链表中间的一个元素，需要从起点（表头）开始迭代列表直到找到所需元素。</p>
<p>完整代码示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">LinkedList</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">Node</span> = <span class="keyword">function</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">element</span> = element</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> length = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> head = <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 向列表尾部添加一个新的项</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">append</span> = <span class="keyword">function</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(element)</span><br><span class="line">    <span class="keyword">let</span> current</span><br><span class="line">    <span class="comment">// 列表中第一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (head === <span class="literal">null</span>) &#123;</span><br><span class="line">      head = node</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      current = node</span><br><span class="line">      <span class="comment">// 循环列表，直到找到最后一项</span></span><br><span class="line">      <span class="keyword">while</span> (current.<span class="property">next</span>) &#123;</span><br><span class="line">        current = current.<span class="property">next</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 找到最后一项，将其next赋为node，建立连接</span></span><br><span class="line">      current.<span class="property">next</span> = node</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新列表长度</span></span><br><span class="line">    length++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 向列表的特定位置插入一个新的项</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">insert</span> = <span class="keyword">function</span>(<span class="params">position, element</span>) &#123;</span><br><span class="line">    <span class="comment">// 检查越界值</span></span><br><span class="line">    <span class="keyword">if</span> (position &gt;= <span class="number">0</span> &amp;&amp; position &lt;= length) &#123;</span><br><span class="line">      <span class="keyword">let</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(element)</span><br><span class="line">      <span class="keyword">let</span> current = head</span><br><span class="line">      <span class="keyword">let</span> previous</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">      <span class="comment">// 在第一个位置添加</span></span><br><span class="line">      <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">        node.<span class="property">next</span> = current</span><br><span class="line">        head = node</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">          previous = current</span><br><span class="line">          current = current.<span class="property">next</span></span><br><span class="line">        &#125;</span><br><span class="line">        node.<span class="property">next</span> = current</span><br><span class="line">        previous.<span class="property">next</span> = node</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新列表长度</span></span><br><span class="line">      length++</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从列表的特定位置移除一项</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">removeAt</span> = <span class="keyword">function</span>(<span class="params">position</span>) &#123;</span><br><span class="line">    <span class="comment">// 检查越界值</span></span><br><span class="line">    <span class="keyword">if</span> (position &gt; -<span class="number">1</span> &amp;&amp; position &lt; length) &#123;</span><br><span class="line">      <span class="keyword">let</span> current = head</span><br><span class="line">      <span class="keyword">let</span> previous</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">      <span class="comment">// 移除第一项</span></span><br><span class="line">      <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">        head = current.<span class="property">next</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">          previous = current</span><br><span class="line">          current = current.<span class="property">next</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将previous与current的下一项连接起来；跳过current，从而移除它</span></span><br><span class="line">        previous.<span class="property">next</span> = current.<span class="property">next</span></span><br><span class="line">      &#125;</span><br><span class="line">      length--</span><br><span class="line">      <span class="keyword">return</span> current.<span class="property">element</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从列表中移除一项</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="variable language_">this</span>.<span class="title function_">indexOf</span>(element)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">removeAt</span>(index)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回元素在列表中的索引，若列表中没有该元素则返回-1</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">indexOf</span> = <span class="keyword">function</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = head</span><br><span class="line">    <span class="keyword">let</span> index = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">      <span class="keyword">if</span> (element === current.<span class="property">element</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> index</span><br><span class="line">      &#125;</span><br><span class="line">      index++</span><br><span class="line">      current = current.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">isEmpty</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> length === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回链表包含的元素个数，与数组的length属性类似</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> length</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getHead</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 由于列表项使用了Node类，就需要重写继承自JS默认的toString方法，让其只输出元素值</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 首先要访问列表中的所有元素，就需要有一个起点，也就是head。我们会把current变量当作索引，控制循环访问列表</span></span><br><span class="line">    <span class="comment">// 我们还需要初始化用于拼接元素值的变量，接下来就是循环访问列表中的每个元素</span></span><br><span class="line">    <span class="comment">// 我们要用current来检查元素是否存在，然后得到元素内容进行拼接</span></span><br><span class="line">    <span class="comment">// 最后迭代下一个元素，最终返回列表内容的字符串</span></span><br><span class="line">    <span class="keyword">let</span> current = head</span><br><span class="line">    <span class="keyword">let</span> string = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">      string += current.<span class="property">element</span> + (current.<span class="property">next</span> ? <span class="string">&#x27;n&#x27;</span> : <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      current = current.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> string</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">print</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> md1 = <span class="string">`</span></span><br><span class="line"><span class="string">  LinkedList数据结构还需要一个Node辅助类。Node类表示要加入列表的项，它包含一个element属性，即要添加到列表的值，以及一个next属性，即指向列表中下一个节点项的指针。</span></span><br><span class="line"><span class="string">  LinkedList类也有存储列表项的数组的length属性（是一个私有变量）</span></span><br><span class="line"><span class="string">  另一个重要点是，我们还需要存储第一个节点的引用。为此，可以把这个引用存储在称为head的变量中</span></span><br><span class="line"><span class="string">  然后就是LinkedList类的方法</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<h3 id="链表优点"><a href="#链表优点" class="headerlink" title="链表优点"></a>链表优点</h3><ol>
<li><p>使用链表数据结构可以克服数组链表需要预先知道数据大小的缺点，链表数据结构可以充分内存空间，实现灵活的内存动态管理</p>
</li>
<li><p>数据的存取往往要在不同的排列顺序中转换，而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的指针。链表允许插入和移除链表上任意位置上的节点，但是不允许随机存取</p>
</li>
</ol>
<h3 id="链表缺点"><a href="#链表缺点" class="headerlink" title="链表缺点"></a>链表缺点</h3><p>链表失去了数组随机读取的优点，同时链表由于增加了节点的指针域，空间开销比较大</p>
<hr>
<p>先到这里，后面再补充吧~~</p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>【总结】2023年底面临的危机及一些反思</title>
    <url>/2023/12/31/2387cab0-af8f-11ee-82f7-d739bc345d4e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="吐槽（为什么又开始写博客了）"><a href="#吐槽（为什么又开始写博客了）" class="headerlink" title="吐槽（为什么又开始写博客了）"></a>吐槽（为什么又开始写博客了）</h1><blockquote>
<p>2016年毕业，恰逢互联网的蓬勃发展，我选择了前端岗位。那时，技术更新速度惊人，从jQuery的面向对象开发模式逐渐过渡到利用现代构建工具、React、Vue等框架实现高效开发。为了不断迎接新的挑战，我始终不停地学习。 随着工作逐渐稳定，我将更多的重心放在了生活和家庭上，这是理所应当的事情。我曾认为中年危机只存在于段子中，与我尚有一段距离，然而却发现它悄然降临，带来了无尽的焦虑和大数据带来的各种烦恼和负能量。对此，我感到抗拒和迷茫。在短暂的自我调整中，我偶然翻阅了之前看了一半的《学习产品思维》，受益匪浅。 因此，我决定写下这篇博客，以此吹响“反击”的号角。</p>
</blockquote>
<span id="more"></span>


<p>运用产品思维的一个好处就是可以跳脱当前，站在一个客观的角度俯瞰全局，在此就预设一个命题来进行思考——如何看待当下的失业危机，该怎样调整和应对？</p>
<h1 id="明确目的"><a href="#明确目的" class="headerlink" title="明确目的"></a>明确目的</h1><h2 id="解决焦虑，设定目标"><a href="#解决焦虑，设定目标" class="headerlink" title="解决焦虑，设定目标"></a>解决焦虑，设定目标</h2><p>焦虑无非是不知道做什么，对自己能力的不自信，从而产生的一种大众跟随情绪。但自从学完了产品思维后，不良情绪逐渐消散。设定了许许多许的可完成的目标，那还有什么理由停留不前呢？</p>
<h2 id="接受现实，坦然面对"><a href="#接受现实，坦然面对" class="headerlink" title="接受现实，坦然面对"></a>接受现实，坦然面对</h2><p>首先要处理的是年底前（元旦后可能还会有一些工作）的对接工作，需要特别注意的是：</p>
<ol>
<li>✅ 19年和21年某几个项目文档，做好注释不留坑；</li>
<li>✅ 对于搭建环境时不同Node版本可能遇到的一些问题；</li>
<li>✅ 另外需要提交当前维护的两个项目的代码，并添加注释；</li>
<li>✅ 顺利完成交接。</li>
</ol>
<p>对于公司欠薪的情况感到遗憾，但生活仍将继续。我会选择通过劳动仲裁途径来维护自己的权益，这也积累了一些仲裁经验，希望将来不会再用到这些经验。</p>
<h2 id="在公司六年工作的总结"><a href="#在公司六年工作的总结" class="headerlink" title="在公司六年工作的总结"></a>在公司六年工作的总结</h2><p>这里就不写太多了，作为一个引子，会把相关内容移到另一个在线简历项目中，这里写个大纲：</p>
<ul>
<li>完成的项目<ul>
<li>时间</li>
<li>收益</li>
<li>技术架构</li>
<li>难点</li>
<li>启发</li>
</ul>
</li>
<li>经验<ul>
<li>团队管理</li>
<li>项目管理</li>
<li>项目维护</li>
</ul>
</li>
<li>个人<ul>
<li>贡献</li>
<li>优势</li>
<li>不足</li>
</ul>
</li>
</ul>
<h2 id="如何调整"><a href="#如何调整" class="headerlink" title="如何调整"></a>如何调整</h2><p>写到这里，压力和负担感已经减轻了许多。我在本地启动了之前的博客备份，被同事们看到后，还收到了一顿彩虹屁 XD<br> 加油吧，我们江湖再见！~</p>
<p>到现在其实心理上已不再感到沉重，只需要把目标转化为行动，并坚持下去^_^ 不断获取反馈，及时调整，相信自己一定可以克服这道难关。</p>
<h2 id="如何应对"><a href="#如何应对" class="headerlink" title="如何应对"></a>如何应对</h2><p>结合着个人情况设立了以下目标，并会根据实际情况做出反馈及时更新该篇博客。</p>
<ol start="0">
<li>设定阶段计划 与 每天学习计划</li>
</ol>
<ul>
<li>保持学习状态，按计划执行</li>
<li>若因家事等不能执行，也要留出1h进行阅读</li>
<li>让github重新活跃起来</li>
</ul>
<ol>
<li>个人网站重新搭建</li>
</ol>
<ul>
<li>✅<del>购买服务器、恢复域名</del></li>
<li>✅<del>2024年1月中旬左右完成备案</del></li>
<li>✅<del>备案搞定后技术博客更新，部署上线</del></li>
</ul>
<ol start="2">
<li>23年底做完资料大整理</li>
</ol>
<ul>
<li>✅ <del>学习云盘，个人移动盘资料内容同步更新、整理</del></li>
<li>✅ <del>github、gitee垃圾项目，fork等清理</del></li>
<li>✅ <del>[fridolph]学习项目，按新的目录重新分类、整理</del></li>
<li>✅ 制定1-2月的学习计划，并开始执行</li>
</ul>
<ol start="3">
<li>技术学习提高 与 博客上新计划</li>
</ol>
<ul>
<li>✅ 完成vue3组件库项目</li>
<li>⏳ 看书，刷面试题  </li>
<li>⏳ 整理知识点，每周至少产出一篇博客</li>
</ul>
<ol start="4">
<li><del>恢复驾驶资格（悲催，忙着忘换驾照超过一年）</del> 后面再说  <!-- - [&#x2716;] 计划2月考过科目一（下载驾考宝典，每天至少刷50道题库） -->
  <!-- - [&#x2716;] 预约考试前一周 去指定医院 进行C1的体检. 计划1月8日 拍一寸免冠白底照，app上预约考科目一 -->
  <!-- - [&#x2716;] 通过科目一，成功换驾照 --></li>
</ol>
<h2 id="温故知新，迎接挑战"><a href="#温故知新，迎接挑战" class="headerlink" title="温故知新，迎接挑战"></a>温故知新，迎接挑战</h2><p>相信自己，回想一下毕业时找工作的情形吧。需要把知识形成体系，多借助思维脑图，把掌握的东西表达出来即可。</p>
<h1 id="准备面试"><a href="#准备面试" class="headerlink" title="准备面试"></a>准备面试</h1><ul>
<li>✅ 用vue3+ts重构<code>myresume</code>项目部署上线</li>
<li>⏳ 更新个人简历pdf，并同步到BOSS直聘、拉钩（可趁着春节前后）</li>
<li>⏳ 完善开源项目 FE-prepare-interview</li>
</ul>
<blockquote>
<p>ps <code>myresume</code>是之前自己写着玩的项目，正好趁此机会升级一波，看看能不能加点新东西，保持活力。有那么点想法了，看有否有时间去完善吧</p>
</blockquote>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>写在最后<br>作为一名理科生，写作真的是一道不易跨越的坎坷…… ORZ，但带有明确定义的写作目标会让动笔变得更容易一些。我们可以尽量遵循SMART原则，给自己一定的反馈和奖励，从而让自己能够持之以恒。</p>
<p>每个人都处于自己当下的环境中，要相信自己，相信你能够做到，加油！</p>
<p>希望自己能找到一份不996、少加班且有双休的工作，也祝愿家人朋友们健康平安！</p>
]]></content>
      <categories>
        <category>随笔随想</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>【解决方案】移动端布局解决hotcss</title>
    <url>/2018/03/29/8ab67ce0-af94-11ee-b271-6d57d4b0c8c6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>号称移动端布局终极解决方案。其实现非常简洁，但功能却不是盖的。在最近准备做的一个项目中会用到该解决方案，知根知底最好的办法便是学习官方文档和敲源码了。嗯，感觉这法还好，于是废话不多说，开始正文吧</p>
</blockquote>
<span id="more"></span>

<h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><a href="http://imochen.github.io/hotcss/">hotcss</a> 官网称这是一个移动端布局开发的解决方案，使用动态HTML根字体大小和动态viewport scale。之前有一篇很火的讲述移动端布局的，介绍了淘宝、网易几家大厂的实现方式，这里的不同也就是在这个动态viewport scale上了吧。</p>
<p>其优势在于：</p>
<ul>
<li>保证不同设备下的统一视觉体验。</li>
<li>不需要你再手动设置viewport，根据当前环境计算出最适合的viewport。</li>
<li>支持任意尺寸的设计图，不局限于特定尺寸的设计图。</li>
<li>支持单一项目，多种设计图尺寸，专为解决大型，长周期项目。</li>
<li>提供px2rem转换方法，CSS布局，零成本转换，原始值不丢失。</li>
<li>有效解决移动端真实1像素问题。</li>
</ul>
<p><strong>用法</strong></p>
<p>直接引入</p>
<pre><code>&lt;script src=&quot;/path/to/hotcss.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h3 id="css写法"><a href="#css写法" class="headerlink" title="css写法"></a>css写法</h3><p>推荐使用scss来编写css，在scss文件的头部使用import将px2rem导入</p>
<pre><code>@import &#39;/path/to/px2rem.scss&#39;;
</code></pre>
<p>如果项目是单一尺寸设计图，那么你需要去px2rem.scss中定义全局的designWidth。</p>
<pre><code>@function px2rem( $px )&#123;
  @return $px*320/$designWidth/20 + rem;
&#125;
$designWidth : 750; //如设计图是750
</code></pre>
<p>如果你的项目是多尺寸设计图，那么就不能定义全局的designWidth了。需要在你的业务scss中单独定义。如以下是style.scss</p>
<pre><code>@import &#39;/path/to/px2rem.scss&#39;;
$designWidth : 750; //如设计图是750
</code></pre>
<p>$designWidth必须要在使用px2rem前定义。否则scss编译会出错。</p>
<h2 id="hotcss-源码学习"><a href="#hotcss-源码学习" class="headerlink" title="hotcss 源码学习"></a>hotcss 源码学习</h2><p>上面的是用来初（凑）步（字）认（数）识的，果断还是要从源码着手，才能拨云见雾。</p>
<p>项目目录</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">├── example	<span class="comment">//所有的示例都在这个目录下</span></span><br><span class="line">│   ├── duang</span><br><span class="line">│   ├── normal</span><br><span class="line">│   └── wolf</span><br><span class="line">│</span><br><span class="line">└── src	<span class="comment">//主要文件在这里</span></span><br><span class="line">    ├── hotcss.<span class="property">js</span></span><br><span class="line">    ├── px2rem.<span class="property">less</span></span><br><span class="line">    ├── px2rem.<span class="property">scss</span></span><br><span class="line">    └── px2rem.<span class="property">styl</span></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;(<span class="keyword">function</span>(<span class="params">widnow, <span class="variable language_">document</span></span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// 给hotcss开辟个命名空间，暴露给外部访问</span></span><br><span class="line">  <span class="keyword">var</span> hotcss = &#123;&#125;</span><br><span class="line">  ;(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 根据devicePixelRatio自定计算scale</span></span><br><span class="line">    <span class="comment">// 可以有效解决移动端1px问题</span></span><br><span class="line">    <span class="keyword">var</span> viewportEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=&quot;viewport&quot;]&#x27;</span>),</span><br><span class="line">      hotcssEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;meta[name=&quot;hotcss&quot;]&#x27;</span>),</span><br><span class="line">      dpr = <span class="variable language_">window</span>.<span class="property">devicePixelRatio</span> || <span class="number">1</span>, <span class="comment">// 默认给1</span></span><br><span class="line">      maxWidth = <span class="number">540</span>,  <span class="comment">// 这个最大宽度是可以手动调整的，表示我们支持的最大宽度</span></span><br><span class="line">      designWidth = <span class="number">0</span>  <span class="comment">// 该值最终为设计稿宽度 比如 ip5 320 实际计算得 640    </span></span><br><span class="line">    <span class="comment">// 这里有点绕，一句话说就是，dpr超过3的按3算，2-3之间按2算，1-2之间按1算</span></span><br><span class="line">    dpr = dpr &gt;= <span class="number">3</span> ? <span class="number">3</span> : (dpr &gt;= <span class="number">2</span> ? <span class="number">2</span> : <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 允许通过自定义name为hotcss的meta头，通过initial-dpr来强制页面缩放</span></span><br><span class="line">    <span class="keyword">if</span> (hotcssEl) &#123;</span><br><span class="line">      <span class="keyword">var</span> hotcssCon = hotcssEl.<span class="title function_">getAttribute</span>(<span class="string">&#x27;content&#x27;</span>) <span class="comment">// 拿meta的content</span></span><br><span class="line">      <span class="keyword">if</span> (hotcssCon) &#123;</span><br><span class="line">        <span class="comment">// 搞不清楚运行一下就好， &#x27;initial-dpr=2.333&#x27;.match(/initial\-dpr=([\d\.]+)/)</span></span><br><span class="line">        <span class="comment">// 返回数组 [&#x27;initial-dpr=2.333&#x27;, &#x27;2.333&#x27;] </span></span><br><span class="line">        <span class="keyword">var</span> initialDprMatch = hotcssCon.<span class="title function_">match</span>(<span class="regexp">/initial\-dpr=([\d\.]+)/</span>)</span><br><span class="line">        <span class="keyword">if</span> (initialDprMatch) &#123;</span><br><span class="line">          <span class="comment">// 实际上取 上数组的第1项 即具体数值</span></span><br><span class="line">          dpr = <span class="built_in">parseFloat</span>(initialDprMatch[<span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> maxWidthMatch = hotcssCon.<span class="title function_">match</span>(<span class="regexp">/max\-width=(\d\.)+/</span>)</span><br><span class="line">        <span class="keyword">if</span> (maxWidthMatch) &#123;</span><br><span class="line">          <span class="comment">// 同上，拿到了最大宽度</span></span><br><span class="line">          maxWidth = <span class="built_in">parseFloat</span>(maxWidthMatch[<span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> designWidthMatch = hotcssCon.<span class="title function_">match</span>(<span class="regexp">/degisn\-width=([\d\.]+)/</span>)</span><br><span class="line">        <span class="keyword">if</span> (designWidthMatch) &#123;</span><br><span class="line">          <span class="comment">// 这个设计宽度很重要，下面会将到</span></span><br><span class="line">          designWidth = <span class="built_in">parseFloat</span>(designWidthMatch[<span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给html设置 data-dpr属性</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;data-dpr&#x27;</span>, dpr)</span><br><span class="line">    <span class="comment">// 同时为hotcss对象 添加属性 dpr</span></span><br><span class="line">    hotcss.<span class="property">dpr</span> = dpr</span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;max-width&#x27;</span>, maxWidth)</span><br><span class="line">    hotcss.<span class="property">maxWidth</span> = maxWidth</span><br><span class="line">    <span class="keyword">if</span> (designWidth) &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;design-width&#x27;</span>, designWidth)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保证 px2rem 和 rem2px 不传第二个参数时，获取 hotcss.desgnWidth 是 undefined导致的NaN</span></span><br><span class="line">    hotcss.<span class="property">designWidth</span> = designWidth</span><br><span class="line">    <span class="keyword">var</span> scale = <span class="number">1</span> / dpr,</span><br><span class="line">      <span class="comment">// 注：我觉得麻烦就改成es6写法了，作者为兼容性用的 + 来拼接，这段大家写viewport都很熟悉吧</span></span><br><span class="line">      content = <span class="string">`width=device-width, initial-scale=<span class="subst">$&#123;scale&#125;</span>, minimum-scale=<span class="subst">$&#123;scale&#125;</span>, maximum-scale=<span class="subst">$&#123;scale&#125;</span>, user-scalable=no`</span></span><br><span class="line">    <span class="comment">// 容错处理，如果没写viewport作者大大很和善地帮加上了</span></span><br><span class="line">    <span class="keyword">if</span> (viewportEl) &#123;</span><br><span class="line">      viewportEl.<span class="title function_">setAttribute</span>(<span class="string">&#x27;content&#x27;</span>, content)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      viewportEl = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;meta&#x27;</span>)</span><br><span class="line">      viewportEl.<span class="title function_">setAttribute</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;viewport&#x27;</span>)</span><br><span class="line">      viewportEl.<span class="title function_">setAttribute</span>(<span class="string">&#x27;content&#x27;</span>, <span class="string">&#x27;content&#x27;</span>)</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(viewportEl)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)()</span><br><span class="line">  <span class="comment">// 其实到这里为止还没开始重头戏，前戏为，我们将 html文档设置了需要的前置属性</span></span><br><span class="line">  <span class="comment">// meta-dpr max-width design-width 通过这3个值就能进行以下的适配工作了</span></span><br><span class="line">  hotcss.<span class="property">px2rem</span> = <span class="keyword">function</span>(<span class="params">px, designWidth</span>) &#123;</span><br><span class="line">    <span class="comment">// 预判你将会在JS中用到尺寸，特提供一个方法助你在JS中将px转为rem</span></span><br><span class="line">    <span class="keyword">if</span> (!designWidth) &#123;</span><br><span class="line">      <span class="comment">// 如果在JS中大量用到此方法，建议直接定义 hotcss.designWidth 来定义设计图尺寸</span></span><br><span class="line">      <span class="comment">// 否则可以在第二个参数告诉设计图是多大</span></span><br><span class="line">      designWidth = <span class="built_in">parseInt</span>(hotcss.<span class="property">designWidth</span>, <span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按320宽 与 设计图比例 进行 20份等比分配</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(px, <span class="number">10</span>) * <span class="number">320</span> / designWidth / <span class="number">20</span></span><br><span class="line">  &#125;</span><br><span class="line">  hotcss.<span class="property">rem2px</span> = <span class="keyword">function</span>(<span class="params">rem, designWidth</span>) &#123;</span><br><span class="line">    <span class="comment">// 新增一个rem2px的方法，用法和 px2rem 一致</span></span><br><span class="line">    <span class="keyword">if</span> (!designWidth) &#123;</span><br><span class="line">      designWidth = <span class="built_in">parseInt</span>(hotcss.<span class="property">designWidth</span>, <span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// rem可能为小数，这里暂不作处理</span></span><br><span class="line">    <span class="comment">// rem是 以320标准和设计图尺寸比 除以20份 得到的，这里反过来求得 px</span></span><br><span class="line">    <span class="keyword">return</span> rem * <span class="number">20</span> * designWidth / <span class="number">320</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 核心方法，给html 设置 font-size, 因为 rem是基于 根元素的fontsize</span></span><br><span class="line">  hotcss.<span class="property">mresize</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// getBoundingClientRect()有少数兼容性问题</span></span><br><span class="line">    <span class="keyword">var</span> innerWidth = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">getBoundingClientRect</span>().<span class="property">width</span> || <span class="variable language_">window</span>.<span class="property">innerWidth</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 我们之前给hotcss设了最大宽度，这是一个处理边界</span></span><br><span class="line">    <span class="comment">// 假设 苹果xxx 宽度是 2560 / 3 = 853，我们处理的最大宽为 600， 则说明走以下逻辑， 反之则重设innerWidth</span></span><br><span class="line">    <span class="keyword">if</span> (hotcss.<span class="property">maxWidth</span> &amp;&amp; (innerWidth / hotcss.<span class="property">dpr</span> &gt; hotcss.<span class="property">maxWidth</span>)) &#123;</span><br><span class="line">      innerWidth = hotcss.<span class="property">maxWidth</span> * hotcss.<span class="property">dpr</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!innerWidth) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 还记得我们将设计图尺寸切分成20份吗。dpr已用于innerWidth计算了。这里按320宽还原回去</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">style</span>.<span class="property">fontSize</span> = (innerWidth * <span class="number">20</span> / <span class="number">320</span>) + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    <span class="comment">// 有回调则执行回调</span></span><br><span class="line">    hotcss.<span class="property">callback</span> &amp;&amp; hotcss.<span class="title function_">callback</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 先直接调用一次，调用后， html根元素被设置了：</span></span><br><span class="line">  <span class="comment">// data-dpr、max-width、design-width、font-size</span></span><br><span class="line">  hotcss.<span class="title function_">mresize</span>() </span><br><span class="line">  <span class="comment">// 接下来的 即函数节流了，用于性能优化</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(hotcss.<span class="property">tid</span>)</span><br><span class="line">    <span class="comment">// 这个时间可按实际需求更改</span></span><br><span class="line">    hotcss.<span class="property">tid</span> = <span class="built_in">setTimeout</span>(hotcss.<span class="property">mresize</span>, <span class="number">33</span>)</span><br><span class="line">  &#125;, <span class="literal">false</span>)</span><br><span class="line">  <span class="comment">// 这里可理解为初始化，load后先执行一次</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, hotcss.<span class="property">mresize</span>, <span class="literal">false</span>) </span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    hotcss.<span class="title function_">mresize</span>()</span><br><span class="line">    <span class="comment">// 这里作者为保险又调用了一次，真是小心谨慎啊</span></span><br><span class="line">  &#125;, <span class="number">333</span>)</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">hotcss</span> = hotcss</span><br><span class="line">  <span class="comment">// 命名空间暴露出来，控制权也暴露了，需要时可手动调用以处理某些特别需求</span></span><br><span class="line">&#125;)(<span class="variable language_">window</span>, <span class="variable language_">document</span>)</span><br></pre></td></tr></table></figure>

<p>还不错，加上注释也没多少行代码，为以后读大段源码打下了基础…… 误。。。 看到这里，其实和之前淘宝 rem 解决方案差不多，这里只是进行整合。<br>我们可以简单回顾一下，脚本执行后 为window添加全局变量hotcss。在其中可以调用 hotcss.mresize方法，设置几大重要值，随着屏幕尺寸的改变，font-size也会跟着变，从而让我们写在代码中的rem值也随之调整，这样就实现了移动端的适配。</p>
<h3 id="接口说明"><a href="#接口说明" class="headerlink" title="接口说明"></a>接口说明</h3><p><strong>initial-dpr</strong></p>
<p>可以通过强制设置dpr。来关闭响应的viewport scale。使得viewport scale始终为固定值。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;hotcss&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-dpr=1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/path/to/hotcss.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">如iphone微信强设dpr=1，则可以长按识别二维码。</span></span><br><span class="line"><span class="comment">注意，强制设置dpr=1后，css中的1px在2x，3x屏上则不再是真实的1px。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>max-width</strong><br>通过设置该值来优化平板&#x2F;PC访问体验，注意该值默认值为540。设置为0则该功能关闭。 为了配合使用该设置，请给body增加样式width:16rem;margin:0 auto;。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;hotcss&quot;</span> <span class="attr">content</span>=<span class="string">&quot;max-width=640&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/path/to/hotcss.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">默认为540，可根据具体需求自己定义</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">16rem</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>design-width</strong><br>通过对design-width的设置可以在本页运行的JS中直接使用hotcss.px2rem&#x2F;hotcss.rem2px方法，无需再传递第二个值。</p>
<meta name="hotcss" content="design-width=750">
<script src="/path/to/hotcss.js"></script>

<p><strong>hotcss.mresize</strong><br>用于重新计算布局，一般不需要你手动调用。</p>
<pre><code>hotcss.mresize();
</code></pre>
<p><strong>hotcss.callback</strong><br>触发mresize的时候会执行该方法。</p>
<pre><code>hotcss.callback = function()&#123;
  //your code here
&#125;
</code></pre>
<p>单位转换 <code>hotcss.px2rem</code> &#x2F; <code>hotcss.rem2px</code><br>hotcss.px2rem 和 hotcss.rem2px。你可以预先设定hotcss.designWidth可以在meta中设置design-width，则之后使用这两个方法不需要再传递第二个参数。</p>
<p>迭代后仍然支持在js中设置hotcss.designWidth，推荐使用meta去设置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [px2rem px值转换为rem值]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  &#123;<span class="type">[number]</span>&#125; px          [需要转换的值]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  &#123;<span class="type">[number]</span>&#125; designWidth [设计图的宽度尺寸]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">[number]</span>&#125;             [返回转换后的结果]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">hotcss.<span class="title function_">px2rem</span>( px , designWidth );</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同上。</span></span><br><span class="line"><span class="comment"> * 注意：因为rem可能为小数，转换后的px值有可能不是整数，需要自己手动处理。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">hotcss.<span class="title function_">rem2px</span>( rem , designWidth );</span><br><span class="line"><span class="comment">//你可以在meta中定义design-width，此后使用px2rem/rem2px，就不需要传递designWidth值了。同时也支持旧的设置方式，直接在JS中设置hotcss.designWidth</span></span><br><span class="line">hotcss.<span class="title function_">px2rem</span>(<span class="number">200</span>);</span><br><span class="line">hotcss.<span class="title function_">rem2px</span>(<span class="number">350</span>);</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>官方文档 <a href="http://imochen.github.io/hotcss/">http://imochen.github.io/hotcss/</a></p>
<p>github <a href="https://github.com/imochen/hotcss/blob/master/src/hotcss.js">https://github.com/imochen/hotcss/blob/master/src/hotcss.js</a></p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>移动端</tag>
        <tag>解决方案</tag>
      </tags>
  </entry>
  <entry>
    <title>【设计模式】从订阅发布模式说起</title>
    <url>/2018/06/13/2409cf20-af93-11ee-a3ea-ab0d390a17b0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>先扯点闲话。一时兴起，遂决定之后采用这个前缀来写这个十多篇的系列总结了。在之前的学习和博客整理中，感觉都挺没方向，很散乱。除了看书的总结外，其他时候都是零碎性地学习，我想，若能系统性地带着目的去散落这些点，再类似依赖收集一样把这些零碎的东西汇总整理出来，那应该也挺不错的~</p>
</blockquote>
<!-- ![学习正则表达式](/18-6-14/4361135.jpg) -->

<p>这周的复习知识点主要是以下几方面：</p>
<ul>
<li>设计模式之发布订阅&#x2F;观察者模式</li>
<li>事件相关，事件、模型、处理机制</li>
<li>Ajax</li>
<li>异步</li>
</ul>
<span id="more"></span>

<p>我将这些点梳理到了脑图中，并作了一些批注，感觉一边整理了知识点，也让自己有了一个整体的脉络和方向感，树越分散也就是所谓的深度，让树更深也就是知识的深度。</p>
<!-- ![知识点梳理](/18-6-14/52685215.jpg) -->

<h2 id="从设计原则说起"><a href="#从设计原则说起" class="headerlink" title="从设计原则说起"></a>从设计原则说起</h2><p>一个优秀的程序员通常由其<strong>操作技能</strong>、<strong>知识水平</strong>，<strong>经验层力</strong>和<strong>能力</strong>四个方面组成。这些原则，也就是巨人的肩膀，总结而出流传至今，每一个程序员都应该了解，运用于开发和生活中。</p>
<p>要我来说的话就是，先去了解，知道有这些东西，也许不能马上运用到实际项目中，但当我们遇到困难时，就可以回顾一下图里的各原则，结合以下经验：</p>
<ol>
<li>粗浅地了解这些原则</li>
<li>在（公司或开源）项目中观察或总结他人或自己的设计</li>
<li>实践、回顾，再总结</li>
<li>总结后再回到第1步深入了解以此往复</li>
</ol>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>比较概念的解释是，目标和观察者是基类，目标提供维护观察者的一系列方法，观察者提供更新接口。具体观察者和具体目标继承各自的基类，然后具体观察者把自己注册到具体目标里，在具体目标发生变化时候，调度观察者的更新方法</p>
<!-- ![观察者模式](/18-6-14/636423.jpg) -->

<p>简易版观察者模式实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObserverList</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observerList</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">add</span>(<span class="params">observer</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="title function_">push</span>(observer)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="variable language_">this</span>.<span class="title function_">count</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">observerList</span>[index]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">removeAt</span>(<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="title function_">splice</span>(index, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">count</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="property">length</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">indexOf</span>(<span class="params">observer, startIndex = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = startIndex</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="variable language_">this</span>.<span class="title function_">count</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">observerList</span>[i] === observer) &#123;</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">      &#125;</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span> = <span class="keyword">new</span> <span class="title class_">ObserverList</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addObserver</span>(<span class="params">observer</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">add</span>(observer)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">removeObserver</span>(<span class="params">observer</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">removeAt</span>(<span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">indexOf</span>(observer))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">notify</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> observerCount = <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">count</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; observerCount; i++) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">get</span>(i).<span class="title function_">update</span>(args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p>比较概念的解释是，订阅者把自己想订阅的事件注册到调度中心，当该事件触发时候，发布者发布该事件到调度中心（顺带上下文），由调度中心统一调度订阅者注册到调度中心的处理代码。</p>
<!-- ![发布订阅模式](/18-6-14/91374451.jpg) -->

<p>简易版发布订阅模式实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">class</span> <span class="title class_">PubSub</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span> = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">subscribe</span>(<span class="params">type, fn</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> listeners = <span class="variable language_">this</span>.<span class="property">subscribers</span>[type] || []</span><br><span class="line">    listeners.<span class="title function_">push</span>(fn)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span>[type] = listeners</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">unsubscribe</span>(<span class="params">type, fn</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> listeners = <span class="variable language_">this</span>.<span class="property">subscribers</span>[type]</span><br><span class="line">    <span class="keyword">if</span> (!listeners) <span class="keyword">return</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span>[type] = listeners.<span class="title function_">filter</span>(<span class="function"><span class="params">v</span> =&gt;</span> v !== fn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">publish</span>(<span class="params">type, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> listeners = <span class="variable language_">this</span>.<span class="property">subscribers</span>[type]</span><br><span class="line">    <span class="keyword">if</span> (!listeners) <span class="keyword">return</span></span><br><span class="line">    listeners.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> (item.<span class="title function_">apply</span>(type, args)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><ul>
<li>两者最大的区别是调度的地方<br>虽然两种模式都存在订阅者和发布者（具体观察者可认为是订阅者，具体目标可认为是观察者），但是观察者模式是由具体目标调度的，而发布&#x2F;订阅模式是统一由调度中心调度的。所以观察者模式的订阅者和发布者之间是存在依赖的，而发布&#x2F;订阅模式则不会</li>
<li>两种模式都可以用于松散耦合，改进代码管理和潜在的复用</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>观察者和发布&#x2F;订阅模式鼓励我们认真思考应用程序不同部分之间的关​​系。他们还帮助我们确定包含直接关系的层次，而这些关系可以用主题和观察者集合取而代之。这可以有效地将应用程序分解为更小，更松散的块，以改善代码管理和重用的潜力。</p>
<p>使用Observer模式的进一步动机是我们需要保持相关对象之间的一致性，而不需要使类紧密耦合。例如，当一个对象需要能够通知其他对象而不做这些对象的假设时。</p>
<p>使用这两种模式时，观察者和主体之间可能存在动态关系。这提供了很大的灵活性，当我们的应用程序的不同部分紧密耦合时，这可能不容易实现。</p>
<p>尽管对于每个问题来说，这并不总是最好的解决方案，但这些模式仍然是设计分离系统的最佳工具之一，应该被视为任何JavaScript开发人员的工具带中的重要工具。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>因此，这些模式的一些问题实际上源于其主要益处。在“发布&#x2F;订阅”中，通过将发布者与订阅者分离，有时可能难以获得我们应用程序的特定部分正常运行的保证。</p>
<p>例如，发布商可能会假定一个或多个订阅者正在倾听他们。假设我们正在使用这样的假设来记录或输出关于某些应用程序过程的错误。如果执行日志记录的用户崩溃（或出于某种原因无法运行），由于系统的解耦特性，发布者将无法看到这种情况。</p>
<p>这种模式的另一个缺点是用户对彼此的存在并不知情，并且对转换发布商的成本视而不见。由于用户和发布者之间的动态关系，更新依赖性很难追踪。</p>
<hr>
<h3 id="实践应用-实现Vue的双向绑定"><a href="#实践应用-实现Vue的双向绑定" class="headerlink" title="实践应用 - 实现Vue的双向绑定"></a>实践应用 - 实现Vue的双向绑定</h3><p>这么一看的话，其实Vue里的双向绑定的实现也是发布订阅模式吧。为什么不是观察者？ 因为多了一个Watcher，这就是相当于调度中心，通过这一层为中间人进行的更新。</p>
<p>这类的代码看多少次都不嫌多，这是之前网上一个不错的实现，我拿过来学习了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyVue</span> &#123;</span><br><span class="line">  <span class="comment">// new Vue(&#123; ... &#125;) 这个options就是这里的对象啦</span></span><br><span class="line">  <span class="comment">// 初始化 将 options 赋值到实例对象上</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$options</span> = options</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$el</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(options.<span class="property">el</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$methods</span> = options.<span class="property">methods</span></span><br><span class="line">    <span class="comment">// data的内容会放到这里来， 这也就说明了 初始化结束后，手动加的值不会被监听到</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_binding</span> = &#123;&#125;</span><br><span class="line">    <span class="comment">// 初始化时会监听data上的属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_observe</span>(<span class="variable language_">this</span>.<span class="property">$data</span>)</span><br><span class="line">    <span class="comment">// 初始化时 编译 $el 里的子节点</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_compile</span>(<span class="variable language_">this</span>.<span class="property">$el</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">_observe</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="variable language_">this</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">        that.<span class="property">_binding</span>[key] = &#123;</span><br><span class="line">          <span class="comment">// 添加依赖收集， 是个数组</span></span><br><span class="line">          <span class="attr">_directives</span>: []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(that.<span class="property">_binding</span>[key])</span><br><span class="line">        <span class="keyword">let</span> val = obj[key]</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">          <span class="comment">// 若是对象就递归</span></span><br><span class="line">          that.<span class="title function_">_observe</span>(val)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> binding = that.<span class="property">_binding</span>[key]</span><br><span class="line">        <span class="comment">// 响应式 双向绑定的核心操作</span></span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(that.<span class="property">$data</span>, key, &#123;</span><br><span class="line">          <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> 获取 <span class="subst">$&#123;val&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> 更新 <span class="subst">$&#123;newVal&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">if</span> (val !== newVal) &#123;</span><br><span class="line">              val = newVal</span><br><span class="line">              binding.<span class="property">_directives</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">                item.<span class="title function_">update</span>()</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">_compile</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">let</span> nodes = root.<span class="property">children</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nodes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> node = nodes[i]</span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">children</span>.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">_compile</span>(node)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (node.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;v-click&#x27;</span>)) &#123;</span><br><span class="line">        node.<span class="property">onclick</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">let</span> attrVal = nodes[i].<span class="title function_">getAttribute</span>(<span class="string">&#x27;v-click&#x27;</span>)</span><br><span class="line">          <span class="keyword">return</span> that.<span class="property">$methods</span>[attrVal].<span class="title function_">bind</span>(that.<span class="property">$data</span>)</span><br><span class="line">        &#125;)()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (node.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;v-model&#x27;</span>) &amp;&amp; (node.<span class="property">tagName</span> === <span class="string">&#x27;INPUT&#x27;</span> || node.<span class="property">tagName</span> === <span class="string">&#x27;TEXTAREA&#x27;</span>)) &#123;</span><br><span class="line">        node.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, (<span class="keyword">function</span>(<span class="params">key</span>) &#123;</span><br><span class="line">          <span class="keyword">let</span> attrVal = node.<span class="title function_">getAttribute</span>(<span class="string">&#x27;v-model&#x27;</span>)</span><br><span class="line">          that.<span class="property">_binding</span>[attrVal].<span class="property">_directives</span>.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Wathcer</span>(</span><br><span class="line">            <span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">            node,</span><br><span class="line">            that,</span><br><span class="line">            attrVal,</span><br><span class="line">            <span class="string">&#x27;value&#x27;</span></span><br><span class="line">          ))</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            that.<span class="property">$data</span>[attrVal] = nodes[key].<span class="property">value</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)(i))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (node.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;v-bind&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">let</span> attrVal = node.<span class="title function_">getAttribute</span>(<span class="string">&#x27;v-bind&#x27;</span>)</span><br><span class="line">        that.<span class="property">_binding</span>[attrVal].<span class="property">_directives</span>.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Watcher</span>(</span><br><span class="line">          <span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">          node,</span><br><span class="line">          that,</span><br><span class="line">          attrVal,</span><br><span class="line">          <span class="string">&#x27;innerHTML&#x27;</span></span><br><span class="line">        ))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, el, vm, exp, attr</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name    <span class="comment">// 指令名</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">el</span> = el        <span class="comment">// 指令对应dom</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm        <span class="comment">// 指令所属MyVue实例</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">exp</span> = exp      <span class="comment">// 指令对应值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">attr</span> = attr    <span class="comment">// 绑定的属性值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">update</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">el</span>[<span class="variable language_">this</span>.<span class="property">attr</span>] = <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">$data</span>[<span class="variable language_">this</span>.<span class="property">exp</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>这里说一下，我们通过 new 生成了一个 MyVue实例，而传入的参数（对象）作为配置，在初始化阶段做了这些事情：</p>
<ol>
<li>赋值，实例的 $options $el $data $method 都是从options里获取到的</li>
<li>_observe 为每一个实例上的data属性添加监听 （通过Object.defineProperty）</li>
<li>_compile 编译节点，指令对应的value对应一个新的Watcher，进行依赖收集从而触发数据响应</li>
</ol>
<p>于是到codepen上试试吧</p>
<iframe height='300' scrolling='no' title='simple Vue ~ MVVM' src='//codepen.io/fridolph/embed/gKxrBO/?height=300&theme-id=dark&default-tab=js,result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='https://codepen.io/fridolph/pen/gKxrBO/'>simple Vue ~ MVVM</a> by fridolph (<a href='https://codepen.io/fridolph'>@fridolph</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>

<hr>
<h2 id="event-js-的实现"><a href="#event-js-的实现" class="headerlink" title="event.js 的实现"></a>event.js 的实现</h2><p>这是一个典型的发布订阅模式的应用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义R对象 如果支持es6用原生的Reflect，没就相当于提供polyfill</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> R = <span class="keyword">typeof</span> <span class="title class_">Reflect</span> === <span class="string">&#x27;object&#x27;</span> ? <span class="title class_">Reflect</span> : <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ReflectApply</span> = R &amp;&amp; <span class="keyword">typeof</span> R.<span class="property">apply</span> === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">  ? R.<span class="property">apply</span></span><br><span class="line">  : <span class="keyword">function</span> <span class="title function_">ReflectApply</span>(<span class="params">target, receiver, args</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span>.<span class="title function_">call</span>(target, receiver, args);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ReflectOwnKeys</span></span><br><span class="line"><span class="keyword">if</span> (R &amp;&amp; <span class="keyword">typeof</span> R.<span class="property">ownKeys</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">  <span class="title class_">ReflectOwnKeys</span> = R.<span class="property">ownKeys</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property">getOwnPropertySymbols</span>) &#123;</span><br><span class="line">  <span class="title class_">ReflectOwnKeys</span> = <span class="keyword">function</span> <span class="title function_">ReflectOwnKeys</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(target)</span><br><span class="line">      .<span class="title function_">concat</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(target));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="title class_">ReflectOwnKeys</span> = <span class="keyword">function</span> <span class="title function_">ReflectOwnKeys</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(target);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.warn的封装</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ProcessEmitWarning</span>(<span class="params">warning</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">console</span> &amp;&amp; <span class="variable language_">console</span>.<span class="property">warn</span>) <span class="variable language_">console</span>.<span class="title function_">warn</span>(warning);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Number.isNaN 是es6加入的，后面是并联的兼容处理，Number类型 自身与自身不相等的只有NaN了</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">NumberIsNaN</span> = <span class="title class_">Number</span>.<span class="property">isNaN</span> || <span class="keyword">function</span> <span class="title function_">NumberIsNaN</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value !== value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">EventEmitter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">EventEmitter</span>.<span class="property">init</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将EventEmitter构造函数作为默认导出</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">EventEmitter</span>;</span><br><span class="line"><span class="comment">// 向后兼容node 0.10.x 版本 看来这个库相当老了啊，不过也不妨碍我们学习</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property">EventEmitter</span> = <span class="title class_">EventEmitter</span>;</span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_events</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_eventsCount</span> = <span class="number">0</span>;</span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_maxListeners</span> = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认情况下，如果超过10个侦听器，EventEmitters将会输出警告添加到它</span></span><br><span class="line"><span class="comment">// 这是一个有用的默认值，它有助于查找内存泄漏</span></span><br><span class="line"><span class="keyword">var</span> defaultMaxListeners = <span class="number">10</span>;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">EventEmitter</span>, <span class="string">&#x27;defaultMaxListeners&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> defaultMaxListeners;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">&#x27;number&#x27;</span> || arg &lt; <span class="number">0</span> || <span class="title class_">NumberIsNaN</span>(arg)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RangeError</span>(<span class="string">&#x27;The value of &quot;defaultMaxListeners&quot; is out of range. It must be a non-negative number. Received &#x27;</span> + arg + <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    defaultMaxListeners = arg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造类的静态方法</span></span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property">init</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 相当于constructor的构造函数调用 初始化</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_events</span> === <span class="literal">undefined</span> ||</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_events</span> === <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="variable language_">this</span>).<span class="property">_events</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_events</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_eventsCount</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_maxListeners</span> = <span class="variable language_">this</span>.<span class="property">_maxListeners</span> || <span class="literal">undefined</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显然不是所有的Emitters侦听器都应该限制为10个。这个功能允许增加</span></span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setMaxListeners</span> = <span class="keyword">function</span> <span class="title function_">setMaxListeners</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> n !== <span class="string">&#x27;number&#x27;</span> || n &lt; <span class="number">0</span> || <span class="title class_">NumberIsNaN</span>(n)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RangeError</span>(<span class="string">&#x27;The value of &quot;n&quot; is out of range. It must be a non-negative number. Received &#x27;</span> + n + <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_maxListeners</span> = n;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给下面的 getMaxListeners方法用  EventEmitter原型方法里的 this指向实例对象</span></span><br><span class="line"><span class="comment">// 所以可从实例中 拿到 属性值 _maxListeners</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">$getMaxListeners</span>(<span class="params">that</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (that.<span class="property">_maxListeners</span> === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">EventEmitter</span>.<span class="property">defaultMaxListeners</span>;</span><br><span class="line">  <span class="keyword">return</span> that.<span class="property">_maxListeners</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getMaxListeners</span> = <span class="keyword">function</span> <span class="title function_">getMaxListeners</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> $getMaxListeners(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">emit</span> = <span class="keyword">function</span> <span class="title function_">emit</span>(<span class="params">type</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="comment">// emit第一个参数一般是方法名，所以 从arguments[1]开始</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) args.<span class="title function_">push</span>(<span class="variable language_">arguments</span>[i]);</span><br><span class="line">  <span class="comment">// 右边的表达式返回一个布尔值 ，type报错就为true。doError可理解为错误标记的flag</span></span><br><span class="line">  <span class="keyword">var</span> doError = (type === <span class="string">&#x27;error&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拿到 实例的 _events 对象</span></span><br><span class="line">  <span class="keyword">var</span> events = <span class="variable language_">this</span>.<span class="property">_events</span>;</span><br><span class="line">  <span class="keyword">if</span> (events !== <span class="literal">undefined</span>)</span><br><span class="line">    <span class="comment">// 没有错就直接返回 false</span></span><br><span class="line">    doError = (doError &amp;&amp; events.<span class="property">error</span> === <span class="literal">undefined</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!doError)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面是错误处理</span></span><br><span class="line">  <span class="keyword">if</span> (doError) &#123;</span><br><span class="line">    <span class="keyword">var</span> er;</span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> &gt; <span class="number">0</span>)</span><br><span class="line">      er = args[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (er <span class="keyword">instanceof</span> <span class="title class_">Error</span>) &#123;</span><br><span class="line">      <span class="comment">// 注意：“throw”这一行的注释是有意的，他们表示 如果这导致未处理的异常，则在Node的输出中输入。</span></span><br><span class="line">      <span class="keyword">throw</span> er;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 错误上下文为er 这里的er就是传进来的type的报错环境上下文</span></span><br><span class="line">    <span class="keyword">var</span> err = <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Unhandled error.&#x27;</span> + (er ? <span class="string">&#x27; (&#x27;</span> + er.<span class="property">message</span> + <span class="string">&#x27;)&#x27;</span> : <span class="string">&#x27;&#x27;</span>));</span><br><span class="line">    err.<span class="property">context</span> = er;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从events里找type对应的函数 拿到 并赋给handler</span></span><br><span class="line">  <span class="keyword">var</span> handler = events[type];</span><br><span class="line">  <span class="keyword">if</span> (handler === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handler === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 绑定上下文</span></span><br><span class="line">    <span class="title class_">ReflectApply</span>(handler, <span class="variable language_">this</span>, args);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// handler多次调用  把多个handler 放到数组里来处理</span></span><br><span class="line">    <span class="keyword">var</span> len = handler.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">var</span> listeners = <span class="title function_">arrayClone</span>(handler, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">      <span class="title class_">ReflectApply</span>(listeners[i], <span class="variable language_">this</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_addListener</span>(<span class="params">target, type, listener, prepend</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> m;</span><br><span class="line">  <span class="keyword">var</span> events;</span><br><span class="line">  <span class="keyword">var</span> existing;</span><br><span class="line">  <span class="comment">// listener类型判断</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;The &quot;listener&quot; argument must be of type Function. Received type &#x27;</span> + <span class="keyword">typeof</span> listener);</span><br><span class="line">  &#125;</span><br><span class="line">  events = target.<span class="property">_events</span>;</span><br><span class="line">  <span class="keyword">if</span> (events === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    events = target.<span class="property">_events</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">    target.<span class="property">_eventsCount</span> = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 为了避免在 type === &quot;newListener&quot; 这种情况下递归</span></span><br><span class="line">    <span class="comment">// 在将其添加到侦听器之前，首先触发 &quot;newListener&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (events.<span class="property">newListener</span> !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      target.<span class="title function_">emit</span>(<span class="string">&#x27;newListener&#x27;</span>, type,</span><br><span class="line">                  listener.<span class="property">listener</span> ? listener.<span class="property">listener</span> : listener);</span><br><span class="line">      <span class="comment">// 重新分配 `events`，因为newListener处理程序可能导致了 this._events被分配给一个新的对象</span></span><br><span class="line">      events = target.<span class="property">_events</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    existing = events[type];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (existing === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// 优化一个listener的情况。不需要额外的数组对象</span></span><br><span class="line">    existing = events[type] = listener;</span><br><span class="line">    ++target.<span class="property">_eventsCount</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> existing === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 添加第二个元素，需要更改为数组</span></span><br><span class="line">      existing = events[type] =</span><br><span class="line">        prepend ? [listener, existing] : [existing, listener];</span><br><span class="line">      <span class="comment">//如果我们已经有了一个数组，只需追加</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prepend) &#123;</span><br><span class="line">      existing.<span class="title function_">unshift</span>(listener);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      existing.<span class="title function_">push</span>(listener);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查监听器泄漏</span></span><br><span class="line">    m = $getMaxListeners(target);</span><br><span class="line">    <span class="comment">// m &gt; 0 &amp;&amp; (exiting.length &gt; m &amp;&amp; !existing.warned )</span></span><br><span class="line">    <span class="keyword">if</span> (m &gt; <span class="number">0</span> &amp;&amp; existing.<span class="property">length</span> &gt; m &amp;&amp; !existing.<span class="property">warned</span>) &#123;</span><br><span class="line">      existing.<span class="property">warned</span> = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 没有错误代码，因为它是一个warning</span></span><br><span class="line">      <span class="keyword">var</span> w = <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">        <span class="string">&#x27;Possible EventEmitter memory leak detected. &#x27;</span> +</span><br><span class="line">        existing.<span class="property">length</span> + <span class="string">&#x27; &#x27;</span> + <span class="title class_">String</span>(type) + <span class="string">&#x27; listeners &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;added. Use emitter.setMaxListeners() to &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;increase limit&#x27;</span></span><br><span class="line">      )</span><br><span class="line">      w.<span class="property">name</span> = <span class="string">&#x27;MaxListenersExceededWarning&#x27;</span>;</span><br><span class="line">      w.<span class="property">emitter</span> = target;</span><br><span class="line">      w.<span class="property">type</span> = type;</span><br><span class="line">      w.<span class="property">count</span> = existing.<span class="property">length</span>;</span><br><span class="line">      <span class="title class_">ProcessEmitWarning</span>(w);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结合上面的函数，这是高阶函数的用法 普通地，我们一般会传 事件名和回调</span></span><br><span class="line"><span class="comment">// 这里返回 _addListner方法 第一个参数是 this 实例对象作为上下文环境</span></span><br><span class="line"><span class="comment">// 然后是 事件名，回调，prepend默认为false</span></span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addListener</span> = <span class="keyword">function</span> <span class="title function_">addListener</span>(<span class="params">type, listener</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">_addListener</span>(<span class="variable language_">this</span>, type, listener, <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 同名方法 addListner 和用 on等效</span></span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">on</span> = <span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addListener</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和on的区别在于 prepend为true，当前已经是数组了才会这样用（不同我们来，已经封装在内部逻辑里了）</span></span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">prependListener</span> = <span class="keyword">function</span> <span class="title function_">prependListener</span>(<span class="params">type, listener</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">_addListener</span>(<span class="variable language_">this</span>, type, listener, <span class="literal">true</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onceWrapper</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 把参数放到 args中。 我们先看下面的 _onceWrap方法</span></span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) args.<span class="title function_">push</span>(<span class="variable language_">arguments</span>[i]);</span><br><span class="line">  <span class="comment">// 显然，这个if逻辑会走到里</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">fired</span>) &#123;</span><br><span class="line">    <span class="comment">// removeListener会被调用</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">target</span>.<span class="title function_">removeListener</span>(<span class="variable language_">this</span>.<span class="property">type</span>, <span class="variable language_">this</span>.<span class="property">wrapFn</span>);</span><br><span class="line">    <span class="comment">// 然后再把fired 设回true</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fired</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 这里因为ReflectApply的原因，this上下文回到了 实例对象上</span></span><br><span class="line">    <span class="title class_">ReflectApply</span>(<span class="variable language_">this</span>.<span class="property">listener</span>, <span class="variable language_">this</span>.<span class="property">target</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_onceWrap</span>(<span class="params">target, type, listener</span>) &#123;</span><br><span class="line">  <span class="comment">// 初始state</span></span><br><span class="line">  <span class="keyword">var</span> state = &#123; <span class="attr">fired</span>: <span class="literal">false</span>, <span class="attr">wrapFn</span>: <span class="literal">undefined</span>, <span class="attr">target</span>: target, <span class="attr">type</span>: type, <span class="attr">listener</span>: listener &#125;;</span><br><span class="line">  <span class="comment">// 好 有了这个bind后，上面onceWrapper的this就知道了，我们再跳回去</span></span><br><span class="line">  <span class="keyword">var</span> wrapped = onceWrapper.<span class="title function_">bind</span>(state);</span><br><span class="line">  wrapped.<span class="property">listener</span> = listener;</span><br><span class="line">  state.<span class="property">wrapFn</span> = wrapped;</span><br><span class="line">  <span class="keyword">return</span> wrapped;</span><br><span class="line">  <span class="comment">// 回到wrapped这个上下文中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法可理解为调用一次后 自动把方法注销掉</span></span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">once</span> = <span class="keyword">function</span> <span class="title function_">once</span>(<span class="params">type, listener</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;The &quot;listener&quot; argument must be of type Function. Received type &#x27;</span> + <span class="keyword">typeof</span> listener);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">on</span>(type, <span class="title function_">_onceWrap</span>(<span class="variable language_">this</span>, type, listener));</span><br><span class="line">  <span class="comment">// 后同，return this 是返回实例对象自身，方便链式调用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">prependOnceListener</span> = <span class="keyword">function</span> <span class="title function_">prependOnceListener</span>(<span class="params">type, listener</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;The &quot;listener&quot; argument must be of type Function. Received type &#x27;</span> + <span class="keyword">typeof</span> listener);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">prependListener</span>(type, <span class="title function_">_onceWrap</span>(<span class="variable language_">this</span>, type, listener));</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除监听方法</span></span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">removeListener</span> = <span class="keyword">function</span> <span class="title function_">removeListener</span>(<span class="params">type, listener</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> list, events, position, i, originalListener;</span><br><span class="line">  <span class="comment">// 错误判断，这里先略过了</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;The &quot;listener&quot; argument must be of type Function. Received type &#x27;</span> + <span class="keyword">typeof</span> listener);</span><br><span class="line">  &#125;</span><br><span class="line">  events = <span class="variable language_">this</span>.<span class="property">_events</span>;</span><br><span class="line">  <span class="keyword">if</span> (events === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// list被赋值为evnets[type] 即 一个注册的事件</span></span><br><span class="line">  list = events[type];</span><br><span class="line">  <span class="keyword">if</span> (list === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前list 和所传的注册事件若一致就进入这个逻辑里</span></span><br><span class="line">  <span class="keyword">if</span> (list === listener || list.<span class="property">listener</span> === listener) &#123;</span><br><span class="line">    <span class="comment">// 处理 注册事件 为单个函数 的情况</span></span><br><span class="line">    <span class="keyword">if</span> (--<span class="variable language_">this</span>.<span class="property">_eventsCount</span> === <span class="number">0</span>)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_events</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">delete</span> events[type];</span><br><span class="line">      <span class="keyword">if</span> (events.<span class="property">removeListener</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">emit</span>(<span class="string">&#x27;removeListener&#x27;</span>, type, list.<span class="property">listener</span> || listener);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> list !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理 注册事件 为数组的情况</span></span><br><span class="line">    position = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = list.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (list[i] === listener || list[i].<span class="property">listener</span> === listener) &#123;</span><br><span class="line">        originalListener = list[i].<span class="property">listener</span>;</span><br><span class="line">        position = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>)</span><br><span class="line">      list.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">spliceOne</span>(list, position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list.<span class="property">length</span> === <span class="number">1</span>)</span><br><span class="line">      events[type] = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (events.<span class="property">removeListener</span> !== <span class="literal">undefined</span>)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">emit</span>(<span class="string">&#x27;removeListener&#x27;</span>, type, originalListener || listener);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同名方法，等同于 removeListener</span></span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">off</span> = <span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">removeListener</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除所有的监听</span></span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">removeAllListeners</span> = <span class="keyword">function</span> <span class="title function_">removeAllListeners</span>(<span class="params">type</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> listeners, events, i;</span><br><span class="line">  events = <span class="variable language_">this</span>.<span class="property">_events</span>;</span><br><span class="line">  <span class="keyword">if</span> (events === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不侦听removeListener，不需要触发emit</span></span><br><span class="line">  <span class="keyword">if</span> (events.<span class="property">removeListener</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 通过赋值的方式 让 实例对象的 _events 为空</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_events</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">      <span class="comment">// 事件数清0</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_eventsCount</span> = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[type] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (--<span class="variable language_">this</span>.<span class="property">_eventsCount</span> === <span class="number">0</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_events</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">delete</span> events[type];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为所有事件上的所有侦听器发出removeListener</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(events);</span><br><span class="line">    <span class="keyword">var</span> key;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">      key = keys[i];</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&#x27;removeListener&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">removeAllListeners</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">removeAllListeners</span>(<span class="string">&#x27;removeListener&#x27;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_events</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_eventsCount</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  listeners = events[type];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> listeners === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">removeListener</span>(type, listeners);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (listeners !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">// LIFO order</span></span><br><span class="line">    <span class="keyword">for</span> (i = listeners.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">removeListener</span>(type, listeners[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样的，我们先看 原型方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_listeners</span>(<span class="params">target, type, unwrap</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> events = target.<span class="property">_events</span>;</span><br><span class="line">  <span class="keyword">if</span> (events === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  <span class="comment">// 参数type为事件名</span></span><br><span class="line">  <span class="keyword">var</span> evlistener = events[type];</span><br><span class="line">  <span class="keyword">if</span> (evlistener === <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> evlistener === <span class="string">&#x27;function&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> unwrap ? [evlistener.<span class="property">listener</span> || evlistener] : [evlistener];</span><br><span class="line">  <span class="keyword">return</span> unwrap ?</span><br><span class="line">    <span class="title function_">unwrapListeners</span>(evlistener) : <span class="title function_">arrayClone</span>(evlistener, evlistener.<span class="property">length</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">listeners</span> = <span class="keyword">function</span> <span class="title function_">listeners</span>(<span class="params">type</span>) &#123;</span><br><span class="line">  <span class="comment">// 返回 _listeners调用的结果，回到 _listener函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">_listeners</span>(<span class="variable language_">this</span>, type, <span class="literal">true</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">rawListeners</span> = <span class="keyword">function</span> <span class="title function_">rawListeners</span>(<span class="params">type</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">_listeners</span>(<span class="variable language_">this</span>, type, <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property">listenerCount</span> = <span class="keyword">function</span>(<span class="params">emitter, type</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> emitter.<span class="property">listenerCount</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> emitter.<span class="title function_">listenerCount</span>(type);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> listenerCount.<span class="title function_">call</span>(emitter, type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">listenerCount</span> = listenerCount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">listenerCount</span>(<span class="params">type</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> events = <span class="variable language_">this</span>.<span class="property">_events</span>;</span><br><span class="line">  <span class="keyword">if</span> (events !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> evlistener = events[type];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> evlistener === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (evlistener !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> evlistener.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">EventEmitter</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eventNames</span> = <span class="keyword">function</span> <span class="title function_">eventNames</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_eventsCount</span> &gt; <span class="number">0</span> ? <span class="title class_">ReflectOwnKeys</span>(<span class="variable language_">this</span>.<span class="property">_events</span>) : [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助方法，浅拷贝数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arrayClone</span>(<span class="params">arr, n</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> copy = <span class="keyword">new</span> <span class="title class_">Array</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    copy[i] = arr[i];</span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组中删除某项</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">spliceOne</span>(<span class="params">list, index</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (; index + <span class="number">1</span> &lt; list.<span class="property">length</span>; index++)</span><br><span class="line">    list[index] = list[index + <span class="number">1</span>];</span><br><span class="line">  list.<span class="title function_">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// listner的拷贝</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unwrapListeners</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ret = <span class="keyword">new</span> <span class="title class_">Array</span>(arr.<span class="property">length</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ret.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">    ret[i] = arr[i].<span class="property">listener</span> || arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【设计模式】初识IOC</title>
    <url>/2017/12/13/54a81920-af93-11ee-b66c-4dae10829f86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>看到群里的大佬们在讨论着，冒出了好多“生词”，竟然完全不知，惭愧惭愧，于是各种谷歌百度后将之整理一下。近几年，前端应用（WebApp）正朝着大规模方向发展，在这个过程中我们会对项目拆解成多个模块&#x2F;组件来组合使用，以此提高我们代码的复用性，最终提高研发效率。在编写一个复杂组件的时候，总会依赖其他组件来协同完成某个逻辑功能。组件越复杂，依赖越多，可复用性就越差，我们可以借助软件工程中优秀的编程理念来提高复杂组件的可复用性，以下将详述其中之一的依赖倒置理念。</p>
</blockquote>
<span id="more"></span>

<p>之前自学React，看到了高阶组件这么一个概念。那么理解之前，我们首先要理解高阶函数这个概念</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello World&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">hello</span>() <span class="comment">// &#x27;Hello World&#x27;</span></span><br><span class="line"><span class="comment">// hello()</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">WrapperHello</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;before ------ say hello&#x27;</span>)</span><br><span class="line">    <span class="title function_">fn</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;after ------- say hello&#x27;</span>)</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line">hello = <span class="title class_">WrapperHello</span>(hello)</span><br><span class="line"><span class="title function_">hello</span>()</span><br><span class="line"><span class="comment">// &#x27;before ------ say hello&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;Hello World&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;after ------- say hello&#x27;</span></span><br></pre></td></tr></table></figure>

<p>函数既可以当参数，也可以当返回值</p>
<h3 id="属性代理"><a href="#属性代理" class="headerlink" title="属性代理"></a>属性代理</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">WrapHello</span>(<span class="params">Comp</span>) &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">WrapComp</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>高阶组件 - 属性代理<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Comp</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">WrapComp</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Hello</span> = <span class="title class_">WrapHello</span>(<span class="title class_">Hello</span>)</span><br><span class="line">&lt;<span class="title class_">Hello</span> /&gt;</span><br><span class="line"><span class="comment">// 这个Hello 组件 已经有p标签了</span></span><br></pre></td></tr></table></figure>

<p>上面的 WrapComponent 就是属性代理<br>可以在其添加更多的属性或组件等</p>
<h3 id="反向继承"><a href="#反向继承" class="headerlink" title="反向继承"></a>反向继承</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">WrapComponent</span>(<span class="params">Comp</span>) &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Wrap</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Comp</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Comp</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;高阶函数 - 反向继承&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Wrap</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Hello</span> = <span class="title class_">WrapComponent</span>(<span class="title class_">Hello</span>)</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="依赖反转-Inversion-of-Control"><a href="#依赖反转-Inversion-of-Control" class="headerlink" title="依赖反转 Inversion of Control"></a>依赖反转 Inversion of Control</h2><p>其实这词好像经常听到过，很高端的样子。我们先来百科的解释： 控制反转把创建对象的权利交给框架，是框架的重要特征，并非面向对象编程的专业术语。<br>它包括依赖注入<code>Dependency Injection</code>和依赖查找<code>Dependency Lookup</code></p>
<p>它包含两个准则：</p>
<ol>
<li>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象</li>
<li>抽象不应该依赖于具体实现，具体实现应该依赖于抽象</li>
</ol>
<p>其背后的核心思想是：面向接口编程</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>IoC最大的好处是什么？因为把对象生成放在了XML里定义，所以当我们需要换一个实现子类将会变成很简单（一般这样的对象都是实现于某种接口的），只要修改XML就可以了，这样我们甚至可以实现对象的热插拔（有点像USB接口和SCSI硬盘了）。</p>
<p>IoC最大的缺点是什么？（1）生成一个对象的步骤变复杂了（事实上操作上还是挺简单的），对于不习惯这种方式的人，会觉得有些别扭和不直观。（2）对象生成因为是使用反射编程，在效率上有些损耗。但相对于IoC提高的维护性和灵活性来说，这点损耗是微不足道的，除非某对象的生成对效率要求特别高。（3）缺少IDE重构操作的支持，如果在Eclipse要对类改名，那么你还需要去XML文件里手工去改了，这似乎是所有XML方式的缺陷所在。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p><strong>实现数据访问层</strong></p>
<p>数据访问层有两个目标。第一是将数据库引擎从应用中抽象出来，这样就可以随时改变数据库—比方说，从微软SQL变成Oracle。不过在实践上很少会这么做，也没有足够的理由未来使用实现数据访问层而进行重构现有应用的努力。[3]<br>第二个目标是将数据模型从数据库实现中抽象出来。这使得数据库或代码开源根据需要改变，同时只会影响主应用的一小部分——数据访问层。这一目标是值得的，为了在现有系统中实现它进行必要的重构。</p>
<p><strong>模块与接口重构</strong></p>
<p>依赖注入背后的一个核心思想是单一功能原则（single responsibility principle）。该原则指出，每一个对象应该有一个特定的目的，而应用需要利用这一目的的不同部分应当使用合适的对象。这意味着这些对象在系统的任何地方都可以重用。但在现有系统里面很多时候都不是这样的。[3] </p>
<p><strong>随时增加单元测试</strong></p>
<p>把功能封装到整个对象里面会导致自动测试困难或者不可能。将模块和接口与特定对象隔离，以这种方式重构可以执行更先进的单元测试。按照后面再增加测试的想法继续重构模块是诱惑力的，但这是错误的。</p>
<p><strong>使用服务定位器而不是构造注入</strong></p>
<p>实现控制反转不止一种方法。最常见的办法是使用构造注入，这需要在对象首次被创建是提供所有的软件依赖。然而，构造注入要假设整个系统都使用这一模式，这意味着整个系统必须同时进行重构。这很困难、有风险，且耗时。</p>
<hr>
<p>我们还是由例子来看：要实现一个列表 A，能够加载一系列的信息并展示<br>于是很自然地我们遵守单一职责功能，将展示和加载两个逻辑分成两个类：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// loading.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Loader</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">url</span> = url</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">load</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="variable language_">this</span>.<span class="property">url</span>)</span><br><span class="line">    <span class="keyword">return</span> result.<span class="title function_">text</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****************************/</span></span><br><span class="line"><span class="comment">// list.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Loader</span> <span class="keyword">from</span> <span class="string">&#x27;./Loader</span></span><br><span class="line"><span class="string">export default class List &#123;</span></span><br><span class="line"><span class="string">  constructor(container) &#123;</span></span><br><span class="line"><span class="string">    this.container = container</span></span><br><span class="line"><span class="string">    this.loader = new Loader(&#x27;</span>list.<span class="property">json</span><span class="string">&#x27;)</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  async render() &#123;</span></span><br><span class="line"><span class="string">    let items = await this.loader.load()</span></span><br><span class="line"><span class="string">    this.container.textContent = items</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">/*****************************/</span></span><br><span class="line"><span class="string">// main.js</span></span><br><span class="line"><span class="string">import List from &#x27;</span>./<span class="title class_">List</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">let list = new List(document.getElementById(&#x27;</span>elem<span class="string">&#x27;))</span></span><br><span class="line"><span class="string">List.render()</span></span><br></pre></td></tr></table></figure>

<p>列表A很快开发完毕，于是继续开发下一个列表 B，B 的功能和 A 类似，也是加载数据展示数据，区别在于 B 的数据来源是一个第三方的服务，他们提供一个 js sdk 给你调用能够返回数据信息。<br>很自然的我们想到 A 的展示逻辑是可以复用的，对于数据加载这个逻辑我们重新实现一个 ThirdLoader 来专门加载第三方服务就是了，但回到 List 模块，我们发现在其构造函数中写死了对 Loader 的依赖：</p>
<pre><code>this.loader = new Loader(&#39;/list&#39;); 
</code></pre>
<p>导致无法对 List 设置第三方数据加载逻辑。这个问题就在于 List 依赖了具体的实现而不是依赖一个 Loader 接口。</p>
<p>IOC正是解决这类问题的最佳良药，我们再回顾IOC的两条准则，再看看如何利用IOC理念解决这类问题：</p>
<p><code>1. 高层次的模块不应该依赖于低层次的模块，它们都应该依赖于抽象</code></p>
<p>上述代码中，列表模块是高层次的模块，Loader是低层次的模块。高层次的List依赖了低层次的Loader，违背了该准则。好在准备也提供了解决方案：<strong>应该依赖于抽象</strong>。<br>那什么是抽象？即<code>接口</code>，放在JS语言中，接口则是隐式的。</p>
<p>我们正好实践下该准则：</p>
<ol>
<li>我们定义一个隐式的接口ILoader,ILoader声明了一个load方法，该方法签名是返回一个包含请求结果的Promise</li>
<li>将List模块对Loader模块的依赖调整为对ILoader接口的依赖：我们在List模块中移除对Loader模块的依赖（即移除import语句），同时构造函数中增加一个参数，该参数是一个实现了ILoader接口的实例</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// list.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">List</span>() &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">container, loader</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">container</span> = container</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">loader</span> = loader</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">textContent</span> = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">loader</span>.<span class="title function_">load</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>为了完成列表A的功能，我们还要改造main.js，将实现了ILoader的Loader模块实例化传给List模块：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">List</span> <span class="keyword">from</span> <span class="string">&#x27;./List&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Loader</span> <span class="keyword">from</span> <span class="string">&#x27;./Loader&#x27;</span></span><br><span class="line"><span class="keyword">let</span> list = <span class="keyword">new</span> <span class="title class_">List</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;elem&#x27;</span>), <span class="keyword">new</span> <span class="title class_">Loader</span>(<span class="string">&#x27;list.json&#x27;</span>))</span><br><span class="line">list.<span class="title function_">render</span>()</span><br></pre></td></tr></table></figure>

<p>至此，我们完成了对List模块的一次改造，List从对具体实现Loader的依赖变成了对抽象接口ILoader的依赖，而List模块中对Loader模块的导入和实例化过程转移到了main.js，这一过程就是我们的<code>依赖倒置</code>。依赖创建的控制权交给了外部main.js，而在main.js中查找创建依赖并将依赖传递给List模块的这一过程我们称之为依赖注入<code>Dependency injection</code></p>
<p>我们再来看看IOC的第二个准则：<code>2. 抽象不应该依赖于具体实现，具体实现应该依赖于抽象</code>，我们的ILoader接口显然不会依赖于任何具体实现，而Loader这个具体实现依赖于ILoader接口，完全符合了IOC的第二准则。</p>
<p>原有系统的依赖关系图结果如下：</p>
<img src="/原有关系依赖图.jpg" />


<p>基于新的依赖架构，List模块具备了设置不同数据加载逻辑的能力，现在我们可以复用List模块再实现列表B的数据加载逻辑并在main中组装即可完成列表B的功能：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ThirdLoader.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">&#x27;../third/sdk&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">ThirdServiceLoader</span> &#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">load</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">request</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">List</span> <span class="keyword">from</span> <span class="string">&#x27;./List&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Loader</span> <span class="keyword">from</span> <span class="string">&#x27;./Loader&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ThirdLoader</span> <span class="keyword">from</span> <span class="string">&#x27;./ThirdLoader&#x27;</span></span><br><span class="line"><span class="keyword">let</span> listA = <span class="keyword">new</span> <span class="title class_">List</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;a&#x27;</span>), <span class="keyword">new</span> <span class="title class_">Loader</span>(<span class="string">&#x27;list.json&#x27;</span>))</span><br><span class="line">listA.<span class="title function_">render</span>()</span><br><span class="line"><span class="keyword">let</span> listB = <span class="keyword">new</span> <span class="title class_">List</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;b&#x27;</span>), <span class="keyword">new</span> <span class="title class_">ThirdLoader</span>())</span><br><span class="line">listB.<span class="title function_">render</span>()</span><br></pre></td></tr></table></figure>

<p>最终的一个依赖关系图如下：</p>
<img src="/最终依赖关系图.jpg" />

<p>至此我们上面演示了应用 IoC 理念对高层模块的一个依赖架构改造，提高了高层模块的可复用性。</p>
<h2 id="IOC小结"><a href="#IOC小结" class="headerlink" title="IOC小结"></a>IOC小结</h2><p>总结我们最开始遇到的问题：类 A 直接依赖类 B，假如要将类 A 改为依赖类 C，则必须通过修改类 A 的代码来达成。这种场景下，类 A 一般是高层模块，负责复杂的业务逻辑；类 B 和类 C 是低层模块，负责基本的原子操作；假如修改类 A，会给程序带来不必要的风险。</p>
<p>IOC 解决方案：将类 A 修改为依赖接口 I，类 B 和类 C 各自实现接口 I，类 A 通过接口 I 间接与类 B 或者类 C 发生联系，则会大大降低修改类 A 的几率。</p>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>【JS】理解跨域及相关解决方案</title>
    <url>/2018/07/07/fb89cef0-af93-11ee-89ab-bfef527c66bb/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>写这篇一是为复习，二来是有个良好的总结。对于知识点的理解总是一知半解，不深入，这篇希望在此基础上不断深化加深印象和理解。</p>
</blockquote>
<span id="more"></span>

<h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><blockquote>
<p>A cross-domain solution (CDS) is a means of information assurance that provides the ability to manually or automatically access or transfer between two or more differing security domains.</p>
</blockquote>
<p>解决两个安全域之间的信息传递，这个就叫做CDS——跨域解决方案。跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。</p>
<h3 id="为什么需要跨域"><a href="#为什么需要跨域" class="headerlink" title="为什么需要跨域"></a>为什么需要跨域</h3><p>浏览器有同源策略限制。</p>
<p>同源策略&#x2F;SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p>
<p>这是一个用于隔离潜在恶意文件的重要安全机制。同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。</p>
<p>我们要知道协议、域名和端口一致就是同源的就好。这里有点不直观，举例来看好了，以下列出了常见的跨域场景：</p>
<table>
<thead>
<tr>
<th align="center">URL</th>
<th align="center">说明</th>
<th align="center">是否允许通信</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a href="http://www.domain.com/a.js">http://www.domain.com/a.js</a><br><a href="http://www.domain.com/b.js">http://www.domain.com/b.js</a><br><a href="http://www.domain.com/lab/c.js">http://www.domain.com/lab/c.js</a></td>
<td align="center">同一域名，不同文件或路径</td>
<td align="center">允许</td>
</tr>
<tr>
<td align="center"><a href="http://www.domain.com:8000/a.js">http://www.domain.com:8000/a.js</a><br><a href="http://www.domain.com/b.js">http://www.domain.com/b.js</a></td>
<td align="center">同一域名，不同端口</td>
<td align="center">不允许</td>
</tr>
<tr>
<td align="center"><a href="http://www.domain.com/a.js">http://www.domain.com/a.js</a><br><a href="https://www.domain.com/b.js">https://www.domain.com/b.js</a></td>
<td align="center">同一域名，不同协议</td>
<td align="center">不允许</td>
</tr>
<tr>
<td align="center"><a href="http://www.domain.com/a.js">http://www.domain.com/a.js</a><br><a href="http://192.168.4.12/b.js">http://192.168.4.12/b.js</a></td>
<td align="center">域名和域名对应相同ip</td>
<td align="center">不允许</td>
</tr>
<tr>
<td align="center"><a href="http://www.domain.com/a.js">http://www.domain.com/a.js</a><br><a href="http://192.168.4.12/b.js">http://192.168.4.12/b.js</a></td>
<td align="center">域名和域名对应相同ip</td>
<td align="center">不允许</td>
</tr>
<tr>
<td align="center"><a href="http://www.domain.com/a.js">http://www.domain.com/a.js</a><br><a href="http://x.domain.com/b.js">http://x.domain.com/b.js</a><br><a href="http://domain.com/c.js">http://domain.com/c.js</a></td>
<td align="center">主域相同，子域不同</td>
<td align="center">不允许</td>
</tr>
<tr>
<td align="center"><a href="http://www.domain1.com/a.js">http://www.domain1.com/a.js</a><br><a href="http://www.domain2.com/b.js">http://www.domain2.com/b.js</a></td>
<td align="center">不同域名</td>
<td align="center">不允许</td>
</tr>
</tbody></table>
<p>data：URLs获得一个新的，空的安全上下文。</p>
<p>在页面中用 about:blank 或 javascript: URL 执行的脚本会继承打开该 URL 的文档的源，因为这些类型的 URLs 没有明确包含有关原始服务器的信息。</p>
<h2 id="避免同源限制"><a href="#避免同源限制" class="headerlink" title="避免同源限制"></a>避免同源限制</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>同源网页的Cookie才能共享，但是两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享cookie</p>
<blockquote>
<p>该方法只适用于Cookie和iframe窗口。 localStorage和IndexDB无法通过这种方法规避，而要使用PostMessage API</p>
</blockquote>
<p>另外，服务器也可以在设置cookie时，指定cookie所属域名为一级域名</p>
<pre><code>Set-Cookie: key=value; domain=.example.com; path=/
</code></pre>
<p>这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie</p>
<h3 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h3><p>如果两个网页不同源，就无法拿到对方的DOM，典型例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。</p>
<p>如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的document.domain属性，就可以规避同源政策，拿到DOM。</p>
<p>对于完全不同源的网站，目前有三种方法，可以解决跨域窗口的通信问题。</p>
<ul>
<li>片段识别符 fragment identifier</li>
<li>window.name</li>
<li>跨文档通信API Cross-document messaging</li>
</ul>
<ol>
<li>片段识别符</li>
</ol>
<p>片段识别符指的是 url的#号后面部分，如果只是改变片段标识符，页面不会重新刷新。父窗口可以把信息，写入子窗口的片段标识符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> src = originURL + <span class="string">&#x27;#&#x27;</span> + data</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myIframe&#x27;</span>).<span class="property">src</span> = src</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子窗口通过监听hashchange事件得到通知</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onhashchange</span> = checkMessage</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> message = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hash</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样子窗口也可以改变父窗口的片段标识符</p>
<pre><code>parent.location.href = target + &#39;#&#39; + hash
</code></pre>
<ol start="2">
<li>window.name</li>
</ol>
<p>浏览器窗口有window.name属性。这个属性最大特点是，无论是否同源，只要是在同一个窗口里，前一个网页设置里这个属性，后一个网页可以读取它。</p>
<p>父窗口先打开一个子窗口，载入一个不同源的页面，该页面将信息写入window.name属性</p>
<pre><code>window.name = data
</code></pre>
<p>接着，子窗口跳回一个与主窗口同域的网址</p>
<pre><code>location = &#39;http://parent.url.com/xxx.html&#39;
</code></pre>
<p>然后，主窗口就可以读取子窗口的window.name了</p>
<pre><code>var data = document.getElementById(&#39;myFrame&#39;).contentWindow.name
</code></pre>
<p>该方法的优点是，window.name容量很大，可以放置很长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能。</p>
<p><strong>document.domain</strong></p>
<p>通过修改document的domain属性，我们可以在域和子域或者不同的子域之间通信。同域策略认为域和子域隶属于不同的域，比如<a href="http://www.a.com和sub.a.com是不同的域,这时,我们无法在www.a.com下的页面中调用sub.a.com中定义的javascript方法.但是当我们把它们document的domain属性都修改为a.com,浏览器就会认为它们处于同一个域下,那么我们就可以互相调用对方的method来通信了./">www.a.com和sub.a.com是不同的域，这时，我们无法在www.a.com下的页面中调用sub.a.com中定义的JavaScript方法。但是当我们把它们document的domain属性都修改为a.com，浏览器就会认为它们处于同一个域下，那么我们就可以互相调用对方的method来通信了。</a></p>
<ol start="3">
<li>window.postMessage</li>
</ol>
<p>上两种都属于抖机灵操作，HTML为解决该问题，引入了一个全新的API，跨文档通信API Cross-document messaging</p>
<p>该API为window对象新增了一个<code>window.postMessage</code>方法，允许跨窗口通信，无论这两个窗口是否同源</p>
<p>举例来说，父窗口<a href="http://aaa.com向子窗口http//bbb.com%E5%8F%91%E6%B6%88%E6%81%AF%EF%BC%8C%E8%B0%83%E7%94%A8postMessage%E6%96%B9%E6%B3%95%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86%E3%80%82">http://aaa.com向子窗口http://bbb.com发消息，调用postMessage方法就可以了。</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> popup = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;http://bbb.com&#x27;</span>, title)</span><br><span class="line">popup.<span class="title function_">postMessage</span>(<span class="string">&#x27;hello world&#x27;</span>, <span class="string">&#x27;http://bbb.com&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>postMessage方法的第一个参数是具体的信息内容，第二个参数是接受消息的窗口的源origin，即协议+域名+端口。也可以设为*，表示不限制域名，向所有窗口发送。</p>
<p>子窗口向父窗口发送消息的写法类似：</p>
<pre><code>widnow.opener.postMessage(&#39;Nice to see you&#39;, &#39;http://aaa.com&#39;)
</code></pre>
<p>父窗口和子窗口都可以通过message事件，监听对方的消息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<h3 id="server-proxy"><a href="#server-proxy" class="headerlink" title="server proxy"></a>server proxy</h3><p>在数据提供方没有提供对JSONP协议或者window.name协议的支持，也没有对其它域开放访问权限时，我们可以通过server proxy的方式来抓取数据。</p>
<p>例如当<a href="http://www.a.com域下的页面需要请求www.b.com下的资源文件asset.txt时,直接发送一个指向www.b.com/asset.txt%E7%9A%84Ajax%E8%AF%B7%E6%B1%82%E8%82%AF%E5%AE%9A%E6%98%AF%E4%BC%9A%E8%A2%AB%E6%B5%8F%E8%A7%88%E5%99%A8%E9%98%BB%E6%AD%A2%E3%80%82%E8%BF%99%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8www.a.com%E4%B8%8B%E9%85%8D%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%90%86%EF%BC%8C%E7%84%B6%E5%90%8E%E6%8A%8AAjax%E8%AF%B7%E6%B1%82%E7%BB%91%E5%AE%9A%E5%88%B0%E8%BF%99%E4%B8%AA%E4%BB%A3%E7%90%86%E8%B7%AF%E5%BE%84%E4%B8%8B%EF%BC%8C%E4%BE%8B%E5%A6%82www.a.com/proxy/">www.a.com域下的页面需要请求www.b.com下的资源文件asset.txt时，直接发送一个指向www.b.com/asset.txt的Ajax请求肯定是会被浏览器阻止。这时，我们在www.a.com下配一个代理，然后把Ajax请求绑定到这个代理路径下，例如www.a.com/proxy/</a>, 然后这个代理发送HTTP请求访问<a href="http://www.b.com下的asset.txt,跨域的http请求是在服务器端进行的,客户端并没有产生跨域的ajax请求.这个跨域方式不需要和目标资源签订协议,带有侵略性,另外需要注意的是实践中应该对这个代理实施一定程度的保护,比如限制他人使用或者使用频率./">www.b.com下的asset.txt，跨域的HTTP请求是在服务器端进行的，客户端并没有产生跨域的Ajax请求。这个跨域方式不需要和目标资源签订协议，带有侵略性，另外需要注意的是实践中应该对这个代理实施一定程度的保护，比如限制他人使用或者使用频率。</a></p>
<h2 id="Ajax跨域"><a href="#Ajax跨域" class="headerlink" title="Ajax跨域"></a>Ajax跨域</h2><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老实浏览器全部支持，服务器改造小。</p>
<p>它的基本思想是，网页通过添加一个<code>script</code>标签，向服务器请求json数据，这种做法不受同源策略限制；服务器接受请求后，将数据放在一个指定名字的回调里传回来</p>
<p>首先，网页动态插入<code>script</code>元素，由它向跨源网址发出请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addScriptTag</span>(<span class="params">src</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElmement</span>(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">  script.<span class="property">src</span> = src</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">addScriptTag</span>(<span class="string">&#x27;http://example.com/ip=0.0.0.0?callback=foo&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;your public IP address is: &#x27;</span> + data.<span class="property">ip</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>script</code>元素请求的脚本， 直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为js对象，而不是字符串，因此避免了使用JSON.parse的步骤</p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p><code>WebSocket</code>是一种通信协议，使用ws:&#x2F;&#x2F; (非加密) 和 wss:&#x2F;&#x2F; (加密) 作为协议前缀。该协议不实行同源限制，只要服务器支持，就可以使用它进行跨源通信。</p>
<p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。</p>
<p>我们来看下例子，下面是前端部分代码：(原生WebSocket API使用起来不太方便，我们使用Socket.io)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>user: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./socket.io.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> socket = <span class="title function_">io</span>(<span class="string">&#x27;http://www.domain2.com:8080&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 连接成功处理</span></span></span><br><span class="line"><span class="language-javascript">  socket.<span class="title function_">on</span>(<span class="string">&#x27;connect&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 监听服务端消息</span></span></span><br><span class="line"><span class="language-javascript">    socket.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;data from server: &#x27;</span> + msg)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;text&#x27;</span>).<span class="property">onblur</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    socket.<span class="title function_">send</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>node.js socket 部分实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> socket = <span class="built_in">require</span>(<span class="string">&#x27;socket.io&#x27;</span>)</span><br><span class="line"><span class="comment">// 启http服务</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  res.<span class="title function_">end</span>()</span><br><span class="line">&#125;)</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server is running at port 8080&#x27;</span>)</span><br><span class="line"><span class="comment">// 监听socket连接</span></span><br><span class="line">socket.<span class="title function_">listen</span>(server).<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="params">client</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 接受消息</span></span><br><span class="line">  client.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">    client.<span class="title function_">send</span>(<span class="string">&#x27;hello: &#x27;</span> + msg)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;data from client: &#x27;</span> + msg)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 断开处理</span></span><br><span class="line">  client.<span class="title function_">on</span>(<span class="string">&#x27;disconnect&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;client socket has closed.&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>下例是浏览器发出的WebSocket请求的头信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /chat HTTP /1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http://example.com</span><br></pre></td></tr></table></figure>

<p>上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。</p>
<p>正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure>

<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS是一个W3C标准，全称是”跨域资源共享” Cross Origin Resource Share，它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</p>
<blockquote>
<p>实现CORS通信的关键是服务端，只要服务端实现了CORS接口，就可以跨源通信</p>
</blockquote>
<p>具体看软一峰老师这篇就好<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解</a></p>
<p>CORS目前是跨域的主流解决方案，相比JSONP更为强大。JSONP只支持GET请求，而CORS支持所有类型的HTTP请求。但是JSONP有优势在于兼容性，所以还是需要根据场景来决定是否使用该方案。</p>
<h3 id="nginx代理跨域"><a href="#nginx代理跨域" class="headerlink" title="nginx代理跨域"></a>nginx代理跨域</h3><p><strong>nginx配置解决iconfont跨域</strong></p>
<p>浏览器跨域访问JS、CSS、img等常规静态资源被同源策略许可，但iconfont字体文件例外，此时可在nginx的静态资源服务器中加入以下配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  add_header Access-Control-Allow-Origin: *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>nginx反向代理跨域接口</strong></p>
<p>跨域原理：同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略也就不存在跨域问题了。</p>
<p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做桥接，反向代理访问domain2接口，并且可顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。下面是具体配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># proxy服务器</span></span><br><span class="line">server &#123;</span><br><span class="line">  listen 81;</span><br><span class="line">  server_name www.domain1.com;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://www.domain2.com:8080; <span class="comment"># 反向代理</span></span><br><span class="line">    proxy_cookie_domain www.domain2.com www.domain1.com; <span class="comment"># 修改cookie里域名</span></span><br><span class="line">    index index.html index.htm;</span><br><span class="line">    <span class="comment"># 当用webpack-dev-server等中间件代理接口访问nginx时，此时无浏览器参与</span></span><br><span class="line">    <span class="comment"># 所以没有同源限制，下面的跨域配置可不启用</span></span><br><span class="line">    add_header Access-Control-Allow-Origin http://www.domain1.com; <span class="comment"># 当前端只跨域不带cookie时，可为 *</span></span><br><span class="line">    add_header Access-Control-Allow-Credentails <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前端代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"><span class="comment">// 前端开关，浏览器是否读写cookie</span></span><br><span class="line">xhr.<span class="property">withCredentails</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 访问nginx中的代理服务器</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;http://www.domain1.com:81/?user=admin&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.<span class="title function_">send</span>()</span><br></pre></td></tr></table></figure>

<p>node.js后台示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>()</span><br><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> params = qs.<span class="title function_">parse</span>(req.<span class="property">url</span>.<span class="title function_">substring</span>(<span class="number">2</span>))</span><br><span class="line">  <span class="comment">// 向前台写cookie</span></span><br><span class="line">  res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;Set-Cookie&#x27;</span>: <span class="string">&#x27;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#x27;</span></span><br><span class="line">    <span class="comment">// 设置HttpOnly 前端无法通过document.cookie读取</span></span><br><span class="line">  &#125;)</span><br><span class="line">  res.<span class="title function_">write</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(params))</span><br><span class="line">  res.<span class="title function_">end</span>()</span><br><span class="line">&#125;)</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server is running at port 8080&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="常见安全问题及思考"><a href="#常见安全问题及思考" class="headerlink" title="常见安全问题及思考"></a>常见安全问题及思考</h2><h3 id="JSONP导致的安全问题"><a href="#JSONP导致的安全问题" class="headerlink" title="JSONP导致的安全问题"></a>JSONP导致的安全问题</h3><p>我们知道，一切用户输入都是“有害”的。传入callback值会在结果里面直接返回。因此，如果该参数过滤不严格，会导致XSS</p>
<ol>
<li>Callback可自定义导致的安全问题</li>
</ol>
<p>当输出 JSON 时，没有严格定义好 Content-Type（ Content-Type: application&#x2F;json ）然后加上 callback 这个输出点没有进行过滤直接导致了一个典型的 XSS 漏洞。例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">v</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(v.<span class="property">name</span>);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://0.0.0.0/1.php?callback=test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$callback</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;callback&#x27;</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="variable">$callback</span>.<span class="string">&#x27;(&#123; &quot;id&quot;: &quot;1&quot;, &quot;name&quot;: &quot;vincent&quot; &#125;);&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于这种漏洞，主要修复手段：</p>
<ul>
<li>严格定义 <code>Content-Type: application/json</code></li>
<li>过滤callback以及JSON数据输出(针对输出结果进行转码处理)</li>
</ul>
<ol start="2">
<li>json劫持</li>
</ol>
<p>json劫持属于CSRF的范畴。攻击者可以在自己的站点中写入一条访问JSON的JS，在用户cookie未过期的情况下，JSON中会返回敏感的用户信息，然后攻击者可以获取到数据，并发送到自己的站点</p>
<p>敏感数据获取程序如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// alert(v.name)</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> url = <span class="string">&#x27;http://0.0.0.0/&#x27;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data)</span></span><br><span class="line"><span class="language-javascript">  xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url, <span class="literal">true</span>)</span></span><br><span class="line"><span class="language-javascript">  xhr.<span class="title function_">send</span>()</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://x.x.x.x/1.php?callback=test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是<code>Content-Type</code>和<code>X-Content-Type-Options</code>头，如果在API请求的响应标头中，<code>X-Content-Type-Options</code>设置为<code>nosniff</code>，则必须将<code>Content-Type</code>设置为 JS(text&#x2F;javascript、application&#x2F;javascript, text&#x2F;ecmascript)来在所有浏览器上生效。这是因为通过在响应中包含回调，响应不再是JSON，而是JavaScript</p>
<p>若配置</p>
<pre><code>header(&#39;Content-type: application/json; chartset=utf-8&#39;)
header(&#39;X-Content-Type-Options: nosniff&#39;)
</code></pre>
<p>console输入如下：</p>
<pre><code>Refused to execute script from &#39;http://10.59.0.248/1.php?callback=test&#39; because its MIME type (&#39;application/json&#39;) is not executable, and strict MIME type checking is enabled.
</code></pre>
<p>常见的修复方案：</p>
<ol>
<li>Referer正则匹配</li>
</ol>
<p>常见的有Referer匹配正则编写错误导致正则绕过。（一般情况下浏览器直接访问某URL是不带Referer的，所以很多防御部署是允许空Referer的）</p>
<ol start="2">
<li>添加Token</li>
<li>放弃使用jsonp跨域获取数据，使用CORS或PostMessage</li>
</ol>
<h3 id="CORS的安全性问题"><a href="#CORS的安全性问题" class="headerlink" title="CORS的安全性问题"></a>CORS的安全性问题</h3><p>重点参考这篇</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#">MDN HTTP访问控制（CORS）</a></p>
<p><a href="https://dailc.github.io/2018/01/04/security_ajaxissafeornot.html">AJAX请求真的不安全么？谈谈Web安全与AJAX的关系</a></p>
<p>Access-Control-Allow-Origin就是一个允许请求的域白名单，只有是这个域里有的，服务器才会统一跨域请求，如果合理的设置白名单，反而可以避免CSRF攻击。</p>
<p>设置成*的一般是公共的API，为了避免被频繁请求或DDOS，一般会多出密钥验证的步骤，并且限制请求频率和次数。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">浏览器同源政策及其规避方法</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解</a></li>
<li><a href="http://www.cnblogs.com/hustskyking/archive/2013/03/31/CDS-introduce.html">JavaScript跨域（1）：什么是跨域，如何跨域</a></li>
<li><a href="http://www.cnblogs.com/hustskyking/articles/ten-methods-cross-domain.html">跨域资源共享的10种方式</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#">MDN HTTP访问控制（CORS）</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/domain#helloworld">MDN - Document.domain</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">MDN - 浏览器的同源策略</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#">MDN HTTP访问控制（CORS）</a></li>
<li><a href="https://dailc.github.io/2018/01/04/security_ajaxissafeornot.html">AJAX请求真的不安全么？谈谈Web安全与AJAX的关系</a></li>
</ul>
]]></content>
      <categories>
        <category>编程学习</category>
      </categories>
      <tags>
        <tag>跨域</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>【部署】如何用心仪的域名访问博客？记录上线过程</title>
    <url>/2024/01/09/2d58d0c0-af94-11ee-85f5-25fd4f01902b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>经过大半个月的折腾，看到自己的博客成功上线并能够访问，感到非常欣喜。尽管之前写过类似的文章，但貌似不见了，因此我决定重新写一篇，作为总结，并顺便为博客注入新的活力。</p>
<span id="more"></span>

<p><strong>写在之前：</strong></p>
<p>说明一下，我已经完成了 Github&#x2F;Gitee Pages 和 Hexo 等搭建工作，因此不会再详细描述这些步骤。最初，我的博客是为了分享给家人和朋友看的，由于他们可能没有梯子等工具，因此如果网站加载速度缓慢，会严重影响他们对网站的评价。（我正好也准备面试性能优化这方面的知识，可以在后面展开讨论，但在这篇文章中就不详述了。）</p>
<p>接下来，我将总结一下，我是如何从零开始搭建博客的。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="选择并购买服务器"><a href="#选择并购买服务器" class="headerlink" title="选择并购买服务器"></a>选择并购买服务器</h2><p>首先打开浏览器，进入搜索引擎，输入：“<code>云服务器选择 -广告 -推广</code>”，进行比价。因为之前我购买域名和服务器时使用的是阿里云，所以这次我也继续选择了它。</p>
<h3 id="如何选择？"><a href="#如何选择？" class="headerlink" title="如何选择？"></a>如何选择？</h3><blockquote>
<p>在选择云服务器时，对于个人开发者来说，最重要的是价格便宜且性价比高。通常来说，2 核 2G 的云服务器，一年大约 200 元左右是可以接受的。这里就不多说了，选择的原则是服务器距离自己的地理位置较近，配置适中，价格可以接受。</p>
</blockquote>
<h3 id="你需要知道的有这些"><a href="#你需要知道的有这些" class="headerlink" title="你需要知道的有这些"></a>你需要知道的有这些</h3><ol>
<li>公网 IP</li>
</ol>
<p>进入云服务器控制台，进入实例（就是你买的服务器）页面。记住公网 IP 即可，之后用 SSH 或 XShell 等填的服务器地址就是这个</p>
<ol start="2">
<li>服务器 root 密码</li>
</ol>
<p>可根据需要自行重置</p>
<ol start="3">
<li>镜像操作系统</li>
</ol>
<p>网上资源和教程都很多，选择较新稳定的版本即可。个人用的是 Ubuntu 20.04 64 位</p>
<h2 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h2><p>推荐使用 XShell、Xftp。前者可以在 Windows 界面下用来访问远端不同系统下的服务器，实现远程控制终端的目的。后者 Xftp 是一个功能强大的 SFTP、FTP 文件传输软件，方便用于远程传输项目、资源文件等。</p>
<a class="tag-Link" target="_blank" href=" https://www.netsarang.com/en/xshell-download/">
    <div class="tag-link-tips">引用站外地址，点击打开新页面标签</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style="background-image: url(https://api.iowen.cn/favicon/ https://www.netsarang.com/en/xshell-download/.png);"></div>
        <div class="tag-link-right">
            <div class="tag-link-title">XShell7</div>
            <div class="tag-link-sitename"> </div>
        </div>
        <i class="fa-solid fa-angle-right"></i>
    </div>
    </a>

<a class="tag-Link" target="_blank" href=" https://www.xshell.com/zh/xftp/">
    <div class="tag-link-tips">引用站外地址，点击打开新页面标签</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style="background-image: url(https://api.iowen.cn/favicon/ https://www.xshell.com/zh/xftp/.png);"></div>
        <div class="tag-link-right">
            <div class="tag-link-title">XFTP7</div>
            <div class="tag-link-sitename"> </div>
        </div>
        <i class="fa-solid fa-angle-right"></i>
    </div>
    </a>

<h2 id="域名和备案"><a href="#域名和备案" class="headerlink" title="域名和备案"></a>域名和备案</h2><p>对应云服务商都可以查询、购买域名，选择自己喜欢的域名即可。需要注意的是，这只是一个开始，想要使其能正常访问需要进行备案和解析。这里就不展开了。现在备案不需要购买那些幕布了，只需要身份证，比以前方便得多，全部可以在线完成。</p>
<h1 id="部署相关配置"><a href="#部署相关配置" class="headerlink" title="部署相关配置"></a>部署相关配置</h1><p>到这里开始正式搭建环境了。打开<code>XShell</code>进入购买的服务器.</p>
<h2 id="升级服务器软件包，安装必要的软件"><a href="#升级服务器软件包，安装必要的软件" class="headerlink" title="升级服务器软件包，安装必要的软件"></a>升级服务器软件包，安装必要的软件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里选的centos所以是yum</span></span><br><span class="line">sudo yum update</span><br><span class="line">sudo yum install git vim openssl build-essential libssh-dev wget curl</span><br></pre></td></tr></table></figure>

<h2 id="安装-nvm"><a href="#安装-nvm" class="headerlink" title="安装 nvm"></a>安装 nvm</h2><p>直接上文档，这里用 Git install 的方式</p>
<a class="tag-Link" target="_blank" href=" https://github.com/nvm-sh/nvm?tab=readme-ov-file#git-install">
    <div class="tag-link-tips">引用站外地址，点击打开新页面标签</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style="background-image: url(https://api.iowen.cn/favicon/ https://github.com/nvm-sh/nvm?tab=readme-ov-file#git-install.png);"></div>
        <div class="tag-link-right">
            <div class="tag-link-title">nvm</div>
            <div class="tag-link-sitename">git install 安装</div>
        </div>
        <i class="fa-solid fa-angle-right"></i>
    </div>
    </a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/nvm-sh/nvm.git .nvm</span><br><span class="line"><span class="built_in">cd</span> .nvm</span><br><span class="line">./install.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启一下就可以访问到nvm命令了</span></span><br><span class="line"><span class="comment"># 查看稳定版本，顺便设置淘宝源</span></span><br><span class="line">nvm ls-remote</span><br><span class="line"></span><br><span class="line">nvm install 16.20.2</span><br><span class="line">node -v <span class="comment"># 可以用了</span></span><br></pre></td></tr></table></figure>

<p>顺便设置 git 的 username 和 email</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;xxx&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;xxx@xxx.com&quot;</span></span><br><span class="line"></span><br><span class="line">npm config <span class="built_in">set</span> registry http://registry.npmmirror.com</span><br></pre></td></tr></table></figure>

<h2 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install nginx <span class="comment"># 安装nginx</span></span><br><span class="line">nginx -v <span class="comment"># 查看版本</span></span><br></pre></td></tr></table></figure>

<h2 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a>配置 nginx</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/nginx/conf.d <span class="comment"># 目录切换到nginx的配置路径</span></span><br><span class="line">vi blog_fridolph_top.conf <span class="comment"># 以 域名.conf 格式命名便于整理</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># fileName: blog-fridolph-top.conf</span></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80; <span class="comment"># 指定端口</span></span><br><span class="line">  server_name blog.fridolph.top; <span class="comment">#你的域名或者 ip</span></span><br><span class="line">  location / &#123;</span><br><span class="line">    root /home/myblog-hexo;  <span class="comment"># 指定静态网站根目录</span></span><br><span class="line">    index index.html index.htm;  <span class="comment"># 指定默认访问文件</span></span><br><span class="line">    default_type <span class="string">&#x27;application/x-javascript;chartset=utf-8&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location ~ .*.(gif|jpg|jpeg|png|webp|bmp|swf)$ &#123;</span><br><span class="line">    expires 30d; <span class="comment"># 静态资源文件 过期时间30天</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location ~ .*.(js|css)?$ &#123;</span><br><span class="line">    expires 1h; <span class="comment"># css/js文件过期时间1小时</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前下的 <code>Xftp</code> 现在就可派上用场了，我一般是根据项目类型放到 服务器 <code>/home/</code> 路径下，填上对应的项目名方便整理。</p>
<p>再执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -t</span><br><span class="line">service nginx restart</span><br></pre></td></tr></table></figure>

<p>再到云服务器的控制台，解析域名，添加<code>@、www、blog、*</code>等对应记录即可</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>服务器里的中文路径，浏览器访问不能正常展示（ 我以前怎么没遇到过这问题？</p>
<blockquote>
<p>解决方案 hexo 的话使用 <code>hexo-uuid</code> 插件，生成的文章用 uuid 来代替原有的中文路径</p>
</blockquote>
<p>折腾了半天的 nginx 配置，发现即便是拿 utf-8 重新保存，打开还是有编码问题。中文支持确实不友好，这也侧面提醒了我们在服务端使用尽量用英文+数字吧，减少潜在的坑。</p>
<h3 id="升级-HTTPS，添加-SSL-证书"><a href="#升级-HTTPS，添加-SSL-证书" class="headerlink" title="升级 HTTPS，添加 SSL 证书"></a>升级 HTTPS，添加 SSL 证书</h3><ol start="0">
<li>服务器安装 certbot 安装相关依赖</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加epel源</span></span><br><span class="line">dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm</span><br><span class="line"><span class="comment"># 更新dnf仓库</span></span><br><span class="line">dnf upgrade</span><br><span class="line"><span class="comment"># 安装snap</span></span><br><span class="line">dnf install snapd -y</span><br><span class="line"><span class="comment"># 设置开机启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> --now snapd.socket</span><br><span class="line"><span class="comment"># 设置软链接  可通过snapd快速调用命令</span></span><br><span class="line"><span class="built_in">ln</span> -s /var/lib/snapd/snap /snap</span><br><span class="line"><span class="comment"># 更新快照</span></span><br><span class="line">snap install core</span><br><span class="line">snap refresh core</span><br><span class="line"><span class="comment"># 可能需要等待会儿</span></span><br><span class="line">snap install --classic certbot</span><br><span class="line"><span class="comment"># 可通过certbot快速调用命令</span></span><br><span class="line"><span class="built_in">ln</span> -s /snap/bin/certbot /usr/bin/certbot</span><br><span class="line"><span class="comment"># certbot安装完毕执行certbot --version，输出版本表示安装成功</span></span><br><span class="line">certbot --version</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按80端口写好对应的conf 能访问即可</span></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name blog.fridolph.top;</span><br><span class="line">  root /home/myblog-hexo;</span><br><span class="line">  rewrite ^(.*)$ https://$host<span class="variable">$1</span>;</span><br><span class="line">  location / &#123;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">    default_type <span class="string">&#x27;application/x-javascript;chartset=utf-8&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  location ~ .*.(gif|jpg|jpeg|png|webp|bmp|swf)$ &#123;</span><br><span class="line">    expires 30d; <span class="comment"># 静态资源文件 过期时间30天</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location ~ .*.(js|css)?$ &#123;</span><br><span class="line">    expires 30m; <span class="comment"># css/js文件过期时间1小时</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行命令扫描 Nginx 所有配置，输出信息，都是英文看不懂自己谷歌，跟着选就好了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">certbot --nginx</span><br><span class="line"><span class="comment"># HTTPS证书最终生成到 /etc/letsencrypt/xxx 目录中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deploying certificate</span></span><br><span class="line"><span class="comment"># Successfully deployed certificate for blog.fridolph.top to /etc/nginx/conf.d/blog-fridolph-top.conf</span></span><br><span class="line"><span class="comment"># Congratulations! You have successfully enabled HTTPS on https://blog.fridolph.top</span></span><br></pre></td></tr></table></figure>

<p>看到上面这个提示就说明成功了</p>
<p>再重启下即可</p>
<h3 id="nginx-不生效问题"><a href="#nginx-不生效问题" class="headerlink" title="nginx 不生效问题"></a>nginx 不生效问题</h3><p>注意路径填写，我之前使用 <code>/root/</code> 根路径下的都不生效 - - 不知道为啥，浪费了好多时间，建议用 <code>/usr</code> 或者 <code>/home</code> 看个人喜好吧</p>
<h3 id="配置成功了但访问不到"><a href="#配置成功了但访问不到" class="headerlink" title="配置成功了但访问不到"></a>配置成功了但访问不到</h3><p>如果是阿里云有默认安全策略，查看一下是否开启了 80 和 443 端口</p>
<p><img src="/2024/01/09/2d58d0c0-af94-11ee-85f5-25fd4f01902b/safe.png" alt="是否开启安全策略"></p>
<h1 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h1><p>网站可以访问啦，接下来就是优化问题，后续有时间再开新坑吧！</p>
]]></content>
      <categories>
        <category>代码相关</category>
      </categories>
      <tags>
        <tag>nvm</tag>
        <tag>nginx</tag>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title>【配置】VS Code常用插件整理-2024版</title>
    <url>/2024/01/13/aa84d770-af93-11ee-a3bf-e16cc0e18c49/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Visual Studio Code是个牛逼的编辑器，启动非常快，我已经抛弃WebStorm Sublime了。<br>支持各种语言，相比其他IDE，轻量级完全可配置还集成Git感觉非常的适合前端开发。 所以我仔细研究了一下文档未来可能会作为主力工具使用。</p>
<p>虽然习惯了N久的快捷键，没法，习惯什么的是吧，习惯下就好了所以 <a href="https://code.visualstudio.com/docs/customization/keybindings">官方快捷键大全</a> ，看看这个就好，好在现在快捷键熟悉得差不多了，不会比sublime慢多少</p>
<span id="more"></span>

<h1 id="VS-code插件整理"><a href="#VS-code插件整理" class="headerlink" title="VS code插件整理"></a>VS code插件整理</h1><p>家里电脑之前杂七杂八东西装太多 &#x3D; &#x3D; 太卡，遂重装了系统，各种环境重新搭一遍。顺便更新这篇吧</p>
<h2 id="基础功能扩展"><a href="#基础功能扩展" class="headerlink" title="基础功能扩展"></a>基础功能扩展</h2><ul>
<li>One monokai 因为我喜欢，我放在第一了</li>
<li>vscode-icons </li>
<li>output colorizer 让log文件变得五颜六色</li>
<li>Color Highlight，识别代码中的颜色，包括各种颜色格式；</li>
<li>Color Manager 调色盘</li>
<li>Bracket Pair Colorizer，识别代码中的各种括号，并且标记上不同的颜色，方便你扫视到匹配的括号，在括号使用非常多的情况下能环节眼部压力，编辑器快捷键固然好用，但是在临近嵌套多的情况下却有些力不从心；</li>
<li>Project Manager，项目管理，让我们方便的在命令面板中切换项目文件夹，当然，你也可以直接打开包含多个项目的父级文件夹，但这样可能会让 VSCode 变慢；</li>
</ul>
<h2 id="代码检查-格式化"><a href="#代码检查-格式化" class="headerlink" title="代码检查 &#x2F; 格式化"></a>代码检查 &#x2F; 格式化</h2><ul>
<li>Prettier 代码格式化，这两个选一个就好</li>
<li>Better Comments 为注释增加几种风格的标注</li>
<li>Better Align md 和 js 里的变量、注释更好的对齐</li>
<li>Conventional Commits 把Conventional拿到vscode了，对个人来说这样提交更快</li>
<li>editorconfig for vscode 支持 .editorconfig</li>
<li>ESlint 代码检查工具不解释了</li>
<li>ESLint Chinese Rules 同上</li>
<li>html snippets</li>
<li>javascript code snippets &#x2F; Super Console 我换成这个了</li>
</ul>
<h2 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h2><ul>
<li>Auto Close Tag，适用于 JSX、Vue、HTML，在打开标签并且键入 <code>&lt;/</code> 的时候，能自动补全要闭合的标签；</li>
<li>Auto Rename Tag，适用于 JSX、Vue、HTML，在修改标签名时，能在你修改开始（结束）标签的时候修改对应的结束（开始）标签，帮你减少 50% 的击键；</li>
<li>auto-header 快速为文件加注释头</li>
<li>Path Intellisense，文件路径补全，在你用任何方式引入文件系统中的路径时提供智能提示和自动完成；</li>
<li>NPM Intellisense，NPM 依赖补全，在你引入任何 node_modules 里面的依赖包时提供智能提示和自动完成；</li>
<li>IntelliSense for CSS class names，CSS 类名补全，会自动扫描整个项目里面的 CSS 类名并在你输入类名时做智能提示；</li>
<li>Auto Comment Blocks 效率注释</li>
</ul>
<h2 id="编码效率"><a href="#编码效率" class="headerlink" title="编码效率"></a>编码效率</h2><ul>
<li>Auto Import 查找帮快速import</li>
<li>HTML-Essentials Web开发插件包</li>
<li>embrace 快速的在选中代码两边添加各种引号、括号，不用来回移动光标</li>
<li>Bracket Pair Colorizer 更方便看括号，作用域等</li>
<li>Code Spell Checker 检查英语拼写是否合法. 选装… 一堆报错</li>
<li>Code Runner 名副其实的代码运行插件，支持数十种语言，在不离开代码编辑器的前提下通过命令面板可直接执行代码，并查看输出</li>
<li>path autocomplete 路径补全</li>
<li>别名路径跳转 就是搜索中文名</li>
<li>Tailwind CSS IntelliSense 如果用tailwind肯定要装</li>
</ul>
<h2 id="项目管理、功能增强"><a href="#项目管理、功能增强" class="headerlink" title="项目管理、功能增强"></a>项目管理、功能增强</h2><ul>
<li>Code Runner 直接跑js代码，node.js</li>
<li>CodeSnap 复制代码生成图片</li>
<li>file peek 可以看到对应文件的代码片段</li>
<li>Svg Preview svg 预览</li>
<li>Settings Sync 基于 Gist 实现 VSCode 用户配置、快捷键配置、已安装插件列表等的备份和恢复功能，配置过程有详细精确的操作步骤文档。生成的备份 Gist 默认是私密的，如果你想设置为共享的，也可以一键切换。</li>
<li>Git Lens 把 VSCode 结合 Git 的使用体验优化到了极致，能让我们在不离开编辑器，不执行任何命令的情况下知晓光标所在位置代码的修改时间、作者信息等。</li>
<li>Code Outline 能在单独窗口中列出当源代码中的各种符号，比如变量名、类名、方法名等，并支持快速跳转，有点类似于 Vim 里面的 ctags，翻看老代码、开源项目代码时非常有用。</li>
<li>Project Management 可简单切换多个项目</li>
</ul>
<h2 id="辅助工具"><a href="#辅助工具" class="headerlink" title="辅助工具"></a>辅助工具</h2><ul>
<li>A-super-translate 英语小白必备</li>
<li>any-rule 很多常用正则</li>
<li>Codelf 变量起名神器</li>
<li>can i use 浏览器兼容性检查</li>
<li>Debugger for Chrome 允许像chrome一样在vs code里调试</li>
<li>partial diff 同名，可以查看文件间的差异</li>
<li>todo highlight 待做项高亮，且可查看统计</li>
<li>Version lens 查看package依赖，且帮更新，需要自行npm install</li>
<li>VSCode Map Preview 地图坐标信息格式文件，就可就行预览</li>
<li>vscode-fileheader 自行生成file header</li>
<li>Super Console 一个前端使用的日志打印工具</li>
</ul>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><ul>
<li>Vue VS Code Extension Pack 一个扩展包，包括10个插件</li>
<li>Vite 不解释，配套Vue3</li>
<li>Vitest Vite的单元测试扩展</li>
</ul>
<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><ul>
<li>ES7+React 开发必备</li>
</ul>
]]></content>
      <categories>
        <category>代码相关</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>【ESLint】配置详解，规范代码</title>
    <url>/2017/01/22/d9f10a10-af93-11ee-b7d4-c7141f6eb230/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<p>在很久之前就想通过工具来规范自己的代码风格，减少程序出错的概率，特别是最近的React, Vue项目里，ESlint成了标配，但是实际上一直懒癌发作也没去看它的文档，使用着它默认的规则，有的地方确实是逼死强迫症，所以为了不那么费力，自己灵活配置会更好些！</p>
</blockquote>
<p>作为一个有理想有抱负的前端工程师，只是使用默认规则，而不是看完文档了然于心，显然是不行滴 ^_^.. 团队协作时，若是团队的代码风格统一，能够大大减少沟通成本。（其实面试时和老大聊到代码规范，当时就说到用 JSHint ，或者 ESLint 等工具来统一的。。。这也算是我来填一个坑吧~）</p>
<p>好了，前情摘要就到这，我们开始吧！</p>
<h2 id="什么是-ESLint-？"><a href="#什么是-ESLint-？" class="headerlink" title="什么是 ESLint ？"></a>什么是 ESLint ？</h2><blockquote>
<p>ESLint 是在 ECMAScript&#x2F;JavaScript 代码中识别和报告模式匹配的工具，它的目标是保证代码的一致性和避免错误。</p>
</blockquote>
<span id="more"></span>

<p>在许多方面，它和 JSLint、JSHint 相似，除了少数的例外：</p>
<ul>
<li>ESLint 使用 Espree 解析 JavaScript。</li>
<li>ESLint 使用 AST 去分析代码中的模式</li>
<li>ESLint 是完全插件化的。</li>
</ul>
<p>每一个规则都是一个插件并且你可以在运行时添加更多的规则。以上来自官网。不想再说下去，反正就是一个代码风格检测工具就对了</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><pre><code>npm install -g eslint
</code></pre>
<p>如果你第一次使用 ESLint，你必须使用 –init 命令新建一个配置文件：</p>
<pre><code>eslint –init
</code></pre>
<p>使用 ESLint 检测任何 JavaScript 文件：</p>
<pre><code>eslint test 2.js
</code></pre>
<p>ESLint 中一些规则运行命令它可以帮你自动修复</p>
<pre><code>eslint test.js –fix
</code></pre>
<p>为了可以更直观的反馈，可能更多的会直接安装编辑器插件来进行错误提示，我使用的是VS Code下个插件就好，配置起来很简单，会自动生成配置文件</p>
<h2 id="规则定义"><a href="#规则定义" class="headerlink" title="规则定义"></a>规则定义</h2><p>ESLint 支持几种格式的配置文件，如果同一个目录下有多个配置文件，ESLint 只会使用一个。优先级顺序如下：</p>
<ul>
<li>JavaScript - 使用 .eslintrc.js 然后输出一个配置对象。</li>
<li>YAML - 使用 .eslintrc.yaml 或 .eslintrc.yml 去定义配置的结构。</li>
<li>JSON -使用 .eslintrc.json 去定义配置的结构，ESLint 的 JSON 文件允许 JavaScript 风格的注释。</li>
<li>Deprecated -使用 .eslintrc，可以使 JSON 也可以是 YAML。</li>
<li>package.json - 在 package.json 里创建一个 eslintConfig属性，在那里定义你的配置。</li>
</ul>
<h2 id="这是我目前使用的-eslintrc"><a href="#这是我目前使用的-eslintrc" class="headerlink" title="这是我目前使用的 .eslintrc"></a>这是我目前使用的 <code>.eslintrc</code></h2><p>算是备份了，也有注释，文件不大，推荐不去掉注释，不然到时忘了难得查</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 环境定义了预定义的全局变量。</span></span><br><span class="line">  <span class="string">&quot;env&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">//环境定义了预定义的全局变量。更多在官网查看</span></span><br><span class="line">    <span class="string">&quot;browser&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;node&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;commonjs&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;amd&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;es6&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;mocha&quot;</span>:<span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// JavaScript 语言选项</span></span><br><span class="line">  <span class="string">&quot;parserOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// ECMAScript 版本</span></span><br><span class="line">    <span class="string">&quot;ecmaVersion&quot;</span>:<span class="number">6</span>,</span><br><span class="line">    <span class="string">&quot;sourceType&quot;</span>:<span class="string">&quot;script&quot;</span>,<span class="comment">//module</span></span><br><span class="line">    <span class="comment">// 想使用的额外的语言特性:</span></span><br><span class="line">    <span class="string">&quot;ecmaFeatures&quot;</span>: &#123;</span><br><span class="line">      <span class="comment">// 允许在全局作用域下使用 return 语句</span></span><br><span class="line">      <span class="string">&quot;globalReturn&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// impliedStric</span></span><br><span class="line">      <span class="string">&quot;impliedStrict&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 启用 JSX</span></span><br><span class="line">      <span class="string">&quot;jsx&quot;</span>:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// &quot;off&quot; 或 0 - 关闭规则</span></span><br><span class="line">  <span class="comment">// &quot;warn&quot; 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出),</span></span><br><span class="line">  <span class="comment">// &quot;error&quot; 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)  </span></span><br><span class="line">  <span class="string">&quot;rules&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">////////////////</span></span><br><span class="line">    <span class="comment">// 可能的错误 //</span></span><br><span class="line">    <span class="comment">////////////////</span></span><br><span class="line">    <span class="comment">// 禁止条件表达式中出现赋值操作符</span></span><br><span class="line">    <span class="string">&quot;no-cond-assign&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁用 console</span></span><br><span class="line">    <span class="string">&quot;no-console&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止在条件中使用常量表达式</span></span><br><span class="line">    <span class="comment">// if (false) &#123;</span></span><br><span class="line">    <span class="comment">// doSomethingUnfinished();</span></span><br><span class="line">    <span class="comment">// &#125; //cuowu</span></span><br><span class="line">    <span class="string">&quot;no-constant-condition&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止在正则表达式中使用控制字符 ：new RegExp(&quot;\x1f&quot;)</span></span><br><span class="line">    <span class="string">&quot;no-control-regex&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗号，</span></span><br><span class="line">    <span class="comment">// always-multiline：多行模式必须带逗号，单行模式不能带逗号</span></span><br><span class="line">    <span class="string">&quot;comma-dangle&quot;</span>: [<span class="number">1</span>,<span class="string">&quot;always-multiline&quot;</span>],</span><br><span class="line">    <span class="comment">// 禁用 debugger</span></span><br><span class="line">    <span class="string">&quot;no-debugger&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止 function 定义中出现重名参数</span></span><br><span class="line">    <span class="string">&quot;no-dupe-args&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止对象字面量中出现重复的 key</span></span><br><span class="line">    <span class="string">&quot;no-dupe-keys&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止重复的 case 标签</span></span><br><span class="line">    <span class="string">&quot;no-duplicate-case&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止空语句块</span></span><br><span class="line">    <span class="string">&quot;no-empty&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止在正则表达式中使用空字符集 (/^abc[]/)</span></span><br><span class="line">    <span class="string">&quot;no-empty-character-class&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止对 catch 子句的参数重新赋值</span></span><br><span class="line">    <span class="string">&quot;no-ex-assign&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止不必要的布尔转换</span></span><br><span class="line">    <span class="string">&quot;no-extra-boolean-cast&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止不必要的括号 //(a * b) + c;//报错</span></span><br><span class="line">    <span class="string">&quot;no-extra-parens&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止不必要的分号</span></span><br><span class="line">    <span class="string">&quot;no-extra-semi&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止对 function 声明重新赋值</span></span><br><span class="line">    <span class="string">&quot;no-func-assign&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止在嵌套的块中出现 function 或 var 声明</span></span><br><span class="line">    <span class="string">&quot;no-inner-declarations&quot;</span>: [<span class="number">2</span>,<span class="string">&quot;functions&quot;</span>],</span><br><span class="line">    <span class="comment">// 禁止 RegExp 构造函数中无效的正则表达式字符串</span></span><br><span class="line">    <span class="string">&quot;no-invalid-regexp&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止在字符串和注释之外不规则的空白</span></span><br><span class="line">    <span class="string">&quot;no-irregular-whitespace&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止在 in 表达式中出现否定的左操作数</span></span><br><span class="line">    <span class="string">&quot;no-negated-in-lhs&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止把全局对象 (Math 和 JSON) 作为函数调用 错误：var math = Math();</span></span><br><span class="line">    <span class="string">&quot;no-obj-calls&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止直接使用 Object.prototypes 的内置属性</span></span><br><span class="line">    <span class="string">&quot;no-prototype-builtins&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止正则表达式字面量中出现多个空格</span></span><br><span class="line">    <span class="string">&quot;no-regex-spaces&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁用稀疏数组</span></span><br><span class="line">    <span class="string">&quot;no-sparse-arrays&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止出现令人困惑的多行表达式</span></span><br><span class="line">    <span class="string">&quot;no-unexpected-multiline&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止在return、throw、continue 和 break语句之后出现不可达代码</span></span><br><span class="line">    <span class="comment">// function foo() &#123;  return true;  console.log(&quot;done&quot;); &#125;</span></span><br><span class="line">    <span class="comment">//错误    </span></span><br><span class="line">    <span class="string">&quot;no-unreachable&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 要求使用 isNaN() 检查 NaN</span></span><br><span class="line">    <span class="string">&quot;use-isnan&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 强制使用有效的 JSDoc 注释</span></span><br><span class="line">    <span class="string">&quot;valid-jsdoc&quot;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 强制 typeof 表达式与有效的字符串进行比较</span></span><br><span class="line">    <span class="comment">// typeof foo === &quot;undefimed&quot; 错误</span></span><br><span class="line">    <span class="string">&quot;valid-typeof&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">//////////////</span></span><br><span class="line">    <span class="comment">// 最佳实践 //</span></span><br><span class="line">    <span class="comment">//////////////</span></span><br><span class="line">    <span class="comment">// 定义对象的set存取器属性时，强制定义get</span></span><br><span class="line">    <span class="string">&quot;accessor-pairs&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 强制数组方法的回调函数中有 return 语句</span></span><br><span class="line">    <span class="string">&quot;array-callback-return&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制把变量的使用限制在其定义的作用域范围内</span></span><br><span class="line">    <span class="string">&quot;block-scoped-var&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 限制圈复杂度，也就是类似if else能连续接多少个</span></span><br><span class="line">    <span class="string">&quot;complexity&quot;</span>: [<span class="number">2</span>,<span class="number">9</span>],</span><br><span class="line">    <span class="comment">// 要求 return 语句要么总是指定返回的值，要么不指定</span></span><br><span class="line">    <span class="string">&quot;consistent-return&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制所有控制语句使用一致的括号风格</span></span><br><span class="line">    <span class="string">&quot;curly&quot;</span>: [<span class="number">2</span>,<span class="string">&quot;all&quot;</span>],</span><br><span class="line">    <span class="comment">// switch 语句强制 default 分支，也可添加 // no default 注释取消此次警告</span></span><br><span class="line">    <span class="string">&quot;default-case&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 强制object.key 中 . 的位置，参数:</span></span><br><span class="line">    <span class="comment">// property，&#x27;.&#x27;号应与属性在同一行</span></span><br><span class="line">    <span class="comment">// object, &#x27;.&#x27; 号应与对象名在同一行</span></span><br><span class="line">    <span class="string">&quot;dot-location&quot;</span>: [<span class="number">2</span>,<span class="string">&quot;property&quot;</span>],</span><br><span class="line">    <span class="comment">// 强制使用.号取属性</span></span><br><span class="line">    <span class="comment">// 参数： allowKeywords：true 使用保留字做属性名时，只能使用.方式取属性</span></span><br><span class="line">    <span class="comment">// false 使用保留字做属性名时, 只能使用[]方式取属性 e.g [2, &#123;&quot;allowKeywords&quot;: false&#125;]</span></span><br><span class="line">    <span class="comment">// allowPattern: 当属性名匹配提供的正则表达式时，</span></span><br><span class="line">    <span class="comment">// 允许使用[]方式取值,否则只能用.号取值 e.g [2, &#123;&quot;allowPattern&quot;: &quot;^[a-z]+(_[a-z]+)+$&quot;&#125;]</span></span><br><span class="line">    <span class="string">&quot;dot-notation&quot;</span>: [<span class="number">2</span>, &#123;<span class="string">&quot;allowKeywords&quot;</span>:<span class="literal">false</span>&#125;],</span><br><span class="line">    <span class="comment">// 使用 === 替代 == allow-null允许null和undefined==</span></span><br><span class="line">    <span class="string">&quot;eqeqeq&quot;</span>: [<span class="number">2</span>,<span class="string">&quot;allow-null&quot;</span>],</span><br><span class="line">    <span class="comment">// 要求 for-in 循环中有一个 if 语句</span></span><br><span class="line">    <span class="string">&quot;guard-for-in&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁用 alert、confirm 和 prompt</span></span><br><span class="line">    <span class="string">&quot;no-alert&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁用 arguments.caller 或 arguments.callee</span></span><br><span class="line">    <span class="string">&quot;no-caller&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 不允许在 case 子句中使用词法声明</span></span><br><span class="line">    <span class="string">&quot;no-case-declarations&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止除法操作符显式的出现在正则表达式开始的位置</span></span><br><span class="line">    <span class="string">&quot;no-div-regex&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止 if 语句中有 return 之后有 else</span></span><br><span class="line">    <span class="string">&quot;no-else-return&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止出现空函数.如果一个函数包含了一条注释，它将不会被认为有问题。</span></span><br><span class="line">    <span class="string">&quot;no-empty-function&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止使用空解构模式no-empty-pattern</span></span><br><span class="line">    <span class="string">&quot;no-empty-pattern&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止在没有类型检查操作符的情况下与 null 进行比较</span></span><br><span class="line">    <span class="string">&quot;no-eq-null&quot;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 禁用 eval()</span></span><br><span class="line">    <span class="string">&quot;no-eval&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止扩展原生类型</span></span><br><span class="line">    <span class="string">&quot;no-extend-native&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止不必要的 .bind() 调用</span></span><br><span class="line">    <span class="string">&quot;no-extra-bind&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁用不必要的标签</span></span><br><span class="line">    <span class="string">&quot;no-extra-label:&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止 case 语句落空</span></span><br><span class="line">    <span class="string">&quot;no-fallthrough&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止数字字面量中使用前导和末尾小数点</span></span><br><span class="line">    <span class="string">&quot;no-floating-decimal&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止使用短符号进行类型转换(!!fOO)</span></span><br><span class="line">    <span class="string">&quot;no-implicit-coercion&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止在全局范围内使用 var 和命名的 function 声明</span></span><br><span class="line">    <span class="string">&quot;no-implicit-globals&quot;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 禁止使用类似 eval() 的方法</span></span><br><span class="line">    <span class="string">&quot;no-implied-eval&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止 this 关键字出现在类和类对象之外</span></span><br><span class="line">    <span class="string">&quot;no-invalid-this&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁用 __iterator__ 属性</span></span><br><span class="line">    <span class="string">&quot;no-iterator&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁用标签语句</span></span><br><span class="line">    <span class="string">&quot;no-labels&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁用不必要的嵌套块</span></span><br><span class="line">    <span class="string">&quot;no-lone-blocks&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止在循环中出现 function 声明和表达式</span></span><br><span class="line">    <span class="string">&quot;no-loop-func&quot;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 禁用魔术数字(3.14什么的用常量代替)</span></span><br><span class="line">    <span class="comment">// &quot;no-magic-numbers&quot;:[2,&#123;&quot;ignore&quot;: [0,-1,1] &#125;],</span></span><br><span class="line">    <span class="comment">// 禁止使用多个空格</span></span><br><span class="line">    <span class="string">&quot;no-multi-spaces&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止使用多行字符串，在 JavaScript 中，可以在新行之前使用斜线创建多行字符串</span></span><br><span class="line">    <span class="string">&quot;no-multi-str&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止对原生对象赋值</span></span><br><span class="line">    <span class="string">&quot;no-native-reassign&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止在非赋值或条件语句中使用 new 操作符</span></span><br><span class="line">    <span class="string">&quot;no-new&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止对 Function 对象使用 new 操作符</span></span><br><span class="line">    <span class="string">&quot;no-new-func&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止对 String，Number 和 Boolean 使用 new 操作符</span></span><br><span class="line">    <span class="string">&quot;no-new-wrappers&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁用八进制字面量</span></span><br><span class="line">    <span class="string">&quot;no-octal&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止在字符串中使用八进制转义序列</span></span><br><span class="line">    <span class="string">&quot;no-octal-escape&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 不允许对 function 的参数进行重新赋值</span></span><br><span class="line">    <span class="string">&quot;no-param-reassign&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁用 __proto__ 属性</span></span><br><span class="line">    <span class="string">&quot;no-proto&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止使用 var 多次声明同一变量</span></span><br><span class="line">    <span class="string">&quot;no-redeclare&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁用指定的通过 require 加载的模块</span></span><br><span class="line">    <span class="string">&quot;no-return-assign&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止使用 javascript: url</span></span><br><span class="line">    <span class="string">&quot;no-script-url&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止自我赋值</span></span><br><span class="line">    <span class="string">&quot;no-self-assign&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止自身比较</span></span><br><span class="line">    <span class="string">&quot;no-self-compare&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁用逗号操作符</span></span><br><span class="line">    <span class="string">&quot;no-sequences&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止抛出非异常字面量</span></span><br><span class="line">    <span class="string">&quot;no-throw-literal&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁用一成不变的循环条件</span></span><br><span class="line">    <span class="string">&quot;no-unmodified-loop-condition&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止出现未使用过的表达式</span></span><br><span class="line">    <span class="string">&quot;no-unused-expressions&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁用未使用过的标签</span></span><br><span class="line">    <span class="string">&quot;no-unused-labels&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止不必要的 .call() 和 .apply()</span></span><br><span class="line">    <span class="string">&quot;no-useless-call&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止不必要的字符串字面量或模板字面量的连接</span></span><br><span class="line">    <span class="string">&quot;no-useless-concat&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁用不必要的转义字符</span></span><br><span class="line">    <span class="string">&quot;no-useless-escape&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁用 void 操作符</span></span><br><span class="line">    <span class="string">&quot;no-void&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止在注释中使用特定的警告术语</span></span><br><span class="line">    <span class="string">&quot;no-warning-comments&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁用 with 语句</span></span><br><span class="line">    <span class="string">&quot;no-with&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 强制在parseInt()使用基数参数</span></span><br><span class="line">    <span class="string">&quot;radix&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 要求所有的 var 声明出现在它们所在的作用域顶部</span></span><br><span class="line">    <span class="string">&quot;vars-on-top&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求 IIFE 使用括号括起来</span></span><br><span class="line">    <span class="string">&quot;wrap-iife&quot;</span>: [<span class="number">2</span>,<span class="string">&quot;any&quot;</span>],</span><br><span class="line">    <span class="comment">// 要求或禁止 “Yoda” 条件</span></span><br><span class="line">    <span class="string">&quot;yoda&quot;</span>: [<span class="number">2</span>,<span class="string">&quot;never&quot;</span>],</span><br><span class="line">    <span class="comment">// 要求或禁止使用严格模式指令</span></span><br><span class="line">    <span class="string">&quot;strict&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">//////////////</span></span><br><span class="line">    <span class="comment">// 变量声明 //</span></span><br><span class="line">    <span class="comment">//////////////</span></span><br><span class="line">    <span class="comment">// 要求或禁止 var 声明中的初始化(初值)</span></span><br><span class="line">    <span class="string">&quot;init-declarations&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 不允许 catch 子句的参数与外层作用域中的变量同名</span></span><br><span class="line">    <span class="string">&quot;no-catch-shadow&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止删除变量</span></span><br><span class="line">    <span class="string">&quot;no-delete-var&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 不允许标签与变量同名</span></span><br><span class="line">    <span class="string">&quot;no-label-var&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁用特定的全局变量</span></span><br><span class="line">    <span class="string">&quot;no-restricted-globals&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止 var 声明 与外层作用域的变量同名</span></span><br><span class="line">    <span class="string">&quot;no-shadow&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止覆盖受限制的标识符</span></span><br><span class="line">    <span class="string">&quot;no-shadow-restricted-names&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁用未声明的变量，除非它们在 /*global */ 注释中被提到</span></span><br><span class="line">    <span class="string">&quot;no-undef&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止将变量初始化为 undefined</span></span><br><span class="line">    <span class="string">&quot;no-undef-init&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止将 undefined 作为标识符</span></span><br><span class="line">    <span class="string">&quot;no-undefined&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止出现未使用过的变量</span></span><br><span class="line">    <span class="string">&quot;no-unused-vars&quot;</span>: [<span class="number">0</span>, &#123;<span class="string">&quot;vars&quot;</span>:<span class="string">&quot;all&quot;</span>,<span class="string">&quot;args&quot;</span>:<span class="string">&quot;none&quot;</span>&#125;],</span><br><span class="line">    <span class="comment">// 不允许在变量定义之前使用它们</span></span><br><span class="line">    <span class="string">&quot;no-use-before-define&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">//////////////////////////</span></span><br><span class="line">    <span class="comment">// Node.js and CommonJS //</span></span><br><span class="line">    <span class="comment">//////////////////////////</span></span><br><span class="line">    <span class="comment">// require return statements after callbacks</span></span><br><span class="line">    <span class="string">&quot;callback-return&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求 require() 出现在顶层模块作用域中</span></span><br><span class="line">    <span class="string">&quot;global-require&quot;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 要求回调函数中有容错处理</span></span><br><span class="line">    <span class="string">&quot;handle-callback-err&quot;</span>: [<span class="number">2</span>,<span class="string">&quot;^(err|error)$&quot;</span>],</span><br><span class="line">    <span class="comment">// 禁止混合常规 var 声明和 require 调用</span></span><br><span class="line">    <span class="string">&quot;no-mixed-requires&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止调用 require 时使用 new 操作符</span></span><br><span class="line">    <span class="string">&quot;no-new-require&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止对 __dirname 和 __filename进行字符串连接</span></span><br><span class="line">    <span class="string">&quot;no-path-concat&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁用 process.env</span></span><br><span class="line">    <span class="string">&quot;no-process-env&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁用 process.exit()</span></span><br><span class="line">    <span class="string">&quot;no-process-exit&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁用同步方法</span></span><br><span class="line">    <span class="string">&quot;no-sync&quot;</span>:<span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////</span></span><br><span class="line">    <span class="comment">// 风格指南 //</span></span><br><span class="line">    <span class="comment">//////////////</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定数组的元素之间要以空格隔开(, 后面)， </span></span><br><span class="line">    <span class="comment">// never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格</span></span><br><span class="line">    <span class="string">&quot;array-bracket-spacing&quot;</span>: [<span class="number">2</span>,<span class="string">&quot;never&quot;</span>],</span><br><span class="line">    <span class="comment">// 禁止或强制在单行代码块中使用空格(禁用)</span></span><br><span class="line">    <span class="string">&quot;block-spacing&quot;</span>:[<span class="number">1</span>,<span class="string">&quot;never&quot;</span>],</span><br><span class="line">    <span class="comment">//强制使用一致的缩进 第二个参数为 &quot;tab&quot; 时，会使用tab，</span></span><br><span class="line">    <span class="comment">// if while function 后面的&#123;必须与if在同一行，java风格。</span></span><br><span class="line">    <span class="string">&quot;brace-style&quot;</span>: [<span class="number">2</span>,<span class="string">&quot;1tbs&quot;</span>, &#123;<span class="string">&quot;allowSingleLine&quot;</span>:<span class="literal">true</span>&#125;],</span><br><span class="line">    <span class="comment">// 双峰驼命名格式</span></span><br><span class="line">    <span class="string">&quot;camelcase&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 控制逗号前后的空格</span></span><br><span class="line">    <span class="string">&quot;comma-spacing&quot;</span>: [<span class="number">2</span>, &#123;<span class="string">&quot;before&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;after&quot;</span>:<span class="literal">true</span>&#125;],</span><br><span class="line">    <span class="comment">// 控制逗号在行尾出现还是在行首出现 (默认行尾)</span></span><br><span class="line">    <span class="comment">// http://eslint.org/docs/rules/comma-style</span></span><br><span class="line">    <span class="string">&quot;comma-style&quot;</span>: [<span class="number">2</span>,<span class="string">&quot;last&quot;</span>],</span><br><span class="line">    <span class="comment">//&quot;SwitchCase&quot; (默认：0) 强制 switch 语句中的 case 子句的缩进水平</span></span><br><span class="line">    <span class="comment">// 以方括号取对象属性时，[ 后面和 ] 前面是否需要空格, 可选参数 never, always</span></span><br><span class="line">    <span class="string">&quot;computed-property-spacing&quot;</span>: [<span class="number">2</span>,<span class="string">&quot;never&quot;</span>],</span><br><span class="line">    <span class="comment">// 用于指统一在回调函数中指向this的变量名，箭头函数中的this已经可以指向外层调用者，应该没卵用了</span></span><br><span class="line">    <span class="comment">// e.g [0,&quot;that&quot;] 指定只能 var that = this. </span></span><br><span class="line">    <span class="comment">// that不能指向其他任何值，this也不能赋值给that以外的其他值</span></span><br><span class="line">    <span class="string">&quot;consistent-this&quot;</span>: [<span class="number">1</span>,<span class="string">&quot;that&quot;</span>],</span><br><span class="line">    <span class="comment">// 强制使用命名的 function 表达式</span></span><br><span class="line">    <span class="string">&quot;func-names&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 文件末尾强制换行</span></span><br><span class="line">    <span class="string">&quot;eol-last&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// &quot;indent&quot;: [2,4, &#123;&quot;SwitchCase&quot;:1&#125;],</span></span><br><span class="line">    <span class="comment">// 强制在对象字面量的属性中键和值之间使用一致的间距</span></span><br><span class="line">    <span class="string">&quot;key-spacing&quot;</span>: [<span class="number">2</span>, &#123;<span class="string">&quot;beforeColon&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;afterColon&quot;</span>:<span class="literal">true</span>&#125;],</span><br><span class="line">    <span class="comment">// 强制使用一致的换行风格</span></span><br><span class="line">    <span class="string">&quot;linebreak-style&quot;</span>: [<span class="number">1</span>,<span class="string">&quot;unix&quot;</span>],</span><br><span class="line">    <span class="comment">// 要求在注释周围有空行 ( 要求在块级注释之前有一空行)</span></span><br><span class="line">    <span class="string">&quot;lines-around-comment&quot;</span>: [<span class="number">1</span>,&#123;<span class="string">&quot;beforeBlockComment&quot;</span>:<span class="literal">true</span>&#125;],</span><br><span class="line">    <span class="comment">// 强制一致地使用函数声明或函数表达式，方法定义风格，参数：</span></span><br><span class="line">    <span class="comment">// declaration: 强制使用方法声明的方式，function f()&#123;&#125; e.g [2, &quot;declaration&quot;]</span></span><br><span class="line">    <span class="comment">// expression：强制使用方法表达式的方式，var f = function() &#123;&#125; e.g [2, &quot;expression&quot;]</span></span><br><span class="line">    <span class="comment">// allowArrowFunctions: declaration风格中允许箭头函数。 </span></span><br><span class="line">    <span class="comment">// e.g [2, &quot;declaration&quot;, &#123; &quot;allowArrowFunctions&quot;: true &#125;]</span></span><br><span class="line">    <span class="string">&quot;func-style&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制回调函数最大嵌套深度 5层</span></span><br><span class="line">    <span class="string">&quot;max-nested-callbacks&quot;</span>: [<span class="number">1</span>,<span class="number">5</span>],</span><br><span class="line">    <span class="comment">// 禁止使用指定的标识符</span></span><br><span class="line">    <span class="string">&quot;id-blacklist&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制标识符的最新和最大长度</span></span><br><span class="line">    <span class="string">&quot;id-length&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求标识符匹配一个指定的正则表达式</span></span><br><span class="line">    <span class="string">&quot;id-match&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制在 JSX 属性中一致地使用双引号或单引号</span></span><br><span class="line">    <span class="string">&quot;jsx-quotes&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制在关键字前后使用一致的空格 (前后腰需要)</span></span><br><span class="line">    <span class="string">&quot;keyword-spacing&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 强制一行的最大长度</span></span><br><span class="line">    <span class="string">&quot;max-len&quot;</span>:[<span class="number">1</span>,<span class="number">200</span>],</span><br><span class="line">    <span class="comment">// 强制最大行数</span></span><br><span class="line">    <span class="string">&quot;max-lines&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制 function 定义中最多允许的参数数量</span></span><br><span class="line">    <span class="string">&quot;max-params&quot;</span>:[<span class="number">1</span>,<span class="number">7</span>],</span><br><span class="line">    <span class="comment">// 强制 function 块最多允许的的语句数量</span></span><br><span class="line">    <span class="string">&quot;max-statements&quot;</span>:[<span class="number">1</span>,<span class="number">200</span>],</span><br><span class="line">    <span class="comment">// 强制每一行中所允许的最大语句数量</span></span><br><span class="line">    <span class="string">&quot;max-statements-per-line&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求构造函数首字母大写 </span></span><br><span class="line">    <span class="comment">//（要求调用 new 操作符时有首字母大小的函数，允许调用首字母大写的函数时没有 new 操作符。）</span></span><br><span class="line">    <span class="string">&quot;new-cap&quot;</span>: [<span class="number">2</span>, &#123;<span class="string">&quot;newIsCap&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;capIsNew&quot;</span>:<span class="literal">false</span>&#125;],</span><br><span class="line">    <span class="comment">// 要求调用无参构造函数时有圆括号</span></span><br><span class="line">    <span class="string">&quot;new-parens&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 要求或禁止 var 声明语句后有一行空行</span></span><br><span class="line">    <span class="string">&quot;newline-after-var&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止使用 Array 构造函数</span></span><br><span class="line">    <span class="string">&quot;no-array-constructor&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁用按位运算符</span></span><br><span class="line">    <span class="string">&quot;no-bitwise&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求 return 语句之前有一空行</span></span><br><span class="line">    <span class="string">&quot;newline-before-return&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求方法链中每个调用都有一个换行符</span></span><br><span class="line">    <span class="string">&quot;newline-per-chained-call&quot;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 禁用 continue 语句</span></span><br><span class="line">    <span class="string">&quot;no-continue&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止在代码行后使用内联注释</span></span><br><span class="line">    <span class="string">&quot;no-inline-comments&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止 if 作为唯一的语句出现在 else 语句中</span></span><br><span class="line">    <span class="string">&quot;no-lonely-if&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止混合使用不同的操作符</span></span><br><span class="line">    <span class="string">&quot;no-mixed-operators&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 不允许空格和 tab 混合缩进</span></span><br><span class="line">    <span class="string">&quot;no-mixed-spaces-and-tabs&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 不允许多个空行</span></span><br><span class="line">    <span class="string">&quot;no-multiple-empty-lines&quot;</span>: [<span class="number">2</span>, &#123;<span class="string">&quot;max&quot;</span>:<span class="number">2</span>&#125;],</span><br><span class="line">    <span class="comment">// 不允许否定的表达式</span></span><br><span class="line">    <span class="string">&quot;no-negated-condition&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 不允许使用嵌套的三元表达式</span></span><br><span class="line">    <span class="string">&quot;no-nested-ternary&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止使用 Object 的构造函数</span></span><br><span class="line">    <span class="string">&quot;no-new-object&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止使用一元操作符 ++ 和 --</span></span><br><span class="line">    <span class="string">&quot;no-plusplus&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止使用特定的语法</span></span><br><span class="line">    <span class="string">&quot;no-restricted-syntax&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止 function 标识符和括号之间出现空格</span></span><br><span class="line">    <span class="string">&quot;no-spaced-func&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 不允许使用三元操作符</span></span><br><span class="line">    <span class="string">&quot;no-ternary&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁用行尾空格</span></span><br><span class="line">    <span class="string">&quot;no-trailing-spaces&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止标识符中有悬空下划线_bar</span></span><br><span class="line">    <span class="string">&quot;no-underscore-dangle&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止可以在有更简单的可替代的表达式时使用三元操作符</span></span><br><span class="line">    <span class="string">&quot;no-unneeded-ternary&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止属性前有空白</span></span><br><span class="line">    <span class="string">&quot;no-whitespace-before-property&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制花括号内换行符的一致性</span></span><br><span class="line">    <span class="string">&quot;object-curly-newline&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制在花括号中使用一致的空格</span></span><br><span class="line">    <span class="string">&quot;object-curly-spacing&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制将对象的属性放在不同的行上</span></span><br><span class="line">    <span class="string">&quot;object-property-newline&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制函数中的变量要么一起声明要么分开声明</span></span><br><span class="line">    <span class="string">&quot;one-var&quot;</span>: [<span class="number">2</span>, &#123;<span class="string">&quot;initialized&quot;</span>:<span class="string">&quot;never&quot;</span>&#125;],</span><br><span class="line">    <span class="comment">// 要求或禁止在 var 声明周围换行</span></span><br><span class="line">    <span class="string">&quot;one-var-declaration-per-line&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求或禁止在可能的情况下要求使用简化的赋值操作符</span></span><br><span class="line">    <span class="string">&quot;operator-assignment&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制操作符使用一致的换行符</span></span><br><span class="line">    <span class="string">&quot;operator-linebreak&quot;</span>: [<span class="number">2</span>,<span class="string">&quot;after&quot;</span>, &#123;<span class="string">&quot;overrides&quot;</span>: &#123;<span class="string">&quot;?&quot;</span>:<span class="string">&quot;before&quot;</span>,<span class="string">&quot;:&quot;</span>:<span class="string">&quot;before&quot;</span>&#125; &#125;],</span><br><span class="line">    <span class="comment">// 要求或禁止块内填充</span></span><br><span class="line">    <span class="string">&quot;padded-blocks&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求对象字面量属性名称用引号括起来</span></span><br><span class="line">    <span class="string">&quot;quote-props&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制使用一致的反勾号、双引号或单引号</span></span><br><span class="line">    <span class="string">&quot;quotes&quot;</span>: [<span class="number">2</span>,<span class="string">&quot;single&quot;</span>,<span class="string">&quot;avoid-escape&quot;</span>],</span><br><span class="line">    <span class="comment">// 要求使用 JSDoc 注释</span></span><br><span class="line">    <span class="string">&quot;require-jsdoc&quot;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 要求或禁止使用分号而不是 ASI（这个才是控制行尾部分号的，）</span></span><br><span class="line">    <span class="string">&quot;semi&quot;</span>: [<span class="number">2</span>,<span class="string">&quot;always&quot;</span>],</span><br><span class="line">    <span class="comment">// 强制分号之前和之后使用一致的空格</span></span><br><span class="line">    <span class="string">&quot;semi-spacing&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求同一个声明块中的变量按顺序排列</span></span><br><span class="line">    <span class="string">&quot;sort-vars&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制在块之前使用一致的空格</span></span><br><span class="line">    <span class="string">&quot;space-before-blocks&quot;</span>: [<span class="number">2</span>,<span class="string">&quot;always&quot;</span>],</span><br><span class="line">    <span class="comment">// 强制在 function的左括号之前使用一致的空格</span></span><br><span class="line">    <span class="comment">// &quot;space-before-function-paren&quot;: [0,&quot;always&quot;],</span></span><br><span class="line">    <span class="comment">// 强制在圆括号内使用一致的空格</span></span><br><span class="line">    <span class="string">&quot;space-in-parens&quot;</span>: [<span class="number">2</span>,<span class="string">&quot;never&quot;</span>],</span><br><span class="line">    <span class="comment">// 要求操作符周围有空格</span></span><br><span class="line">    <span class="string">&quot;space-infix-ops&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 强制在一元操作符前后使用一致的空格</span></span><br><span class="line">    <span class="string">&quot;space-unary-ops&quot;</span>: [<span class="number">2</span>, &#123;<span class="string">&quot;words&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;nonwords&quot;</span>:<span class="literal">false</span>&#125;],</span><br><span class="line">    <span class="comment">// 强制在注释中 // 或 /* 使用一致的空格</span></span><br><span class="line">    <span class="string">&quot;spaced-comment&quot;</span>: [</span><br><span class="line">      <span class="number">2</span>,</span><br><span class="line">      <span class="string">&quot;always&quot;</span>, </span><br><span class="line">      &#123;<span class="string">&quot;markers&quot;</span>: [<span class="string">&quot;global&quot;</span>,<span class="string">&quot;globals&quot;</span>,<span class="string">&quot;eslint&quot;</span>,<span class="string">&quot;eslint-disable&quot;</span>,<span class="string">&quot;*package&quot;</span>,<span class="string">&quot;!&quot;</span>] &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 要求或禁止 Unicode BOM</span></span><br><span class="line">    <span class="string">&quot;unicode-bom&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求正则表达式被括号括起来</span></span><br><span class="line">    <span class="string">&quot;wrap-regex&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">//////////////</span></span><br><span class="line">    <span class="comment">// ES6.相关 //</span></span><br><span class="line">    <span class="comment">//////////////</span></span><br><span class="line">    <span class="comment">// 要求箭头函数体使用大括号</span></span><br><span class="line">    <span class="string">&quot;arrow-body-style&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 要求箭头函数的参数使用圆括号</span></span><br><span class="line">    <span class="string">&quot;arrow-parens&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;arrow-spacing&quot;</span>:[<span class="number">2</span>,&#123;<span class="string">&quot;before&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;after&quot;</span>:<span class="literal">true</span>&#125;],</span><br><span class="line">    <span class="comment">// 强制在子类构造函数中用super()调用父类构造函数，TypeScrip的编译器也会提示</span></span><br><span class="line">    <span class="string">&quot;constructor-super&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制 generator 函数中 * 号周围使用一致的空格</span></span><br><span class="line">    <span class="string">&quot;generator-star-spacing&quot;</span>: [<span class="number">2</span>, &#123;<span class="string">&quot;before&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;after&quot;</span>:<span class="literal">true</span>&#125;],</span><br><span class="line">    <span class="comment">// 禁止修改类声明的变量</span></span><br><span class="line">    <span class="string">&quot;no-class-assign&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 不允许箭头功能，在那里他们可以混淆的比较</span></span><br><span class="line">    <span class="string">&quot;no-confusing-arrow&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止修改 const 声明的变量</span></span><br><span class="line">    <span class="string">&quot;no-const-assign&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止类成员中出现重复的名称</span></span><br><span class="line">    <span class="string">&quot;no-dupe-class-members&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 不允许复制模块的进口</span></span><br><span class="line">    <span class="string">&quot;no-duplicate-imports&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止 Symbol 的构造函数</span></span><br><span class="line">    <span class="string">&quot;no-new-symbol&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 允许指定模块加载时的进口</span></span><br><span class="line">    <span class="string">&quot;no-restricted-imports&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 禁止在构造函数中，在调用 super() 之前使用 this 或 super</span></span><br><span class="line">    <span class="string">&quot;no-this-before-super&quot;</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 禁止不必要的计算性能键对象的文字</span></span><br><span class="line">    <span class="string">&quot;no-useless-computed-key&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求使用 let 或 const 而不是 var</span></span><br><span class="line">    <span class="string">&quot;no-var&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求或禁止对象字面量中方法和属性使用简写语法</span></span><br><span class="line">    <span class="string">&quot;object-shorthand&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求使用箭头函数作为回调</span></span><br><span class="line">    <span class="string">&quot;prefer-arrow-callback&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求使用 const 声明那些声明后不再被修改的变量</span></span><br><span class="line">    <span class="string">&quot;prefer-const&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求在合适的地方使用 Reflect 方法</span></span><br><span class="line">    <span class="string">&quot;prefer-reflect&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求使用扩展运算符而非 .apply()</span></span><br><span class="line">    <span class="string">&quot;prefer-spread&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求使用模板字面量而非字符串连接</span></span><br><span class="line">    <span class="string">&quot;prefer-template&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// Suggest using the rest parameters instead of arguments</span></span><br><span class="line">    <span class="string">&quot;prefer-rest-params&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求generator 函数内有 yield</span></span><br><span class="line">    <span class="string">&quot;require-yield&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// enforce spacing between rest and spread operators and their expressions</span></span><br><span class="line">    <span class="string">&quot;rest-spread-spacing&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 强制模块内的 import 排序</span></span><br><span class="line">    <span class="string">&quot;sort-imports&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 要求或禁止模板字符串中的嵌入表达式周围空格的使用</span></span><br><span class="line">    <span class="string">&quot;template-curly-spacing&quot;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 强制在 yield* 表达式中 * 周围使用空格</span></span><br><span class="line">    <span class="string">&quot;yield-star-spacing&quot;</span>:<span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>代码相关</category>
      </categories>
      <tags>
        <tag>eslint</tag>
      </tags>
  </entry>
  <entry>
    <title>【ICU 指南】发发牢骚，生活还得继续</title>
    <url>/2024/02/13/b202fc40-cbc5-11ee-bcb5-e38cb038f43c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>今年对我个人而言注定是不平凡的一年，所有事都扎堆到了一起，剪不断理还乱。</p>
<p>那又能怎么办呢，梳理一下就当一个发泄渠道吧。很多事口述是一个情况，笔述又是另一个思路。</p>
<h1 id="除夕回家"><a href="#除夕回家" class="headerlink" title="除夕回家"></a>除夕回家</h1><p>自己工作的事已处理好，想着早两天回去陪父母，遂把动车票改到了 8 号回老家。本意是好，父母听着很开心。妈听着我要提前回，特意把家庭聚会时间改到了 8 号（除夕前一天）。好巧不巧，这一天预定的饭店正好改时间，提前一天歇业，其他餐厅、饭店基本也订不到了，没法，妈决定说：还是在家里吃吧。</p>
<h2 id="操劳的年夜饭"><a href="#操劳的年夜饭" class="headerlink" title="操劳的年夜饭"></a>操劳的年夜饭</h2><p>多年没这么操劳了。记得那还是爷爷奶奶健在时，亲朋长辈会去爷爷家，（我们这是这样）从早上开始忙活做饭，男同胞们打牌喝酒，女同胞们做饭主持事务。</p>
<p>我是 5 点半下动车，到家差不多 6 点半。快进家门，隔着老远就已听到了打牌声儿，聊天声儿。见着家人，心里盘算着这一年又平安度过了，新的一年开始了。在和亲戚的谈笑和觥筹交错中，其乐融融的年饭吃完了。大人们有的继续进行麻将活动，有的还在随着一杯杯白酒高谈阔论，虽然每年都是这样过来的，总感觉少了点什么？</p>
<p>母亲胃口不好，每年都是这样没吃多少，就和几个姑去继续忙活家务了，收拾、打扫、洗碗、张罗后面几天的饭菜，虽然想过去帮忙，但被拒绝了，让我好好休息陪亲戚。晚上 10 点半后，带着小侄子小侄女几个小朋友出去放鞭炮，然后把图片视频发到大家庭群里，年味渐浓。</p>
<h2 id="征兆"><a href="#征兆" class="headerlink" title="征兆"></a>征兆</h2><p>操劳一整天，待亲戚们走后，母亲悬着的心终于落下，紧绷了一整天，可以得到短暂的休息了，睡去了。从没见过母亲这样的神色。但鞭炮声，爆竹声不断，想来应该没有睡得太好。</p>
<p>第二天一早，母亲依旧不想吃东西，脸色煞白。母亲有着那一代女性的所有优点，勤劳，不怕苦，节俭，但又要强，问了几句说头疼得厉害想休息，要是平时的她绝对不会说自己身体的任何问题，只会打笑说休息下就好了。我意识到问题没有想象般简单，随即拨打了 120。</p>
<h2 id="初入-ICU"><a href="#初入-ICU" class="headerlink" title="初入 ICU"></a>初入 ICU</h2><p>母亲处于半昏迷状态，有意识，但精神状态极差，在医生的建议下直接送到了 ICU。</p>
<p><img src="/2024/02/13/b202fc40-cbc5-11ee-bcb5-e38cb038f43c/icu1.jpg" alt="在ICU 大门口"></p>
<p>那一刻真的很焦急，家属不能进入，只能在医护人员的安抚下焦急地等待。</p>
<p>好在经过第一时间的护理，妈妈的情况稳定了下来，但还是需要进行各项检查还有休息。</p>
<p>心率紊乱，血压 50，肾脏功能衰弱。需要做手术，家属签字做啥心照影，再根据情况做后续手术。</p>
<h3 id="心脏手术"><a href="#心脏手术" class="headerlink" title="心脏手术"></a>心脏手术</h3><p>还好不需要做搭桥等破坏性手术，等待了 1 小时多，医生出来告诉我和爸，妈不要做心脏手术，这一刻紧悬着的心终于放下来了。</p>
<h3 id="办理住院"><a href="#办理住院" class="headerlink" title="办理住院"></a>办理住院</h3><p>虽然计划啥的突然全都打乱了，但生活不就是这样吗。</p>
<p>为妈办理了住院，按住院单上的，备齐了各种生活用品。其他就是多走走了解住院大楼，楼层及布局，门诊，手术，CT，影像科等几个需要常去科室位置，（拍照备忘）提前预约。</p>
<h3 id="转出-ICU"><a href="#转出-ICU" class="headerlink" title="转出 ICU"></a>转出 ICU</h3><p>有时候也要换位思考下父母的心情。妈妈在重症里确实很难受，不能移动，所有操作（小到喝水大到隐私等）都由护士来执行，加上医疗机器的声音，睡不着，恐惧，再加上不想浪费钱（其实这条才是重点） &#x3D; &#x3D; 考虑到妈的情况确实稳定些了，加上不用做大型手术了，和爸商量后，在第三天将妈转出了 ICU 。</p>
<blockquote>
<p>经验可做个参考，我在里呆了 2 小时也觉得压抑。加上妈上一个床位的老人因病逝世，也给了极大的心理压力。这种情况下，病情反倒还好，更应该关心患者的心理健康。</p>
</blockquote>
<p><img src="/2024/02/13/b202fc40-cbc5-11ee-bcb5-e38cb038f43c/icu2.jpg" alt="ICU里"></p>
<h3 id="对症下药"><a href="#对症下药" class="headerlink" title="对症下药"></a>对症下药</h3><p>妈心里总是很内疚，觉得因为她大家没过好年。我们一直在安慰她，不要在意，身体才是最重要的。一开始是因为劳累晕倒，但实际情况其实是因为吃坏了东西，肾脏出了问题，诱发的心脏供血不足（大致是这样，我也听得迷迷糊糊）</p>
<blockquote>
<p>亲朋好友送的所谓的补品、保健药，没按医嘱吃的各种奇奇怪怪的西药、中药。真的恐怖，说了又不听，这次后，好像终于意识到问题了</p>
</blockquote>
<p><img src="/2024/02/13/b202fc40-cbc5-11ee-bcb5-e38cb038f43c/icu4.jpg" alt="检查下来好多了"></p>
<h3 id="利用琐碎时间"><a href="#利用琐碎时间" class="headerlink" title="利用琐碎时间"></a>利用琐碎时间</h3><p>换个思路想想，也挺好的。今年回家没有麻将，没有喧嚣，多了一份紧迫，多了一份重担。</p>
<p><img src="/2024/02/13/b202fc40-cbc5-11ee-bcb5-e38cb038f43c/icu3.jpg" alt="合理利用资源"></p>
<p>这次唯一做得对的就是把本子带回了家。资料能整理多少整理多少呗，积少成多。在这个环境下容易受打扰，节奏容易被打断，不能做复杂的工作。面试类整理，和基础性知识总结就挺适合的。不知不觉，码起字来也更得心应手，渐入佳境。</p>
<h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>我一直对妈说：“这样没什么不好，一家人只要在一起，哪里都是过年，医院里也能过好年！”</p>
<p>经过这次，我意识到了，对父母的关心太少。虽然每周都会打电话问候，该买东西买东西，但还是不够，“她要的是陪伴，而不是六百块，比你的还简单”。</p>
<p>“树欲静而风不止，子欲养而亲不待”，别给自己留遗憾，在父母在时，多关心陪伴下她们吧。</p>
<p>以前总是嫌妈太啰嗦，事无巨细，打车是浪费要坐公交，把线路都规划好了。家里的菜不能浪费，哪些冷藏到冰箱，哪些又该怎么处理。（事实是，爸觉得触霉头都倒了 - - 听到这，妈血压不升反降。。。这是另外出戏就不吐槽了）</p>
<p>现在嘛，拿出了手机备忘录，按妈的要求把这些事都做好了免得她生气，至少在她面前如此，给更多的包容与耐心。</p>
<p><img src="/2024/02/13/b202fc40-cbc5-11ee-bcb5-e38cb038f43c/icu5.jpg" alt="该医生的嘱咐吃药"></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>希望祝愿大家都能身体健康，平安是福。生活不易，加油共勉之！~</p>
]]></content>
      <categories>
        <category>随笔随想</category>
      </categories>
      <tags>
        <tag>ICU</tag>
      </tags>
  </entry>
  <entry>
    <title>【项目总结】Vite+Vue3+TS组件库my-element-plus</title>
    <url>/2024/01/24/f23ba680-bc5d-11ee-a7e9-c70c4914cb61/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>之前发现了一个非常好的学习项目，技术栈很新，于是就学习了一下思路，自己实现了一遍。果然，人还是得逼着自己，最近的学习节奏还算不错，再做完项目后来总结一下，编写并完善文档，这不就形成了一套解决方案吗？尽管这只是一个较简单的项目，很多复杂组件还未加入，但其中的思路还是很有启发性的。</p>
<p>项目地址：<a href="https://github.com/Fridolph/my-element-plus">https://github.com/Fridolph/my-element-plus</a></p>
<p>my-element-plus 学习相关组件及源码，仅供学习参考</p>
<p>文档地址：<a href="https://fridolph.github.io/my-element-docs/">https://fridolph.github.io/my-element-docs/</a></p>
<h1 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h1><p>所谓万事开头难，在决定好技术栈后，最重要的就是进行项目构建。Vue3 + Vite 一把梭确实爽！</p>
<ul>
<li>eslint</li>
<li>postcss</li>
<li>vitest 直接可用</li>
<li>volar</li>
<li>vite</li>
<li>vitepress</li>
</ul>
<blockquote>
<p>相关依赖安装好后，直接按官方推荐设置 vite.config.ts 即可<br>根据经验，在做这种组件库项目时我发现可能需要花费更多时间（当然也可以使用 TDD 测试驱动开发）。但我更喜欢先把组件开发完成再去补充测试……理清需求和目的，逐步实现，效果会更好。</p>
</blockquote>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>对于这种项目，推荐的最佳实践是直接照搬大型开源项目的目录结构。当然，由于这个项目相对小且简单，也可以更加灵活一些，去掉那种复杂的模块结构，按照组件进行分类即可。</p>
<h2 id="配色参考"><a href="#配色参考" class="headerlink" title="配色参考"></a>配色参考</h2><p>色彩 - 组件设计前重要的一环。</p>
<p>中国色</p>
<p><a href="https://peiseka.com/zhongguochuantongse.html">https://peiseka.com/zhongguochuantongse.html</a></p>
<p>bootstrap</p>
<p><a href="https://getbootstrap.com/docs/5.3/customize/color">https://getbootstrap.com/docs/5.3/customize/color</a></p>
<p>tailwind.css</p>
<p><a href="https://tailwindcss.com/docs/customizing-colors">https://tailwindcss.com/docs/customizing-colors</a></p>
<p>可以将颜色先写到 styles 里的变量中，现在更推荐 CSS 的变量</p>
<p>styles &gt; var.css</p>
<p>之前一直用 scss、stylus ，现在原生 css 已经很强大了，浏览器支持也很好，所以我们直接用 css vars</p>
<p>兼容性肯定要做的, autoprefixer 不可少，所以还是上 PostCSS。它是一个功能比较单一的工具，它提供了一种方式用 JavaScript 代码来处理 CSS。它负责把 CSS 代码解析成抽象语法树结构（Abstract Syntax Tree，AST），再交由插件来进行处理。</p>
<h2 id="编写一个组件"><a href="#编写一个组件" class="headerlink" title="编写一个组件"></a>编写一个组件</h2><p>如：Button - 按钮。大概是按以下思路来进行的</p>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>Button 组件大部分关注样式，没有其他交互。可在其上自行绑定事件</p>
<p>根据分析，暂得以下具体属性列表：（button.type.ts）</p>
<ul>
<li>type 样式</li>
<li>plain</li>
<li>round</li>
<li>circle</li>
<li>disabled</li>
<li>icon</li>
<li>loading</li>
</ul>
<p>确定项目文件结构：</p>
<ul>
<li>从简单入手，这里就都放到 components&#x2F;Button 下了<ul>
<li>Button(components) 后续组件都参照这个文件结构来</li>
<li>Button.vue</li>
<li>style.css</li>
<li>types.ts</li>
<li>Button.test.ts</li>
</ul>
</li>
<li>以学习为主没必要过度设计，过于纠结细节</li>
<li>该组件是否能完成基本功能</li>
<li>是否需要暴露实例 或 expose 属性或方法等</li>
</ul>
<p>编写测试代码：</p>
<ul>
<li>测试基本功能展示 OK</li>
<li>传递 prop 后能否正常展示</li>
<li>测试交互事件能否触发</li>
</ul>
<p>总结遇到的一些问题：</p>
<ul>
<li>编码过程遇到的 bug</li>
<li>样式能否实现</li>
<li>其他实现方式 （锦上添花）</li>
</ul>
<p>每当完成一个组件，应立即更新 vitepress 对应的组件文档：</p>
<p>一个组件文档工作量很少，且能有效反馈让进度可控，一定要坚持。一旦堆多了，后期反而文字类工作才是让程序员最头大的</p>
<h2 id="表单组件"><a href="#表单组件" class="headerlink" title="表单组件"></a>表单组件</h2><p>感觉这里总结得还成，就写到博客里了。</p>
<p>表单是用户和网站交互最重要的一部分。</p>
<p>表单有很多控件，这里选了几个简单的模拟实现，就单独整理写到这里了. 表单包含 输入框, 单选框, 下拉选择, 多选框 等用户输入的组件。 使用表单，您可以收集、验证和提交数据。</p>
<p>典型表单：</p>
<p>最基础的表单包括各种输入表单项，比如：</p>
<ul>
<li>input</li>
<li>select</li>
<li>radio</li>
<li>checkbox</li>
</ul>
<p>在每一个 form 组件中，你需要一个 form-item 字段作为输入项的容器，用于获取值与验证值。</p>
<p>按照原型图整理的简单需求：</p>
<ul>
<li>自定义 UI<ul>
<li>整理可自定义</li>
<li>用户可自定义渲染多种类型的表单元素</li>
<li>用户可自定义提交区域内容</li>
</ul>
</li>
<li>验证时机<ul>
<li>表单元素默认 blur 时验证，可自定义</li>
<li>整个表单在点击提交时应全部验证</li>
</ul>
</li>
<li>验证规则<ul>
<li>每个 input 可配置多条规则</li>
<li>规则可自定义</li>
</ul>
</li>
</ul>
<h3 id="组件结构设计"><a href="#组件结构设计" class="headerlink" title="组件结构设计"></a>组件结构设计</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> formOptions = &#123;</span><br><span class="line">  <span class="attr">name</span>: &#123; <span class="attr">key</span>: <span class="string">&#x27;name&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">rules</span>: [], ... &#125;</span><br><span class="line">  [otherKey]: &#123; <span class="attr">key</span>: <span class="string">&#x27;xxx&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">rules</span>: [], ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这种用法过于繁杂，不灵活，在使用上体现不出结构，会让 js 臃肿，所以用 slot 的形式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">:options</span>=<span class="string">&quot;formOptions&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">FormItem</span></span></span><br><span class="line"><span class="tag">    <span class="attr">label</span>=<span class="string">&quot;label&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">FormItem</span></span></span><br><span class="line"><span class="tag">    <span class="attr">label</span>=<span class="string">&quot;label2&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&quot;name2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">FormItem</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="开发步骤："><a href="#开发步骤：" class="headerlink" title="开发步骤："></a>开发步骤：</h3><ol>
<li>根据结构，实现基础布局，完成 demo</li>
<li>添加初始化数据，绑定数据</li>
<li>添加验证</li>
<li>事件交互，验证等</li>
<li>不断完善</li>
</ol>
<h3 id="实现验证功能的思路"><a href="#实现验证功能的思路" class="headerlink" title="实现验证功能的思路"></a>实现验证功能的思路</h3><p>验证类型：</p>
<ul>
<li>表单 Form 整体验证</li>
<li>单个表单 FormItem 的验证</li>
</ul>
<p>表单中每项循环验证一次 every 即为表单验证结果</p>
<p>单个验证实现思路：</p>
<ul>
<li>从父组件 Form 获取对应 option、value</li>
<li>在 FormItem 组件中实现</li>
</ul>
<p>第三方库：async-validator</p>
<h2 id="关于打包"><a href="#关于打包" class="headerlink" title="关于打包"></a>关于打包</h2><blockquote>
<p>为什么要打包？</p>
</blockquote>
<ul>
<li>模块化</li>
<li>可维护性</li>
<li>可复制性</li>
</ul>
<p>模块化定义：以功能块为单位进行程序设计，实现其求解算法的方法称为模块化。模块化的目的是为了降低程序复杂度，使程序设计、调试和维护等操作简单化。</p>
<h3 id="打包什么类型的文件"><a href="#打包什么类型的文件" class="headerlink" title="打包什么类型的文件"></a>打包什么类型的文件</h3><ul>
<li>CommonJs, ES6 modules 需要特殊的打包工具支持</li>
<li>AMD 已过时</li>
<li>浏览器直接使用 （UMD）Universal Module Definition（但不支持 tree shaking）<ul>
<li>通用 JS 格式</li>
<li>兼容 Common.js、AMD、浏览器</li>
</ul>
</li>
</ul>
<p>综上：</p>
<p>首要格式 - ES Module ，并且提供支持 TypeScript 的 type 文件<br>备选方案 - UMD</p>
<h3 id="lib-相关设置"><a href="#lib-相关设置" class="headerlink" title="lib 相关设置"></a>lib 相关设置</h3><p>对应 vite.config.ts 中需要设置 build.lib 相应类型（参考文档配置即可）</p>
<p>我们可为每个组件建立一个 index.ts ，例如 Button</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">App</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Button</span> <span class="keyword">from</span> <span class="string">&#x27;./Button.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Button</span>.<span class="property">install</span> = <span class="function">(<span class="params">app: App</span>) =&gt;</span> &#123;</span><br><span class="line">  app.<span class="title function_">component</span>(<span class="title class_">Button</span>.<span class="property">name</span>, <span class="title class_">Button</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Button</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;./types&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在src和main.ts同级目录下新建一个index.ts用来导入组件，将各组件注册到Vue实例中，这样打包出来就可通过import形式导入了</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> components = [</span><br><span class="line">  <span class="comment">// 组件</span></span><br><span class="line">  <span class="title class_">Button</span>,</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 方法</span></span><br><span class="line">  createMessage,</span><br><span class="line">  closeAllInstances,</span><br><span class="line">  ... </span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">install</span>(<span class="params">app: App</span>) &#123;</span><br><span class="line">  components.<span class="title function_">forEach</span>(<span class="function">(<span class="params">component</span>) =&gt;</span> &#123;</span><br><span class="line">    app.<span class="title function_">component</span>(component.<span class="property">name</span>, component)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; 组件 &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> install</span><br></pre></td></tr></table></figure>

<h3 id="发布遇到的坑"><a href="#发布遇到的坑" class="headerlink" title="发布遇到的坑"></a>发布遇到的坑</h3><p>最近 npm 淘宝源 证书过期了，所以得改地址 &#x3D; &#x3D; 之前老是遇到依赖安装问题，都是这些小问题造成的，一不注意会卡很久</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure>

<p>但在发布时需要登录npm 又得把淘宝源去掉</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org</span><br></pre></td></tr></table></figure>

<p>npm login 登录不上 - - 困扰很久，结果发现是网络问题，手机开热点，电脑连手机的，登npmjs就可以了，发布完记得改回来。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>虽然看起来很简单，但折腾了几周才终于搞定。实际上，大部分时间花在改样式和配置上，而真正完成功能反而挺快的。本来也想试试TailWindCss，但发现还有些应对不了的问题，于是干脆改到了履历项目里（是的，先挖个坑告诉自己必须填）。</p>
<p>加油，2024！只要行动起来，就是好的开始。</p>
]]></content>
      <categories>
        <category>代码相关</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>ui</tag>
      </tags>
  </entry>
</search>
